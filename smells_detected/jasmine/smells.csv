file,type,line,method,source
/spec/performance/performance_test.js,AnonymousTest,"{'startLine':3,'endLine':5}","it('should pass', function() {
      expect(true).toBe(true);
    })",snuts
/spec/performance/performance_test.js,AnonymousTest,"{'startLine':6,'endLine':8}","it('should fail', function() {
      expect(true).toBe(false);
    })",snuts
/spec/core/integration/AsymmetricEqualityTestersSpec.js,AnonymousTest,"{'startLine':3,'endLine':28}","it('passes', async function() {
      const env = new jasmineUnderTest.Env();
      env.it('a spec', function() {
        expectations(env);
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await env.execute();

      expect(reporter.specDone).toHaveBeenCalledTimes(1);
      const result = reporter.specDone.calls.argsFor(0)[0];

      expect(result.status).toEqual('passed');
      expect(result.passedExpectations.length)
        .withContext('Number of passed expectations')
        .toEqual(1);
      expect(result.failedExpectations.length)
        .withContext('Number of failed expectations')
        .toEqual(0);
      expect(
        result.failedExpectations[0] && result.failedExpectations[0].message
      )
        .withContext('Failure message')
        .toBeUndefined();
    })",snuts
/spec/core/integration/AsymmetricEqualityTestersSpec.js,AnonymousTest,"{'startLine':32,'endLine':55}","it('fails', async function() {
      const env = new jasmineUnderTest.Env();
      env.it('a spec', function() {
        expectations(env);
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await env.execute();

      expect(reporter.specDone).toHaveBeenCalledTimes(1);
      const result = reporter.specDone.calls.argsFor(0)[0];

      expect(result.status).toEqual('failed');
      expect(result.failedExpectations.length)
        .withContext('Number of failed expectations')
        .toEqual(1);
      expect(result.failedExpectations[0].message)
        .withContext('Failed with a thrown error rather than a matcher failure')
        .not.toMatch(/^Error: /);
      expect(result.failedExpectations[0].matcherName)
        .withContext('Matcher name')
        .not.toEqual('');
    })",snuts
/spec/core/integration/AsymmetricEqualityTestersSpec.js,SensitiveEquality,"{'startLine':81,'endLine':81}","describe('arrayContaining', function() {
    verifyPasses(function(env) {
      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });
      env.expect([1, 2, 3]).toEqual(jasmineUnderTest.arrayContaining(['2']));
    });

    verifyFails(function(env) {
      env.expect(null).toEqual(jasmineUnderTest.arrayContaining([2]));
    });
  })",snuts
/spec/core/integration/AsymmetricEqualityTestersSpec.js,SensitiveEquality,"{'startLine':94,'endLine':94}","describe('arrayWithExactContents', function() {
    verifyPasses(function(env) {
      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });
      env
        .expect([1, 2])
        .toEqual(jasmineUnderTest.arrayWithExactContents(['2', '1']));
    });

    verifyFails(function(env) {
      env.expect([]).toEqual(jasmineUnderTest.arrayWithExactContents([2]));
    });
  })",snuts
/spec/core/integration/AsymmetricEqualityTestersSpec.js,SensitiveEquality,"{'startLine':134,'endLine':134}","describe('mapContaining', function() {
    verifyPasses(function(env) {
      const actual = new Map();
      actual.set('a', '2');
      const expected = new Map();
      expected.set('a', 2);

      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });

      env.expect(actual).toEqual(jasmineUnderTest.mapContaining(expected));
    });

    verifyFails(function(env) {
      env
        .expect('something')
        .toEqual(jasmineUnderTest.mapContaining(new Map()));
    });
  })",snuts
/spec/core/integration/AsymmetricEqualityTestersSpec.js,SensitiveEquality,"{'startLine':160,'endLine':160}","describe('objectContaining', function() {
    verifyPasses(function(env) {
      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });

      env
        .expect({ a: 1, b: 2 })
        .toEqual(jasmineUnderTest.objectContaining({ a: '1' }));
    });

    verifyFails(function(env) {
      env.expect({}).toEqual(jasmineUnderTest.objectContaining({ a: '1' }));
    });
  })",snuts
/spec/core/integration/AsymmetricEqualityTestersSpec.js,SensitiveEquality,"{'startLine':181,'endLine':181}","describe('setContaining', function() {
    verifyPasses(function(env) {
      const actual = new Set();
      actual.add('1');
      const expected = new Set();
      actual.add(1);

      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });

      env.expect(actual).toEqual(jasmineUnderTest.setContaining(expected));
    });

    verifyFails(function(env) {
      env
        .expect('something')
        .toEqual(jasmineUnderTest.setContaining(new Set()));
    });
  })",snuts
/src/core/Spec.js,NonFunctionalStatement,"{'startLine':34,'endLine':34}",Unknown,snuts
/spec/npmPackage/npmPackageSpec.js,AnonymousTest,"{'startLine':58,'endLine':68}","it('has jsFiles', function() {
    expect(this.packagedCore.files.jsFiles).toEqual([
      'jasmine.js',
      'jasmine-html.js'
    ]);

    const packagedCore = this.packagedCore;
    this.packagedCore.files.jsFiles.forEach(function(fileName) {
      expect(fileName).toExistInPath(packagedCore.files.path);
    });
  })",snuts
/spec/npmPackage/npmPackageSpec.js,AnonymousTest,"{'startLine':70,'endLine':77}","it('has cssFiles', function() {
    expect(this.packagedCore.files.cssFiles).toEqual(['jasmine.css']);

    const packagedCore = this.packagedCore;
    this.packagedCore.files.cssFiles.forEach(function(fileName) {
      expect(fileName).toExistInPath(packagedCore.files.path);
    });
  })",snuts
/spec/npmPackage/npmPackageSpec.js,AnonymousTest,"{'startLine':79,'endLine':85}","it('has bootFiles', function() {
    expect(this.packagedCore.files.bootFiles).toEqual(['boot0.js', 'boot1.js']);

    for (const fileName of this.packagedCore.files.bootFiles) {
      expect(fileName).toExistInPath(this.packagedCore.files.bootDir);
    }
  })",snuts
/spec/npmPackage/npmPackageSpec.js,ConditionalTestLogic,"{'startLine':141,'endLine':145}","it('only has JS and CSS files in the lib dir', function() {
    const files = [];

    function getFiles(dir) {
      const dirents = fs.readdirSync(dir, { withFileTypes: true });

      for (let j = 0; j < dirents.length; j++) {
        const dirent = dirents[j];

        if (dirent.isDirectory()) {
          getFiles(path.resolve(dir, dirent.name));
        } else {
          files.push(path.resolve(dir, dirent.name));
        }
      }
    }

    getFiles(path.resolve(this.tmpDir, 'package/lib'));

    for (let i = 0; i < files.length; i++) {
      expect(files[i]).toMatch(/\.(js|css)$/);
    }
  })",snuts
/spec/html/PrettyPrintHtmlSpec.js,ConditionalTestLogic,"{'startLine':25,'endLine':37}","it(""should print Firefox's wrapped native objects correctly"", function() {
    if (specHelpers.firefoxVersion) {
      const pp = jasmineUnderTest.makePrettyPrinter();
      let err;
      try {
        new CustomEvent();
      } catch (e) {
        err = e;
      }
      // Different versions of FF produce different error messages.
      expect(pp(err)).toMatch(
        /Not enough arguments|CustomEvent.*only 0.*passed/
      );
    }
  })",snuts
/spec/html/HtmlReporterSpec.js,GeneralFixture,"{'startLine':1358,'endLine':1369}","beforeEach(function() {
        container = document.createElement('div');
        reporterConfig = {
          env: env,
          getContainer: function() {
            return container;
          },
          createElement: function() {
            return document.createElement.apply(document, arguments);
          },
          createTextNode: function() {
            return document.createTextNode.apply(document, arguments);
          }
        };
        specStatus = {
          id: 123,
          description: 'with a excluded spec',
          fullName: 'A Suite with a excluded spec',
          status: 'excluded',
          passedExpectations: [],
          failedExpectations: []
        };
      })",snuts
/spec/html/HtmlReporterSpec.js,GeneralFixture,"{'startLine':1370,'endLine':1377}","beforeEach(function() {
        container = document.createElement('div');
        reporterConfig = {
          env: env,
          getContainer: function() {
            return container;
          },
          createElement: function() {
            return document.createElement.apply(document, arguments);
          },
          createTextNode: function() {
            return document.createTextNode.apply(document, arguments);
          }
        };
        specStatus = {
          id: 123,
          description: 'with a excluded spec',
          fullName: 'A Suite with a excluded spec',
          status: 'excluded',
          passedExpectations: [],
          failedExpectations: []
        };
      })",snuts
/spec/html/HtmlReporterSpec.js,IdenticalTestDescription,"{'startLine':1155,'endLine':1181}","it('should navigate and change the setting to on', function() {
        const container = document.createElement('div'),
          navigateHandler = jasmine.createSpy('navigate'),
          getContainer = function() {
            return container;
          },
          reporter = new jasmineUnderTest.HtmlReporter({
            env: env,
            getContainer: getContainer,
            navigateWithNewParam: navigateHandler,
            createElement: function() {
              return document.createElement.apply(document, arguments);
            },
            createTextNode: function() {
              return document.createTextNode.apply(document, arguments);
            }
          });

        env.configure({ random: false });
        reporter.initialize();
        reporter.jasmineDone({});

        const randomUI = container.querySelector('.jasmine-random');
        randomUI.click();

        expect(navigateHandler).toHaveBeenCalledWith('random', true);
      })",snuts
/spec/html/HtmlReporterSpec.js,IdenticalTestDescription,"{'startLine':1183,'endLine':1209}","it('should navigate and change the setting to off', function() {
        const container = document.createElement('div'),
          navigateHandler = jasmine.createSpy('navigate'),
          getContainer = function() {
            return container;
          },
          reporter = new jasmineUnderTest.HtmlReporter({
            env: env,
            getContainer: getContainer,
            navigateWithNewParam: navigateHandler,
            createElement: function() {
              return document.createElement.apply(document, arguments);
            },
            createTextNode: function() {
              return document.createTextNode.apply(document, arguments);
            }
          });

        env.configure({ random: true });
        reporter.initialize();
        reporter.jasmineDone({});

        const randomUI = container.querySelector('.jasmine-random');
        randomUI.click();

        expect(navigateHandler).toHaveBeenCalledWith('random', false);
      })",snuts
/spec/html/HtmlReporterSpec.js,IdenticalTestDescription,"{'startLine':1466,'endLine':1471}","it('reports no failure details', function() {
        reportWithSpecStatus(pendingSpecStatus());
        const specFailure = container.querySelector('.jasmine-failures');

        expect(specFailure.childNodes.length).toEqual(0);
      })",snuts
/spec/html/HtmlReporterSpec.js,IdenticalTestDescription,"{'startLine':1594,'endLine':1597}","it('reports the specs counts', function() {
        const alertBar = container.querySelector('.jasmine-alert .jasmine-bar');
        expect(alertBar.innerHTML).toMatch(/3 specs, 3 failures/);
      })",snuts
/spec/html/HtmlReporterSpec.js,ConditionalTestLogic,"{'startLine':428,'endLine':430}","it('adds a warning to the link title of specs that have no expectations', function() {
      if (!window.console) {
        window.console = { error: function() {} };
      }
      const container = document.createElement('div'),
        getContainer = function() {
          return container;
        },
        reporter = new jasmineUnderTest.HtmlReporter({
          env: env,
          getContainer: getContainer,
          createElement: function() {
            return document.createElement.apply(document, arguments);
          },
          createTextNode: function() {
            return document.createTextNode.apply(document, arguments);
          }
        });

      spyOn(console, 'error');

      reporter.initialize();
      reporter.jasmineStarted({});
      reporter.suiteStarted({ id: 1 });
      reporter.specStarted({
        id: 1,
        passedExpectations: [],
        failedExpectations: []
      });
      reporter.specDone({
        id: 1,
        status: 'passed',
        description: 'Spec Description',
        passedExpectations: [],
        failedExpectations: []
      });
      reporter.suiteDone({ id: 1 });
      reporter.jasmineDone({});

      const summary = container.querySelector('.jasmine-summary');
      const suite = summary.childNodes[0];
      const specs = suite.childNodes[1];
      const spec = specs.childNodes[0];
      const specLink = spec.childNodes[0];
      expect(specLink.innerHTML).toMatch(/SPEC HAS NO EXPECTATIONS/);
    })",snuts
/spec/html/HtmlReporterSpec.js,NonFunctionalStatement,"{'startLine':429,'endLine':429}","it('adds a warning to the link title of specs that have no expectations', function() {
      if (!window.console) {
        window.console = { error: function() {} };
      }
      const container = document.createElement('div'),
        getContainer = function() {
          return container;
        },
        reporter = new jasmineUnderTest.HtmlReporter({
          env: env,
          getContainer: getContainer,
          createElement: function() {
            return document.createElement.apply(document, arguments);
          },
          createTextNode: function() {
            return document.createTextNode.apply(document, arguments);
          }
        });

      spyOn(console, 'error');

      reporter.initialize();
      reporter.jasmineStarted({});
      reporter.suiteStarted({ id: 1 });
      reporter.specStarted({
        id: 1,
        passedExpectations: [],
        failedExpectations: []
      });
      reporter.specDone({
        id: 1,
        status: 'passed',
        description: 'Spec Description',
        passedExpectations: [],
        failedExpectations: []
      });
      reporter.suiteDone({ id: 1 });
      reporter.jasmineDone({});

      const summary = container.querySelector('.jasmine-summary');
      const suite = summary.childNodes[0];
      const specs = suite.childNodes[1];
      const spec = specs.childNodes[0];
      const specLink = spec.childNodes[0];
      expect(specLink.innerHTML).toMatch(/SPEC HAS NO EXPECTATIONS/);
    })",snuts
/spec/html/HtmlReporterSpec.js,VerboseStatement,"{'startLine':306,'endLine':354}","it('displays expandable stack traces', function() {
      const container = document.createElement('div'),
        getContainer = function() {
          return container;
        },
        reporter = new jasmineUnderTest.HtmlReporter({
          env: env,
          getContainer: getContainer,
          createElement: function() {
            return document.createElement.apply(document, arguments);
          },
          createTextNode: function() {
            return document.createTextNode.apply(document, arguments);
          }
        });

      reporter.initialize();

      reporter.jasmineStarted({});
      reporter.jasmineDone({
        deprecationWarnings: [
          {
            message: 'a deprecation',
            stack: 'a stack trace'
          }
        ],
        failedExpectations: []
      });

      const expander = container.querySelector(
        '.jasmine-alert .jasmine-bar .jasmine-expander'
      );
      const expanderContents = expander.querySelector(
        '.jasmine-expander-contents'
      );
      expect(expanderContents.textContent).toMatch(/a stack trace/);

      const expanderLink = expander.querySelector('a');
      expect(expander).not.toHaveClass('jasmine-expanded');
      expect(expanderLink.textContent).toMatch(/Show stack trace/);

      expanderLink.click();
      expect(expander).toHaveClass('jasmine-expanded');
      expect(expanderLink.textContent).toMatch(/Hide stack trace/);
      expanderLink.click();

      expect(expander).not.toHaveClass('jasmine-expanded');
      expect(expanderLink.textContent).toMatch(/Show stack trace/);
    })",snuts
/spec/html/HtmlReporterSpec.js,VerboseStatement,"{'startLine':427,'endLine':472}","it('adds a warning to the link title of specs that have no expectations', function() {
      if (!window.console) {
        window.console = { error: function() {} };
      }
      const container = document.createElement('div'),
        getContainer = function() {
          return container;
        },
        reporter = new jasmineUnderTest.HtmlReporter({
          env: env,
          getContainer: getContainer,
          createElement: function() {
            return document.createElement.apply(document, arguments);
          },
          createTextNode: function() {
            return document.createTextNode.apply(document, arguments);
          }
        });

      spyOn(console, 'error');

      reporter.initialize();
      reporter.jasmineStarted({});
      reporter.suiteStarted({ id: 1 });
      reporter.specStarted({
        id: 1,
        passedExpectations: [],
        failedExpectations: []
      });
      reporter.specDone({
        id: 1,
        status: 'passed',
        description: 'Spec Description',
        passedExpectations: [],
        failedExpectations: []
      });
      reporter.suiteDone({ id: 1 });
      reporter.jasmineDone({});

      const summary = container.querySelector('.jasmine-summary');
      const suite = summary.childNodes[0];
      const specs = suite.childNodes[1];
      const spec = specs.childNodes[0];
      const specLink = spec.childNodes[0];
      expect(specLink.innerHTML).toMatch(/SPEC HAS NO EXPECTATIONS/);
    })",snuts
/spec/html/HtmlReporterSpec.js,VerboseStatement,"{'startLine':502,'endLine':623}","it('reports the suite names with status, and spec names with status and duration', function() {
      const container = document.createElement('div'),
        getContainer = function() {
          return container;
        },
        reporter = new jasmineUnderTest.HtmlReporter({
          env: env,
          getContainer: getContainer,
          createElement: function() {
            return document.createElement.apply(document, arguments);
          },
          createTextNode: function() {
            return document.createTextNode.apply(document, arguments);
          },
          addToExistingQueryString: function(key, value) {
            return '?foo=bar&' + key + '=' + value;
          }
        });
      reporter.initialize();

      reporter.jasmineStarted({});
      reporter.suiteStarted({
        id: 1,
        description: 'A Suite',
        fullName: 'A Suite'
      });

      let specResult = {
        id: 123,
        description: 'with a spec',
        fullName: 'A Suite with a spec',
        status: 'passed',
        failedExpectations: [],
        passedExpectations: [{ passed: true }],
        duration: 1230
      };
      reporter.specStarted(specResult);
      reporter.specDone(specResult);

      reporter.suiteStarted({
        id: 2,
        description: 'inner suite',
        fullName: 'A Suite inner suite'
      });

      specResult = {
        id: 124,
        description: 'with another spec',
        fullName: 'A Suite inner suite with another spec',
        status: 'passed',
        failedExpectations: [],
        passedExpectations: [{ passed: true }],
        duration: 1240
      };
      reporter.specStarted(specResult);
      reporter.specDone(specResult);

      reporter.suiteDone({
        id: 2,
        status: 'things',
        description: 'inner suite',
        fullName: 'A Suite inner suite'
      });

      specResult = {
        id: 209,
        description: 'with a failing spec',
        fullName: 'A Suite inner with a failing spec',
        status: 'failed',
        failedExpectations: [{}],
        passedExpectations: [],
        duration: 2090
      };
      reporter.specStarted(specResult);
      reporter.specDone(specResult);

      reporter.suiteDone({
        id: 1,
        status: 'things',
        description: 'A Suite',
        fullName: 'A Suite'
      });

      reporter.jasmineDone({});
      const summary = container.querySelector('.jasmine-summary');

      expect(summary.childNodes.length).toEqual(1);

      const outerSuite = summary.childNodes[0];
      expect(outerSuite.childNodes.length).toEqual(4);

      const classes = [];
      for (let i = 0; i < outerSuite.childNodes.length; i++) {
        const node = outerSuite.childNodes[i];
        classes.push(node.getAttribute('class'));
      }
      expect(classes).toEqual([
        'jasmine-suite-detail jasmine-things',
        'jasmine-specs',
        'jasmine-suite',
        'jasmine-specs'
      ]);

      const suiteDetail = outerSuite.childNodes[0];
      const suiteLink = suiteDetail.childNodes[0];
      expect(suiteLink.innerHTML).toEqual('A Suite');
      expect(suiteLink.getAttribute('href')).toEqual('/?foo=bar&spec=A Suite');

      const specs = outerSuite.childNodes[1];
      const spec = specs.childNodes[0];
      expect(spec.getAttribute('class')).toEqual('jasmine-passed');
      expect(spec.getAttribute('id')).toEqual('spec-123');

      const specLink = spec.childNodes[0];
      expect(specLink.innerHTML).toEqual('with a spec');
      expect(specLink.getAttribute('href')).toEqual(
        '/?foo=bar&spec=A Suite with a spec'
      );

      const specDuration = spec.childNodes[1];
      expect(specDuration.innerHTML).toEqual('(1230ms)');
    })",snuts
/spec/html/HtmlReporterSpec.js,VerboseStatement,"{'startLine':1599,'endLine':1641}","it('reports failure messages and stack traces', function() {
        const specFailures = container.querySelector('.jasmine-failures');

        expect(specFailures.childNodes.length).toEqual(3);

        const specFailure = specFailures.childNodes[0];
        expect(specFailure.getAttribute('class')).toMatch(/jasmine-failed/);
        expect(specFailure.getAttribute('class')).toMatch(
          /jasmine-spec-detail/
        );

        const specDiv = specFailure.childNodes[0];
        expect(specDiv.getAttribute('class')).toEqual('jasmine-description');

        const message = specFailure.childNodes[1].childNodes[0];
        expect(message.getAttribute('class')).toEqual('jasmine-result-message');
        expect(message.innerHTML).toEqual('a failure message');

        const stackTrace = specFailure.childNodes[1].childNodes[1];
        expect(stackTrace.getAttribute('class')).toEqual('jasmine-stack-trace');
        expect(stackTrace.innerHTML).toEqual('a stack trace');

        const suiteFailure = specFailures.childNodes[0];
        expect(suiteFailure.getAttribute('class')).toMatch(/jasmine-failed/);
        expect(suiteFailure.getAttribute('class')).toMatch(
          /jasmine-spec-detail/
        );

        const suiteDiv = suiteFailure.childNodes[0];
        expect(suiteDiv.getAttribute('class')).toEqual('jasmine-description');

        const suiteMessage = suiteFailure.childNodes[1].childNodes[0];
        expect(suiteMessage.getAttribute('class')).toEqual(
          'jasmine-result-message'
        );
        expect(suiteMessage.innerHTML).toEqual('a failure message');

        const suiteStackTrace = suiteFailure.childNodes[1].childNodes[1];
        expect(suiteStackTrace.getAttribute('class')).toEqual(
          'jasmine-stack-trace'
        );
        expect(suiteStackTrace.innerHTML).toEqual('a stack trace');
      })",snuts
/spec/core/buildExpectationResultSpec.js,ConditionalTestLogic,"{'startLine':81,'endLine':83}","it('handles nodejs assertions', function() {
    if (typeof require === 'undefined') {
      pending('This test only runs in Node');
    }
    const assert = require('assert');
    const value = 8421;
    const expectedValue = 'JasmineExpectationTestValue';
    let error;
    try {
      assert.equal(value, expectedValue);
    } catch (e) {
      error = e;
    }

    expect(error.code).toEqual('ERR_ASSERTION');
    expect(error.actual).toEqual(value);
    expect(error.expected).toEqual(expectedValue);
    expect(error.operator).toEqual('==');

    const result = jasmineUnderTest.buildExpectationResult({
      passed: false,
      matcherName: '',
      expected: '',
      actual: '',
      error: error
    });

    expect(result.code).toEqual('ERR_ASSERTION');
    expect(result.actual).toEqual(value);
    expect(result.expected).toEqual(expectedValue);
    expect(result.matcherName).toEqual('assert ==');
  })",snuts
/spec/core/buildExpectationResultSpec.js,VerboseStatement,"{'startLine':80,'endLine':111}","it('handles nodejs assertions', function() {
    if (typeof require === 'undefined') {
      pending('This test only runs in Node');
    }
    const assert = require('assert');
    const value = 8421;
    const expectedValue = 'JasmineExpectationTestValue';
    let error;
    try {
      assert.equal(value, expectedValue);
    } catch (e) {
      error = e;
    }

    expect(error.code).toEqual('ERR_ASSERTION');
    expect(error.actual).toEqual(value);
    expect(error.expected).toEqual(expectedValue);
    expect(error.operator).toEqual('==');

    const result = jasmineUnderTest.buildExpectationResult({
      passed: false,
      matcherName: '',
      expected: '',
      actual: '',
      error: error
    });

    expect(result.code).toEqual('ERR_ASSERTION');
    expect(result.actual).toEqual(value);
    expect(result.expected).toEqual(expectedValue);
    expect(result.matcherName).toEqual('assert ==');
  })",snuts
/spec/core/baseSpec.js,IdenticalTestDescription,"{'startLine':114,'endLine':116}","it('returns true when the object is a Set', function() {
      expect(jasmineUnderTest.isIterable_(new Set())).toBe(true);
    })",snuts
/spec/core/baseSpec.js,ConditionalTestLogic,"{'startLine':4,'endLine':6}","it('correctly handles WebSocket events', function(done) {
      if (typeof jasmine.getGlobal().WebSocket === 'undefined') {
        pending('Environment does not provide WebSocket');
      }

      const obj = (function() {
        const sock = new WebSocket('ws://localhost');
        let event;
        sock.onerror = function(e) {
          event = e;
        };
        return function() {
          return event;
        };
      })();
      let left = 20;

      const int = setInterval(function() {
        if (obj() || left === 0) {
          const result = jasmineUnderTest.isError_(obj());
          expect(result).toBe(false);
          clearInterval(int);
          done();
        } else {
          left--;
        }
      }, 100);
    })",snuts
/spec/core/baseSpec.js,ConditionalTestLogic,"{'startLine':21,'endLine':28}","it('correctly handles WebSocket events', function(done) {
      if (typeof jasmine.getGlobal().WebSocket === 'undefined') {
        pending('Environment does not provide WebSocket');
      }

      const obj = (function() {
        const sock = new WebSocket('ws://localhost');
        let event;
        sock.onerror = function(e) {
          event = e;
        };
        return function() {
          return event;
        };
      })();
      let left = 20;

      const int = setInterval(function() {
        if (obj() || left === 0) {
          const result = jasmineUnderTest.isError_(obj());
          expect(result).toBe(false);
          clearInterval(int);
          done();
        } else {
          left--;
        }
      }, 100);
    })",snuts
/spec/core/baseSpec.js,ConditionalTestLogic,"{'startLine':43,'endLine':45}","it('returns true for an Error that originated from another frame', function() {
      if (typeof window === 'undefined') {
        pending('This test only runs in browsers.');
      }

      const iframe = document.createElement('iframe');
      iframe.style.display = 'none';
      document.body.appendChild(iframe);

      try {
        const error = iframe.contentWindow.eval('new Error()');
        expect(jasmineUnderTest.isError_(error)).toBe(true);
      } finally {
        document.body.removeChild(iframe);
      }
    })",snuts
/spec/core/baseSpec.js,ConditionalTestLogic,"{'startLine':181,'endLine':183}","it('is consistent with setTimeout in this environment', function(done) {
      const f1 = jasmine.createSpy('setTimeout callback for ' + max),
        f2 = jasmine.createSpy('setTimeout callback for ' + (max + 1));

      // Suppress printing of TimeoutOverflowWarning in node
      if (typeof process !== 'undefined' && process.emitWarning) {
        spyOn(process, 'emitWarning'); // Node 22
      }
      spyOn(console, 'error'); // Node <22

      let id = setTimeout(f1, max);
      setTimeout(function() {
        clearTimeout(id);
        expect(f1).not.toHaveBeenCalled();

        id = setTimeout(f2, max + 1);
        setTimeout(function() {
          clearTimeout(id);
          expect(f2).toHaveBeenCalled();
          done();
        });
      });
    })",snuts
/spec/core/baseSpec.js,NonFunctionalStatement,"{'startLine':33,'endLine':33}","it('returns true for an Error subclass', function() {
      function MyError() {}
      MyError.prototype = new Error();
      expect(jasmineUnderTest.isError_(new MyError())).toBe(true);
    })",snuts
/spec/core/baseSpec.js,NonFunctionalStatement,"{'startLine':84,'endLine':84}","it(""returns true when the argument's asymmetricMatch is a function"", function() {
      const obj = { asymmetricMatch: function() {} };
      expect(jasmineUnderTest.isAsymmetricEqualityTester_(obj)).toBe(true);
    })",snuts
/spec/core/baseSpec.js,NonFunctionalStatement,"{'startLine':122,'endLine':122}","it('returns true when the object implements @@iterator', function() {
      const myIterable = { [Symbol.iterator]: function() {} };
      expect(jasmineUnderTest.isIterable_(myIterable)).toBe(true);
    })",snuts
/spec/core/baseSpec.js,NonFunctionalStatement,"{'startLine':133,'endLine':133}","it('returns a promise that resolves to true when the promise is pending', function() {
      const promise = new Promise(function() {});
      return expectAsync(jasmineUnderTest.isPending_(promise)).toBeResolvedTo(
        true
      );
    })",snuts
/spec/core/UtilSpec.js,IdenticalTestDescription,"{'startLine':85,'endLine':87}","it('should return true when passed a native promise', function() {
        expect(jasmineUnderTest.isPromiseLike(mockNativePromise)).toBe(true);
      })",snuts
/spec/core/UtilSpec.js,IdenticalTestDescription,"{'startLine':101,'endLine':103}","it('should return false for strings', function() {
        expect(jasmineUnderTest.isPromiseLike('hello')).toBe(false);
      })",snuts
/spec/core/UtilSpec.js,IdenticalTestDescription,"{'startLine':105,'endLine':107}","it('should return false for numbers', function() {
        expect(jasmineUnderTest.isPromiseLike(3)).toBe(false);
      })",snuts
/spec/core/UtilSpec.js,IdenticalTestDescription,"{'startLine':109,'endLine':111}","it('should return false for null', function() {
        expect(jasmineUnderTest.isPromiseLike(null)).toBe(false);
      })",snuts
/spec/core/UtilSpec.js,IdenticalTestDescription,"{'startLine':113,'endLine':115}","it('should return false for undefined', function() {
        expect(jasmineUnderTest.isPromiseLike(undefined)).toBe(false);
      })",snuts
/spec/core/UtilSpec.js,IdenticalTestDescription,"{'startLine':117,'endLine':119}","it('should return false for arrays', function() {
        expect(jasmineUnderTest.isPromiseLike([])).toBe(false);
      })",snuts
/spec/core/UtilSpec.js,IdenticalTestDescription,"{'startLine':121,'endLine':123}","it('should return false for objects', function() {
        expect(jasmineUnderTest.isPromiseLike({})).toBe(false);
      })",snuts
/spec/core/UtilSpec.js,IdenticalTestDescription,"{'startLine':125,'endLine':127}","it('should return false for boolean values', function() {
        expect(jasmineUnderTest.isPromiseLike(true)).toBe(false);
      })",snuts
/spec/core/UtilSpec.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}","it('should return false if the argument is not an array', function() {
      expect(jasmineUnderTest.isArray_(undefined)).toBe(false);
      expect(jasmineUnderTest.isArray_({})).toBe(false);
      expect(jasmineUnderTest.isArray_(function() {})).toBe(false);
      expect(jasmineUnderTest.isArray_('foo')).toBe(false);
      expect(jasmineUnderTest.isArray_(5)).toBe(false);
      expect(jasmineUnderTest.isArray_(null)).toBe(false);
    })",snuts
/spec/core/UtilSpec.js,NonFunctionalStatement,"{'startLine':27,'endLine':27}","it('should return false if the argument is not an object', function() {
      expect(jasmineUnderTest.isObject_(undefined)).toBe(false);
      expect(jasmineUnderTest.isObject_([])).toBe(false);
      expect(jasmineUnderTest.isObject_(function() {})).toBe(false);
      expect(jasmineUnderTest.isObject_('foo')).toBe(false);
      expect(jasmineUnderTest.isObject_(5)).toBe(false);
      expect(jasmineUnderTest.isObject_(null)).toBe(false);
    })",snuts
/spec/core/UtilSpec.js,NonFunctionalStatement,"{'startLine':38,'endLine':38}","describe('promise utils', function() {
    let mockNativePromise, mockPromiseLikeObject;

    const mockPromiseLike = function() {
      this.then = function() {};
    };

    beforeEach(function() {
      mockNativePromise = new Promise(function() {});
      mockPromiseLikeObject = new mockPromiseLike();
    });

    describe('isPromise', function() {
      it('should return true when passed a native promise', function() {
        expect(jasmineUnderTest.isPromise(mockNativePromise)).toBe(true);
      });

      it('should return false for promise like objects', function() {
        expect(jasmineUnderTest.isPromise(mockPromiseLikeObject)).toBe(false);
      });

      it('should return false for strings', function() {
        expect(jasmineUnderTest.isPromise('hello')).toBe(false);
      });

      it('should return false for numbers', function() {
        expect(jasmineUnderTest.isPromise(3)).toBe(false);
      });

      it('should return false for null', function() {
        expect(jasmineUnderTest.isPromise(null)).toBe(false);
      });

      it('should return false for undefined', function() {
        expect(jasmineUnderTest.isPromise(undefined)).toBe(false);
      });

      it('should return false for arrays', function() {
        expect(jasmineUnderTest.isPromise([])).toBe(false);
      });

      it('should return false for objects', function() {
        expect(jasmineUnderTest.isPromise({})).toBe(false);
      });

      it('should return false for boolean values', function() {
        expect(jasmineUnderTest.isPromise(true)).toBe(false);
      });
    });

    describe('isPromiseLike', function() {
      it('should return true when passed a native promise', function() {
        expect(jasmineUnderTest.isPromiseLike(mockNativePromise)).toBe(true);
      });

      it('should return  true for promise like objects', function() {
        expect(jasmineUnderTest.isPromiseLike(mockPromiseLikeObject)).toBe(
          true
        );
      });

      it('should return false if then is not a function', function() {
        expect(
          jasmineUnderTest.isPromiseLike({ then: { its: 'Not a function :O' } })
        ).toBe(false);
      });

      it('should return false for strings', function() {
        expect(jasmineUnderTest.isPromiseLike('hello')).toBe(false);
      });

      it('should return false for numbers', function() {
        expect(jasmineUnderTest.isPromiseLike(3)).toBe(false);
      });

      it('should return false for null', function() {
        expect(jasmineUnderTest.isPromiseLike(null)).toBe(false);
      });

      it('should return false for undefined', function() {
        expect(jasmineUnderTest.isPromiseLike(undefined)).toBe(false);
      });

      it('should return false for arrays', function() {
        expect(jasmineUnderTest.isPromiseLike([])).toBe(false);
      });

      it('should return false for objects', function() {
        expect(jasmineUnderTest.isPromiseLike({})).toBe(false);
      });

      it('should return false for boolean values', function() {
        expect(jasmineUnderTest.isPromiseLike(true)).toBe(false);
      });
    });
  })",snuts
/spec/core/UtilSpec.js,NonFunctionalStatement,"{'startLine':42,'endLine':42}","beforeEach(function() {
      mockNativePromise = new Promise(function() {});
      mockPromiseLikeObject = new mockPromiseLike();
    })",snuts
/spec/core/UserContextSpec.js,IdenticalTestDescription,"{'startLine':44,'endLine':46}","it('does not return the same object', function() {
        expect(this.cloned).not.toBe(this.context);
      })",snuts
/spec/core/UserContextSpec.js,ConditionalTestLogic,"{'startLine':7,'endLine':9}","it('Behaves just like an plain object', function() {
    const context = new jasmineUnderTest.UserContext(),
      properties = [];

    for (const prop in context) {
      if (obj.hasOwnProperty(prop)) {
        properties.push(prop);
      }
    }

    expect(properties).toEqual([]);
  })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':200,'endLine':200}","it('reports the duration of the suite', async function() {
      const timer = jasmine.createSpyObj('timer', ['start', 'elapsed']);
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite1',
        parentSuite: topSuite,
        timer
      });
      topSuite.addChild(suite);
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      expect(timer.start).not.toHaveBeenCalled();
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      suiteRunQueueOpts.queueableFns[0].fn();
      expect(timer.start).toHaveBeenCalled();
      expect(timer.elapsed).not.toHaveBeenCalled();

      timer.elapsed.and.returnValue('the duration');
      suiteRunQueueOpts.onComplete();
      expect(timer.elapsed).toHaveBeenCalled();
      const result = suite.getResult();
      expect(result.duration).toEqual('the duration');
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(result);

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':207,'endLine':207}","it('reports the duration of the suite', async function() {
      const timer = jasmine.createSpyObj('timer', ['start', 'elapsed']);
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite1',
        parentSuite: topSuite,
        timer
      });
      topSuite.addChild(suite);
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      expect(timer.start).not.toHaveBeenCalled();
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      suiteRunQueueOpts.queueableFns[0].fn();
      expect(timer.start).toHaveBeenCalled();
      expect(timer.elapsed).not.toHaveBeenCalled();

      timer.elapsed.and.returnValue('the duration');
      suiteRunQueueOpts.onComplete();
      expect(timer.elapsed).toHaveBeenCalled();
      const result = suite.getResult();
      expect(result.duration).toEqual('the duration');
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(result);

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':260,'endLine':260}","it('returns false if a suite failed', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const failingSuite = new jasmineUnderTest.Suite({
        id: 'failingSuite',
        parentSuite: topSuite
      });
      const passingSuite = new jasmineUnderTest.Suite({
        id: 'passingSuite',
        parentSuite: topSuite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite: failingSuite }, { suite: passingSuite }];
        },
        childrenOfSuiteSegment() {
          return [];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      // Fail the first suite.
      expect(runQueue).toHaveBeenCalledTimes(1);
      const failingSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      failingSuiteRunQueueOpts.queueableFns[0].fn();
      failingSuite.addExpectationResult(false, {});
      failingSuiteRunQueueOpts.onComplete();

      // Passing the second suite should not reset the overall result.
      topSuiteRunQueueOpts.queueableFns[1].fn(function() {});
      expect(runQueue).toHaveBeenCalledTimes(1);
      const passingSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      passingSuiteRunQueueOpts.queueableFns[0].fn();
      passingSuiteRunQueueOpts.onComplete();

      topSuiteRunQueueOpts.onComplete();

      const result = await executePromise;
      expect(result.hasFailures).toEqual(true);
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':267,'endLine':267}","it('returns false if a suite failed', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const failingSuite = new jasmineUnderTest.Suite({
        id: 'failingSuite',
        parentSuite: topSuite
      });
      const passingSuite = new jasmineUnderTest.Suite({
        id: 'passingSuite',
        parentSuite: topSuite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite: failingSuite }, { suite: passingSuite }];
        },
        childrenOfSuiteSegment() {
          return [];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      // Fail the first suite.
      expect(runQueue).toHaveBeenCalledTimes(1);
      const failingSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      failingSuiteRunQueueOpts.queueableFns[0].fn();
      failingSuite.addExpectationResult(false, {});
      failingSuiteRunQueueOpts.onComplete();

      // Passing the second suite should not reset the overall result.
      topSuiteRunQueueOpts.queueableFns[1].fn(function() {});
      expect(runQueue).toHaveBeenCalledTimes(1);
      const passingSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      passingSuiteRunQueueOpts.queueableFns[0].fn();
      passingSuiteRunQueueOpts.onComplete();

      topSuiteRunQueueOpts.onComplete();

      const result = await executePromise;
      expect(result.hasFailures).toEqual(true);
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':278,'endLine':278}","it('returns false if a suite failed', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const failingSuite = new jasmineUnderTest.Suite({
        id: 'failingSuite',
        parentSuite: topSuite
      });
      const passingSuite = new jasmineUnderTest.Suite({
        id: 'passingSuite',
        parentSuite: topSuite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite: failingSuite }, { suite: passingSuite }];
        },
        childrenOfSuiteSegment() {
          return [];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      // Fail the first suite.
      expect(runQueue).toHaveBeenCalledTimes(1);
      const failingSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      failingSuiteRunQueueOpts.queueableFns[0].fn();
      failingSuite.addExpectationResult(false, {});
      failingSuiteRunQueueOpts.onComplete();

      // Passing the second suite should not reset the overall result.
      topSuiteRunQueueOpts.queueableFns[1].fn(function() {});
      expect(runQueue).toHaveBeenCalledTimes(1);
      const passingSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      passingSuiteRunQueueOpts.queueableFns[0].fn();
      passingSuiteRunQueueOpts.onComplete();

      topSuiteRunQueueOpts.onComplete();

      const result = await executePromise;
      expect(result.hasFailures).toEqual(true);
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':296,'endLine':296}","it('reports children when there is a beforeAll failure', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.beforeAll({ fn() {} });
      const spec = new jasmineUnderTest.Spec({
        id: 'spec',
        parentSuite: suite,
        queueableFn: { fn() {} }
      });
      suite.addChild(spec);
      topSuite.addChild(suite);
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const reportChildrenOfBeforeAllFailure = jasmine
        .createSpy('reportChildrenOfBeforeAllFailure')
        .and.returnValue(Promise.resolve());
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        reportChildrenOfBeforeAllFailure,
        getConfig() {
          return {};
        }
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      suiteRunQueueOpts.queueableFns[0].fn();
      suite.hadBeforeAllFailure = true;
      suiteRunQueueOpts.onComplete();

      while (reportDispatcher.suiteDone.calls.count() === 0) {
        await Promise.resolve();
      }

      expect(reportDispatcher.specDone).toHaveBeenCalledBefore(
        reportDispatcher.suiteDone
      );
      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':300,'endLine':300}","it('reports children when there is a beforeAll failure', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.beforeAll({ fn() {} });
      const spec = new jasmineUnderTest.Spec({
        id: 'spec',
        parentSuite: suite,
        queueableFn: { fn() {} }
      });
      suite.addChild(spec);
      topSuite.addChild(suite);
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const reportChildrenOfBeforeAllFailure = jasmine
        .createSpy('reportChildrenOfBeforeAllFailure')
        .and.returnValue(Promise.resolve());
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        reportChildrenOfBeforeAllFailure,
        getConfig() {
          return {};
        }
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      suiteRunQueueOpts.queueableFns[0].fn();
      suite.hadBeforeAllFailure = true;
      suiteRunQueueOpts.onComplete();

      while (reportDispatcher.suiteDone.calls.count() === 0) {
        await Promise.resolve();
      }

      expect(reportDispatcher.specDone).toHaveBeenCalledBefore(
        reportDispatcher.suiteDone
      );
      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':338,'endLine':338}","it('reports children when there is a beforeAll failure', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.beforeAll({ fn() {} });
      const spec = new jasmineUnderTest.Spec({
        id: 'spec',
        parentSuite: suite,
        queueableFn: { fn() {} }
      });
      suite.addChild(spec);
      topSuite.addChild(suite);
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const reportChildrenOfBeforeAllFailure = jasmine
        .createSpy('reportChildrenOfBeforeAllFailure')
        .and.returnValue(Promise.resolve());
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        reportChildrenOfBeforeAllFailure,
        getConfig() {
          return {};
        }
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      suiteRunQueueOpts.queueableFns[0].fn();
      suite.hadBeforeAllFailure = true;
      suiteRunQueueOpts.onComplete();

      while (reportDispatcher.suiteDone.calls.count() === 0) {
        await Promise.resolve();
      }

      expect(reportDispatcher.specDone).toHaveBeenCalledBefore(
        reportDispatcher.suiteDone
      );
      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':365,'endLine':365}","it('throws if the wrong suite is completed', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      const spec = new jasmineUnderTest.Spec({
        id: 'spec',
        parentSuite: suite,
        queueableFn: { fn() {} }
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];

      // Complete the suite without starting it
      expect(function() {
        suiteRunQueueOpts.onComplete();
      }).toThrowError('Tried to complete the wrong suite');

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':391,'endLine':391}","it('throws if the wrong suite is completed', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      const spec = new jasmineUnderTest.Spec({
        id: 'spec',
        parentSuite: suite,
        queueableFn: { fn() {} }
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];

      // Complete the suite without starting it
      expect(function() {
        suiteRunQueueOpts.onComplete();
      }).toThrowError('Tried to complete the wrong suite');

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':398,'endLine':398}","it('throws if the wrong suite is completed', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      const spec = new jasmineUnderTest.Spec({
        id: 'spec',
        parentSuite: suite,
        queueableFn: { fn() {} }
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];

      // Complete the suite without starting it
      expect(function() {
        suiteRunQueueOpts.onComplete();
      }).toThrowError('Tried to complete the wrong suite');

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':510,'endLine':510}","it('works for beforeAll when the detectLateRejectionHandling param is true', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.beforeAll(function() {});
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn() {} },
        parentSuite: suite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const globalErrors = mockGlobalErrors();
      const setTimeout = jasmine.createSpy('setTimeout');
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors,
        runableResources: mockRunableResources(),
        reportDispatcher,
        setTimeout,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return { detectLateRejectionHandling: true };
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      expect(suiteRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) }, // onStart
        jasmine.objectContaining({ type: 'beforeAll' }),
        { fn: jasmine.any(Function) }, // detect late rejection handling
        { fn: jasmine.any(Function) } // spec
      ]);
      suiteRunQueueOpts.queueableFns[0].fn();
      const done = jasmine.createSpy('done');
      suiteRunQueueOpts.queueableFns[2].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':512,'endLine':512}","it('works for beforeAll when the detectLateRejectionHandling param is true', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.beforeAll(function() {});
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn() {} },
        parentSuite: suite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const globalErrors = mockGlobalErrors();
      const setTimeout = jasmine.createSpy('setTimeout');
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors,
        runableResources: mockRunableResources(),
        reportDispatcher,
        setTimeout,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return { detectLateRejectionHandling: true };
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      expect(suiteRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) }, // onStart
        jasmine.objectContaining({ type: 'beforeAll' }),
        { fn: jasmine.any(Function) }, // detect late rejection handling
        { fn: jasmine.any(Function) } // spec
      ]);
      suiteRunQueueOpts.queueableFns[0].fn();
      const done = jasmine.createSpy('done');
      suiteRunQueueOpts.queueableFns[2].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':542,'endLine':542}","it('works for beforeAll when the detectLateRejectionHandling param is true', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.beforeAll(function() {});
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn() {} },
        parentSuite: suite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const globalErrors = mockGlobalErrors();
      const setTimeout = jasmine.createSpy('setTimeout');
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors,
        runableResources: mockRunableResources(),
        reportDispatcher,
        setTimeout,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return { detectLateRejectionHandling: true };
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      expect(suiteRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) }, // onStart
        jasmine.objectContaining({ type: 'beforeAll' }),
        { fn: jasmine.any(Function) }, // detect late rejection handling
        { fn: jasmine.any(Function) } // spec
      ]);
      suiteRunQueueOpts.queueableFns[0].fn();
      const done = jasmine.createSpy('done');
      suiteRunQueueOpts.queueableFns[2].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':549,'endLine':549}","it('works for beforeAll when the detectLateRejectionHandling param is true', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.beforeAll(function() {});
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn() {} },
        parentSuite: suite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const globalErrors = mockGlobalErrors();
      const setTimeout = jasmine.createSpy('setTimeout');
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors,
        runableResources: mockRunableResources(),
        reportDispatcher,
        setTimeout,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return { detectLateRejectionHandling: true };
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      expect(suiteRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) }, // onStart
        jasmine.objectContaining({ type: 'beforeAll' }),
        { fn: jasmine.any(Function) }, // detect late rejection handling
        { fn: jasmine.any(Function) } // spec
      ]);
      suiteRunQueueOpts.queueableFns[0].fn();
      const done = jasmine.createSpy('done');
      suiteRunQueueOpts.queueableFns[2].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':579,'endLine':579}","it('works for afterAll when the detectLateRejectionHandling param is true', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.afterAll(function() {});
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn() {} },
        parentSuite: suite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const globalErrors = mockGlobalErrors();
      const setTimeout = jasmine.createSpy('setTimeout');
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors,
        runableResources: mockRunableResources(),
        reportDispatcher,
        setTimeout,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return { detectLateRejectionHandling: true };
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      expect(suiteRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) }, // onStart
        { fn: jasmine.any(Function) }, // spec
        jasmine.objectContaining({ type: 'afterAll' }),
        { fn: jasmine.any(Function) } // detect late rejection handling
      ]);
      suiteRunQueueOpts.queueableFns[0].fn();
      const done = jasmine.createSpy('done');
      suiteRunQueueOpts.queueableFns[3].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':581,'endLine':581}","it('works for afterAll when the detectLateRejectionHandling param is true', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.afterAll(function() {});
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn() {} },
        parentSuite: suite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const globalErrors = mockGlobalErrors();
      const setTimeout = jasmine.createSpy('setTimeout');
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors,
        runableResources: mockRunableResources(),
        reportDispatcher,
        setTimeout,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return { detectLateRejectionHandling: true };
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      expect(suiteRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) }, // onStart
        { fn: jasmine.any(Function) }, // spec
        jasmine.objectContaining({ type: 'afterAll' }),
        { fn: jasmine.any(Function) } // detect late rejection handling
      ]);
      suiteRunQueueOpts.queueableFns[0].fn();
      const done = jasmine.createSpy('done');
      suiteRunQueueOpts.queueableFns[3].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':611,'endLine':611}","it('works for afterAll when the detectLateRejectionHandling param is true', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.afterAll(function() {});
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn() {} },
        parentSuite: suite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const globalErrors = mockGlobalErrors();
      const setTimeout = jasmine.createSpy('setTimeout');
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors,
        runableResources: mockRunableResources(),
        reportDispatcher,
        setTimeout,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return { detectLateRejectionHandling: true };
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      expect(suiteRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) }, // onStart
        { fn: jasmine.any(Function) }, // spec
        jasmine.objectContaining({ type: 'afterAll' }),
        { fn: jasmine.any(Function) } // detect late rejection handling
      ]);
      suiteRunQueueOpts.queueableFns[0].fn();
      const done = jasmine.createSpy('done');
      suiteRunQueueOpts.queueableFns[3].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':618,'endLine':618}","it('works for afterAll when the detectLateRejectionHandling param is true', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.afterAll(function() {});
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn() {} },
        parentSuite: suite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const globalErrors = mockGlobalErrors();
      const setTimeout = jasmine.createSpy('setTimeout');
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors,
        runableResources: mockRunableResources(),
        reportDispatcher,
        setTimeout,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return { detectLateRejectionHandling: true };
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      expect(suiteRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) }, // onStart
        { fn: jasmine.any(Function) }, // spec
        jasmine.objectContaining({ type: 'afterAll' }),
        { fn: jasmine.any(Function) } // detect late rejection handling
      ]);
      suiteRunQueueOpts.queueableFns[0].fn();
      const done = jasmine.createSpy('done');
      suiteRunQueueOpts.queueableFns[3].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,NonFunctionalStatement,"{'startLine':674,'endLine':674}","describe('TreeRunner', function() {
  describe('spec execution', function() {
    it('starts the timer, reports the spec started, and updates run state at the start of the queue', async function() {
      const timer = jasmine.createSpyObj('timer', ['start']);
      const spec = new jasmineUnderTest.Spec({
        id: 'spec1',
        queueableFn: {},
        timer
      });
      const {
        runQueue,
        currentRunableTracker,
        runableResources,
        reportDispatcher,
        suiteRunQueueArgs,
        executePromise
      } = runSingleSpecSuite(spec);
      suiteRunQueueArgs.queueableFns[0].fn();

      expect(runQueue).toHaveBeenCalledTimes(1);
      const specRunQueueArgs = runQueue.calls.mostRecent().args[0];
      const next = jasmine.createSpy('next');
      specRunQueueArgs.queueableFns[0].fn(next);

      expect(timer.start).toHaveBeenCalled();
      expect(currentRunableTracker.currentRunable()).toBe(spec);
      expect(runableResources.initForRunable).toHaveBeenCalledWith(
        spec.id,
        spec.parentSuiteId
      );
      expect(reportDispatcher.specStarted).toHaveBeenCalledWith(spec.result);
      await Promise.resolve();
      expect(reportDispatcher.specStarted).toHaveBeenCalledBefore(next);
      await expectAsync(executePromise).toBePending();
    });

    it('stops the timer, updates run state, and reports the spec done at the end of the queue', async function() {
      const timer = jasmine.createSpyObj('timer', ['start', 'elapsed']);
      const spec = new jasmineUnderTest.Spec({
        id: 'spec1',
        queueableFn: {},
        timer
      });
      const {
        runQueue,
        currentRunableTracker,
        runableResources,
        reportDispatcher,
        suiteRunQueueArgs,
        executePromise
      } = runSingleSpecSuite(spec);

      suiteRunQueueArgs.queueableFns[0].fn();

      expect(runQueue).toHaveBeenCalledTimes(1);
      const specRunQueueArgs = runQueue.calls.mostRecent().args[0];
      const next = jasmine.createSpy('next');
      timer.elapsed.and.returnValue('the elapsed time');
      currentRunableTracker.setCurrentSpec(spec);
      specRunQueueArgs.queueableFns[1].fn(next);

      expect(currentRunableTracker.currentSpec()).toBeFalsy();
      expect(runableResources.clearForRunable).toHaveBeenCalledWith(spec.id);
      expect(reportDispatcher.specDone).toHaveBeenCalledWith(spec.result);
      expect(spec.result.duration).toEqual('the elapsed time');
      expect(spec.reportedDone).toEqual(true);
      await Promise.resolve();
      await Promise.resolve();
      await Promise.resolve();
      expect(reportDispatcher.specDone).toHaveBeenCalledBefore(next);
      await expectAsync(executePromise).toBePending();
    });

    it('runs before and after fns', function() {
      const before = { fn: jasmine.createSpy('before') };
      const after = { fn: jasmine.createSpy('after') };
      const queueableFn = {
        fn: jasmine.createSpy('test body').and.callFake(function() {
          expect(before).toHaveBeenCalled();
          expect(after).not.toHaveBeenCalled();
        })
      };
      const spec = new jasmineUnderTest.Spec({
        queueableFn: queueableFn,
        beforeAndAfterFns: function() {
          return { befores: [before], afters: [after] };
        }
      });

      const { runQueue, suiteRunQueueArgs } = runSingleSpecSuite(spec);
      suiteRunQueueArgs.queueableFns[0].fn();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const specRunQueueArgs = runQueue.calls.mostRecent().args[0];

      expect(specRunQueueArgs.queueableFns[1]).toEqual(before);
      expect(specRunQueueArgs.queueableFns[2]).toEqual(queueableFn);
      expect(specRunQueueArgs.queueableFns[3]).toEqual(after);
    });

    it('marks specs pending at runtime', function() {
      let spec;
      const queueableFn = {
        fn() {
          spec.pend();
        }
      };
      spec = new jasmineUnderTest.Spec({ queueableFn });

      const { runQueue, suiteRunQueueArgs } = runSingleSpecSuite(spec);
      suiteRunQueueArgs.queueableFns[0].fn();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const specRunQueueArgs = runQueue.calls.mostRecent().args[0];

      expect(specRunQueueArgs.queueableFns[1]).toEqual(queueableFn);
      queueableFn.fn();

      expect(spec.getResult().status).toEqual('pending');
      expect(spec.getResult().pendingReason).toEqual('');
    });

    it('marks specs pending at runtime with a message', function() {
      let spec;
      const queueableFn = {
        fn() {
          spec.pend('some reason');
        }
      };
      spec = new jasmineUnderTest.Spec({ queueableFn });

      const { runQueue, suiteRunQueueArgs } = runSingleSpecSuite(spec);
      suiteRunQueueArgs.queueableFns[0].fn();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const specRunQueueArgs = runQueue.calls.mostRecent().args[0];

      expect(specRunQueueArgs.queueableFns[1]).toEqual(queueableFn);
      queueableFn.fn();

      expect(spec.getResult().status).toEqual('pending');
      expect(spec.getResult().pendingReason).toEqual('some reason');
    });

    it('passes failSpecWithNoExp to Spec#executionFinished', async function() {
      const spec = new jasmineUnderTest.Spec({
        id: 'spec1',
        queueableFn: {}
      });
      spyOn(spec, 'executionFinished');
      const {
        runQueue,
        suiteRunQueueArgs,
        executePromise
      } = runSingleSpecSuite(spec, { failSpecWithNoExpectations: true });

      suiteRunQueueArgs.queueableFns[0].fn();

      expect(runQueue).toHaveBeenCalledTimes(1);
      const specRunQueueArgs = runQueue.calls.mostRecent().args[0];
      expect(specRunQueueArgs.queueableFns[1].type).toEqual('specCleanup');
      specRunQueueArgs.queueableFns[1].fn();

      expect(spec.executionFinished).toHaveBeenCalledWith(false, true);
      await expectAsync(executePromise).toBePending();
    });
  });

  describe('Suite execution', function() {
    it('reports the duration of the suite', async function() {
      const timer = jasmine.createSpyObj('timer', ['start', 'elapsed']);
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite1',
        parentSuite: topSuite,
        timer
      });
      topSuite.addChild(suite);
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      expect(timer.start).not.toHaveBeenCalled();
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      suiteRunQueueOpts.queueableFns[0].fn();
      expect(timer.start).toHaveBeenCalled();
      expect(timer.elapsed).not.toHaveBeenCalled();

      timer.elapsed.and.returnValue('the duration');
      suiteRunQueueOpts.onComplete();
      expect(timer.elapsed).toHaveBeenCalled();
      const result = suite.getResult();
      expect(result.duration).toEqual('the duration');
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(result);

      await expectAsync(executePromise).toBePending();
    });

    it('returns false if a suite failed', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const failingSuite = new jasmineUnderTest.Suite({
        id: 'failingSuite',
        parentSuite: topSuite
      });
      const passingSuite = new jasmineUnderTest.Suite({
        id: 'passingSuite',
        parentSuite: topSuite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite: failingSuite }, { suite: passingSuite }];
        },
        childrenOfSuiteSegment() {
          return [];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      // Fail the first suite.
      expect(runQueue).toHaveBeenCalledTimes(1);
      const failingSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      failingSuiteRunQueueOpts.queueableFns[0].fn();
      failingSuite.addExpectationResult(false, {});
      failingSuiteRunQueueOpts.onComplete();

      // Passing the second suite should not reset the overall result.
      topSuiteRunQueueOpts.queueableFns[1].fn(function() {});
      expect(runQueue).toHaveBeenCalledTimes(1);
      const passingSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      passingSuiteRunQueueOpts.queueableFns[0].fn();
      passingSuiteRunQueueOpts.onComplete();

      topSuiteRunQueueOpts.onComplete();

      const result = await executePromise;
      expect(result.hasFailures).toEqual(true);
    });

    it('reports children when there is a beforeAll failure', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.beforeAll({ fn() {} });
      const spec = new jasmineUnderTest.Spec({
        id: 'spec',
        parentSuite: suite,
        queueableFn: { fn() {} }
      });
      suite.addChild(spec);
      topSuite.addChild(suite);
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const reportChildrenOfBeforeAllFailure = jasmine
        .createSpy('reportChildrenOfBeforeAllFailure')
        .and.returnValue(Promise.resolve());
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        reportChildrenOfBeforeAllFailure,
        getConfig() {
          return {};
        }
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      suiteRunQueueOpts.queueableFns[0].fn();
      suite.hadBeforeAllFailure = true;
      suiteRunQueueOpts.onComplete();

      while (reportDispatcher.suiteDone.calls.count() === 0) {
        await Promise.resolve();
      }

      expect(reportDispatcher.specDone).toHaveBeenCalledBefore(
        reportDispatcher.suiteDone
      );
      await expectAsync(executePromise).toBePending();
    });

    it('throws if the wrong suite is completed', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      const spec = new jasmineUnderTest.Spec({
        id: 'spec',
        parentSuite: suite,
        queueableFn: { fn() {} }
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];

      // Complete the suite without starting it
      expect(function() {
        suiteRunQueueOpts.onComplete();
      }).toThrowError('Tried to complete the wrong suite');

      await expectAsync(executePromise).toBePending();
    });
  });

  it('does not remove before and after fns from the top suite', async function() {
    const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
    spyOn(topSuite, 'cleanupBeforeAfter');
    const executionTree = {
      topSuite,
      childrenOfTopSuite() {
        return [];
      },
      isExcluded() {
        return false;
      }
    };
    const runQueue = jasmine.createSpy('runQueue');
    const subject = new jasmineUnderTest.TreeRunner({
      executionTree,
      runQueue,
      globalErrors: mockGlobalErrors(),
      runableResources: mockRunableResources(),
      reportDispatcher: mockReportDispatcher(),
      currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
      getConfig() {
        return {};
      }
    });

    const executePromise = subject.execute();
    expect(runQueue).toHaveBeenCalledTimes(1);
    const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
    runQueue.calls.reset();

    for (const qfn of topSuiteRunQueueOpts.queueableFns) {
      qfn.fn();
    }
    topSuiteRunQueueOpts.onComplete();

    await expectAsync(executePromise).toBeResolved();
    expect(topSuite.cleanupBeforeAfter).not.toHaveBeenCalled();
  });

  describe('Late promise rejection handling', function() {
    it('works for specs when the detectLateRejectionHandling param is true', function() {
      const before = jasmine.createSpy('before');
      const after = jasmine.createSpy('after');
      const queueableFn = {
        fn: jasmine.createSpy('test body').and.callFake(function() {
          expect(before).toHaveBeenCalled();
          expect(after).not.toHaveBeenCalled();
        })
      };
      const spec = new jasmineUnderTest.Spec({
        queueableFn,
        beforeAndAfterFns: function() {
          return { befores: [before], afters: [after] };
        }
      });

      const {
        runQueue,
        setTimeout,
        suiteRunQueueArgs,
        globalErrors
      } = runSingleSpecSuite(spec, { detectLateRejectionHandling: true });

      suiteRunQueueArgs.queueableFns[0].fn();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const specRunQueueOpts = runQueue.calls.mostRecent().args[0];

      expect(specRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) },
        before,
        queueableFn,
        after,
        { fn: jasmine.any(Function) },
        {
          fn: jasmine.any(Function),
          type: 'specCleanup'
        }
      ]);

      const done = jasmine.createSpy('done');
      specRunQueueOpts.queueableFns[4].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();
      expect(done).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalled();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );
    });

    it('works for beforeAll when the detectLateRejectionHandling param is true', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.beforeAll(function() {});
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn() {} },
        parentSuite: suite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const globalErrors = mockGlobalErrors();
      const setTimeout = jasmine.createSpy('setTimeout');
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors,
        runableResources: mockRunableResources(),
        reportDispatcher,
        setTimeout,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return { detectLateRejectionHandling: true };
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      expect(suiteRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) }, // onStart
        jasmine.objectContaining({ type: 'beforeAll' }),
        { fn: jasmine.any(Function) }, // detect late rejection handling
        { fn: jasmine.any(Function) } // spec
      ]);
      suiteRunQueueOpts.queueableFns[0].fn();
      const done = jasmine.createSpy('done');
      suiteRunQueueOpts.queueableFns[2].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );

      await expectAsync(executePromise).toBePending();
    });

    it('works for afterAll when the detectLateRejectionHandling param is true', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.afterAll(function() {});
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn() {} },
        parentSuite: suite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const globalErrors = mockGlobalErrors();
      const setTimeout = jasmine.createSpy('setTimeout');
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors,
        runableResources: mockRunableResources(),
        reportDispatcher,
        setTimeout,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return { detectLateRejectionHandling: true };
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      expect(suiteRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) }, // onStart
        { fn: jasmine.any(Function) }, // spec
        jasmine.objectContaining({ type: 'afterAll' }),
        { fn: jasmine.any(Function) } // detect late rejection handling
      ]);
      suiteRunQueueOpts.queueableFns[0].fn();
      const done = jasmine.createSpy('done');
      suiteRunQueueOpts.queueableFns[3].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );

      await expectAsync(executePromise).toBePending();
    });
  });

  function runSingleSpecSuite(spec, optionalConfig) {
    const topSuiteId = 'suite1';
    spec.parentSuiteId = topSuiteId;
    const topSuite = new jasmineUnderTest.Suite({ id: topSuiteId });
    topSuite.addChild(spec);
    const executionTree = {
      topSuite,
      childrenOfTopSuite() {
        return [{ spec }];
      },
      isExcluded() {
        return false;
      }
    };
    const runQueue = jasmine.createSpy('runQueue');
    const reportDispatcher = mockReportDispatcher();
    const runableResources = mockRunableResources();
    const globalErrors = mockGlobalErrors();
    const setTimeout = jasmine.createSpy('setTimeout');
    const currentRunableTracker = new jasmineUnderTest.CurrentRunableTracker();
    const subject = new jasmineUnderTest.TreeRunner({
      executionTree,
      runQueue,
      globalErrors,
      setTimeout,
      runableResources,
      reportDispatcher,
      currentRunableTracker,
      getConfig() {
        return optionalConfig || {};
      },
      reportChildrenOfBeforeAllFailure() {}
    });

    const executePromise = subject.execute();
    expect(runQueue).toHaveBeenCalledTimes(1);
    const suiteRunQueueArgs = runQueue.calls.mostRecent().args[0];
    runQueue.calls.reset();

    return {
      runQueue,
      globalErrors,
      setTimeout,
      currentRunableTracker,
      runableResources,
      reportDispatcher,
      suiteRunQueueArgs,
      executePromise
    };
  }

  function mockReportDispatcher() {
    const reportDispatcher = jasmine.createSpyObj(
      'reportDispatcher',
      jasmineUnderTest.reporterEvents
    );

    for (const k of jasmineUnderTest.reporterEvents) {
      reportDispatcher[k].and.returnValue(Promise.resolve());
    }

    return reportDispatcher;
  }

  function mockRunableResources() {
    return jasmine.createSpyObj('runableResources', [
      'initForRunable',
      'clearForRunable'
    ]);
  }

  function mockGlobalErrors() {
    return jasmine.createSpyObj('globalErrors', ['reportUnhandledRejections']);
  }
})",snuts
/spec/core/TreeRunnerSpec.js,VerboseStatement,"{'startLine':3,'endLine':35}","it('starts the timer, reports the spec started, and updates run state at the start of the queue', async function() {
      const timer = jasmine.createSpyObj('timer', ['start']);
      const spec = new jasmineUnderTest.Spec({
        id: 'spec1',
        queueableFn: {},
        timer
      });
      const {
        runQueue,
        currentRunableTracker,
        runableResources,
        reportDispatcher,
        suiteRunQueueArgs,
        executePromise
      } = runSingleSpecSuite(spec);
      suiteRunQueueArgs.queueableFns[0].fn();

      expect(runQueue).toHaveBeenCalledTimes(1);
      const specRunQueueArgs = runQueue.calls.mostRecent().args[0];
      const next = jasmine.createSpy('next');
      specRunQueueArgs.queueableFns[0].fn(next);

      expect(timer.start).toHaveBeenCalled();
      expect(currentRunableTracker.currentRunable()).toBe(spec);
      expect(runableResources.initForRunable).toHaveBeenCalledWith(
        spec.id,
        spec.parentSuiteId
      );
      expect(reportDispatcher.specStarted).toHaveBeenCalledWith(spec.result);
      await Promise.resolve();
      expect(reportDispatcher.specStarted).toHaveBeenCalledBefore(next);
      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,VerboseStatement,"{'startLine':37,'endLine':72}","it('stops the timer, updates run state, and reports the spec done at the end of the queue', async function() {
      const timer = jasmine.createSpyObj('timer', ['start', 'elapsed']);
      const spec = new jasmineUnderTest.Spec({
        id: 'spec1',
        queueableFn: {},
        timer
      });
      const {
        runQueue,
        currentRunableTracker,
        runableResources,
        reportDispatcher,
        suiteRunQueueArgs,
        executePromise
      } = runSingleSpecSuite(spec);

      suiteRunQueueArgs.queueableFns[0].fn();

      expect(runQueue).toHaveBeenCalledTimes(1);
      const specRunQueueArgs = runQueue.calls.mostRecent().args[0];
      const next = jasmine.createSpy('next');
      timer.elapsed.and.returnValue('the elapsed time');
      currentRunableTracker.setCurrentSpec(spec);
      specRunQueueArgs.queueableFns[1].fn(next);

      expect(currentRunableTracker.currentSpec()).toBeFalsy();
      expect(runableResources.clearForRunable).toHaveBeenCalledWith(spec.id);
      expect(reportDispatcher.specDone).toHaveBeenCalledWith(spec.result);
      expect(spec.result.duration).toEqual('the elapsed time');
      expect(spec.reportedDone).toEqual(true);
      await Promise.resolve();
      await Promise.resolve();
      await Promise.resolve();
      expect(reportDispatcher.specDone).toHaveBeenCalledBefore(next);
      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,VerboseStatement,"{'startLine':167,'endLine':224}","it('reports the duration of the suite', async function() {
      const timer = jasmine.createSpyObj('timer', ['start', 'elapsed']);
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite1',
        parentSuite: topSuite,
        timer
      });
      topSuite.addChild(suite);
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      expect(timer.start).not.toHaveBeenCalled();
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      suiteRunQueueOpts.queueableFns[0].fn();
      expect(timer.start).toHaveBeenCalled();
      expect(timer.elapsed).not.toHaveBeenCalled();

      timer.elapsed.and.returnValue('the duration');
      suiteRunQueueOpts.onComplete();
      expect(timer.elapsed).toHaveBeenCalled();
      const result = suite.getResult();
      expect(result.duration).toEqual('the duration');
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(result);

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,VerboseStatement,"{'startLine':226,'endLine':288}","it('returns false if a suite failed', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const failingSuite = new jasmineUnderTest.Suite({
        id: 'failingSuite',
        parentSuite: topSuite
      });
      const passingSuite = new jasmineUnderTest.Suite({
        id: 'passingSuite',
        parentSuite: topSuite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite: failingSuite }, { suite: passingSuite }];
        },
        childrenOfSuiteSegment() {
          return [];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      // Fail the first suite.
      expect(runQueue).toHaveBeenCalledTimes(1);
      const failingSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      failingSuiteRunQueueOpts.queueableFns[0].fn();
      failingSuite.addExpectationResult(false, {});
      failingSuiteRunQueueOpts.onComplete();

      // Passing the second suite should not reset the overall result.
      topSuiteRunQueueOpts.queueableFns[1].fn(function() {});
      expect(runQueue).toHaveBeenCalledTimes(1);
      const passingSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      passingSuiteRunQueueOpts.queueableFns[0].fn();
      passingSuiteRunQueueOpts.onComplete();

      topSuiteRunQueueOpts.onComplete();

      const result = await executePromise;
      expect(result.hasFailures).toEqual(true);
    })",snuts
/spec/core/TreeRunnerSpec.js,VerboseStatement,"{'startLine':290,'endLine':354}","it('reports children when there is a beforeAll failure', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.beforeAll({ fn() {} });
      const spec = new jasmineUnderTest.Spec({
        id: 'spec',
        parentSuite: suite,
        queueableFn: { fn() {} }
      });
      suite.addChild(spec);
      topSuite.addChild(suite);
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const reportChildrenOfBeforeAllFailure = jasmine
        .createSpy('reportChildrenOfBeforeAllFailure')
        .and.returnValue(Promise.resolve());
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        reportChildrenOfBeforeAllFailure,
        getConfig() {
          return {};
        }
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      suiteRunQueueOpts.queueableFns[0].fn();
      suite.hadBeforeAllFailure = true;
      suiteRunQueueOpts.onComplete();

      while (reportDispatcher.suiteDone.calls.count() === 0) {
        await Promise.resolve();
      }

      expect(reportDispatcher.specDone).toHaveBeenCalledBefore(
        reportDispatcher.suiteDone
      );
      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,VerboseStatement,"{'startLine':356,'endLine':409}","it('throws if the wrong suite is completed', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      const spec = new jasmineUnderTest.Spec({
        id: 'spec',
        parentSuite: suite,
        queueableFn: { fn() {} }
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors: mockGlobalErrors(),
        runableResources: mockRunableResources(),
        reportDispatcher,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return {};
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];

      // Complete the suite without starting it
      expect(function() {
        suiteRunQueueOpts.onComplete();
      }).toThrowError('Tried to complete the wrong suite');

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,VerboseStatement,"{'startLine':452,'endLine':502}","it('works for specs when the detectLateRejectionHandling param is true', function() {
      const before = jasmine.createSpy('before');
      const after = jasmine.createSpy('after');
      const queueableFn = {
        fn: jasmine.createSpy('test body').and.callFake(function() {
          expect(before).toHaveBeenCalled();
          expect(after).not.toHaveBeenCalled();
        })
      };
      const spec = new jasmineUnderTest.Spec({
        queueableFn,
        beforeAndAfterFns: function() {
          return { befores: [before], afters: [after] };
        }
      });

      const {
        runQueue,
        setTimeout,
        suiteRunQueueArgs,
        globalErrors
      } = runSingleSpecSuite(spec, { detectLateRejectionHandling: true });

      suiteRunQueueArgs.queueableFns[0].fn();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const specRunQueueOpts = runQueue.calls.mostRecent().args[0];

      expect(specRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) },
        before,
        queueableFn,
        after,
        { fn: jasmine.any(Function) },
        {
          fn: jasmine.any(Function),
          type: 'specCleanup'
        }
      ]);

      const done = jasmine.createSpy('done');
      specRunQueueOpts.queueableFns[4].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();
      expect(done).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalled();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );
    })",snuts
/spec/core/TreeRunnerSpec.js,VerboseStatement,"{'startLine':504,'endLine':571}","it('works for beforeAll when the detectLateRejectionHandling param is true', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.beforeAll(function() {});
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn() {} },
        parentSuite: suite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const globalErrors = mockGlobalErrors();
      const setTimeout = jasmine.createSpy('setTimeout');
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors,
        runableResources: mockRunableResources(),
        reportDispatcher,
        setTimeout,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return { detectLateRejectionHandling: true };
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      expect(suiteRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) }, // onStart
        jasmine.objectContaining({ type: 'beforeAll' }),
        { fn: jasmine.any(Function) }, // detect late rejection handling
        { fn: jasmine.any(Function) } // spec
      ]);
      suiteRunQueueOpts.queueableFns[0].fn();
      const done = jasmine.createSpy('done');
      suiteRunQueueOpts.queueableFns[2].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeRunnerSpec.js,VerboseStatement,"{'startLine':573,'endLine':640}","it('works for afterAll when the detectLateRejectionHandling param is true', async function() {
      const topSuite = new jasmineUnderTest.Suite({ id: 'topSuite' });
      const suite = new jasmineUnderTest.Suite({
        id: 'suite',
        parentSuite: topSuite
      });
      suite.afterAll(function() {});
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn() {} },
        parentSuite: suite
      });
      const executionTree = {
        topSuite,
        childrenOfTopSuite() {
          return [{ suite }];
        },
        childrenOfSuiteSegment() {
          return [{ spec }];
        },
        isExcluded() {
          return false;
        }
      };
      const runQueue = jasmine.createSpy('runQueue');
      const reportDispatcher = mockReportDispatcher();
      const globalErrors = mockGlobalErrors();
      const setTimeout = jasmine.createSpy('setTimeout');
      const subject = new jasmineUnderTest.TreeRunner({
        executionTree,
        runQueue,
        globalErrors,
        runableResources: mockRunableResources(),
        reportDispatcher,
        setTimeout,
        currentRunableTracker: new jasmineUnderTest.CurrentRunableTracker(),
        getConfig() {
          return { detectLateRejectionHandling: true };
        },
        reportChildrenOfBeforeAllFailure() {}
      });

      const executePromise = subject.execute();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const topSuiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      runQueue.calls.reset();
      topSuiteRunQueueOpts.queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(1);
      const suiteRunQueueOpts = runQueue.calls.mostRecent().args[0];
      expect(suiteRunQueueOpts.queueableFns).toEqual([
        { fn: jasmine.any(Function) }, // onStart
        { fn: jasmine.any(Function) }, // spec
        jasmine.objectContaining({ type: 'afterAll' }),
        { fn: jasmine.any(Function) } // detect late rejection handling
      ]);
      suiteRunQueueOpts.queueableFns[0].fn();
      const done = jasmine.createSpy('done');
      suiteRunQueueOpts.queueableFns[3].fn(done);
      expect(globalErrors.reportUnhandledRejections).not.toHaveBeenCalled();

      expect(setTimeout).toHaveBeenCalledOnceWith(jasmine.any(Function));
      setTimeout.calls.argsFor(0)[0]();
      expect(globalErrors.reportUnhandledRejections).toHaveBeenCalledBefore(
        done
      );

      await expectAsync(executePromise).toBePending();
    })",snuts
/spec/core/TreeProcessorSpec.js,NonFunctionalStatement,"{'startLine':19,'endLine':19}","describe('TreeProcessor', function() {
  let nodeNumber = 0,
    leafNumber = 0;

  function Node(attrs) {
    attrs = attrs || {};
    this.id = 'node' + nodeNumber++;
    this.children = attrs.children || [];
    this.canBeReentered = function() {
      return !attrs.noReenter;
    };
    this.markedPending = attrs.markedPending || false;
    this.sharedUserContext = function() {
      return attrs.userContext || {};
    };
    this.getResult = jasmine.createSpy(this.id + '#execute');
    this.beforeAllFns = attrs.beforeAllFns || [];
    this.afterAllFns = attrs.afterAllFns || [];
    this.cleanupBeforeAfter = function() {};
  }

  function Leaf(attrs) {
    attrs = attrs || {};
    this.id = 'leaf' + leafNumber++;
    this.markedPending = attrs.markedPending || false;
    this.execute = jasmine.createSpy(this.id + '#execute');
  }

  it('processes a single leaf', function() {
    const leaf = new Leaf(),
      processor = new jasmineUnderTest.TreeProcessor({
        tree: leaf,
        runnableIds: [leaf.id]
      });

    const result = processor.processTree();

    expect(result.isExcluded(leaf)).toEqual(false);
  });

  it('processes a single pending leaf', function() {
    const leaf = new Leaf({ markedPending: true }),
      processor = new jasmineUnderTest.TreeProcessor({
        tree: leaf,
        runnableIds: [leaf.id]
      });

    const result = processor.processTree();

    expect(result.isExcluded(leaf)).toEqual(false);
  });

  it('processes a single non-specified leaf', function() {
    const leaf = new Leaf(),
      processor = new jasmineUnderTest.TreeProcessor({
        tree: leaf,
        runnableIds: []
      });

    const result = processor.processTree();

    expect(result.isExcluded(leaf)).toEqual(true);
  });

  it('processes a single excluded leaf', function() {
    const leaf = new Leaf(),
      processor = new jasmineUnderTest.TreeProcessor({
        tree: leaf,
        runnableIds: [leaf.id],
        excludeNode: function() {
          return true;
        }
      });

    const result = processor.processTree();

    expect(result.isExcluded(leaf)).toEqual(true);
  });

  it('processes a tree with a single leaf with the root specified', function() {
    const leaf = new Leaf(),
      parent = new Node({ children: [leaf] }),
      processor = new jasmineUnderTest.TreeProcessor({
        tree: parent,
        runnableIds: [parent.id]
      });

    const result = processor.processTree();

    expect(result.isExcluded(parent)).toEqual(false);
    expect(result.childrenOfTopSuite()).toEqual([{ spec: leaf }]);
    expect(result.isExcluded(leaf)).toEqual(false);
  });

  it('processes a tree with a single pending leaf, with the root specified', function() {
    const leaf = new Leaf({ markedPending: true }),
      parent = new Node({ children: [leaf] }),
      processor = new jasmineUnderTest.TreeProcessor({
        tree: parent,
        runnableIds: [parent.id]
      });

    const result = processor.processTree();

    expect(result.isExcluded(parent)).toEqual(true);
    expect(result.childrenOfTopSuite()).toEqual([{ spec: leaf }]);
    expect(result.isExcluded(leaf)).toEqual(false);
  });

  it('runs orders leaves before non-specified leaves within a parent node', function() {
    const specified = new Leaf();
    const nonSpecified = new Leaf();
    const root = new Node({ children: [nonSpecified, specified] });
    const processor = new jasmineUnderTest.TreeProcessor({
      tree: root,
      runnableIds: [specified.id]
    });

    const result = processor.processTree();

    expect(result.childrenOfTopSuite()).toEqual([
      { spec: specified },
      { spec: nonSpecified }
    ]);
  });

  it('processes an excluded node with children', function() {
    const leaf1 = new Leaf();
    const node = new Node({ children: [leaf1] });
    const root = new Node({ children: [node] });
    const processor = new jasmineUnderTest.TreeProcessor({
      tree: root,
      runnableIds: []
    });

    const result = processor.processTree();

    expect(result.childrenOfTopSuite()).toEqual([
      { suite: node, segmentNumber: 0 }
    ]);
    expect(result.isExcluded(node)).toEqual(true);
    expect(result.childrenOfSuiteSegment(node, 0)).toEqual([{ spec: leaf1 }]);
    expect(result.isExcluded(node)).toEqual(true);
  });

  it('processes a complicated tree with the root specified', function() {
    const pendingLeaf = new Leaf({ markedPending: true }),
      executableLeaf = new Leaf({ markedPending: false }),
      parent = new Node({ children: [pendingLeaf, executableLeaf] }),
      childless = new Node(),
      childOfPending = new Leaf({ markedPending: true }),
      pendingNode = new Node({
        markedPending: true,
        children: [childOfPending]
      }),
      parentOfPendings = new Node({
        markedPending: false,
        children: [childless, pendingNode]
      }),
      root = new Node({ children: [parent, parentOfPendings] }),
      processor = new jasmineUnderTest.TreeProcessor({
        tree: root,
        runnableIds: [root.id]
      });

    const result = processor.processTree();

    expect(result.isExcluded(parent)).toEqual(false);
    expect(result.childrenOfTopSuite()).toEqual([
      { suite: parent, segmentNumber: 0 },
      { suite: parentOfPendings, segmentNumber: 0 }
    ]);

    expect(result.isExcluded(parentOfPendings)).toEqual(true);
    expect(result.childrenOfSuiteSegment(parentOfPendings, 0)).toEqual([
      { suite: childless, segmentNumber: 0 },
      { suite: pendingNode, segmentNumber: 0 }
    ]);

    expect(result.isExcluded(childless)).toEqual(true);
    expect(result.childrenOfSuiteSegment(childless, 0)).toEqual([]);

    expect(result.isExcluded(pendingLeaf)).toEqual(false);
    expect(result.isExcluded(executableLeaf)).toEqual(false);

    expect(result.isExcluded(parent)).toEqual(false);
    expect(result.childrenOfSuiteSegment(parent, 0)).toEqual([
      { spec: pendingLeaf },
      { spec: executableLeaf }
    ]);

    expect(result.isExcluded(pendingNode)).toEqual(true);
    expect(result.childrenOfSuiteSegment(pendingNode, 0)).toEqual([
      { spec: childOfPending }
    ]);

    expect(result.isExcluded(childOfPending)).toEqual(false);
  });

  it('throws if the specified order would re-enter a node that does not allow re-entry', function() {
    const leaf1 = new Leaf(),
      leaf2 = new Leaf(),
      leaf3 = new Leaf(),
      reentered = new Node({ noReenter: true, children: [leaf1, leaf2] }),
      root = new Node({ children: [reentered, leaf3] }),
      processor = new jasmineUnderTest.TreeProcessor({
        tree: root,
        runnableIds: [leaf1.id, leaf3.id, leaf2.id]
      });

    expect(function() {
      processor.processTree();
    }).toThrowError(
      'Invalid order: would cause a beforeAll or afterAll to be run multiple times'
    );
  });

  it('does not throw if a node being re-entered allows re-entry', function() {
    const leaf1 = new Leaf();
    const leaf2 = new Leaf();
    const leaf3 = new Leaf();
    const reentered = new Node({ children: [leaf1, leaf2] });
    const root = new Node({ children: [reentered, leaf3] });
    const processor = new jasmineUnderTest.TreeProcessor({
      tree: root,
      runnableIds: [leaf1.id, leaf3.id, leaf2.id]
    });
    const env = jasmineUnderTest.getEnv();
    spyOn(env, 'deprecated');

    processor.processTree();

    expect(env.deprecated).toHaveBeenCalledWith(
      'The specified spec/suite order splits up a suite, running unrelated specs in the middle of it. This will become an error in a future release.'
    );
  });

  it(""does not throw if a node which can't be re-entered is only entered once"", function() {
    const leaf1 = new Leaf(),
      leaf2 = new Leaf(),
      leaf3 = new Leaf(),
      noReentry = new Node({ noReenter: true }),
      root = new Node({ children: [noReentry] }),
      processor = new jasmineUnderTest.TreeProcessor({
        tree: root,
        runnableIds: [leaf2.id, leaf1.id, leaf3.id]
      });

    processor.processTree();
  });

  it(""does not throw if a node which can't be re-entered is run directly"", function() {
    const noReentry = new Node({ noReenter: true }),
      root = new Node({ children: [noReentry] }),
      processor = new jasmineUnderTest.TreeProcessor({
        tree: root,
        runnableIds: [root.id]
      });

    processor.processTree();
  });

  it('orders children according to orderChildren when specified', function() {
    const leaf1 = new Leaf();
    const leaf2 = new Leaf();
    const leaf3 = new Leaf();
    const leaf4 = new Leaf();
    const leaf5 = new Leaf();
    const leaf6 = new Leaf();
    const leaf7 = new Leaf();
    const leaf8 = new Leaf();
    const leaf9 = new Leaf();
    const leaf10 = new Leaf();
    const leaf11 = new Leaf();
    const root = new Node({
      children: [
        leaf1,
        leaf2,
        leaf3,
        leaf4,
        leaf5,
        leaf6,
        leaf7,
        leaf8,
        leaf9,
        leaf10,
        leaf11
      ]
    });
    const runQueue = jasmine.createSpy('runQueue');
    const processor = new jasmineUnderTest.TreeProcessor({
      tree: root,
      runnableIds: [root.id],
      runQueue,
      orderChildren: function(node) {
        const children = node.children.slice();
        return children.reverse();
      }
    });

    const result = processor.processTree();

    expect(result.childrenOfTopSuite()).toEqual([
      { spec: leaf11 },
      { spec: leaf10 },
      { spec: leaf9 },
      { spec: leaf8 },
      { spec: leaf7 },
      { spec: leaf6 },
      { spec: leaf5 },
      { spec: leaf4 },
      { spec: leaf3 },
      { spec: leaf2 },
      { spec: leaf1 }
    ]);
  });
})",snuts
/spec/core/TreeProcessorSpec.js,VerboseStatement,"{'startLine':146,'endLine':198}","it('processes a complicated tree with the root specified', function() {
    const pendingLeaf = new Leaf({ markedPending: true }),
      executableLeaf = new Leaf({ markedPending: false }),
      parent = new Node({ children: [pendingLeaf, executableLeaf] }),
      childless = new Node(),
      childOfPending = new Leaf({ markedPending: true }),
      pendingNode = new Node({
        markedPending: true,
        children: [childOfPending]
      }),
      parentOfPendings = new Node({
        markedPending: false,
        children: [childless, pendingNode]
      }),
      root = new Node({ children: [parent, parentOfPendings] }),
      processor = new jasmineUnderTest.TreeProcessor({
        tree: root,
        runnableIds: [root.id]
      });

    const result = processor.processTree();

    expect(result.isExcluded(parent)).toEqual(false);
    expect(result.childrenOfTopSuite()).toEqual([
      { suite: parent, segmentNumber: 0 },
      { suite: parentOfPendings, segmentNumber: 0 }
    ]);

    expect(result.isExcluded(parentOfPendings)).toEqual(true);
    expect(result.childrenOfSuiteSegment(parentOfPendings, 0)).toEqual([
      { suite: childless, segmentNumber: 0 },
      { suite: pendingNode, segmentNumber: 0 }
    ]);

    expect(result.isExcluded(childless)).toEqual(true);
    expect(result.childrenOfSuiteSegment(childless, 0)).toEqual([]);

    expect(result.isExcluded(pendingLeaf)).toEqual(false);
    expect(result.isExcluded(executableLeaf)).toEqual(false);

    expect(result.isExcluded(parent)).toEqual(false);
    expect(result.childrenOfSuiteSegment(parent, 0)).toEqual([
      { spec: pendingLeaf },
      { spec: executableLeaf }
    ]);

    expect(result.isExcluded(pendingNode)).toEqual(true);
    expect(result.childrenOfSuiteSegment(pendingNode, 0)).toEqual([
      { spec: childOfPending }
    ]);

    expect(result.isExcluded(childOfPending)).toEqual(false);
  })",snuts
/spec/core/TreeProcessorSpec.js,VerboseStatement,"{'startLine':263,'endLine':316}","it('orders children according to orderChildren when specified', function() {
    const leaf1 = new Leaf();
    const leaf2 = new Leaf();
    const leaf3 = new Leaf();
    const leaf4 = new Leaf();
    const leaf5 = new Leaf();
    const leaf6 = new Leaf();
    const leaf7 = new Leaf();
    const leaf8 = new Leaf();
    const leaf9 = new Leaf();
    const leaf10 = new Leaf();
    const leaf11 = new Leaf();
    const root = new Node({
      children: [
        leaf1,
        leaf2,
        leaf3,
        leaf4,
        leaf5,
        leaf6,
        leaf7,
        leaf8,
        leaf9,
        leaf10,
        leaf11
      ]
    });
    const runQueue = jasmine.createSpy('runQueue');
    const processor = new jasmineUnderTest.TreeProcessor({
      tree: root,
      runnableIds: [root.id],
      runQueue,
      orderChildren: function(node) {
        const children = node.children.slice();
        return children.reverse();
      }
    });

    const result = processor.processTree();

    expect(result.childrenOfTopSuite()).toEqual([
      { spec: leaf11 },
      { spec: leaf10 },
      { spec: leaf9 },
      { spec: leaf8 },
      { spec: leaf7 },
      { spec: leaf6 },
      { spec: leaf5 },
      { spec: leaf4 },
      { spec: leaf3 },
      { spec: leaf2 },
      { spec: leaf1 }
    ]);
  })",snuts
/spec/core/TimerSpec.js,GeneralFixture,"{'startLine':18,'endLine':18}","beforeEach(function() {
      // eslint-disable-next-line no-implicit-globals
      Date = jasmine.createSpy('date spy');
    })",snuts
/spec/core/SuiteSpec.js,NonFunctionalStatement,"{'startLine':231,'endLine':231}","it('clears the reportedDone flag when reset', function() {
    const suite = new jasmineUnderTest.Suite({
      queueableFn: { fn: function() {} }
    });
    suite.reportedDone = true;

    suite.reset();

    expect(suite.reportedDone).toBeFalse();
  })",snuts
/spec/core/SuiteSpec.js,NonFunctionalStatement,"{'startLine':267,'endLine':267}","describe('attr.autoCleanClosures', function() {
    function arrangeSuite(attrs) {
      const suite = new jasmineUnderTest.Suite(attrs);
      suite.beforeAll(function() {});
      suite.beforeEach(function() {});
      suite.afterEach(function() {});
      suite.afterAll(function() {});
      return suite;
    }

    it('should clean closures when ""attr.autoCleanClosures"" is missing', function() {
      const suite = arrangeSuite({});
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    });

    it('should clean closures when ""attr.autoCleanClosures"" is true', function() {
      const suite = arrangeSuite({ autoCleanClosures: true });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    });

    it('should NOT clean closures when ""attr.autoCleanClosures"" is false', function() {
      const suite = arrangeSuite({ autoCleanClosures: false });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).not.toBe(null);
      expect(suite.beforeFns[0].fn).not.toBe(null);
      expect(suite.afterFns[0].fn).not.toBe(null);
      expect(suite.afterAllFns[0].fn).not.toBe(null);
    });
  })",snuts
/spec/core/SuiteSpec.js,NonFunctionalStatement,"{'startLine':268,'endLine':268}","describe('attr.autoCleanClosures', function() {
    function arrangeSuite(attrs) {
      const suite = new jasmineUnderTest.Suite(attrs);
      suite.beforeAll(function() {});
      suite.beforeEach(function() {});
      suite.afterEach(function() {});
      suite.afterAll(function() {});
      return suite;
    }

    it('should clean closures when ""attr.autoCleanClosures"" is missing', function() {
      const suite = arrangeSuite({});
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    });

    it('should clean closures when ""attr.autoCleanClosures"" is true', function() {
      const suite = arrangeSuite({ autoCleanClosures: true });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    });

    it('should NOT clean closures when ""attr.autoCleanClosures"" is false', function() {
      const suite = arrangeSuite({ autoCleanClosures: false });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).not.toBe(null);
      expect(suite.beforeFns[0].fn).not.toBe(null);
      expect(suite.afterFns[0].fn).not.toBe(null);
      expect(suite.afterAllFns[0].fn).not.toBe(null);
    });
  })",snuts
/spec/core/SuiteSpec.js,NonFunctionalStatement,"{'startLine':269,'endLine':269}","describe('attr.autoCleanClosures', function() {
    function arrangeSuite(attrs) {
      const suite = new jasmineUnderTest.Suite(attrs);
      suite.beforeAll(function() {});
      suite.beforeEach(function() {});
      suite.afterEach(function() {});
      suite.afterAll(function() {});
      return suite;
    }

    it('should clean closures when ""attr.autoCleanClosures"" is missing', function() {
      const suite = arrangeSuite({});
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    });

    it('should clean closures when ""attr.autoCleanClosures"" is true', function() {
      const suite = arrangeSuite({ autoCleanClosures: true });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    });

    it('should NOT clean closures when ""attr.autoCleanClosures"" is false', function() {
      const suite = arrangeSuite({ autoCleanClosures: false });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).not.toBe(null);
      expect(suite.beforeFns[0].fn).not.toBe(null);
      expect(suite.afterFns[0].fn).not.toBe(null);
      expect(suite.afterAllFns[0].fn).not.toBe(null);
    });
  })",snuts
/spec/core/SuiteSpec.js,NonFunctionalStatement,"{'startLine':270,'endLine':270}","describe('attr.autoCleanClosures', function() {
    function arrangeSuite(attrs) {
      const suite = new jasmineUnderTest.Suite(attrs);
      suite.beforeAll(function() {});
      suite.beforeEach(function() {});
      suite.afterEach(function() {});
      suite.afterAll(function() {});
      return suite;
    }

    it('should clean closures when ""attr.autoCleanClosures"" is missing', function() {
      const suite = arrangeSuite({});
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    });

    it('should clean closures when ""attr.autoCleanClosures"" is true', function() {
      const suite = arrangeSuite({ autoCleanClosures: true });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    });

    it('should NOT clean closures when ""attr.autoCleanClosures"" is false', function() {
      const suite = arrangeSuite({ autoCleanClosures: false });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).not.toBe(null);
      expect(suite.beforeFns[0].fn).not.toBe(null);
      expect(suite.afterFns[0].fn).not.toBe(null);
      expect(suite.afterAllFns[0].fn).not.toBe(null);
    });
  })",snuts
/spec/core/SuiteSpec.js,SubOptimalAssert,"{'startLine':277,'endLine':277}","it('should clean closures when ""attr.autoCleanClosures"" is missing', function() {
      const suite = arrangeSuite({});
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    })",snuts
/spec/core/SuiteSpec.js,SubOptimalAssert,"{'startLine':278,'endLine':278}","it('should clean closures when ""attr.autoCleanClosures"" is missing', function() {
      const suite = arrangeSuite({});
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    })",snuts
/spec/core/SuiteSpec.js,SubOptimalAssert,"{'startLine':279,'endLine':279}","it('should clean closures when ""attr.autoCleanClosures"" is missing', function() {
      const suite = arrangeSuite({});
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    })",snuts
/spec/core/SuiteSpec.js,SubOptimalAssert,"{'startLine':280,'endLine':280}","it('should clean closures when ""attr.autoCleanClosures"" is missing', function() {
      const suite = arrangeSuite({});
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    })",snuts
/spec/core/SuiteSpec.js,SubOptimalAssert,"{'startLine':286,'endLine':286}","it('should clean closures when ""attr.autoCleanClosures"" is true', function() {
      const suite = arrangeSuite({ autoCleanClosures: true });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    })",snuts
/spec/core/SuiteSpec.js,SubOptimalAssert,"{'startLine':287,'endLine':287}","it('should clean closures when ""attr.autoCleanClosures"" is true', function() {
      const suite = arrangeSuite({ autoCleanClosures: true });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    })",snuts
/spec/core/SuiteSpec.js,SubOptimalAssert,"{'startLine':288,'endLine':288}","it('should clean closures when ""attr.autoCleanClosures"" is true', function() {
      const suite = arrangeSuite({ autoCleanClosures: true });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    })",snuts
/spec/core/SuiteSpec.js,SubOptimalAssert,"{'startLine':289,'endLine':289}","it('should clean closures when ""attr.autoCleanClosures"" is true', function() {
      const suite = arrangeSuite({ autoCleanClosures: true });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).toBe(null);
      expect(suite.beforeFns[0].fn).toBe(null);
      expect(suite.afterFns[0].fn).toBe(null);
      expect(suite.afterAllFns[0].fn).toBe(null);
    })",snuts
/spec/core/SuiteSpec.js,SubOptimalAssert,"{'startLine':295,'endLine':295}","it('should NOT clean closures when ""attr.autoCleanClosures"" is false', function() {
      const suite = arrangeSuite({ autoCleanClosures: false });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).not.toBe(null);
      expect(suite.beforeFns[0].fn).not.toBe(null);
      expect(suite.afterFns[0].fn).not.toBe(null);
      expect(suite.afterAllFns[0].fn).not.toBe(null);
    })",snuts
/spec/core/SuiteSpec.js,SubOptimalAssert,"{'startLine':296,'endLine':296}","it('should NOT clean closures when ""attr.autoCleanClosures"" is false', function() {
      const suite = arrangeSuite({ autoCleanClosures: false });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).not.toBe(null);
      expect(suite.beforeFns[0].fn).not.toBe(null);
      expect(suite.afterFns[0].fn).not.toBe(null);
      expect(suite.afterAllFns[0].fn).not.toBe(null);
    })",snuts
/spec/core/SuiteSpec.js,SubOptimalAssert,"{'startLine':297,'endLine':297}","it('should NOT clean closures when ""attr.autoCleanClosures"" is false', function() {
      const suite = arrangeSuite({ autoCleanClosures: false });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).not.toBe(null);
      expect(suite.beforeFns[0].fn).not.toBe(null);
      expect(suite.afterFns[0].fn).not.toBe(null);
      expect(suite.afterAllFns[0].fn).not.toBe(null);
    })",snuts
/spec/core/SuiteSpec.js,SubOptimalAssert,"{'startLine':298,'endLine':298}","it('should NOT clean closures when ""attr.autoCleanClosures"" is false', function() {
      const suite = arrangeSuite({ autoCleanClosures: false });
      suite.cleanupBeforeAfter();
      expect(suite.beforeAllFns[0].fn).not.toBe(null);
      expect(suite.beforeFns[0].fn).not.toBe(null);
      expect(suite.afterFns[0].fn).not.toBe(null);
      expect(suite.afterAllFns[0].fn).not.toBe(null);
    })",snuts
/spec/core/SuiteBuilderSpec.js,AnonymousTest,"{'startLine':370,'endLine':378}","it('resets totalSpecsDefined', function() {
      const env = { configuration: () => ({}) };
      const suiteBuilder = new jasmineUnderTest.SuiteBuilder({ env });
      suiteBuilder.it('a spec');

      suiteBuilder.parallelReset();

      expect(suiteBuilder.totalSpecsDefined).toEqual(0);
    })",snuts
/spec/core/SuiteBuilderSpec.js,AnonymousTest,"{'startLine':380,'endLine':388}","it('resets focusedRunables', function() {
      const env = { configuration: () => ({}) };
      const suiteBuilder = new jasmineUnderTest.SuiteBuilder({ env });
      suiteBuilder.fit('a spec', function() {});

      suiteBuilder.parallelReset();

      expect(suiteBuilder.focusedRunables).toEqual([]);
    })",snuts
/spec/core/SuiteBuilderSpec.js,NonFunctionalStatement,"{'startLine':149,'endLine':149}","it('adds the spec to its suite', function() {
      const env = { configuration: () => ({}) };
      const suiteBuilder = new jasmineUnderTest.SuiteBuilder({ env });

      let spec;
      const suite = suiteBuilder.describe('a suite', function() {
        spec = suiteBuilder[fnName]('a spec', function() {});
      });

      expect(suite.children).toEqual([sameInstanceAs(spec)]);
    })",snuts
/spec/core/SuiteBuilderSpec.js,NonFunctionalStatement,"{'startLine':159,'endLine':159}","it('gives each spec a unique ID', function() {
      const env = { configuration: () => ({}) };
      const suiteBuilder = new jasmineUnderTest.SuiteBuilder({ env });

      const spec1 = suiteBuilder[fnName]('a spec', function() {});
      const spec2 = suiteBuilder[fnName]('another spec', function() {});

      expect(spec1.id).toMatch(/^spec[0-9]+$/);
      expect(spec2.id).toMatch(/^spec[0-9]+$/);
      expect(spec1.id).not.toEqual(spec2.id);
    })",snuts
/spec/core/SuiteBuilderSpec.js,NonFunctionalStatement,"{'startLine':160,'endLine':160}","it('gives each spec a unique ID', function() {
      const env = { configuration: () => ({}) };
      const suiteBuilder = new jasmineUnderTest.SuiteBuilder({ env });

      const spec1 = suiteBuilder[fnName]('a spec', function() {});
      const spec2 = suiteBuilder[fnName]('another spec', function() {});

      expect(spec1.id).toMatch(/^spec[0-9]+$/);
      expect(spec2.id).toMatch(/^spec[0-9]+$/);
      expect(spec1.id).not.toEqual(spec2.id);
    })",snuts
/spec/core/SuiteBuilderSpec.js,NonFunctionalStatement,"{'startLine':174,'endLine':174}","it('gives each spec a full path', function() {
      const env = { configuration: () => ({}) };
      const suiteBuilder = new jasmineUnderTest.SuiteBuilder({ env });
      let spec;

      suiteBuilder.describe('a suite', function() {
        suiteBuilder.describe('a nested suite', function() {
          spec = suiteBuilder[fnName]('a spec', function() {});
        });
      });

      expect(spec.getPath()).toEqual(['a suite', 'a nested suite', 'a spec']);
    })",snuts
/spec/core/SuiteBuilderSpec.js,NonFunctionalStatement,"{'startLine':344,'endLine':344}","it('preserves top suite befores and afters', function() {
      const env = { configuration: () => ({}) };
      const suiteBuilder = new jasmineUnderTest.SuiteBuilder({ env });

      function beforeAll() {}
      function beforeEach() {}
      function afterEach() {}
      function afterAll() {}

      suiteBuilder.beforeAll(beforeAll);
      suiteBuilder.beforeEach(beforeEach);
      suiteBuilder.afterEach(afterEach);
      suiteBuilder.afterAll(afterAll);

      suiteBuilder.parallelReset();

      expect(suiteBuilder.topSuite.beforeAllFns).toEqual([
        jasmine.objectContaining({ fn: beforeAll })
      ]);
      expect(suiteBuilder.topSuite.beforeFns).toEqual([
        jasmine.objectContaining({ fn: beforeEach })
      ]);
      expect(suiteBuilder.topSuite.afterFns).toEqual([
        jasmine.objectContaining({ fn: afterEach })
      ]);
      expect(suiteBuilder.topSuite.afterAllFns).toEqual([
        jasmine.objectContaining({ fn: afterAll })
      ]);
    })",snuts
/spec/core/SuiteBuilderSpec.js,NonFunctionalStatement,"{'startLine':345,'endLine':345}","it('preserves top suite befores and afters', function() {
      const env = { configuration: () => ({}) };
      const suiteBuilder = new jasmineUnderTest.SuiteBuilder({ env });

      function beforeAll() {}
      function beforeEach() {}
      function afterEach() {}
      function afterAll() {}

      suiteBuilder.beforeAll(beforeAll);
      suiteBuilder.beforeEach(beforeEach);
      suiteBuilder.afterEach(afterEach);
      suiteBuilder.afterAll(afterAll);

      suiteBuilder.parallelReset();

      expect(suiteBuilder.topSuite.beforeAllFns).toEqual([
        jasmine.objectContaining({ fn: beforeAll })
      ]);
      expect(suiteBuilder.topSuite.beforeFns).toEqual([
        jasmine.objectContaining({ fn: beforeEach })
      ]);
      expect(suiteBuilder.topSuite.afterFns).toEqual([
        jasmine.objectContaining({ fn: afterEach })
      ]);
      expect(suiteBuilder.topSuite.afterAllFns).toEqual([
        jasmine.objectContaining({ fn: afterAll })
      ]);
    })",snuts
/spec/core/SuiteBuilderSpec.js,NonFunctionalStatement,"{'startLine':346,'endLine':346}","it('preserves top suite befores and afters', function() {
      const env = { configuration: () => ({}) };
      const suiteBuilder = new jasmineUnderTest.SuiteBuilder({ env });

      function beforeAll() {}
      function beforeEach() {}
      function afterEach() {}
      function afterAll() {}

      suiteBuilder.beforeAll(beforeAll);
      suiteBuilder.beforeEach(beforeEach);
      suiteBuilder.afterEach(afterEach);
      suiteBuilder.afterAll(afterAll);

      suiteBuilder.parallelReset();

      expect(suiteBuilder.topSuite.beforeAllFns).toEqual([
        jasmine.objectContaining({ fn: beforeAll })
      ]);
      expect(suiteBuilder.topSuite.beforeFns).toEqual([
        jasmine.objectContaining({ fn: beforeEach })
      ]);
      expect(suiteBuilder.topSuite.afterFns).toEqual([
        jasmine.objectContaining({ fn: afterEach })
      ]);
      expect(suiteBuilder.topSuite.afterAllFns).toEqual([
        jasmine.objectContaining({ fn: afterAll })
      ]);
    })",snuts
/spec/core/SuiteBuilderSpec.js,NonFunctionalStatement,"{'startLine':347,'endLine':347}","it('preserves top suite befores and afters', function() {
      const env = { configuration: () => ({}) };
      const suiteBuilder = new jasmineUnderTest.SuiteBuilder({ env });

      function beforeAll() {}
      function beforeEach() {}
      function afterEach() {}
      function afterAll() {}

      suiteBuilder.beforeAll(beforeAll);
      suiteBuilder.beforeEach(beforeEach);
      suiteBuilder.afterEach(afterEach);
      suiteBuilder.afterAll(afterAll);

      suiteBuilder.parallelReset();

      expect(suiteBuilder.topSuite.beforeAllFns).toEqual([
        jasmine.objectContaining({ fn: beforeAll })
      ]);
      expect(suiteBuilder.topSuite.beforeFns).toEqual([
        jasmine.objectContaining({ fn: beforeEach })
      ]);
      expect(suiteBuilder.topSuite.afterFns).toEqual([
        jasmine.objectContaining({ fn: afterEach })
      ]);
      expect(suiteBuilder.topSuite.afterAllFns).toEqual([
        jasmine.objectContaining({ fn: afterAll })
      ]);
    })",snuts
/spec/core/SuiteBuilderSpec.js,NonFunctionalStatement,"{'startLine':383,'endLine':383}","it('resets focusedRunables', function() {
      const env = { configuration: () => ({}) };
      const suiteBuilder = new jasmineUnderTest.SuiteBuilder({ env });
      suiteBuilder.fit('a spec', function() {});

      suiteBuilder.parallelReset();

      expect(suiteBuilder.focusedRunables).toEqual([]);
    })",snuts
/spec/core/SuiteBuilderSpec.js,VerboseStatement,"{'startLine':340,'endLine':368}","it('preserves top suite befores and afters', function() {
      const env = { configuration: () => ({}) };
      const suiteBuilder = new jasmineUnderTest.SuiteBuilder({ env });

      function beforeAll() {}
      function beforeEach() {}
      function afterEach() {}
      function afterAll() {}

      suiteBuilder.beforeAll(beforeAll);
      suiteBuilder.beforeEach(beforeEach);
      suiteBuilder.afterEach(afterEach);
      suiteBuilder.afterAll(afterAll);

      suiteBuilder.parallelReset();

      expect(suiteBuilder.topSuite.beforeAllFns).toEqual([
        jasmine.objectContaining({ fn: beforeAll })
      ]);
      expect(suiteBuilder.topSuite.beforeFns).toEqual([
        jasmine.objectContaining({ fn: beforeEach })
      ]);
      expect(suiteBuilder.topSuite.afterFns).toEqual([
        jasmine.objectContaining({ fn: afterEach })
      ]);
      expect(suiteBuilder.topSuite.afterAllFns).toEqual([
        jasmine.objectContaining({ fn: afterAll })
      ]);
    })",snuts
/spec/core/SpyStrategySpec.js,NonFunctionalStatement,"{'startLine':256,'endLine':256}","it('does not allow custom strategies to overwrite existing methods', function() {
    const spyStrategy = new jasmineUnderTest.SpyStrategy({
      fn: function() {},
      customStrategies: {
        exec: function() {}
      }
    });

    expect(spyStrategy.exec).toBe(jasmineUnderTest.SpyStrategy.prototype.exec);
  })",snuts
/spec/core/SpyStrategySpec.js,NonFunctionalStatement,"{'startLine':258,'endLine':258}","it('does not allow custom strategies to overwrite existing methods', function() {
    const spyStrategy = new jasmineUnderTest.SpyStrategy({
      fn: function() {},
      customStrategies: {
        exec: function() {}
      }
    });

    expect(spyStrategy.exec).toBe(jasmineUnderTest.SpyStrategy.prototype.exec);
  })",snuts
/spec/core/SpyStrategySpec.js,NonFunctionalStatement,"{'startLine':273,'endLine':273}","it('throws an error when a non-function is passed to callFake strategy', function() {
    const originalFn = jasmine.createSpy('original'),
      spyStrategy = new jasmineUnderTest.SpyStrategy({ fn: originalFn });

    spyOn(jasmineUnderTest, 'isFunction_').and.returnValue(false);
    spyOn(jasmineUnderTest, 'isAsyncFunction_').and.returnValue(false);

    expect(function() {
      spyStrategy.callFake(function() {});
    }).toThrowError(/^Argument passed to callFake should be a function, got/);

    expect(function() {
      spyStrategy.callFake(function() {});
    }).toThrowError(/^Argument passed to callFake should be a function, got/);
  })",snuts
/spec/core/SpyStrategySpec.js,NonFunctionalStatement,"{'startLine':277,'endLine':277}","it('throws an error when a non-function is passed to callFake strategy', function() {
    const originalFn = jasmine.createSpy('original'),
      spyStrategy = new jasmineUnderTest.SpyStrategy({ fn: originalFn });

    spyOn(jasmineUnderTest, 'isFunction_').and.returnValue(false);
    spyOn(jasmineUnderTest, 'isAsyncFunction_').and.returnValue(false);

    expect(function() {
      spyStrategy.callFake(function() {});
    }).toThrowError(/^Argument passed to callFake should be a function, got/);

    expect(function() {
      spyStrategy.callFake(function() {});
    }).toThrowError(/^Argument passed to callFake should be a function, got/);
  })",snuts
/spec/core/SpyStrategySpec.js,NonFunctionalStatement,"{'startLine':285,'endLine':285}","it('allows generator functions to be passed to callFake strategy', function() {
    const generator = function*() {
        yield 'ok';
      },
      spyStrategy = new jasmineUnderTest.SpyStrategy({ fn: function() {} });

    spyStrategy.callFake(generator);

    expect(spyStrategy.exec().next().value).toEqual('ok');
  })",snuts
/spec/core/SpyStrategySpec.js,NonFunctionalStatement,"{'startLine':317,'endLine':317}","it('returns the spy after changing the strategy', function() {
    const spy = {},
      spyFn = jasmine.createSpy('spyFn').and.returnValue(spy),
      spyStrategy = new jasmineUnderTest.SpyStrategy({ getSpy: spyFn });

    expect(spyStrategy.callThrough()).toBe(spy);
    expect(spyStrategy.returnValue()).toBe(spy);
    expect(spyStrategy.throwError()).toBe(spy);
    expect(spyStrategy.callFake(function() {})).toBe(spy);
    expect(spyStrategy.stub()).toBe(spy);
  })",snuts
/spec/core/SpySpec.js,ConditionalTestLogic,"{'startLine':247,'endLine':249}","it('uses the provided matchersUtil selecting a strategy', function() {
    const matchersUtil = new jasmineUnderTest.MatchersUtil({
      customTesters: [
        function(a, b) {
          if ((a === 'bar' && b === 'baz') || (a === 'baz' && b === 'bar')) {
            return true;
          }
        }
      ]
    });
    const spy = new jasmineUnderTest.Spy('aSpy', matchersUtil);
    spy.and.returnValue('default strategy return value');
    spy.withArgs('bar').and.returnValue('custom strategy return value');
    expect(spy('foo')).toEqual('default strategy return value');
    expect(spy('baz')).toEqual('custom strategy return value');
  })",snuts
/spec/core/SpySpec.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}","beforeEach(function() {
      TestClass = function() {};
      TestClass.prototype.someFunction = function() {};
      TestClass.prototype.someFunction.bob = 'test';
    })",snuts
/spec/core/SpySpec.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}","beforeEach(function() {
      TestClass = function() {};
      TestClass.prototype.someFunction = function() {};
      TestClass.prototype.someFunction.bob = 'test';
    })",snuts
/spec/core/SpySpec.js,NonFunctionalStatement,"{'startLine':31,'endLine':31}","it('should allow you to omit the name argument and only pass the originalFn argument', function() {
      const fn = function test() {};
      const spy = env.createSpy(fn);

      expect(spy.and.identity).toEqual('test');
    })",snuts
/spec/core/SpySpec.js,NonFunctionalStatement,"{'startLine':99,'endLine':99}","it('preserves arity of original function', function() {
      const functions = [
        function nullary() {},
        function unary(arg) {},
        function binary(arg1, arg2) {},
        function ternary(arg1, arg2, arg3) {},
        function quaternary(arg1, arg2, arg3, arg4) {},
        function quinary(arg1, arg2, arg3, arg4, arg5) {},
        function senary(arg1, arg2, arg3, arg4, arg5, arg6) {}
      ];

      for (let arity = 0; arity < functions.length; arity++) {
        const someFunction = functions[arity],
          spy = env.createSpy(someFunction.name, someFunction);

        expect(spy.length).toEqual(arity);
      }
    })",snuts
/spec/core/SpySpec.js,NonFunctionalStatement,"{'startLine':100,'endLine':100}","it('preserves arity of original function', function() {
      const functions = [
        function nullary() {},
        function unary(arg) {},
        function binary(arg1, arg2) {},
        function ternary(arg1, arg2, arg3) {},
        function quaternary(arg1, arg2, arg3, arg4) {},
        function quinary(arg1, arg2, arg3, arg4, arg5) {},
        function senary(arg1, arg2, arg3, arg4, arg5, arg6) {}
      ];

      for (let arity = 0; arity < functions.length; arity++) {
        const someFunction = functions[arity],
          spy = env.createSpy(someFunction.name, someFunction);

        expect(spy.length).toEqual(arity);
      }
    })",snuts
/spec/core/SpySpec.js,NonFunctionalStatement,"{'startLine':101,'endLine':101}","it('preserves arity of original function', function() {
      const functions = [
        function nullary() {},
        function unary(arg) {},
        function binary(arg1, arg2) {},
        function ternary(arg1, arg2, arg3) {},
        function quaternary(arg1, arg2, arg3, arg4) {},
        function quinary(arg1, arg2, arg3, arg4, arg5) {},
        function senary(arg1, arg2, arg3, arg4, arg5, arg6) {}
      ];

      for (let arity = 0; arity < functions.length; arity++) {
        const someFunction = functions[arity],
          spy = env.createSpy(someFunction.name, someFunction);

        expect(spy.length).toEqual(arity);
      }
    })",snuts
/spec/core/SpySpec.js,NonFunctionalStatement,"{'startLine':102,'endLine':102}","it('preserves arity of original function', function() {
      const functions = [
        function nullary() {},
        function unary(arg) {},
        function binary(arg1, arg2) {},
        function ternary(arg1, arg2, arg3) {},
        function quaternary(arg1, arg2, arg3, arg4) {},
        function quinary(arg1, arg2, arg3, arg4, arg5) {},
        function senary(arg1, arg2, arg3, arg4, arg5, arg6) {}
      ];

      for (let arity = 0; arity < functions.length; arity++) {
        const someFunction = functions[arity],
          spy = env.createSpy(someFunction.name, someFunction);

        expect(spy.length).toEqual(arity);
      }
    })",snuts
/spec/core/SpySpec.js,NonFunctionalStatement,"{'startLine':103,'endLine':103}","it('preserves arity of original function', function() {
      const functions = [
        function nullary() {},
        function unary(arg) {},
        function binary(arg1, arg2) {},
        function ternary(arg1, arg2, arg3) {},
        function quaternary(arg1, arg2, arg3, arg4) {},
        function quinary(arg1, arg2, arg3, arg4, arg5) {},
        function senary(arg1, arg2, arg3, arg4, arg5, arg6) {}
      ];

      for (let arity = 0; arity < functions.length; arity++) {
        const someFunction = functions[arity],
          spy = env.createSpy(someFunction.name, someFunction);

        expect(spy.length).toEqual(arity);
      }
    })",snuts
/spec/core/SpySpec.js,NonFunctionalStatement,"{'startLine':104,'endLine':104}","it('preserves arity of original function', function() {
      const functions = [
        function nullary() {},
        function unary(arg) {},
        function binary(arg1, arg2) {},
        function ternary(arg1, arg2, arg3) {},
        function quaternary(arg1, arg2, arg3, arg4) {},
        function quinary(arg1, arg2, arg3, arg4, arg5) {},
        function senary(arg1, arg2, arg3, arg4, arg5, arg6) {}
      ];

      for (let arity = 0; arity < functions.length; arity++) {
        const someFunction = functions[arity],
          spy = env.createSpy(someFunction.name, someFunction);

        expect(spy.length).toEqual(arity);
      }
    })",snuts
/spec/core/SpySpec.js,NonFunctionalStatement,"{'startLine':105,'endLine':105}","it('preserves arity of original function', function() {
      const functions = [
        function nullary() {},
        function unary(arg) {},
        function binary(arg1, arg2) {},
        function ternary(arg1, arg2, arg3) {},
        function quaternary(arg1, arg2, arg3, arg4) {},
        function quinary(arg1, arg2, arg3, arg4, arg5) {},
        function senary(arg1, arg2, arg3, arg4, arg5, arg6) {}
      ];

      for (let arity = 0; arity < functions.length; arity++) {
        const someFunction = functions[arity],
          spy = env.createSpy(someFunction.name, someFunction);

        expect(spy.length).toEqual(arity);
      }
    })",snuts
/spec/core/SpyRegistrySpec.js,IdenticalTestDescription,"{'startLine':141,'endLine':146}","it('checks for the existence of the object', function() {
      const spyRegistry = new jasmineUnderTest.SpyRegistry();
      expect(function() {
        spyRegistry.spyOnProperty(void 0, 'pants');
      }).toThrowError(/could not find an object/);
    })",snuts
/spec/core/SpyRegistrySpec.js,IdenticalTestDescription,"{'startLine':157,'endLine':164}","it('checks for the existence of the method', function() {
      const spyRegistry = new jasmineUnderTest.SpyRegistry(),
        subject = {};

      expect(function() {
        spyRegistry.spyOnProperty(subject, 'pants');
      }).toThrowError(/property does not exist/);
    })",snuts
/spec/core/SpyRegistrySpec.js,IdenticalTestDescription,"{'startLine':182,'endLine':203}","it('checks if it can be spied upon', function() {
      const subject = {};

      Object.defineProperty(subject, 'myProp', {
        get: function() {}
      });

      Object.defineProperty(subject, 'spiedProp', {
        get: function() {},
        configurable: true
      });

      const spyRegistry = new jasmineUnderTest.SpyRegistry();

      expect(function() {
        spyRegistry.spyOnProperty(subject, 'myProp');
      }).toThrowError(/is not declared configurable/);

      expect(function() {
        spyRegistry.spyOnProperty(subject, 'spiedProp');
      }).not.toThrowError(/is not declared configurable/);
    })",snuts
/spec/core/SpyRegistrySpec.js,IdenticalTestDescription,"{'startLine':298,'endLine':303}","it('checks for the existence of the object', function() {
      const spyRegistry = new jasmineUnderTest.SpyRegistry();
      expect(function() {
        spyRegistry.spyOnAllFunctions(void 0);
      }).toThrowError(/spyOnAllFunctions could not find an object to spy upon/);
    })",snuts
/spec/core/SpyRegistrySpec.js,IdenticalTestDescription,"{'startLine':688,'endLine':715}","it(""does not add a property that the spied-upon object didn't originally have"", function() {
      const spies = [],
        spyRegistry = new jasmineUnderTest.SpyRegistry({
          currentSpies: function() {
            return spies;
          },
          createSpy: createSpy
        }),
        originalReturn = 1,
        subjectParent = {};

      Object.defineProperty(subjectParent, 'spiedProp', {
        get: function() {
          return originalReturn;
        },
        configurable: true
      });

      const subject = Object.create(subjectParent);

      expect(subject.hasOwnProperty('spiedProp')).toBe(false);

      spyRegistry.spyOnProperty(subject, 'spiedProp');
      spyRegistry.clearSpies();

      expect(subject.hasOwnProperty('spiedProp')).toBe(false);
      expect(subject.spiedProp).toBe(originalReturn);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':58,'endLine':58}","it('checks if it has already been spied upon', function() {
      const spies = [],
        spyRegistry = new jasmineUnderTest.SpyRegistry({
          currentSpies: function() {
            return spies;
          },
          createSpy: createSpy
        }),
        subject = { spiedFunc: function() {} };

      spyRegistry.spyOn(subject, 'spiedFunc');

      expect(function() {
        spyRegistry.spyOn(subject, 'spiedFunc');
      }).toThrowError(/has already been spied upon/);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':108,'endLine':108}","it('throws if assigning to the property is a no-op', function() {
      const scope = {};

      function original() {
        return 1;
      }

      Object.defineProperty(scope, 'myFunc', {
        get() {
          return original;
        },
        set() {}
      });

      const spyRegistry = new jasmineUnderTest.SpyRegistry({
        createSpy: createSpy
      });
      expect(function() {
        spyRegistry.spyOn(scope, 'myFunc');
      }).toThrowError(
        ""<spyOn> : Can't spy on myFunc because assigning to it had no effect""
      );
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':186,'endLine':186}","it('checks if it can be spied upon', function() {
      const subject = {};

      Object.defineProperty(subject, 'myProp', {
        get: function() {}
      });

      Object.defineProperty(subject, 'spiedProp', {
        get: function() {},
        configurable: true
      });

      const spyRegistry = new jasmineUnderTest.SpyRegistry();

      expect(function() {
        spyRegistry.spyOnProperty(subject, 'myProp');
      }).toThrowError(/is not declared configurable/);

      expect(function() {
        spyRegistry.spyOnProperty(subject, 'spiedProp');
      }).not.toThrowError(/is not declared configurable/);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':190,'endLine':190}","it('checks if it can be spied upon', function() {
      const subject = {};

      Object.defineProperty(subject, 'myProp', {
        get: function() {}
      });

      Object.defineProperty(subject, 'spiedProp', {
        get: function() {},
        configurable: true
      });

      const spyRegistry = new jasmineUnderTest.SpyRegistry();

      expect(function() {
        spyRegistry.spyOnProperty(subject, 'myProp');
      }).toThrowError(/is not declared configurable/);

      expect(function() {
        spyRegistry.spyOnProperty(subject, 'spiedProp');
      }).not.toThrowError(/is not declared configurable/);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':240,'endLine':240}","it('overrides the property setter on the object and returns the spy', function() {
      const spyRegistry = new jasmineUnderTest.SpyRegistry({
          createSpy: createSpy
        }),
        subject = {},
        returnValue = 1;

      Object.defineProperty(subject, 'spiedProperty', {
        get: function() {
          return returnValue;
        },
        set: function() {},
        configurable: true
      });

      const spy = spyRegistry.spyOnProperty(subject, 'spiedProperty', 'set');
      const setter = Object.getOwnPropertyDescriptor(subject, 'spiedProperty')
        .set;

      expect(subject.spiedProperty).toEqual(returnValue);
      expect(setter).toEqual(spy);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':402,'endLine':402}","it('overrides prototype methods on the object', function() {
      const spyRegistry = new jasmineUnderTest.SpyRegistry({
        createSpy: function() {
          return 'I am a spy';
        }
      });

      const noop1 = function() {};
      const noop2 = function() {};

      const MyClass = function() {
        this.spied1 = noop1;
      };
      MyClass.prototype.spied2 = noop2;

      const subject = new MyClass();
      spyRegistry.spyOnAllFunctions(subject);

      expect(subject.spied1).toBe('I am a spy');
      expect(subject.spied2).toBe('I am a spy');
      expect(MyClass.prototype.spied2).toBe(noop2);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':403,'endLine':403}","it('overrides prototype methods on the object', function() {
      const spyRegistry = new jasmineUnderTest.SpyRegistry({
        createSpy: function() {
          return 'I am a spy';
        }
      });

      const noop1 = function() {};
      const noop2 = function() {};

      const MyClass = function() {
        this.spied1 = noop1;
      };
      MyClass.prototype.spied2 = noop2;

      const subject = new MyClass();
      spyRegistry.spyOnAllFunctions(subject);

      expect(subject.spied1).toBe('I am a spy');
      expect(subject.spied2).toBe('I am a spy');
      expect(MyClass.prototype.spied2).toBe(noop2);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':425,'endLine':425}","it('does not override non-enumerable properties (like Object.prototype methods)', function() {
      const spyRegistry = new jasmineUnderTest.SpyRegistry({
        createSpy: function() {
          return 'I am a spy';
        }
      });
      const subject = {
        spied1: function() {}
      };

      spyRegistry.spyOnAllFunctions(subject);

      expect(subject.spied1).toBe('I am a spy');
      expect(subject.toString).not.toBe('I am a spy');
      expect(subject.hasOwnProperty).not.toBe('I am a spy');
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':442,'endLine':442}","it('does not override Object.prototype methods', function() {
        const spyRegistry = new jasmineUnderTest.SpyRegistry({
          createSpy: function() {
            return 'I am a spy';
          }
        });
        const subject = {
          spied1: function() {}
        };

        spyRegistry.spyOnAllFunctions(subject, true);

        expect(subject.spied1).toBe('I am a spy');
        expect(subject.toString).not.toBe('I am a spy');
        expect(subject.hasOwnProperty).not.toBe('I am a spy');
      })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':459,'endLine':459}","it('overrides non-enumerable properties', function() {
        const spyRegistry = new jasmineUnderTest.SpyRegistry({
          createSpy: function() {
            return 'I am a spy';
          }
        });
        const subject = {
          spied1: function() {},
          spied2: function() {}
        };

        Object.defineProperty(subject, 'spied2', {
          enumerable: false,
          writable: true,
          configurable: true
        });

        spyRegistry.spyOnAllFunctions(subject, true);

        expect(subject.spied1).toBe('I am a spy');
        expect(subject.spied2).toBe('I am a spy');
      })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':460,'endLine':460}","it('overrides non-enumerable properties', function() {
        const spyRegistry = new jasmineUnderTest.SpyRegistry({
          createSpy: function() {
            return 'I am a spy';
          }
        });
        const subject = {
          spied1: function() {},
          spied2: function() {}
        };

        Object.defineProperty(subject, 'spied2', {
          enumerable: false,
          writable: true,
          configurable: true
        });

        spyRegistry.spyOnAllFunctions(subject, true);

        expect(subject.spied1).toBe('I am a spy');
        expect(subject.spied2).toBe('I am a spy');
      })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':482,'endLine':482}","it('should not spy on non-enumerable functions named constructor', function() {
        const spyRegistry = new jasmineUnderTest.SpyRegistry({
          createSpy: function() {
            return 'I am a spy';
          }
        });
        const subject = {
          constructor: function() {}
        };

        Object.defineProperty(subject, 'constructor', {
          enumerable: false,
          writable: true,
          configurable: true
        });

        spyRegistry.spyOnAllFunctions(subject, true);

        expect(subject.constructor).not.toBe('I am a spy');
      })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':503,'endLine':503}","it('should spy on enumerable functions named constructor', function() {
        const spyRegistry = new jasmineUnderTest.SpyRegistry({
          createSpy: function() {
            return 'I am a spy';
          }
        });
        const subject = {
          constructor: function() {}
        };

        spyRegistry.spyOnAllFunctions(subject, true);

        expect(subject.constructor).toBe('I am a spy');
      })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':517,'endLine':517}","it('should not throw an exception if we try and access strict mode restricted properties', function() {
        const spyRegistry = new jasmineUnderTest.SpyRegistry({
          createSpy: function() {
            return 'I am a spy';
          }
        });
        const subject = function() {};
        const fn = function() {
          spyRegistry.spyOnAllFunctions(subject, true);
        };

        expect(fn).not.toThrow();
      })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':532,'endLine':532}","it('should not spy on properties which are more permissable further up the prototype chain', function() {
        const spyRegistry = new jasmineUnderTest.SpyRegistry({
          createSpy: function() {
            return 'I am a spy';
          }
        });
        const subjectParent = Object.defineProperty({}, 'sharedProp', {
          value: function() {},
          writable: true,
          configurable: true
        });

        const subject = Object.create(subjectParent);

        Object.defineProperty(subject, 'sharedProp', {
          value: function() {}
        });

        const fn = function() {
          spyRegistry.spyOnAllFunctions(subject, true);
        };

        expect(fn).not.toThrow();
        expect(subject).not.toBe('I am a spy');
      })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':540,'endLine':540}","it('should not spy on properties which are more permissable further up the prototype chain', function() {
        const spyRegistry = new jasmineUnderTest.SpyRegistry({
          createSpy: function() {
            return 'I am a spy';
          }
        });
        const subjectParent = Object.defineProperty({}, 'sharedProp', {
          value: function() {},
          writable: true,
          configurable: true
        });

        const subject = Object.create(subjectParent);

        Object.defineProperty(subject, 'sharedProp', {
          value: function() {}
        });

        const fn = function() {
          spyRegistry.spyOnAllFunctions(subject, true);
        };

        expect(fn).not.toThrow();
        expect(subject).not.toBe('I am a spy');
      })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':562,'endLine':562}","it('restores the original functions on the spied-upon objects', function() {
      const spies = [],
        spyRegistry = new jasmineUnderTest.SpyRegistry({
          currentSpies: function() {
            return spies;
          },
          createSpy: createSpy
        }),
        originalFunction = function() {},
        subject = { spiedFunc: originalFunction };

      spyRegistry.spyOn(subject, 'spiedFunc');
      spyRegistry.clearSpies();

      expect(subject.spiedFunc).toBe(originalFunction);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':579,'endLine':579}","it('restores the original functions, even when that spy has been replace and re-spied upon', function() {
      const spies = [],
        spyRegistry = new jasmineUnderTest.SpyRegistry({
          currentSpies: function() {
            return spies;
          },
          createSpy: createSpy
        }),
        originalFunction = function() {},
        subject = { spiedFunc: originalFunction };

      spyRegistry.spyOn(subject, 'spiedFunc');

      // replace the original spy with some other function
      subject.spiedFunc = function() {};

      // spy on the function in that location again
      spyRegistry.spyOn(subject, 'spiedFunc');

      spyRegistry.clearSpies();

      expect(subject.spiedFunc).toBe(originalFunction);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':585,'endLine':585}","it('restores the original functions, even when that spy has been replace and re-spied upon', function() {
      const spies = [],
        spyRegistry = new jasmineUnderTest.SpyRegistry({
          currentSpies: function() {
            return spies;
          },
          createSpy: createSpy
        }),
        originalFunction = function() {},
        subject = { spiedFunc: originalFunction };

      spyRegistry.spyOn(subject, 'spiedFunc');

      // replace the original spy with some other function
      subject.spiedFunc = function() {};

      // spy on the function in that location again
      spyRegistry.spyOn(subject, 'spiedFunc');

      spyRegistry.clearSpies();

      expect(subject.spiedFunc).toBe(originalFunction);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':603,'endLine':603}","it(""does not add a property that the spied-upon object didn't originally have"", function() {
      const spies = [],
        spyRegistry = new jasmineUnderTest.SpyRegistry({
          currentSpies: function() {
            return spies;
          },
          createSpy: createSpy
        }),
        originalFunction = function() {},
        subjectParent = { spiedFunc: originalFunction };

      const subject = Object.create(subjectParent);

      expect(subject.hasOwnProperty('spiedFunc')).toBe(false);

      spyRegistry.spyOn(subject, 'spiedFunc');
      spyRegistry.clearSpies();

      expect(subject.hasOwnProperty('spiedFunc')).toBe(false);
      expect(subject.spiedFunc).toBe(originalFunction);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':625,'endLine':625}","it(""restores the original function when it's inherited and cannot be deleted"", function() {
      const spies = [],
        spyRegistry = new jasmineUnderTest.SpyRegistry({
          currentSpies: function() {
            return spies;
          },
          createSpy: createSpy
        }),
        originalFunction = function() {},
        subjectParent = { spiedFunc: originalFunction };

      const subject = Object.create(subjectParent);

      spyRegistry.spyOn(subject, 'spiedFunc');

      // simulate a spy that cannot be deleted
      Object.defineProperty(subject, 'spiedFunc', {
        configurable: false
      });

      spyRegistry.clearSpies();

      expect(jasmineUnderTest.isSpy(subject.spiedFunc)).toBe(false);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':643,'endLine':643}","it('restores window.onerror by overwriting, not deleting', function() {
      function FakeWindow() {}
      FakeWindow.prototype.onerror = function() {};

      const spies = [],
        global = new FakeWindow(),
        spyRegistry = new jasmineUnderTest.SpyRegistry({
          currentSpies: function() {
            return spies;
          },
          createSpy: createSpy,
          global: global
        });

      spyRegistry.spyOn(global, 'onerror');
      spyRegistry.clearSpies();
      expect(global.onerror).toBe(FakeWindow.prototype.onerror);
      expect(global.hasOwnProperty('onerror')).toBe(true);
    })",snuts
/spec/core/SpyRegistrySpec.js,NonFunctionalStatement,"{'startLine':644,'endLine':644}","it('restores window.onerror by overwriting, not deleting', function() {
      function FakeWindow() {}
      FakeWindow.prototype.onerror = function() {};

      const spies = [],
        global = new FakeWindow(),
        spyRegistry = new jasmineUnderTest.SpyRegistry({
          currentSpies: function() {
            return spies;
          },
          createSpy: createSpy,
          global: global
        });

      spyRegistry.spyOn(global, 'onerror');
      spyRegistry.clearSpies();
      expect(global.onerror).toBe(FakeWindow.prototype.onerror);
      expect(global.hasOwnProperty('onerror')).toBe(true);
    })",snuts
/spec/core/SpyRegistrySpec.js,VerboseStatement,"{'startLine':305,'endLine':393}","it('overrides all writable and configurable functions of the object and its parents', function() {
      const spyRegistry = new jasmineUnderTest.SpyRegistry({
        createSpy: function() {
          return 'I am a spy';
        }
      });
      const createNoop = function() {
        return function() {
          /**/
        };
      };
      const noop1 = createNoop();
      const noop2 = createNoop();
      const noop3 = createNoop();
      const noop4 = createNoop();
      const noop5 = createNoop();

      const parent = {
        parentSpied1: noop1
      };
      const subject = Object.create(parent);
      Object.defineProperty(subject, 'spied1', {
        value: noop1,
        writable: true,
        configurable: true,
        enumerable: true
      });
      Object.defineProperty(subject, 'spied2', {
        value: noop2,
        writable: true,
        configurable: true,
        enumerable: true
      });
      let _spied3 = noop3;
      Object.defineProperty(subject, 'spied3', {
        configurable: true,
        set: function(val) {
          _spied3 = val;
        },
        get: function() {
          return _spied3;
        },
        enumerable: true
      });
      subject.spied4 = noop4;
      Object.defineProperty(subject, 'notSpied2', {
        value: noop2,
        writable: false,
        configurable: true,
        enumerable: true
      });
      Object.defineProperty(subject, 'notSpied3', {
        value: noop3,
        writable: true,
        configurable: false,
        enumerable: true
      });
      Object.defineProperty(subject, 'notSpied4', {
        configurable: false,
        set: function() {
          /**/
        },
        get: function() {
          return noop4;
        },
        enumerable: true
      });
      Object.defineProperty(subject, 'notSpied5', {
        value: noop5,
        writable: true,
        configurable: true,
        enumerable: false
      });
      subject.notSpied6 = 6;

      const spiedObject = spyRegistry.spyOnAllFunctions(subject);

      expect(subject.parentSpied1).toBe('I am a spy');
      expect(subject.notSpied2).toBe(noop2);
      expect(subject.notSpied3).toBe(noop3);
      expect(subject.notSpied4).toBe(noop4);
      expect(subject.notSpied5).toBe(noop5);
      expect(subject.notSpied6).toBe(6);
      expect(subject.spied1).toBe('I am a spy');
      expect(subject.spied2).toBe('I am a spy');
      expect(subject.spied3).toBe('I am a spy');
      expect(subject.spied4).toBe('I am a spy');
      expect(spiedObject).toBe(subject);
    })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':39,'endLine':39}","it('removes the fn if autoCleanClosures is true', function() {
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} },
        autoCleanClosures: true
      });

      spec.executionFinished();
      expect(spec.queueableFn.fn).toBeFalsy();
    })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':49,'endLine':49}","it('removes the fn after execution if autoCleanClosures is undefined', function() {
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} },
        autoCleanClosures: undefined
      });

      spec.executionFinished();
      expect(spec.queueableFn.fn).toBeFalsy();
    })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':58,'endLine':58}","it('does not remove the fn after execution if autoCleanClosures is false', function() {
      function originalFn() {}
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: originalFn },
        autoCleanClosures: false
      });

      spec.executionFinished();
      expect(spec.queueableFn.fn).toBe(originalFn);
    })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':72,'endLine':72}","it('get the property value', function() {
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} }
      });

      spec.setSpecProperty('a', 4);
      expect(spec.getSpecProperty('a')).toBe(4);
    })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':83,'endLine':83}","it('adds the property to the result', function() {
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} }
      });

      spec.setSpecProperty('a', 4);

      expect(spec.result.properties).toEqual({ a: 4 });
    })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':93,'endLine':93}","it('replace the property result when it was previously set', function() {
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} }
      });

      spec.setSpecProperty('a', 'original-value');
      spec.setSpecProperty('b', 'original-value');
      spec.setSpecProperty('a', 'new-value');

      expect(spec.result.properties).toEqual({
        a: 'new-value',
        b: 'original-value'
      });
    })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':110,'endLine':110}","it('is ""passed"" by default', function() {
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} }
      });
      expect(spec.getResult().status).toBe('passed');
    })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':117,'endLine':117}","it('is ""passed"" if all expectations passed', function() {
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} }
      });

      spec.addExpectationResult(true, {});

      expect(spec.getResult().status).toBe('passed');
    })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':127,'endLine':127}","it('is ""failed"" if any expectation failed', function() {
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} }
      });

      spec.addExpectationResult(true, {});
      spec.addExpectationResult(false, {});

      expect(spec.getResult().status).toBe('failed');
    })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':152,'endLine':152}","it('keeps track of passed and failed expectations', function() {
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} }
      });

      spec.addExpectationResult(true, { message: 'expectation1' });
      spec.addExpectationResult(false, { message: 'expectation2' });

      expect(spec.result.passedExpectations).toEqual([
        jasmine.objectContaining({ message: 'expectation1' })
      ]);
      expect(spec.result.failedExpectations).toEqual([
        jasmine.objectContaining({ message: 'expectation2' })
      ]);
    })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':169,'endLine':169}","it('throws an ExpectationFailed error', function() {
        const spec = new jasmineUnderTest.Spec({
          queueableFn: { fn: () => {} },
          throwOnExpectationFailure: true
        });

        spec.addExpectationResult(true, { message: 'passed' });
        expect(function() {
          spec.addExpectationResult(false, { message: 'failed' });
        }).toThrowError(jasmineUnderTest.errors.ExpectationFailed);

        expect(spec.result.failedExpectations).toEqual([
          jasmine.objectContaining({ message: 'failed' })
        ]);
      })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':187,'endLine':187}","it('does not throw', function() {
        const spec = new jasmineUnderTest.Spec({
          queueableFn: { fn: () => {} }
        });

        spec.addExpectationResult(false, { message: 'failed' });

        expect(spec.result.failedExpectations).toEqual([
          jasmine.objectContaining({ message: 'failed' })
        ]);
      })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':203,'endLine':203}","it('forwards late expectation failures to onLateError', function() {
    const onLateError = jasmine.createSpy('onLateError');
    const spec = new jasmineUnderTest.Spec({
      onLateError,
      queueableFn: { fn: function() {} }
    });
    const data = {
      matcherName: '',
      passed: false,
      expected: '',
      actual: '',
      error: new Error('nope')
    };

    spec.reportedDone = true;
    spec.addExpectationResult(false, data, true);

    expect(onLateError).toHaveBeenCalledWith(
      jasmine.objectContaining({
        message: jasmine.stringMatching(/^Error: nope/)
      })
    );
    expect(spec.result.failedExpectations).toEqual([]);
  })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':228,'endLine':228}","it('does not forward non-late expectation failures to onLateError', function() {
    const onLateError = jasmine.createSpy('onLateError');
    const spec = new jasmineUnderTest.Spec({
      onLateError,
      queueableFn: { fn: function() {} }
    });
    const data = {
      matcherName: '',
      passed: false,
      expected: '',
      actual: '',
      error: new Error('nope')
    };

    spec.addExpectationResult(false, data, true);

    expect(onLateError).not.toHaveBeenCalled();
  })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':247,'endLine':247}","it('forwards late handleException calls to onLateError', function() {
    const onLateError = jasmine.createSpy('onLateError');
    const spec = new jasmineUnderTest.Spec({
      onLateError,
      queueableFn: { fn: function() {} }
    });

    spec.reportedDone = true;
    spec.handleException(new Error('oops'));

    expect(onLateError).toHaveBeenCalledWith(
      jasmine.objectContaining({
        message: jasmine.stringMatching(/^Error: oops/)
      })
    );
    expect(spec.result.failedExpectations).toEqual([]);
  })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':265,'endLine':265}","it('does not forward non-late handleException calls to onLateError', function() {
    const onLateError = jasmine.createSpy('onLateError');
    const spec = new jasmineUnderTest.Spec({
      onLateError,
      queueableFn: { fn: function() {} }
    });
    const error = new Error('oops');

    spec.handleException(error);

    expect(onLateError).not.toHaveBeenCalled();
    expect(spec.result.failedExpectations.length).toEqual(1);
  })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':277,'endLine':277}","it('clears the reportedDone flag when reset', function() {
    const spec = new jasmineUnderTest.Spec({
      queueableFn: { fn: function() {} }
    });
    spec.reportedDone = true;

    spec.reset();

    expect(spec.reportedDone).toBeFalse();
  })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':289,'endLine':289}","it('does not throw an ExpectationFailed error when handling an error', function() {
    const resultCallback = jasmine.createSpy('resultCallback'),
      spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: function() {} },
        resultCallback: resultCallback,
        throwOnExpectationFailure: true
      });

    spec.handleException('failing exception');
  })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':362,'endLine':362}","it('adds the messages to the result', function() {
      const timer = jasmine.createSpyObj('timer', ['start', 'elapsed']);
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} },
        timer: timer
      });
      const t1 = 123;
      const t2 = 456;

      expect(spec.result.debugLogs).toBeNull();
      timer.elapsed.and.returnValue(t1);
      spec.debugLog('msg 1');
      expect(spec.result.debugLogs).toEqual([
        { message: 'msg 1', timestamp: t1 }
      ]);
      timer.elapsed.and.returnValue(t2);
      spec.debugLog('msg 2');
      expect(spec.result.debugLogs).toEqual([
        { message: 'msg 1', timestamp: t1 },
        { message: 'msg 2', timestamp: t2 }
      ]);
    })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':385,'endLine':385}","it('removes the logs from the result', function() {
        const spec = new jasmineUnderTest.Spec({
          queueableFn: { fn: () => {} }
        });

        spec.debugLog('msg');
        spec.executionFinished();

        expect(spec.result.debugLogs).toBeNull();
      })",snuts
/spec/core/SpecSpec.js,NonFunctionalStatement,"{'startLine':399,'endLine':399}","it('includes the messages in the result', function() {
        const timer = jasmine.createSpyObj('timer', ['start', 'elapsed']);
        const spec = new jasmineUnderTest.Spec({
          queueableFn: { fn: () => {} },
          timer: timer
        });
        const timestamp = 12345;

        timer.elapsed.and.returnValue(timestamp);

        spec.debugLog('msg');
        spec.handleException(new Error('nope'));
        spec.executionFinished();

        expect(spec.result.debugLogs).toEqual([
          { message: 'msg', timestamp: timestamp }
        ]);
      })",snuts
/spec/core/SkipAfterBeforeAllErrorPolicySpec.js,IdenticalTestDescription,"{'startLine':17,'endLine':30}","it('does not skip anything', function() {
        const policy = new jasmineUnderTest.SkipAfterBeforeAllErrorPolicy(
          arrayOfArbitraryFns(4)
        );

        policy.fnErrored(0);
        expect(policy.skipTo(0)).toEqual(1);
        policy.fnErrored(1);
        expect(policy.skipTo(1)).toEqual(2);
        policy.fnErrored(2);
        expect(policy.skipTo(2)).toEqual(3);
        policy.fnErrored(3);
        expect(policy.skipTo(3)).toEqual(4);
      })",snuts
/spec/core/SkipAfterBeforeAllErrorPolicySpec.js,NonFunctionalStatement,"{'startLine':37,'endLine':37}","it('skips subsequent functions other than afterAll', function() {
        const suite = {};
        const fns = [
          { type: 'beforeAll', fn: () => {}, suite },
          { fn: () => {} },
          { fn: () => {} },
          { type: 'afterAll', fn: () => {} },
          { type: 'afterAll', fn: () => {} }
        ];
        const policy = new jasmineUnderTest.SkipAfterBeforeAllErrorPolicy(fns);

        policy.fnErrored(0);
        expect(policy.skipTo(0)).toEqual(3);
        expect(policy.skipTo(3)).toEqual(4);
      })",snuts
/spec/core/SkipAfterBeforeAllErrorPolicySpec.js,NonFunctionalStatement,"{'startLine':38,'endLine':38}","it('skips subsequent functions other than afterAll', function() {
        const suite = {};
        const fns = [
          { type: 'beforeAll', fn: () => {}, suite },
          { fn: () => {} },
          { fn: () => {} },
          { type: 'afterAll', fn: () => {} },
          { type: 'afterAll', fn: () => {} }
        ];
        const policy = new jasmineUnderTest.SkipAfterBeforeAllErrorPolicy(fns);

        policy.fnErrored(0);
        expect(policy.skipTo(0)).toEqual(3);
        expect(policy.skipTo(3)).toEqual(4);
      })",snuts
/spec/core/SkipAfterBeforeAllErrorPolicySpec.js,NonFunctionalStatement,"{'startLine':39,'endLine':39}","it('skips subsequent functions other than afterAll', function() {
        const suite = {};
        const fns = [
          { type: 'beforeAll', fn: () => {}, suite },
          { fn: () => {} },
          { fn: () => {} },
          { type: 'afterAll', fn: () => {} },
          { type: 'afterAll', fn: () => {} }
        ];
        const policy = new jasmineUnderTest.SkipAfterBeforeAllErrorPolicy(fns);

        policy.fnErrored(0);
        expect(policy.skipTo(0)).toEqual(3);
        expect(policy.skipTo(3)).toEqual(4);
      })",snuts
/spec/core/SkipAfterBeforeAllErrorPolicySpec.js,NonFunctionalStatement,"{'startLine':40,'endLine':40}","it('skips subsequent functions other than afterAll', function() {
        const suite = {};
        const fns = [
          { type: 'beforeAll', fn: () => {}, suite },
          { fn: () => {} },
          { fn: () => {} },
          { type: 'afterAll', fn: () => {} },
          { type: 'afterAll', fn: () => {} }
        ];
        const policy = new jasmineUnderTest.SkipAfterBeforeAllErrorPolicy(fns);

        policy.fnErrored(0);
        expect(policy.skipTo(0)).toEqual(3);
        expect(policy.skipTo(3)).toEqual(4);
      })",snuts
/spec/core/SkipAfterBeforeAllErrorPolicySpec.js,NonFunctionalStatement,"{'startLine':41,'endLine':41}","it('skips subsequent functions other than afterAll', function() {
        const suite = {};
        const fns = [
          { type: 'beforeAll', fn: () => {}, suite },
          { fn: () => {} },
          { fn: () => {} },
          { type: 'afterAll', fn: () => {} },
          { type: 'afterAll', fn: () => {} }
        ];
        const policy = new jasmineUnderTest.SkipAfterBeforeAllErrorPolicy(fns);

        policy.fnErrored(0);
        expect(policy.skipTo(0)).toEqual(3);
        expect(policy.skipTo(3)).toEqual(4);
      })",snuts
/spec/core/SkipAfterBeforeAllErrorPolicySpec.js,NonFunctionalStatement,"{'startLine':56,'endLine':56}","it(""sets the suite's hadBeforeAllFailure property to true"", function() {
        const suite = {};
        const fns = [{ type: 'beforeAll', fn: () => {}, suite }];
        const policy = new jasmineUnderTest.SkipAfterBeforeAllErrorPolicy(fns);

        policy.fnErrored(0);

        expect(suite.hadBeforeAllFailure).toBeTrue();
      })",snuts
/spec/core/SkipAfterBeforeAllErrorPolicySpec.js,NonFunctionalStatement,"{'startLine':67,'endLine':67}","it('does not try to access the suite, which is probably not there', function() {
        const fns = [{ fn: () => {} /* no suite */ }];
        const policy = new jasmineUnderTest.SkipAfterBeforeAllErrorPolicy(fns);

        expect(() => policy.fnErrored(0)).not.toThrow();
      })",snuts
/spec/core/SkipAfterBeforeAllErrorPolicySpec.js,NonFunctionalStatement,"{'startLine':80,'endLine':80}",Unknown,snuts
/spec/core/RunnerSpec.js,GeneralFixture,"{'startLine':12,'endLine':12}","beforeEach(function() {
      suiteNumber = 0;
      specNumber = 0;
      runQueue = jasmine.createSpy('runQueue');
      globalErrors = 'the global errors instance';
      reportDispatcher = jasmine.createSpyObj(
        'reportDispatcher',
        jasmineUnderTest.reporterEvents
      );

      for (const k of jasmineUnderTest.reporterEvents) {
        reportDispatcher[k].and.returnValue(Promise.resolve());
      }

      // Reasonable defaults, may be overridden in some cases
      failSpecWithNoExpectations = false;
      detectLateRejectionHandling = false;

      spyOn(jasmineUnderTest.TreeRunner.prototype, '_executeSpec');
    })",snuts
/spec/core/RunnerSpec.js,GeneralFixture,"{'startLine':13,'endLine':13}","beforeEach(function() {
      suiteNumber = 0;
      specNumber = 0;
      runQueue = jasmine.createSpy('runQueue');
      globalErrors = 'the global errors instance';
      reportDispatcher = jasmine.createSpyObj(
        'reportDispatcher',
        jasmineUnderTest.reporterEvents
      );

      for (const k of jasmineUnderTest.reporterEvents) {
        reportDispatcher[k].and.returnValue(Promise.resolve());
      }

      // Reasonable defaults, may be overridden in some cases
      failSpecWithNoExpectations = false;
      detectLateRejectionHandling = false;

      spyOn(jasmineUnderTest.TreeRunner.prototype, '_executeSpec');
    })",snuts
/spec/core/RunnerSpec.js,GeneralFixture,"{'startLine':15,'endLine':15}","beforeEach(function() {
      suiteNumber = 0;
      specNumber = 0;
      runQueue = jasmine.createSpy('runQueue');
      globalErrors = 'the global errors instance';
      reportDispatcher = jasmine.createSpyObj(
        'reportDispatcher',
        jasmineUnderTest.reporterEvents
      );

      for (const k of jasmineUnderTest.reporterEvents) {
        reportDispatcher[k].and.returnValue(Promise.resolve());
      }

      // Reasonable defaults, may be overridden in some cases
      failSpecWithNoExpectations = false;
      detectLateRejectionHandling = false;

      spyOn(jasmineUnderTest.TreeRunner.prototype, '_executeSpec');
    })",snuts
/spec/core/RunnerSpec.js,NonFunctionalStatement,"{'startLine':50,'endLine':50}","describe('Integration with TreeProcessor and TreeRunner', function() {
    let suiteNumber,
      specNumber,
      runQueue,
      globalErrors,
      reportDispatcher,
      failSpecWithNoExpectations,
      detectLateRejectionHandling;

    beforeEach(function() {
      suiteNumber = 0;
      specNumber = 0;
      runQueue = jasmine.createSpy('runQueue');
      globalErrors = 'the global errors instance';
      reportDispatcher = jasmine.createSpyObj(
        'reportDispatcher',
        jasmineUnderTest.reporterEvents
      );

      for (const k of jasmineUnderTest.reporterEvents) {
        reportDispatcher[k].and.returnValue(Promise.resolve());
      }

      // Reasonable defaults, may be overridden in some cases
      failSpecWithNoExpectations = false;
      detectLateRejectionHandling = false;

      spyOn(jasmineUnderTest.TreeRunner.prototype, '_executeSpec');
    });

    function StubSuite(attrs) {
      attrs = attrs || {};
      this.id = 'suite' + suiteNumber++;
      this.children = attrs.children || [];
      this.canBeReentered = function() {
        return !attrs.noReenter;
      };
      this.markedPending = attrs.markedPending || false;
      this.sharedUserContext = function() {
        return attrs.userContext || {};
      };
      this.result = {
        id: this.id,
        failedExpectations: []
      };
      this.getResult = jasmine.createSpy('getResult');
      this.beforeAllFns = attrs.beforeAllFns || [];
      this.afterAllFns = attrs.afterAllFns || [];
      this.cleanupBeforeAfter = function() {};
      this.startTimer = function() {};
      this.endTimer = function() {};
    }

    function StubSpec(attrs) {
      attrs = attrs || {};
      this.id = 'spec' + specNumber++;
      this.markedPending = attrs.markedPending || false;
      this.execute = jasmine.createSpy(this.id + '#execute');
      this.beforeAndAfterFns = () => ({ befores: [], afters: [] });
      this.userContext = () => ({});
      this.getFullName = () => '';
      this.queueableFn = () => {};
    }

    function makeRunner(topSuite) {
      const defaultOptions = {
        getConfig: () => ({
          specFilter: () => true,
          failSpecWithNoExpectations,
          detectLateRejectionHandling
        }),
        focusedRunables: () => [],
        totalSpecsDefined: () => 1,
        TreeProcessor: jasmineUnderTest.TreeProcessor,
        runableResources: {
          initForRunable: () => {},
          clearForRunable: () => {}
        },
        reportDispatcher,
        globalErrors,
        runQueue
      };
      return new jasmineUnderTest.Runner({
        ...defaultOptions,
        topSuite
      });
    }

    function arrayNotContaining(item) {
      return {
        asymmetricMatch(other, matchersUtil) {
          if (!jasmine.isArray_(other)) {
            return false;
          }

          for (const x of other) {
            if (matchersUtil.equals(x, item)) {
              return false;
            }
          }

          return true;
        }
      };
    }

    // Precondition: jasmineUnderTest.TreeRunner.prototype._executeSpec is a spy
    function verifyAndFinishSpec(spec, queueableFn, shouldBeExcluded) {
      const ex = jasmineUnderTest.TreeRunner.prototype._executeSpec;
      ex.withArgs(spec, 'onComplete').and.callThrough();

      queueableFn.fn('onComplete');
      expect(ex).toHaveBeenCalledWith(spec, 'onComplete');

      expect(runQueue).toHaveBeenCalledWith(
        jasmine.objectContaining({
          isLeaf: true,
          SkipPolicy: jasmineUnderTest.CompleteOnFirstErrorSkipPolicy,
          queueableFns: shouldBeExcluded
            ? arrayNotContaining(spec.queueableFn)
            : jasmine.arrayContaining([spec.queueableFn])
        })
      );
    }

    it('runs a single spec', async function() {
      const spec = new StubSpec();
      const topSuite = new StubSuite({
        children: [spec],
        userContext: { root: 'context' }
      });
      detectLateRejectionHandling = true;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { root: 'context' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      verifyAndFinishSpec(spec, runQueueArgs.queueableFns[0], false);
      runQueueArgs.onComplete();
      await promise;
    });

    it('runs an empty suite', async function() {
      const suite = new StubSuite({ userContext: { for: 'suite' } });
      const topSuite = new StubSuite({
        children: [suite],
        userContext: { for: 'topSuite' }
      });
      suite.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { for: 'topSuite' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      const nodeDone = jasmine.createSpy('nodeDone');
      runQueueArgs.queueableFns[0].fn(nodeDone);
      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onMultipleDone: null,
        queueableFns: [{ fn: jasmine.any(Function) }],
        userContext: { for: 'suite' },
        onException: jasmine.any(Function),
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      runQueue.calls.mostRecent().args[0].queueableFns[0].fn('foo');
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(suite.result);

      suite.getResult.and.returnValue({ my: 'result' });

      runQueue.calls.mostRecent().args[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith({ my: 'result' });

      runQueueArgs.onComplete();
      await promise;
    });

    it('runs a non-empty suite', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const suite = new StubSuite({ children: [spec1, spec2] });
      const topSuite = new StubSuite({ children: [suite] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(2);
      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(3);

      verifyAndFinishSpec(spec1, queueableFns[1], false);
      verifyAndFinishSpec(spec2, queueableFns[2], false);
      await expectAsync(promise).toBePending();
    });

    it('""runs"" an excluded suite', async function() {
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      // Empty list of runable IDs excludes everything
      const promise = subject.execute([]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn();
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(parent.result);

      verifyAndFinishSpec(spec, queueableFns[1], true);

      parent.getResult.and.returnValue(parent.result);
      runQueue.calls.argsFor(1)[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(parent.result);
      await expectAsync(promise).toBePending();
    });

    it('handles the failSpecWithNoExpectations option', async function() {
      failSpecWithNoExpectations = true;
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[1].fn('foo');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec, 'foo');

      await expectAsync(promise).toBePending();
    });

    it('runs beforeAlls and afterAlls for a suite with children', async function() {
      const spec = new StubSpec();
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [
          { fn: 'beforeAll1', timeout: 1 },
          { fn: 'beforeAll2', timeout: 2 }
        ],
        afterAllFns: [
          { fn: 'afterAll1', timeout: 3 },
          { fn: 'afterAll2', timeout: 4 }
        ]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns).toEqual([
        { fn: jasmine.any(Function) },
        { fn: 'beforeAll1', timeout: 1 },
        { fn: 'beforeAll2', timeout: 2 },
        { fn: jasmine.any(Function) },
        { fn: 'afterAll1', timeout: 3 },
        { fn: 'afterAll2', timeout: 4 }
      ]);

      await expectAsync(promise).toBePending();
    });

    it('does not run beforeAlls or afterAlls for a suite with no children', async function() {
      const target = new StubSuite({
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        1
      );

      await expectAsync(promise).toBePending();
    });

    it('does not run beforeAlls or afterAlls for a suite with only pending children', async function() {
      const spec = new StubSpec({ markedPending: true });
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        2
      );

      await expectAsync(promise).toBePending();
    });

    it('runs specs in the order specified', async function() {
      const specs = [new StubSpec(), new StubSpec()];
      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specs[1].id, specs[0].id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(specs[0], jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specs[1], 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specs[0], 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs specified specs before non-specified specs within a suite', async function() {
      const specified = new StubSpec();
      const nonSpecified = new StubSpec();
      const topSuite = new StubSuite({ children: [nonSpecified, specified] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specified.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(nonSpecified, jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specified, 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecified, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs suites and specs with a specified order', async function() {
      const specifiedSpec = new StubSpec();
      const nonSpecifiedSpec = new StubSpec();
      const specifiedSuite = new StubSuite({ children: [nonSpecifiedSpec] });
      const topSuite = new StubSuite({
        children: [specifiedSpec, specifiedSuite]
      });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specifiedSuite.id, specifiedSpec.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn();

      expect(specifiedSpec.execute).not.toHaveBeenCalled();
      const nodeQueueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      nodeQueueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecifiedSpec, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specifiedSpec, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs suites and specs in the order they were declared', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const parent = new StubSuite({ children: [spec2, spec3] });
      const topSuite = new StubSuite({ children: [spec1, parent] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn();
      const childFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(childFns.length).toBe(3);
      childFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      childFns[2].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs a suite multiple times if the order specified leaves and re-enters it', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const reentered = new StubSuite({ children: [spec1, spec2, spec3] });
      const topSuite = new StubSuite({ children: [reentered, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;

      queueableFns[0].fn();
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(3);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs a parent of a suite with multiple segments correctly', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const parent = new StubSuite({ children: [spec1, spec2, spec3] });
      const grandparent = new StubSuite({ children: [parent] });
      const topSuite = new StubSuite({ children: [grandparent, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(5);

      queueableFns[0].fn();
      expect(runQueue.calls.count()).toBe(2);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(3);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(5);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(6);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(7);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs large segments of nodes in the order they were declared', async function() {
      const specs = [];

      for (let i = 0; i < 11; i++) {
        specs.push(new StubSpec());
      }

      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(11);

      for (let i = 0; i < 11; i++) {
        queueableFns[i].fn('done');
        expect(
          jasmineUnderTest.TreeRunner.prototype._executeSpec
        ).toHaveBeenCalledWith(specs[i], 'done');
      }

      await expectAsync(promise).toBePending();
    });
  })",snuts
/spec/core/RunnerSpec.js,NonFunctionalStatement,"{'startLine':51,'endLine':51}","describe('Integration with TreeProcessor and TreeRunner', function() {
    let suiteNumber,
      specNumber,
      runQueue,
      globalErrors,
      reportDispatcher,
      failSpecWithNoExpectations,
      detectLateRejectionHandling;

    beforeEach(function() {
      suiteNumber = 0;
      specNumber = 0;
      runQueue = jasmine.createSpy('runQueue');
      globalErrors = 'the global errors instance';
      reportDispatcher = jasmine.createSpyObj(
        'reportDispatcher',
        jasmineUnderTest.reporterEvents
      );

      for (const k of jasmineUnderTest.reporterEvents) {
        reportDispatcher[k].and.returnValue(Promise.resolve());
      }

      // Reasonable defaults, may be overridden in some cases
      failSpecWithNoExpectations = false;
      detectLateRejectionHandling = false;

      spyOn(jasmineUnderTest.TreeRunner.prototype, '_executeSpec');
    });

    function StubSuite(attrs) {
      attrs = attrs || {};
      this.id = 'suite' + suiteNumber++;
      this.children = attrs.children || [];
      this.canBeReentered = function() {
        return !attrs.noReenter;
      };
      this.markedPending = attrs.markedPending || false;
      this.sharedUserContext = function() {
        return attrs.userContext || {};
      };
      this.result = {
        id: this.id,
        failedExpectations: []
      };
      this.getResult = jasmine.createSpy('getResult');
      this.beforeAllFns = attrs.beforeAllFns || [];
      this.afterAllFns = attrs.afterAllFns || [];
      this.cleanupBeforeAfter = function() {};
      this.startTimer = function() {};
      this.endTimer = function() {};
    }

    function StubSpec(attrs) {
      attrs = attrs || {};
      this.id = 'spec' + specNumber++;
      this.markedPending = attrs.markedPending || false;
      this.execute = jasmine.createSpy(this.id + '#execute');
      this.beforeAndAfterFns = () => ({ befores: [], afters: [] });
      this.userContext = () => ({});
      this.getFullName = () => '';
      this.queueableFn = () => {};
    }

    function makeRunner(topSuite) {
      const defaultOptions = {
        getConfig: () => ({
          specFilter: () => true,
          failSpecWithNoExpectations,
          detectLateRejectionHandling
        }),
        focusedRunables: () => [],
        totalSpecsDefined: () => 1,
        TreeProcessor: jasmineUnderTest.TreeProcessor,
        runableResources: {
          initForRunable: () => {},
          clearForRunable: () => {}
        },
        reportDispatcher,
        globalErrors,
        runQueue
      };
      return new jasmineUnderTest.Runner({
        ...defaultOptions,
        topSuite
      });
    }

    function arrayNotContaining(item) {
      return {
        asymmetricMatch(other, matchersUtil) {
          if (!jasmine.isArray_(other)) {
            return false;
          }

          for (const x of other) {
            if (matchersUtil.equals(x, item)) {
              return false;
            }
          }

          return true;
        }
      };
    }

    // Precondition: jasmineUnderTest.TreeRunner.prototype._executeSpec is a spy
    function verifyAndFinishSpec(spec, queueableFn, shouldBeExcluded) {
      const ex = jasmineUnderTest.TreeRunner.prototype._executeSpec;
      ex.withArgs(spec, 'onComplete').and.callThrough();

      queueableFn.fn('onComplete');
      expect(ex).toHaveBeenCalledWith(spec, 'onComplete');

      expect(runQueue).toHaveBeenCalledWith(
        jasmine.objectContaining({
          isLeaf: true,
          SkipPolicy: jasmineUnderTest.CompleteOnFirstErrorSkipPolicy,
          queueableFns: shouldBeExcluded
            ? arrayNotContaining(spec.queueableFn)
            : jasmine.arrayContaining([spec.queueableFn])
        })
      );
    }

    it('runs a single spec', async function() {
      const spec = new StubSpec();
      const topSuite = new StubSuite({
        children: [spec],
        userContext: { root: 'context' }
      });
      detectLateRejectionHandling = true;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { root: 'context' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      verifyAndFinishSpec(spec, runQueueArgs.queueableFns[0], false);
      runQueueArgs.onComplete();
      await promise;
    });

    it('runs an empty suite', async function() {
      const suite = new StubSuite({ userContext: { for: 'suite' } });
      const topSuite = new StubSuite({
        children: [suite],
        userContext: { for: 'topSuite' }
      });
      suite.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { for: 'topSuite' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      const nodeDone = jasmine.createSpy('nodeDone');
      runQueueArgs.queueableFns[0].fn(nodeDone);
      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onMultipleDone: null,
        queueableFns: [{ fn: jasmine.any(Function) }],
        userContext: { for: 'suite' },
        onException: jasmine.any(Function),
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      runQueue.calls.mostRecent().args[0].queueableFns[0].fn('foo');
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(suite.result);

      suite.getResult.and.returnValue({ my: 'result' });

      runQueue.calls.mostRecent().args[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith({ my: 'result' });

      runQueueArgs.onComplete();
      await promise;
    });

    it('runs a non-empty suite', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const suite = new StubSuite({ children: [spec1, spec2] });
      const topSuite = new StubSuite({ children: [suite] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(2);
      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(3);

      verifyAndFinishSpec(spec1, queueableFns[1], false);
      verifyAndFinishSpec(spec2, queueableFns[2], false);
      await expectAsync(promise).toBePending();
    });

    it('""runs"" an excluded suite', async function() {
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      // Empty list of runable IDs excludes everything
      const promise = subject.execute([]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn();
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(parent.result);

      verifyAndFinishSpec(spec, queueableFns[1], true);

      parent.getResult.and.returnValue(parent.result);
      runQueue.calls.argsFor(1)[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(parent.result);
      await expectAsync(promise).toBePending();
    });

    it('handles the failSpecWithNoExpectations option', async function() {
      failSpecWithNoExpectations = true;
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[1].fn('foo');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec, 'foo');

      await expectAsync(promise).toBePending();
    });

    it('runs beforeAlls and afterAlls for a suite with children', async function() {
      const spec = new StubSpec();
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [
          { fn: 'beforeAll1', timeout: 1 },
          { fn: 'beforeAll2', timeout: 2 }
        ],
        afterAllFns: [
          { fn: 'afterAll1', timeout: 3 },
          { fn: 'afterAll2', timeout: 4 }
        ]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns).toEqual([
        { fn: jasmine.any(Function) },
        { fn: 'beforeAll1', timeout: 1 },
        { fn: 'beforeAll2', timeout: 2 },
        { fn: jasmine.any(Function) },
        { fn: 'afterAll1', timeout: 3 },
        { fn: 'afterAll2', timeout: 4 }
      ]);

      await expectAsync(promise).toBePending();
    });

    it('does not run beforeAlls or afterAlls for a suite with no children', async function() {
      const target = new StubSuite({
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        1
      );

      await expectAsync(promise).toBePending();
    });

    it('does not run beforeAlls or afterAlls for a suite with only pending children', async function() {
      const spec = new StubSpec({ markedPending: true });
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        2
      );

      await expectAsync(promise).toBePending();
    });

    it('runs specs in the order specified', async function() {
      const specs = [new StubSpec(), new StubSpec()];
      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specs[1].id, specs[0].id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(specs[0], jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specs[1], 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specs[0], 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs specified specs before non-specified specs within a suite', async function() {
      const specified = new StubSpec();
      const nonSpecified = new StubSpec();
      const topSuite = new StubSuite({ children: [nonSpecified, specified] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specified.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(nonSpecified, jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specified, 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecified, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs suites and specs with a specified order', async function() {
      const specifiedSpec = new StubSpec();
      const nonSpecifiedSpec = new StubSpec();
      const specifiedSuite = new StubSuite({ children: [nonSpecifiedSpec] });
      const topSuite = new StubSuite({
        children: [specifiedSpec, specifiedSuite]
      });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specifiedSuite.id, specifiedSpec.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn();

      expect(specifiedSpec.execute).not.toHaveBeenCalled();
      const nodeQueueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      nodeQueueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecifiedSpec, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specifiedSpec, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs suites and specs in the order they were declared', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const parent = new StubSuite({ children: [spec2, spec3] });
      const topSuite = new StubSuite({ children: [spec1, parent] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn();
      const childFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(childFns.length).toBe(3);
      childFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      childFns[2].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs a suite multiple times if the order specified leaves and re-enters it', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const reentered = new StubSuite({ children: [spec1, spec2, spec3] });
      const topSuite = new StubSuite({ children: [reentered, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;

      queueableFns[0].fn();
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(3);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs a parent of a suite with multiple segments correctly', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const parent = new StubSuite({ children: [spec1, spec2, spec3] });
      const grandparent = new StubSuite({ children: [parent] });
      const topSuite = new StubSuite({ children: [grandparent, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(5);

      queueableFns[0].fn();
      expect(runQueue.calls.count()).toBe(2);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(3);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(5);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(6);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(7);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs large segments of nodes in the order they were declared', async function() {
      const specs = [];

      for (let i = 0; i < 11; i++) {
        specs.push(new StubSpec());
      }

      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(11);

      for (let i = 0; i < 11; i++) {
        queueableFns[i].fn('done');
        expect(
          jasmineUnderTest.TreeRunner.prototype._executeSpec
        ).toHaveBeenCalledWith(specs[i], 'done');
      }

      await expectAsync(promise).toBePending();
    });
  })",snuts
/spec/core/RunnerSpec.js,NonFunctionalStatement,"{'startLine':52,'endLine':52}","describe('Integration with TreeProcessor and TreeRunner', function() {
    let suiteNumber,
      specNumber,
      runQueue,
      globalErrors,
      reportDispatcher,
      failSpecWithNoExpectations,
      detectLateRejectionHandling;

    beforeEach(function() {
      suiteNumber = 0;
      specNumber = 0;
      runQueue = jasmine.createSpy('runQueue');
      globalErrors = 'the global errors instance';
      reportDispatcher = jasmine.createSpyObj(
        'reportDispatcher',
        jasmineUnderTest.reporterEvents
      );

      for (const k of jasmineUnderTest.reporterEvents) {
        reportDispatcher[k].and.returnValue(Promise.resolve());
      }

      // Reasonable defaults, may be overridden in some cases
      failSpecWithNoExpectations = false;
      detectLateRejectionHandling = false;

      spyOn(jasmineUnderTest.TreeRunner.prototype, '_executeSpec');
    });

    function StubSuite(attrs) {
      attrs = attrs || {};
      this.id = 'suite' + suiteNumber++;
      this.children = attrs.children || [];
      this.canBeReentered = function() {
        return !attrs.noReenter;
      };
      this.markedPending = attrs.markedPending || false;
      this.sharedUserContext = function() {
        return attrs.userContext || {};
      };
      this.result = {
        id: this.id,
        failedExpectations: []
      };
      this.getResult = jasmine.createSpy('getResult');
      this.beforeAllFns = attrs.beforeAllFns || [];
      this.afterAllFns = attrs.afterAllFns || [];
      this.cleanupBeforeAfter = function() {};
      this.startTimer = function() {};
      this.endTimer = function() {};
    }

    function StubSpec(attrs) {
      attrs = attrs || {};
      this.id = 'spec' + specNumber++;
      this.markedPending = attrs.markedPending || false;
      this.execute = jasmine.createSpy(this.id + '#execute');
      this.beforeAndAfterFns = () => ({ befores: [], afters: [] });
      this.userContext = () => ({});
      this.getFullName = () => '';
      this.queueableFn = () => {};
    }

    function makeRunner(topSuite) {
      const defaultOptions = {
        getConfig: () => ({
          specFilter: () => true,
          failSpecWithNoExpectations,
          detectLateRejectionHandling
        }),
        focusedRunables: () => [],
        totalSpecsDefined: () => 1,
        TreeProcessor: jasmineUnderTest.TreeProcessor,
        runableResources: {
          initForRunable: () => {},
          clearForRunable: () => {}
        },
        reportDispatcher,
        globalErrors,
        runQueue
      };
      return new jasmineUnderTest.Runner({
        ...defaultOptions,
        topSuite
      });
    }

    function arrayNotContaining(item) {
      return {
        asymmetricMatch(other, matchersUtil) {
          if (!jasmine.isArray_(other)) {
            return false;
          }

          for (const x of other) {
            if (matchersUtil.equals(x, item)) {
              return false;
            }
          }

          return true;
        }
      };
    }

    // Precondition: jasmineUnderTest.TreeRunner.prototype._executeSpec is a spy
    function verifyAndFinishSpec(spec, queueableFn, shouldBeExcluded) {
      const ex = jasmineUnderTest.TreeRunner.prototype._executeSpec;
      ex.withArgs(spec, 'onComplete').and.callThrough();

      queueableFn.fn('onComplete');
      expect(ex).toHaveBeenCalledWith(spec, 'onComplete');

      expect(runQueue).toHaveBeenCalledWith(
        jasmine.objectContaining({
          isLeaf: true,
          SkipPolicy: jasmineUnderTest.CompleteOnFirstErrorSkipPolicy,
          queueableFns: shouldBeExcluded
            ? arrayNotContaining(spec.queueableFn)
            : jasmine.arrayContaining([spec.queueableFn])
        })
      );
    }

    it('runs a single spec', async function() {
      const spec = new StubSpec();
      const topSuite = new StubSuite({
        children: [spec],
        userContext: { root: 'context' }
      });
      detectLateRejectionHandling = true;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { root: 'context' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      verifyAndFinishSpec(spec, runQueueArgs.queueableFns[0], false);
      runQueueArgs.onComplete();
      await promise;
    });

    it('runs an empty suite', async function() {
      const suite = new StubSuite({ userContext: { for: 'suite' } });
      const topSuite = new StubSuite({
        children: [suite],
        userContext: { for: 'topSuite' }
      });
      suite.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { for: 'topSuite' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      const nodeDone = jasmine.createSpy('nodeDone');
      runQueueArgs.queueableFns[0].fn(nodeDone);
      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onMultipleDone: null,
        queueableFns: [{ fn: jasmine.any(Function) }],
        userContext: { for: 'suite' },
        onException: jasmine.any(Function),
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      runQueue.calls.mostRecent().args[0].queueableFns[0].fn('foo');
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(suite.result);

      suite.getResult.and.returnValue({ my: 'result' });

      runQueue.calls.mostRecent().args[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith({ my: 'result' });

      runQueueArgs.onComplete();
      await promise;
    });

    it('runs a non-empty suite', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const suite = new StubSuite({ children: [spec1, spec2] });
      const topSuite = new StubSuite({ children: [suite] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(2);
      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(3);

      verifyAndFinishSpec(spec1, queueableFns[1], false);
      verifyAndFinishSpec(spec2, queueableFns[2], false);
      await expectAsync(promise).toBePending();
    });

    it('""runs"" an excluded suite', async function() {
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      // Empty list of runable IDs excludes everything
      const promise = subject.execute([]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn();
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(parent.result);

      verifyAndFinishSpec(spec, queueableFns[1], true);

      parent.getResult.and.returnValue(parent.result);
      runQueue.calls.argsFor(1)[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(parent.result);
      await expectAsync(promise).toBePending();
    });

    it('handles the failSpecWithNoExpectations option', async function() {
      failSpecWithNoExpectations = true;
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[1].fn('foo');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec, 'foo');

      await expectAsync(promise).toBePending();
    });

    it('runs beforeAlls and afterAlls for a suite with children', async function() {
      const spec = new StubSpec();
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [
          { fn: 'beforeAll1', timeout: 1 },
          { fn: 'beforeAll2', timeout: 2 }
        ],
        afterAllFns: [
          { fn: 'afterAll1', timeout: 3 },
          { fn: 'afterAll2', timeout: 4 }
        ]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns).toEqual([
        { fn: jasmine.any(Function) },
        { fn: 'beforeAll1', timeout: 1 },
        { fn: 'beforeAll2', timeout: 2 },
        { fn: jasmine.any(Function) },
        { fn: 'afterAll1', timeout: 3 },
        { fn: 'afterAll2', timeout: 4 }
      ]);

      await expectAsync(promise).toBePending();
    });

    it('does not run beforeAlls or afterAlls for a suite with no children', async function() {
      const target = new StubSuite({
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        1
      );

      await expectAsync(promise).toBePending();
    });

    it('does not run beforeAlls or afterAlls for a suite with only pending children', async function() {
      const spec = new StubSpec({ markedPending: true });
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        2
      );

      await expectAsync(promise).toBePending();
    });

    it('runs specs in the order specified', async function() {
      const specs = [new StubSpec(), new StubSpec()];
      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specs[1].id, specs[0].id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(specs[0], jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specs[1], 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specs[0], 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs specified specs before non-specified specs within a suite', async function() {
      const specified = new StubSpec();
      const nonSpecified = new StubSpec();
      const topSuite = new StubSuite({ children: [nonSpecified, specified] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specified.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(nonSpecified, jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specified, 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecified, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs suites and specs with a specified order', async function() {
      const specifiedSpec = new StubSpec();
      const nonSpecifiedSpec = new StubSpec();
      const specifiedSuite = new StubSuite({ children: [nonSpecifiedSpec] });
      const topSuite = new StubSuite({
        children: [specifiedSpec, specifiedSuite]
      });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specifiedSuite.id, specifiedSpec.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn();

      expect(specifiedSpec.execute).not.toHaveBeenCalled();
      const nodeQueueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      nodeQueueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecifiedSpec, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specifiedSpec, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs suites and specs in the order they were declared', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const parent = new StubSuite({ children: [spec2, spec3] });
      const topSuite = new StubSuite({ children: [spec1, parent] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn();
      const childFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(childFns.length).toBe(3);
      childFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      childFns[2].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs a suite multiple times if the order specified leaves and re-enters it', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const reentered = new StubSuite({ children: [spec1, spec2, spec3] });
      const topSuite = new StubSuite({ children: [reentered, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;

      queueableFns[0].fn();
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(3);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs a parent of a suite with multiple segments correctly', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const parent = new StubSuite({ children: [spec1, spec2, spec3] });
      const grandparent = new StubSuite({ children: [parent] });
      const topSuite = new StubSuite({ children: [grandparent, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(5);

      queueableFns[0].fn();
      expect(runQueue.calls.count()).toBe(2);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(3);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(5);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(6);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(7);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs large segments of nodes in the order they were declared', async function() {
      const specs = [];

      for (let i = 0; i < 11; i++) {
        specs.push(new StubSpec());
      }

      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(11);

      for (let i = 0; i < 11; i++) {
        queueableFns[i].fn('done');
        expect(
          jasmineUnderTest.TreeRunner.prototype._executeSpec
        ).toHaveBeenCalledWith(specs[i], 'done');
      }

      await expectAsync(promise).toBePending();
    });
  })",snuts
/spec/core/RunnerSpec.js,NonFunctionalStatement,"{'startLine':63,'endLine':63}","describe('Integration with TreeProcessor and TreeRunner', function() {
    let suiteNumber,
      specNumber,
      runQueue,
      globalErrors,
      reportDispatcher,
      failSpecWithNoExpectations,
      detectLateRejectionHandling;

    beforeEach(function() {
      suiteNumber = 0;
      specNumber = 0;
      runQueue = jasmine.createSpy('runQueue');
      globalErrors = 'the global errors instance';
      reportDispatcher = jasmine.createSpyObj(
        'reportDispatcher',
        jasmineUnderTest.reporterEvents
      );

      for (const k of jasmineUnderTest.reporterEvents) {
        reportDispatcher[k].and.returnValue(Promise.resolve());
      }

      // Reasonable defaults, may be overridden in some cases
      failSpecWithNoExpectations = false;
      detectLateRejectionHandling = false;

      spyOn(jasmineUnderTest.TreeRunner.prototype, '_executeSpec');
    });

    function StubSuite(attrs) {
      attrs = attrs || {};
      this.id = 'suite' + suiteNumber++;
      this.children = attrs.children || [];
      this.canBeReentered = function() {
        return !attrs.noReenter;
      };
      this.markedPending = attrs.markedPending || false;
      this.sharedUserContext = function() {
        return attrs.userContext || {};
      };
      this.result = {
        id: this.id,
        failedExpectations: []
      };
      this.getResult = jasmine.createSpy('getResult');
      this.beforeAllFns = attrs.beforeAllFns || [];
      this.afterAllFns = attrs.afterAllFns || [];
      this.cleanupBeforeAfter = function() {};
      this.startTimer = function() {};
      this.endTimer = function() {};
    }

    function StubSpec(attrs) {
      attrs = attrs || {};
      this.id = 'spec' + specNumber++;
      this.markedPending = attrs.markedPending || false;
      this.execute = jasmine.createSpy(this.id + '#execute');
      this.beforeAndAfterFns = () => ({ befores: [], afters: [] });
      this.userContext = () => ({});
      this.getFullName = () => '';
      this.queueableFn = () => {};
    }

    function makeRunner(topSuite) {
      const defaultOptions = {
        getConfig: () => ({
          specFilter: () => true,
          failSpecWithNoExpectations,
          detectLateRejectionHandling
        }),
        focusedRunables: () => [],
        totalSpecsDefined: () => 1,
        TreeProcessor: jasmineUnderTest.TreeProcessor,
        runableResources: {
          initForRunable: () => {},
          clearForRunable: () => {}
        },
        reportDispatcher,
        globalErrors,
        runQueue
      };
      return new jasmineUnderTest.Runner({
        ...defaultOptions,
        topSuite
      });
    }

    function arrayNotContaining(item) {
      return {
        asymmetricMatch(other, matchersUtil) {
          if (!jasmine.isArray_(other)) {
            return false;
          }

          for (const x of other) {
            if (matchersUtil.equals(x, item)) {
              return false;
            }
          }

          return true;
        }
      };
    }

    // Precondition: jasmineUnderTest.TreeRunner.prototype._executeSpec is a spy
    function verifyAndFinishSpec(spec, queueableFn, shouldBeExcluded) {
      const ex = jasmineUnderTest.TreeRunner.prototype._executeSpec;
      ex.withArgs(spec, 'onComplete').and.callThrough();

      queueableFn.fn('onComplete');
      expect(ex).toHaveBeenCalledWith(spec, 'onComplete');

      expect(runQueue).toHaveBeenCalledWith(
        jasmine.objectContaining({
          isLeaf: true,
          SkipPolicy: jasmineUnderTest.CompleteOnFirstErrorSkipPolicy,
          queueableFns: shouldBeExcluded
            ? arrayNotContaining(spec.queueableFn)
            : jasmine.arrayContaining([spec.queueableFn])
        })
      );
    }

    it('runs a single spec', async function() {
      const spec = new StubSpec();
      const topSuite = new StubSuite({
        children: [spec],
        userContext: { root: 'context' }
      });
      detectLateRejectionHandling = true;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { root: 'context' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      verifyAndFinishSpec(spec, runQueueArgs.queueableFns[0], false);
      runQueueArgs.onComplete();
      await promise;
    });

    it('runs an empty suite', async function() {
      const suite = new StubSuite({ userContext: { for: 'suite' } });
      const topSuite = new StubSuite({
        children: [suite],
        userContext: { for: 'topSuite' }
      });
      suite.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { for: 'topSuite' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      const nodeDone = jasmine.createSpy('nodeDone');
      runQueueArgs.queueableFns[0].fn(nodeDone);
      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onMultipleDone: null,
        queueableFns: [{ fn: jasmine.any(Function) }],
        userContext: { for: 'suite' },
        onException: jasmine.any(Function),
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      runQueue.calls.mostRecent().args[0].queueableFns[0].fn('foo');
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(suite.result);

      suite.getResult.and.returnValue({ my: 'result' });

      runQueue.calls.mostRecent().args[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith({ my: 'result' });

      runQueueArgs.onComplete();
      await promise;
    });

    it('runs a non-empty suite', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const suite = new StubSuite({ children: [spec1, spec2] });
      const topSuite = new StubSuite({ children: [suite] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(2);
      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(3);

      verifyAndFinishSpec(spec1, queueableFns[1], false);
      verifyAndFinishSpec(spec2, queueableFns[2], false);
      await expectAsync(promise).toBePending();
    });

    it('""runs"" an excluded suite', async function() {
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      // Empty list of runable IDs excludes everything
      const promise = subject.execute([]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn();
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(parent.result);

      verifyAndFinishSpec(spec, queueableFns[1], true);

      parent.getResult.and.returnValue(parent.result);
      runQueue.calls.argsFor(1)[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(parent.result);
      await expectAsync(promise).toBePending();
    });

    it('handles the failSpecWithNoExpectations option', async function() {
      failSpecWithNoExpectations = true;
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[1].fn('foo');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec, 'foo');

      await expectAsync(promise).toBePending();
    });

    it('runs beforeAlls and afterAlls for a suite with children', async function() {
      const spec = new StubSpec();
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [
          { fn: 'beforeAll1', timeout: 1 },
          { fn: 'beforeAll2', timeout: 2 }
        ],
        afterAllFns: [
          { fn: 'afterAll1', timeout: 3 },
          { fn: 'afterAll2', timeout: 4 }
        ]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns).toEqual([
        { fn: jasmine.any(Function) },
        { fn: 'beforeAll1', timeout: 1 },
        { fn: 'beforeAll2', timeout: 2 },
        { fn: jasmine.any(Function) },
        { fn: 'afterAll1', timeout: 3 },
        { fn: 'afterAll2', timeout: 4 }
      ]);

      await expectAsync(promise).toBePending();
    });

    it('does not run beforeAlls or afterAlls for a suite with no children', async function() {
      const target = new StubSuite({
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        1
      );

      await expectAsync(promise).toBePending();
    });

    it('does not run beforeAlls or afterAlls for a suite with only pending children', async function() {
      const spec = new StubSpec({ markedPending: true });
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        2
      );

      await expectAsync(promise).toBePending();
    });

    it('runs specs in the order specified', async function() {
      const specs = [new StubSpec(), new StubSpec()];
      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specs[1].id, specs[0].id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(specs[0], jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specs[1], 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specs[0], 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs specified specs before non-specified specs within a suite', async function() {
      const specified = new StubSpec();
      const nonSpecified = new StubSpec();
      const topSuite = new StubSuite({ children: [nonSpecified, specified] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specified.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(nonSpecified, jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specified, 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecified, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs suites and specs with a specified order', async function() {
      const specifiedSpec = new StubSpec();
      const nonSpecifiedSpec = new StubSpec();
      const specifiedSuite = new StubSuite({ children: [nonSpecifiedSpec] });
      const topSuite = new StubSuite({
        children: [specifiedSpec, specifiedSuite]
      });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specifiedSuite.id, specifiedSpec.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn();

      expect(specifiedSpec.execute).not.toHaveBeenCalled();
      const nodeQueueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      nodeQueueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecifiedSpec, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specifiedSpec, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs suites and specs in the order they were declared', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const parent = new StubSuite({ children: [spec2, spec3] });
      const topSuite = new StubSuite({ children: [spec1, parent] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn();
      const childFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(childFns.length).toBe(3);
      childFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      childFns[2].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs a suite multiple times if the order specified leaves and re-enters it', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const reentered = new StubSuite({ children: [spec1, spec2, spec3] });
      const topSuite = new StubSuite({ children: [reentered, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;

      queueableFns[0].fn();
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(3);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs a parent of a suite with multiple segments correctly', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const parent = new StubSuite({ children: [spec1, spec2, spec3] });
      const grandparent = new StubSuite({ children: [parent] });
      const topSuite = new StubSuite({ children: [grandparent, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(5);

      queueableFns[0].fn();
      expect(runQueue.calls.count()).toBe(2);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(3);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(5);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(6);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(7);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs large segments of nodes in the order they were declared', async function() {
      const specs = [];

      for (let i = 0; i < 11; i++) {
        specs.push(new StubSpec());
      }

      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(11);

      for (let i = 0; i < 11; i++) {
        queueableFns[i].fn('done');
        expect(
          jasmineUnderTest.TreeRunner.prototype._executeSpec
        ).toHaveBeenCalledWith(specs[i], 'done');
      }

      await expectAsync(promise).toBePending();
    });
  })",snuts
/spec/core/RunnerSpec.js,NonFunctionalStatement,"{'startLine':77,'endLine':77}","describe('Integration with TreeProcessor and TreeRunner', function() {
    let suiteNumber,
      specNumber,
      runQueue,
      globalErrors,
      reportDispatcher,
      failSpecWithNoExpectations,
      detectLateRejectionHandling;

    beforeEach(function() {
      suiteNumber = 0;
      specNumber = 0;
      runQueue = jasmine.createSpy('runQueue');
      globalErrors = 'the global errors instance';
      reportDispatcher = jasmine.createSpyObj(
        'reportDispatcher',
        jasmineUnderTest.reporterEvents
      );

      for (const k of jasmineUnderTest.reporterEvents) {
        reportDispatcher[k].and.returnValue(Promise.resolve());
      }

      // Reasonable defaults, may be overridden in some cases
      failSpecWithNoExpectations = false;
      detectLateRejectionHandling = false;

      spyOn(jasmineUnderTest.TreeRunner.prototype, '_executeSpec');
    });

    function StubSuite(attrs) {
      attrs = attrs || {};
      this.id = 'suite' + suiteNumber++;
      this.children = attrs.children || [];
      this.canBeReentered = function() {
        return !attrs.noReenter;
      };
      this.markedPending = attrs.markedPending || false;
      this.sharedUserContext = function() {
        return attrs.userContext || {};
      };
      this.result = {
        id: this.id,
        failedExpectations: []
      };
      this.getResult = jasmine.createSpy('getResult');
      this.beforeAllFns = attrs.beforeAllFns || [];
      this.afterAllFns = attrs.afterAllFns || [];
      this.cleanupBeforeAfter = function() {};
      this.startTimer = function() {};
      this.endTimer = function() {};
    }

    function StubSpec(attrs) {
      attrs = attrs || {};
      this.id = 'spec' + specNumber++;
      this.markedPending = attrs.markedPending || false;
      this.execute = jasmine.createSpy(this.id + '#execute');
      this.beforeAndAfterFns = () => ({ befores: [], afters: [] });
      this.userContext = () => ({});
      this.getFullName = () => '';
      this.queueableFn = () => {};
    }

    function makeRunner(topSuite) {
      const defaultOptions = {
        getConfig: () => ({
          specFilter: () => true,
          failSpecWithNoExpectations,
          detectLateRejectionHandling
        }),
        focusedRunables: () => [],
        totalSpecsDefined: () => 1,
        TreeProcessor: jasmineUnderTest.TreeProcessor,
        runableResources: {
          initForRunable: () => {},
          clearForRunable: () => {}
        },
        reportDispatcher,
        globalErrors,
        runQueue
      };
      return new jasmineUnderTest.Runner({
        ...defaultOptions,
        topSuite
      });
    }

    function arrayNotContaining(item) {
      return {
        asymmetricMatch(other, matchersUtil) {
          if (!jasmine.isArray_(other)) {
            return false;
          }

          for (const x of other) {
            if (matchersUtil.equals(x, item)) {
              return false;
            }
          }

          return true;
        }
      };
    }

    // Precondition: jasmineUnderTest.TreeRunner.prototype._executeSpec is a spy
    function verifyAndFinishSpec(spec, queueableFn, shouldBeExcluded) {
      const ex = jasmineUnderTest.TreeRunner.prototype._executeSpec;
      ex.withArgs(spec, 'onComplete').and.callThrough();

      queueableFn.fn('onComplete');
      expect(ex).toHaveBeenCalledWith(spec, 'onComplete');

      expect(runQueue).toHaveBeenCalledWith(
        jasmine.objectContaining({
          isLeaf: true,
          SkipPolicy: jasmineUnderTest.CompleteOnFirstErrorSkipPolicy,
          queueableFns: shouldBeExcluded
            ? arrayNotContaining(spec.queueableFn)
            : jasmine.arrayContaining([spec.queueableFn])
        })
      );
    }

    it('runs a single spec', async function() {
      const spec = new StubSpec();
      const topSuite = new StubSuite({
        children: [spec],
        userContext: { root: 'context' }
      });
      detectLateRejectionHandling = true;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { root: 'context' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      verifyAndFinishSpec(spec, runQueueArgs.queueableFns[0], false);
      runQueueArgs.onComplete();
      await promise;
    });

    it('runs an empty suite', async function() {
      const suite = new StubSuite({ userContext: { for: 'suite' } });
      const topSuite = new StubSuite({
        children: [suite],
        userContext: { for: 'topSuite' }
      });
      suite.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { for: 'topSuite' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      const nodeDone = jasmine.createSpy('nodeDone');
      runQueueArgs.queueableFns[0].fn(nodeDone);
      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onMultipleDone: null,
        queueableFns: [{ fn: jasmine.any(Function) }],
        userContext: { for: 'suite' },
        onException: jasmine.any(Function),
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      runQueue.calls.mostRecent().args[0].queueableFns[0].fn('foo');
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(suite.result);

      suite.getResult.and.returnValue({ my: 'result' });

      runQueue.calls.mostRecent().args[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith({ my: 'result' });

      runQueueArgs.onComplete();
      await promise;
    });

    it('runs a non-empty suite', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const suite = new StubSuite({ children: [spec1, spec2] });
      const topSuite = new StubSuite({ children: [suite] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(2);
      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(3);

      verifyAndFinishSpec(spec1, queueableFns[1], false);
      verifyAndFinishSpec(spec2, queueableFns[2], false);
      await expectAsync(promise).toBePending();
    });

    it('""runs"" an excluded suite', async function() {
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      // Empty list of runable IDs excludes everything
      const promise = subject.execute([]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn();
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(parent.result);

      verifyAndFinishSpec(spec, queueableFns[1], true);

      parent.getResult.and.returnValue(parent.result);
      runQueue.calls.argsFor(1)[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(parent.result);
      await expectAsync(promise).toBePending();
    });

    it('handles the failSpecWithNoExpectations option', async function() {
      failSpecWithNoExpectations = true;
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[1].fn('foo');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec, 'foo');

      await expectAsync(promise).toBePending();
    });

    it('runs beforeAlls and afterAlls for a suite with children', async function() {
      const spec = new StubSpec();
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [
          { fn: 'beforeAll1', timeout: 1 },
          { fn: 'beforeAll2', timeout: 2 }
        ],
        afterAllFns: [
          { fn: 'afterAll1', timeout: 3 },
          { fn: 'afterAll2', timeout: 4 }
        ]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns).toEqual([
        { fn: jasmine.any(Function) },
        { fn: 'beforeAll1', timeout: 1 },
        { fn: 'beforeAll2', timeout: 2 },
        { fn: jasmine.any(Function) },
        { fn: 'afterAll1', timeout: 3 },
        { fn: 'afterAll2', timeout: 4 }
      ]);

      await expectAsync(promise).toBePending();
    });

    it('does not run beforeAlls or afterAlls for a suite with no children', async function() {
      const target = new StubSuite({
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        1
      );

      await expectAsync(promise).toBePending();
    });

    it('does not run beforeAlls or afterAlls for a suite with only pending children', async function() {
      const spec = new StubSpec({ markedPending: true });
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        2
      );

      await expectAsync(promise).toBePending();
    });

    it('runs specs in the order specified', async function() {
      const specs = [new StubSpec(), new StubSpec()];
      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specs[1].id, specs[0].id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(specs[0], jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specs[1], 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specs[0], 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs specified specs before non-specified specs within a suite', async function() {
      const specified = new StubSpec();
      const nonSpecified = new StubSpec();
      const topSuite = new StubSuite({ children: [nonSpecified, specified] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specified.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(nonSpecified, jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specified, 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecified, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs suites and specs with a specified order', async function() {
      const specifiedSpec = new StubSpec();
      const nonSpecifiedSpec = new StubSpec();
      const specifiedSuite = new StubSuite({ children: [nonSpecifiedSpec] });
      const topSuite = new StubSuite({
        children: [specifiedSpec, specifiedSuite]
      });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specifiedSuite.id, specifiedSpec.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn();

      expect(specifiedSpec.execute).not.toHaveBeenCalled();
      const nodeQueueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      nodeQueueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecifiedSpec, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specifiedSpec, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs suites and specs in the order they were declared', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const parent = new StubSuite({ children: [spec2, spec3] });
      const topSuite = new StubSuite({ children: [spec1, parent] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn();
      const childFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(childFns.length).toBe(3);
      childFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      childFns[2].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs a suite multiple times if the order specified leaves and re-enters it', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const reentered = new StubSuite({ children: [spec1, spec2, spec3] });
      const topSuite = new StubSuite({ children: [reentered, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;

      queueableFns[0].fn();
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(3);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs a parent of a suite with multiple segments correctly', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const parent = new StubSuite({ children: [spec1, spec2, spec3] });
      const grandparent = new StubSuite({ children: [parent] });
      const topSuite = new StubSuite({ children: [grandparent, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(5);

      queueableFns[0].fn();
      expect(runQueue.calls.count()).toBe(2);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(3);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(5);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(6);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(7);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs large segments of nodes in the order they were declared', async function() {
      const specs = [];

      for (let i = 0; i < 11; i++) {
        specs.push(new StubSpec());
      }

      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(11);

      for (let i = 0; i < 11; i++) {
        queueableFns[i].fn('done');
        expect(
          jasmineUnderTest.TreeRunner.prototype._executeSpec
        ).toHaveBeenCalledWith(specs[i], 'done');
      }

      await expectAsync(promise).toBePending();
    });
  })",snuts
/spec/core/RunnerSpec.js,NonFunctionalStatement,"{'startLine':78,'endLine':78}","describe('Integration with TreeProcessor and TreeRunner', function() {
    let suiteNumber,
      specNumber,
      runQueue,
      globalErrors,
      reportDispatcher,
      failSpecWithNoExpectations,
      detectLateRejectionHandling;

    beforeEach(function() {
      suiteNumber = 0;
      specNumber = 0;
      runQueue = jasmine.createSpy('runQueue');
      globalErrors = 'the global errors instance';
      reportDispatcher = jasmine.createSpyObj(
        'reportDispatcher',
        jasmineUnderTest.reporterEvents
      );

      for (const k of jasmineUnderTest.reporterEvents) {
        reportDispatcher[k].and.returnValue(Promise.resolve());
      }

      // Reasonable defaults, may be overridden in some cases
      failSpecWithNoExpectations = false;
      detectLateRejectionHandling = false;

      spyOn(jasmineUnderTest.TreeRunner.prototype, '_executeSpec');
    });

    function StubSuite(attrs) {
      attrs = attrs || {};
      this.id = 'suite' + suiteNumber++;
      this.children = attrs.children || [];
      this.canBeReentered = function() {
        return !attrs.noReenter;
      };
      this.markedPending = attrs.markedPending || false;
      this.sharedUserContext = function() {
        return attrs.userContext || {};
      };
      this.result = {
        id: this.id,
        failedExpectations: []
      };
      this.getResult = jasmine.createSpy('getResult');
      this.beforeAllFns = attrs.beforeAllFns || [];
      this.afterAllFns = attrs.afterAllFns || [];
      this.cleanupBeforeAfter = function() {};
      this.startTimer = function() {};
      this.endTimer = function() {};
    }

    function StubSpec(attrs) {
      attrs = attrs || {};
      this.id = 'spec' + specNumber++;
      this.markedPending = attrs.markedPending || false;
      this.execute = jasmine.createSpy(this.id + '#execute');
      this.beforeAndAfterFns = () => ({ befores: [], afters: [] });
      this.userContext = () => ({});
      this.getFullName = () => '';
      this.queueableFn = () => {};
    }

    function makeRunner(topSuite) {
      const defaultOptions = {
        getConfig: () => ({
          specFilter: () => true,
          failSpecWithNoExpectations,
          detectLateRejectionHandling
        }),
        focusedRunables: () => [],
        totalSpecsDefined: () => 1,
        TreeProcessor: jasmineUnderTest.TreeProcessor,
        runableResources: {
          initForRunable: () => {},
          clearForRunable: () => {}
        },
        reportDispatcher,
        globalErrors,
        runQueue
      };
      return new jasmineUnderTest.Runner({
        ...defaultOptions,
        topSuite
      });
    }

    function arrayNotContaining(item) {
      return {
        asymmetricMatch(other, matchersUtil) {
          if (!jasmine.isArray_(other)) {
            return false;
          }

          for (const x of other) {
            if (matchersUtil.equals(x, item)) {
              return false;
            }
          }

          return true;
        }
      };
    }

    // Precondition: jasmineUnderTest.TreeRunner.prototype._executeSpec is a spy
    function verifyAndFinishSpec(spec, queueableFn, shouldBeExcluded) {
      const ex = jasmineUnderTest.TreeRunner.prototype._executeSpec;
      ex.withArgs(spec, 'onComplete').and.callThrough();

      queueableFn.fn('onComplete');
      expect(ex).toHaveBeenCalledWith(spec, 'onComplete');

      expect(runQueue).toHaveBeenCalledWith(
        jasmine.objectContaining({
          isLeaf: true,
          SkipPolicy: jasmineUnderTest.CompleteOnFirstErrorSkipPolicy,
          queueableFns: shouldBeExcluded
            ? arrayNotContaining(spec.queueableFn)
            : jasmine.arrayContaining([spec.queueableFn])
        })
      );
    }

    it('runs a single spec', async function() {
      const spec = new StubSpec();
      const topSuite = new StubSuite({
        children: [spec],
        userContext: { root: 'context' }
      });
      detectLateRejectionHandling = true;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { root: 'context' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      verifyAndFinishSpec(spec, runQueueArgs.queueableFns[0], false);
      runQueueArgs.onComplete();
      await promise;
    });

    it('runs an empty suite', async function() {
      const suite = new StubSuite({ userContext: { for: 'suite' } });
      const topSuite = new StubSuite({
        children: [suite],
        userContext: { for: 'topSuite' }
      });
      suite.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { for: 'topSuite' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      const nodeDone = jasmine.createSpy('nodeDone');
      runQueueArgs.queueableFns[0].fn(nodeDone);
      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onMultipleDone: null,
        queueableFns: [{ fn: jasmine.any(Function) }],
        userContext: { for: 'suite' },
        onException: jasmine.any(Function),
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      runQueue.calls.mostRecent().args[0].queueableFns[0].fn('foo');
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(suite.result);

      suite.getResult.and.returnValue({ my: 'result' });

      runQueue.calls.mostRecent().args[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith({ my: 'result' });

      runQueueArgs.onComplete();
      await promise;
    });

    it('runs a non-empty suite', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const suite = new StubSuite({ children: [spec1, spec2] });
      const topSuite = new StubSuite({ children: [suite] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(2);
      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(3);

      verifyAndFinishSpec(spec1, queueableFns[1], false);
      verifyAndFinishSpec(spec2, queueableFns[2], false);
      await expectAsync(promise).toBePending();
    });

    it('""runs"" an excluded suite', async function() {
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      // Empty list of runable IDs excludes everything
      const promise = subject.execute([]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn();
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(parent.result);

      verifyAndFinishSpec(spec, queueableFns[1], true);

      parent.getResult.and.returnValue(parent.result);
      runQueue.calls.argsFor(1)[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(parent.result);
      await expectAsync(promise).toBePending();
    });

    it('handles the failSpecWithNoExpectations option', async function() {
      failSpecWithNoExpectations = true;
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[1].fn('foo');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec, 'foo');

      await expectAsync(promise).toBePending();
    });

    it('runs beforeAlls and afterAlls for a suite with children', async function() {
      const spec = new StubSpec();
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [
          { fn: 'beforeAll1', timeout: 1 },
          { fn: 'beforeAll2', timeout: 2 }
        ],
        afterAllFns: [
          { fn: 'afterAll1', timeout: 3 },
          { fn: 'afterAll2', timeout: 4 }
        ]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns).toEqual([
        { fn: jasmine.any(Function) },
        { fn: 'beforeAll1', timeout: 1 },
        { fn: 'beforeAll2', timeout: 2 },
        { fn: jasmine.any(Function) },
        { fn: 'afterAll1', timeout: 3 },
        { fn: 'afterAll2', timeout: 4 }
      ]);

      await expectAsync(promise).toBePending();
    });

    it('does not run beforeAlls or afterAlls for a suite with no children', async function() {
      const target = new StubSuite({
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        1
      );

      await expectAsync(promise).toBePending();
    });

    it('does not run beforeAlls or afterAlls for a suite with only pending children', async function() {
      const spec = new StubSpec({ markedPending: true });
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        2
      );

      await expectAsync(promise).toBePending();
    });

    it('runs specs in the order specified', async function() {
      const specs = [new StubSpec(), new StubSpec()];
      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specs[1].id, specs[0].id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(specs[0], jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specs[1], 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specs[0], 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs specified specs before non-specified specs within a suite', async function() {
      const specified = new StubSpec();
      const nonSpecified = new StubSpec();
      const topSuite = new StubSuite({ children: [nonSpecified, specified] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specified.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(nonSpecified, jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specified, 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecified, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs suites and specs with a specified order', async function() {
      const specifiedSpec = new StubSpec();
      const nonSpecifiedSpec = new StubSpec();
      const specifiedSuite = new StubSuite({ children: [nonSpecifiedSpec] });
      const topSuite = new StubSuite({
        children: [specifiedSpec, specifiedSuite]
      });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specifiedSuite.id, specifiedSpec.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn();

      expect(specifiedSpec.execute).not.toHaveBeenCalled();
      const nodeQueueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      nodeQueueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecifiedSpec, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specifiedSpec, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs suites and specs in the order they were declared', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const parent = new StubSuite({ children: [spec2, spec3] });
      const topSuite = new StubSuite({ children: [spec1, parent] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn();
      const childFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(childFns.length).toBe(3);
      childFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      childFns[2].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs a suite multiple times if the order specified leaves and re-enters it', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const reentered = new StubSuite({ children: [spec1, spec2, spec3] });
      const topSuite = new StubSuite({ children: [reentered, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;

      queueableFns[0].fn();
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(3);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs a parent of a suite with multiple segments correctly', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const parent = new StubSuite({ children: [spec1, spec2, spec3] });
      const grandparent = new StubSuite({ children: [parent] });
      const topSuite = new StubSuite({ children: [grandparent, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(5);

      queueableFns[0].fn();
      expect(runQueue.calls.count()).toBe(2);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(3);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(5);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(6);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(7);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    });

    it('runs large segments of nodes in the order they were declared', async function() {
      const specs = [];

      for (let i = 0; i < 11; i++) {
        specs.push(new StubSpec());
      }

      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(11);

      for (let i = 0; i < 11; i++) {
        queueableFns[i].fn('done');
        expect(
          jasmineUnderTest.TreeRunner.prototype._executeSpec
        ).toHaveBeenCalledWith(specs[i], 'done');
      }

      await expectAsync(promise).toBePending();
    });
  })",snuts
/spec/core/RunnerSpec.js,NonFunctionalStatement,"{'startLine':211,'endLine':211}","it('runs a non-empty suite', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const suite = new StubSuite({ children: [spec1, spec2] });
      const topSuite = new StubSuite({ children: [suite] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(2);
      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(3);

      verifyAndFinishSpec(spec1, queueableFns[1], false);
      verifyAndFinishSpec(spec2, queueableFns[2], false);
      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,NonFunctionalStatement,"{'startLine':234,'endLine':234}","it('""runs"" an excluded suite', async function() {
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      // Empty list of runable IDs excludes everything
      const promise = subject.execute([]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn();
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(parent.result);

      verifyAndFinishSpec(spec, queueableFns[1], true);

      parent.getResult.and.returnValue(parent.result);
      runQueue.calls.argsFor(1)[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(parent.result);
      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,NonFunctionalStatement,"{'startLine':262,'endLine':262}","it('handles the failSpecWithNoExpectations option', async function() {
      failSpecWithNoExpectations = true;
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[1].fn('foo');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec, 'foo');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,NonFunctionalStatement,"{'startLine':295,'endLine':295}","it('runs beforeAlls and afterAlls for a suite with children', async function() {
      const spec = new StubSpec();
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [
          { fn: 'beforeAll1', timeout: 1 },
          { fn: 'beforeAll2', timeout: 2 }
        ],
        afterAllFns: [
          { fn: 'afterAll1', timeout: 3 },
          { fn: 'afterAll2', timeout: 4 }
        ]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns).toEqual([
        { fn: jasmine.any(Function) },
        { fn: 'beforeAll1', timeout: 1 },
        { fn: 'beforeAll2', timeout: 2 },
        { fn: jasmine.any(Function) },
        { fn: 'afterAll1', timeout: 3 },
        { fn: 'afterAll2', timeout: 4 }
      ]);

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,NonFunctionalStatement,"{'startLine':321,'endLine':321}","it('does not run beforeAlls or afterAlls for a suite with no children', async function() {
      const target = new StubSuite({
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        1
      );

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,NonFunctionalStatement,"{'startLine':344,'endLine':344}","it('does not run beforeAlls or afterAlls for a suite with only pending children', async function() {
      const spec = new StubSpec({ markedPending: true });
      const target = new StubSuite({
        children: [spec],
        beforeAllFns: [{ fn: 'before' }],
        afterAllFns: [{ fn: 'after' }]
      });
      const topSuite = new StubSuite({ children: [target] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toEqual(
        2
      );

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':215,'endLine':215}","it('runs a non-empty suite', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const suite = new StubSuite({ children: [spec1, spec2] });
      const topSuite = new StubSuite({ children: [suite] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(2);
      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(3);

      verifyAndFinishSpec(spec1, queueableFns[1], false);
      verifyAndFinishSpec(spec2, queueableFns[2], false);
      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':237,'endLine':237}","it('""runs"" an excluded suite', async function() {
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      // Empty list of runable IDs excludes everything
      const promise = subject.execute([]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn();
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(parent.result);

      verifyAndFinishSpec(spec, queueableFns[1], true);

      parent.getResult.and.returnValue(parent.result);
      runQueue.calls.argsFor(1)[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(parent.result);
      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':265,'endLine':265}","it('handles the failSpecWithNoExpectations option', async function() {
      failSpecWithNoExpectations = true;
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[1].fn('foo');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec, 'foo');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':450,'endLine':450}","it('runs suites and specs in the order they were declared', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const parent = new StubSuite({ children: [spec2, spec3] });
      const topSuite = new StubSuite({ children: [spec1, parent] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn();
      const childFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(childFns.length).toBe(3);
      childFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      childFns[2].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':459,'endLine':459}","it('runs suites and specs in the order they were declared', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const parent = new StubSuite({ children: [spec2, spec3] });
      const topSuite = new StubSuite({ children: [spec1, parent] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn();
      const childFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(childFns.length).toBe(3);
      childFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      childFns[2].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':496,'endLine':496}","it('runs a suite multiple times if the order specified leaves and re-enters it', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const reentered = new StubSuite({ children: [spec1, spec2, spec3] });
      const topSuite = new StubSuite({ children: [reentered, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;

      queueableFns[0].fn();
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(3);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':509,'endLine':509}","it('runs a suite multiple times if the order specified leaves and re-enters it', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const reentered = new StubSuite({ children: [spec1, spec2, spec3] });
      const topSuite = new StubSuite({ children: [reentered, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;

      queueableFns[0].fn();
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(3);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':522,'endLine':522}","it('runs a suite multiple times if the order specified leaves and re-enters it', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const reentered = new StubSuite({ children: [spec1, spec2, spec3] });
      const topSuite = new StubSuite({ children: [reentered, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;

      queueableFns[0].fn();
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(3);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':553,'endLine':553}","it('runs a parent of a suite with multiple segments correctly', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const parent = new StubSuite({ children: [spec1, spec2, spec3] });
      const grandparent = new StubSuite({ children: [parent] });
      const topSuite = new StubSuite({ children: [grandparent, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(5);

      queueableFns[0].fn();
      expect(runQueue.calls.count()).toBe(2);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(3);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(5);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(6);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(7);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':557,'endLine':557}","it('runs a parent of a suite with multiple segments correctly', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const parent = new StubSuite({ children: [spec1, spec2, spec3] });
      const grandparent = new StubSuite({ children: [parent] });
      const topSuite = new StubSuite({ children: [grandparent, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(5);

      queueableFns[0].fn();
      expect(runQueue.calls.count()).toBe(2);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(3);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(5);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(6);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(7);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':574,'endLine':574}","it('runs a parent of a suite with multiple segments correctly', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const parent = new StubSuite({ children: [spec1, spec2, spec3] });
      const grandparent = new StubSuite({ children: [parent] });
      const topSuite = new StubSuite({ children: [grandparent, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(5);

      queueableFns[0].fn();
      expect(runQueue.calls.count()).toBe(2);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(3);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(5);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(6);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(7);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':591,'endLine':591}","it('runs a parent of a suite with multiple segments correctly', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const parent = new StubSuite({ children: [spec1, spec2, spec3] });
      const grandparent = new StubSuite({ children: [parent] });
      const topSuite = new StubSuite({ children: [grandparent, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(5);

      queueableFns[0].fn();
      expect(runQueue.calls.count()).toBe(2);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(3);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(5);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(6);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(7);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,SubOptimalAssert,"{'startLine':618,'endLine':618}","it('runs large segments of nodes in the order they were declared', async function() {
      const specs = [];

      for (let i = 0; i < 11; i++) {
        specs.push(new StubSpec());
      }

      const topSuite = new StubSuite({ children: specs });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(11);

      for (let i = 0; i < 11; i++) {
        queueableFns[i].fn('done');
        expect(
          jasmineUnderTest.TreeRunner.prototype._executeSpec
        ).toHaveBeenCalledWith(specs[i], 'done');
      }

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,VerboseStatement,"{'startLine':154,'endLine':198}","it('runs an empty suite', async function() {
      const suite = new StubSuite({ userContext: { for: 'suite' } });
      const topSuite = new StubSuite({
        children: [suite],
        userContext: { for: 'topSuite' }
      });
      suite.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();

      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onException: jasmine.any(Function),
        userContext: { for: 'topSuite' },
        queueableFns: [{ fn: jasmine.any(Function) }],
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      const runQueueArgs = runQueue.calls.mostRecent().args[0];
      const nodeDone = jasmine.createSpy('nodeDone');
      runQueueArgs.queueableFns[0].fn(nodeDone);
      expect(runQueue).toHaveBeenCalledWith({
        onComplete: jasmine.any(Function),
        onMultipleDone: null,
        queueableFns: [{ fn: jasmine.any(Function) }],
        userContext: { for: 'suite' },
        onException: jasmine.any(Function),
        onMultipleDone: null,
        SkipPolicy: jasmineUnderTest.SkipAfterBeforeAllErrorPolicy
      });

      runQueue.calls.mostRecent().args[0].queueableFns[0].fn('foo');
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(suite.result);

      suite.getResult.and.returnValue({ my: 'result' });

      runQueue.calls.mostRecent().args[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith({ my: 'result' });

      runQueueArgs.onComplete();
      await promise;
    })",snuts
/spec/core/RunnerSpec.js,VerboseStatement,"{'startLine':200,'endLine':220}","it('runs a non-empty suite', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const suite = new StubSuite({ children: [spec1, spec2] });
      const topSuite = new StubSuite({ children: [suite] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      expect(runQueue).toHaveBeenCalledTimes(2);
      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(3);

      verifyAndFinishSpec(spec1, queueableFns[1], false);
      verifyAndFinishSpec(spec2, queueableFns[2], false);
      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,VerboseStatement,"{'startLine':222,'endLine':248}","it('""runs"" an excluded suite', async function() {
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      // Empty list of runable IDs excludes everything
      const promise = subject.execute([]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn();
      expect(reportDispatcher.suiteStarted).toHaveBeenCalledWith(parent.result);

      verifyAndFinishSpec(spec, queueableFns[1], true);

      parent.getResult.and.returnValue(parent.result);
      runQueue.calls.argsFor(1)[0].onComplete();
      expect(reportDispatcher.suiteDone).toHaveBeenCalledWith(parent.result);
      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,VerboseStatement,"{'startLine':250,'endLine':273}","it('handles the failSpecWithNoExpectations option', async function() {
      failSpecWithNoExpectations = true;
      const spec = new StubSpec();
      const parent = new StubSuite({ children: [spec] });
      const topSuite = new StubSuite({ children: [parent] });
      parent.parentSuite = topSuite;
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      let queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn(function() {});

      queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[1].fn('foo');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec, 'foo');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,VerboseStatement,"{'startLine':380,'endLine':406}","it('runs specified specs before non-specified specs within a suite', async function() {
      const specified = new StubSpec();
      const nonSpecified = new StubSpec();
      const topSuite = new StubSuite({ children: [nonSpecified, specified] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specified.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).not.toHaveBeenCalledWith(nonSpecified, jasmine.anything());
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specified, 'done');

      queueableFns[1].fn('done');

      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecified, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,VerboseStatement,"{'startLine':408,'endLine':436}","it('runs suites and specs with a specified order', async function() {
      const specifiedSpec = new StubSpec();
      const nonSpecifiedSpec = new StubSpec();
      const specifiedSuite = new StubSuite({ children: [nonSpecifiedSpec] });
      const topSuite = new StubSuite({
        children: [specifiedSpec, specifiedSuite]
      });
      const subject = makeRunner(topSuite);

      const promise = subject.execute([specifiedSuite.id, specifiedSpec.id]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      queueableFns[0].fn();

      expect(specifiedSpec.execute).not.toHaveBeenCalled();
      const nodeQueueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      nodeQueueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(nonSpecifiedSpec, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(specifiedSpec, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,VerboseStatement,"{'startLine':438,'endLine':471}","it('runs suites and specs in the order they were declared', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const parent = new StubSuite({ children: [spec2, spec3] });
      const topSuite = new StubSuite({ children: [spec1, parent] });
      const subject = makeRunner(topSuite);

      const promise = subject.execute();
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(2);

      queueableFns[0].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn();
      const childFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(childFns.length).toBe(3);
      childFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      childFns[2].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,VerboseStatement,"{'startLine':473,'endLine':529}","it('runs a suite multiple times if the order specified leaves and re-enters it', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const reentered = new StubSuite({ children: [spec1, spec2, spec3] });
      const topSuite = new StubSuite({ children: [reentered, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;

      queueableFns[0].fn();
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(3);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);
      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunnerSpec.js,VerboseStatement,"{'startLine':531,'endLine':602}","it('runs a parent of a suite with multiple segments correctly', async function() {
      const spec1 = new StubSpec();
      const spec2 = new StubSpec();
      const spec3 = new StubSpec();
      const spec4 = new StubSpec();
      const spec5 = new StubSpec();
      const parent = new StubSuite({ children: [spec1, spec2, spec3] });
      const grandparent = new StubSuite({ children: [parent] });
      const topSuite = new StubSuite({ children: [grandparent, spec4, spec5] });
      const subject = makeRunner(topSuite);

      spyOn(jasmineUnderTest.getEnv(), 'deprecated');
      const promise = subject.execute([
        spec1.id,
        spec4.id,
        spec2.id,
        spec5.id,
        spec3.id
      ]);
      await Promise.resolve();
      expect(runQueue).toHaveBeenCalledTimes(1);
      const queueableFns = runQueue.calls.mostRecent().args[0].queueableFns;
      expect(queueableFns.length).toBe(5);

      queueableFns[0].fn();
      expect(runQueue.calls.count()).toBe(2);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(3);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec1, 'done');

      queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec4, 'done');

      queueableFns[2].fn();
      expect(runQueue.calls.count()).toBe(4);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(5);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec2, 'done');

      queueableFns[3].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec5, 'done');

      queueableFns[4].fn();
      expect(runQueue.calls.count()).toBe(6);
      expect(runQueue.calls.mostRecent().args[0].queueableFns.length).toBe(2);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn();
      expect(runQueue.calls.count()).toBe(7);

      runQueue.calls.mostRecent().args[0].queueableFns[1].fn('done');
      expect(
        jasmineUnderTest.TreeRunner.prototype._executeSpec
      ).toHaveBeenCalledWith(spec3, 'done');

      await expectAsync(promise).toBePending();
    })",snuts
/spec/core/RunableResourcesSpec.js,AnonymousTest,"{'startLine':120,'endLine':132}","it('is per-runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      runableResources.setDefaultSpyStrategy(() => {});
      currentRunableId = 2;
      runableResources.initForRunable(2);

      expect(runableResources.defaultSpyStrategy()).toBeUndefined();
    })",snuts
/spec/core/RunableResourcesSpec.js,AnonymousTest,"{'startLine':365,'endLine':378}","it('clears spies', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => 1
      });
      runableResources.initForRunable(1);
      function foo() {}
      const spyObj = { foo };
      runableResources.spyRegistry.spyOn(spyObj, 'foo');
      expect(spyObj.foo).not.toBe(foo);

      runableResources.clearForRunable(1);
      expect(spyObj.foo).toBe(foo);
    })",snuts
/spec/core/RunableResourcesSpec.js,AnonymousTest,"{'startLine':423,'endLine':433}","it('is mutable', function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      function newItem() {}
      runableResources[methodName]().push(newItem);
      expect(runableResources[methodName]()).toEqual([newItem]);
    })",snuts
/spec/core/RunableResourcesSpec.js,AnonymousTest,"{'startLine':435,'endLine':446}","it('is per-runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      runableResources[methodName]().push(() => {});
      runableResources.initForRunable(2);
      currentRunableId = 2;
      expect(runableResources[methodName]()).toEqual([]);
    })",snuts
/spec/core/RunableResourcesSpec.js,AnonymousTest,"{'startLine':492,'endLine':502}","it('is mutable', function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      function newItem() {}
      runableResources[methodName]().foo = newItem;
      expect(runableResources[methodName]()).toEqual({ foo: newItem });
    })",snuts
/spec/core/RunableResourcesSpec.js,AnonymousTest,"{'startLine':504,'endLine':515}","it('is per-runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      runableResources[methodName]().foo = function() {};
      runableResources.initForRunable(2);
      currentRunableId = 2;
      expect(runableResources[methodName]()).toEqual({});
    })",snuts
/spec/core/RunableResourcesSpec.js,IdenticalTestDescription,"{'startLine':71,'endLine':92}","it(""adds all properties to the current runable's matchers"", function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      function toBeFoo() {}
      function toBeBar() {}
      function toBeBaz() {}

      runableResources.addCustomAsyncMatchers({ toBeFoo });
      expect(runableResources.customAsyncMatchers()).toEqual({ toBeFoo });

      runableResources.addCustomAsyncMatchers({ toBeBar, toBeBaz });
      expect(runableResources.customAsyncMatchers()).toEqual({
        toBeFoo,
        toBeBar,
        toBeBaz
      });
    })",snuts
/spec/core/RunableResourcesSpec.js,IdenticalTestDescription,"{'startLine':435,'endLine':446}","it('is per-runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      runableResources[methodName]().push(() => {});
      runableResources.initForRunable(2);
      currentRunableId = 2;
      expect(runableResources[methodName]()).toEqual([]);
    })",snuts
/spec/core/RunableResourcesSpec.js,IdenticalTestDescription,"{'startLine':448,'endLine':456}","it('throws a user-facing error when there is no current runable', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => null
      });
      expect(function() {
        runableResources[methodName]();
      }).toThrowError(errorMsg);
    })",snuts
/spec/core/RunableResourcesSpec.js,IdenticalTestDescription,"{'startLine':481,'endLine':490}","it('is initially empty', function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      expect(runableResources[methodName]()).toEqual({});
    })",snuts
/spec/core/RunableResourcesSpec.js,IdenticalTestDescription,"{'startLine':492,'endLine':502}","it('is mutable', function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      function newItem() {}
      runableResources[methodName]().foo = newItem;
      expect(runableResources[methodName]()).toEqual({ foo: newItem });
    })",snuts
/spec/core/RunableResourcesSpec.js,IdenticalTestDescription,"{'startLine':504,'endLine':515}","it('is per-runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      runableResources[methodName]().foo = function() {};
      runableResources.initForRunable(2);
      currentRunableId = 2;
      expect(runableResources[methodName]()).toEqual({});
    })",snuts
/spec/core/RunableResourcesSpec.js,IdenticalTestDescription,"{'startLine':517,'endLine':525}","it('throws a user-facing error when there is no current runable', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => null
      });
      expect(function() {
        runableResources[methodName]();
      }).toThrowError(errorMsg);
    })",snuts
/spec/core/RunableResourcesSpec.js,IdenticalTestDescription,"{'startLine':527,'endLine':549}","it('inherits from the parent runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      function parentItem() {}
      runableResources[methodName]().parentName = parentItem;
      runableResources.initForRunable(2, 1);
      currentRunableId = 2;
      function childItem() {}
      runableResources[methodName]().childName = childItem;
      expect(runableResources[methodName]()).toEqual({
        parentName: parentItem,
        childName: childItem
      });

      currentRunableId = 1;
      expect(runableResources[methodName]()).toEqual({
        parentName: parentItem
      });
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':47,'endLine':47}","it(""adds all properties to the current runable's matchers"", function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      function toBeFoo() {}
      function toBeBar() {}
      function toBeBaz() {}

      runableResources.addCustomMatchers({ toBeFoo });
      expect(runableResources.customMatchers()).toEqual({ toBeFoo });

      runableResources.addCustomMatchers({ toBeBar, toBeBaz });
      expect(runableResources.customMatchers()).toEqual({
        toBeFoo,
        toBeBar,
        toBeBaz
      });
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':48,'endLine':48}","it(""adds all properties to the current runable's matchers"", function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      function toBeFoo() {}
      function toBeBar() {}
      function toBeBaz() {}

      runableResources.addCustomMatchers({ toBeFoo });
      expect(runableResources.customMatchers()).toEqual({ toBeFoo });

      runableResources.addCustomMatchers({ toBeBar, toBeBaz });
      expect(runableResources.customMatchers()).toEqual({
        toBeFoo,
        toBeBar,
        toBeBaz
      });
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':49,'endLine':49}","it(""adds all properties to the current runable's matchers"", function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      function toBeFoo() {}
      function toBeBar() {}
      function toBeBaz() {}

      runableResources.addCustomMatchers({ toBeFoo });
      expect(runableResources.customMatchers()).toEqual({ toBeFoo });

      runableResources.addCustomMatchers({ toBeBar, toBeBaz });
      expect(runableResources.customMatchers()).toEqual({
        toBeFoo,
        toBeBar,
        toBeBaz
      });
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':79,'endLine':79}","it(""adds all properties to the current runable's matchers"", function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      function toBeFoo() {}
      function toBeBar() {}
      function toBeBaz() {}

      runableResources.addCustomAsyncMatchers({ toBeFoo });
      expect(runableResources.customAsyncMatchers()).toEqual({ toBeFoo });

      runableResources.addCustomAsyncMatchers({ toBeBar, toBeBaz });
      expect(runableResources.customAsyncMatchers()).toEqual({
        toBeFoo,
        toBeBar,
        toBeBaz
      });
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':80,'endLine':80}","it(""adds all properties to the current runable's matchers"", function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      function toBeFoo() {}
      function toBeBar() {}
      function toBeBaz() {}

      runableResources.addCustomAsyncMatchers({ toBeFoo });
      expect(runableResources.customAsyncMatchers()).toEqual({ toBeFoo });

      runableResources.addCustomAsyncMatchers({ toBeBar, toBeBaz });
      expect(runableResources.customAsyncMatchers()).toEqual({
        toBeFoo,
        toBeBar,
        toBeBaz
      });
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':81,'endLine':81}","it(""adds all properties to the current runable's matchers"", function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      function toBeFoo() {}
      function toBeBar() {}
      function toBeBaz() {}

      runableResources.addCustomAsyncMatchers({ toBeFoo });
      expect(runableResources.customAsyncMatchers()).toEqual({ toBeFoo });

      runableResources.addCustomAsyncMatchers({ toBeBar, toBeBaz });
      expect(runableResources.customAsyncMatchers()).toEqual({
        toBeFoo,
        toBeBar,
        toBeBaz
      });
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':114,'endLine':114}","it('returns the value previously set by #setDefaultSpyStrategy', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      const fn = () => {};
      runableResources.setDefaultSpyStrategy(fn);

      expect(runableResources.defaultSpyStrategy()).toBe(fn);
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':127,'endLine':127}","it('is per-runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      runableResources.setDefaultSpyStrategy(() => {});
      currentRunableId = 2;
      runableResources.initForRunable(2);

      expect(runableResources.defaultSpyStrategy()).toBeUndefined();
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':149,'endLine':149}","it(""inherits the parent runable's value"", function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      const fn = () => {};
      runableResources.setDefaultSpyStrategy(fn);
      currentRunableId = 2;
      runableResources.initForRunable(2, 1);

      expect(runableResources.defaultSpyStrategy()).toBe(fn);
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':179,'endLine':179}","it('returns a pretty printer configured with the current customObjectFormatters', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => 1
      });
      runableResources.initForRunable(1);
      function cof() {}
      runableResources.customObjectFormatters().push(cof);
      spyOn(jasmineUnderTest, 'makePrettyPrinter').and.callThrough();
      const pp = runableResources.makePrettyPrinter();

      expect(jasmineUnderTest.makePrettyPrinter).toHaveBeenCalledOnceWith([
        cof
      ]);
      expect(pp).toBe(
        jasmineUnderTest.makePrettyPrinter.calls.first().returnValue
      );
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':201,'endLine':201}","it('returns a MatchersUtil configured with the current resources', function() {
        const runableResources = new jasmineUnderTest.RunableResources({
          globalErrors: stubGlobalErrors(),
          getCurrentRunableId: () => 1
        });
        runableResources.initForRunable(1);
        function cof() {}
        runableResources.customObjectFormatters().push(cof);
        function ceq() {}
        runableResources.customEqualityTesters().push(ceq);
        const expectedPP = {};
        const expectedMatchersUtil = {};
        spyOn(jasmineUnderTest, 'makePrettyPrinter').and.returnValue(
          expectedPP
        );
        spyOn(jasmineUnderTest, 'MatchersUtil').and.returnValue(
          expectedMatchersUtil
        );

        const matchersUtil = runableResources.makeMatchersUtil();

        expect(matchersUtil).toBe(expectedMatchersUtil);
        expect(jasmineUnderTest.makePrettyPrinter).toHaveBeenCalledOnceWith([
          cof
        ]);
        // We need === equality on the pp passed to MatchersUtil
        expect(jasmineUnderTest.MatchersUtil).toHaveBeenCalledOnceWith(
          jasmine.objectContaining({
            customTesters: [ceq]
          })
        );
        expect(jasmineUnderTest.MatchersUtil.calls.argsFor(0)[0].pp).toBe(
          expectedPP
        );
      })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':203,'endLine':203}","it('returns a MatchersUtil configured with the current resources', function() {
        const runableResources = new jasmineUnderTest.RunableResources({
          globalErrors: stubGlobalErrors(),
          getCurrentRunableId: () => 1
        });
        runableResources.initForRunable(1);
        function cof() {}
        runableResources.customObjectFormatters().push(cof);
        function ceq() {}
        runableResources.customEqualityTesters().push(ceq);
        const expectedPP = {};
        const expectedMatchersUtil = {};
        spyOn(jasmineUnderTest, 'makePrettyPrinter').and.returnValue(
          expectedPP
        );
        spyOn(jasmineUnderTest, 'MatchersUtil').and.returnValue(
          expectedMatchersUtil
        );

        const matchersUtil = runableResources.makeMatchersUtil();

        expect(matchersUtil).toBe(expectedMatchersUtil);
        expect(jasmineUnderTest.makePrettyPrinter).toHaveBeenCalledOnceWith([
          cof
        ]);
        // We need === equality on the pp passed to MatchersUtil
        expect(jasmineUnderTest.MatchersUtil).toHaveBeenCalledOnceWith(
          jasmine.objectContaining({
            customTesters: [ceq]
          })
        );
        expect(jasmineUnderTest.MatchersUtil.calls.argsFor(0)[0].pp).toBe(
          expectedPP
        );
      })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':291,'endLine':291}","it(""is configured with the current runable's strategies and matchersUtil"", function() {
        const runableResources = new jasmineUnderTest.RunableResources({
          globalErrors: stubGlobalErrors(),
          getCurrentRunableId: () => 1
        });
        runableResources.initForRunable(1);
        function customStrategy() {}
        function defaultStrategy() {}
        runableResources.customSpyStrategies().foo = customStrategy;
        runableResources.setDefaultSpyStrategy(defaultStrategy);
        spyOn(jasmineUnderTest, 'Spy');
        const matchersUtil = {};
        spyOn(runableResources, 'makeMatchersUtil').and.returnValue(
          matchersUtil
        );

        runableResources.spyFactory.createSpy('foo');

        expect(jasmineUnderTest.Spy).toHaveBeenCalledWith(
          'foo',
          is(matchersUtil),
          jasmine.objectContaining({
            customStrategies: { foo: customStrategy },
            defaultStrategyFn: defaultStrategy
          })
        );
      })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':292,'endLine':292}","it(""is configured with the current runable's strategies and matchersUtil"", function() {
        const runableResources = new jasmineUnderTest.RunableResources({
          globalErrors: stubGlobalErrors(),
          getCurrentRunableId: () => 1
        });
        runableResources.initForRunable(1);
        function customStrategy() {}
        function defaultStrategy() {}
        runableResources.customSpyStrategies().foo = customStrategy;
        runableResources.setDefaultSpyStrategy(defaultStrategy);
        spyOn(jasmineUnderTest, 'Spy');
        const matchersUtil = {};
        spyOn(runableResources, 'makeMatchersUtil').and.returnValue(
          matchersUtil
        );

        runableResources.spyFactory.createSpy('foo');

        expect(jasmineUnderTest.Spy).toHaveBeenCalledWith(
          'foo',
          is(matchersUtil),
          jasmine.objectContaining({
            customStrategies: { foo: customStrategy },
            defaultStrategyFn: defaultStrategy
          })
        );
      })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':333,'endLine':333}","it(""writes to the current runable's spies"", function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => 1
      });
      runableResources.initForRunable(1);
      function foo() {}
      const spyObj = { foo };
      runableResources.spyRegistry.spyOn(spyObj, 'foo');

      expect(runableResources.spies()).toEqual([
        jasmine.objectContaining({
          restoreObjectToOriginalState: jasmine.any(Function)
        })
      ]);
      expect(jasmineUnderTest.isSpy(spyObj.foo)).toBeTrue();

      runableResources.spyRegistry.clearSpies();
      expect(spyObj.foo).toBe(foo);
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':371,'endLine':371}","it('clears spies', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => 1
      });
      runableResources.initForRunable(1);
      function foo() {}
      const spyObj = { foo };
      runableResources.spyRegistry.spyOn(spyObj, 'foo');
      expect(spyObj.foo).not.toBe(foo);

      runableResources.clearForRunable(1);
      expect(spyObj.foo).toBe(foo);
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':400,'endLine':400}","it('does not remove resources for other runables', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => 1
      });
      runableResources.initForRunable(1);
      function cof() {}
      runableResources.customObjectFormatters().push(cof);
      runableResources.clearForRunable(2);
      expect(runableResources.customObjectFormatters()).toEqual([cof]);
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':430,'endLine':430}","it('is mutable', function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      function newItem() {}
      runableResources[methodName]().push(newItem);
      expect(runableResources[methodName]()).toEqual([newItem]);
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':442,'endLine':442}","it('is per-runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      runableResources[methodName]().push(() => {});
      runableResources.initForRunable(2);
      currentRunableId = 2;
      expect(runableResources[methodName]()).toEqual([]);
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':466,'endLine':466}","it('inherits from the parent runable', function() {
        let currentRunableId = 1;
        const runableResources = new jasmineUnderTest.RunableResources({
          globalErrors: stubGlobalErrors(),
          getCurrentRunableId: () => currentRunableId
        });
        runableResources.initForRunable(1);
        function parentItem() {}
        runableResources[methodName]().push(parentItem);
        runableResources.initForRunable(2, 1);
        currentRunableId = 2;
        function childItem() {}
        runableResources[methodName]().push(childItem);
        expect(runableResources[methodName]()).toEqual([parentItem, childItem]);

        currentRunableId = 1;
        expect(runableResources[methodName]()).toEqual([parentItem]);
      })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':470,'endLine':470}","it('inherits from the parent runable', function() {
        let currentRunableId = 1;
        const runableResources = new jasmineUnderTest.RunableResources({
          globalErrors: stubGlobalErrors(),
          getCurrentRunableId: () => currentRunableId
        });
        runableResources.initForRunable(1);
        function parentItem() {}
        runableResources[methodName]().push(parentItem);
        runableResources.initForRunable(2, 1);
        currentRunableId = 2;
        function childItem() {}
        runableResources[methodName]().push(childItem);
        expect(runableResources[methodName]()).toEqual([parentItem, childItem]);

        currentRunableId = 1;
        expect(runableResources[methodName]()).toEqual([parentItem]);
      })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':499,'endLine':499}","it('is mutable', function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      function newItem() {}
      runableResources[methodName]().foo = newItem;
      expect(runableResources[methodName]()).toEqual({ foo: newItem });
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':511,'endLine':511}","it('is per-runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      runableResources[methodName]().foo = function() {};
      runableResources.initForRunable(2);
      currentRunableId = 2;
      expect(runableResources[methodName]()).toEqual({});
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':534,'endLine':534}","it('inherits from the parent runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      function parentItem() {}
      runableResources[methodName]().parentName = parentItem;
      runableResources.initForRunable(2, 1);
      currentRunableId = 2;
      function childItem() {}
      runableResources[methodName]().childName = childItem;
      expect(runableResources[methodName]()).toEqual({
        parentName: parentItem,
        childName: childItem
      });

      currentRunableId = 1;
      expect(runableResources[methodName]()).toEqual({
        parentName: parentItem
      });
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':538,'endLine':538}","it('inherits from the parent runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      function parentItem() {}
      runableResources[methodName]().parentName = parentItem;
      runableResources.initForRunable(2, 1);
      currentRunableId = 2;
      function childItem() {}
      runableResources[methodName]().childName = childItem;
      expect(runableResources[methodName]()).toEqual({
        parentName: parentItem,
        childName: childItem
      });

      currentRunableId = 1;
      expect(runableResources[methodName]()).toEqual({
        parentName: parentItem
      });
    })",snuts
/spec/core/RunableResourcesSpec.js,NonFunctionalStatement,"{'startLine':554,'endLine':554}","describe('RunableResources', function() {
  describe('#spies', function() {
    behavesLikeAPerRunableMutableArray(
      'spies',
      'Spies must be created in a before function or a spec',
      false
    );
  });

  describe('#customSpyStrategies', function() {
    behavesLikeAPerRunableMutableObject(
      'customSpyStrategies',
      'Custom spy strategies must be added in a before function or a spec'
    );
  });

  describe('#customEqualityTesters', function() {
    behavesLikeAPerRunableMutableArray(
      'customEqualityTesters',
      'Custom Equalities must be added in a before function or a spec'
    );
  });

  describe('#customObjectFormatters', function() {
    behavesLikeAPerRunableMutableArray(
      'customObjectFormatters',
      'Custom object formatters must be added in a before function or a spec'
    );
  });

  describe('#customMatchers', function() {
    behavesLikeAPerRunableMutableObject(
      'customMatchers',
      'Matchers must be added in a before function or a spec'
    );
  });

  describe('#addCustomMatchers', function() {
    it(""adds all properties to the current runable's matchers"", function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      function toBeFoo() {}
      function toBeBar() {}
      function toBeBaz() {}

      runableResources.addCustomMatchers({ toBeFoo });
      expect(runableResources.customMatchers()).toEqual({ toBeFoo });

      runableResources.addCustomMatchers({ toBeBar, toBeBaz });
      expect(runableResources.customMatchers()).toEqual({
        toBeFoo,
        toBeBar,
        toBeBaz
      });
    });
  });

  describe('#customAsyncMatchers', function() {
    behavesLikeAPerRunableMutableObject(
      'customAsyncMatchers',
      'Async Matchers must be added in a before function or a spec'
    );
  });

  describe('#addCustomAsyncMatchers', function() {
    it(""adds all properties to the current runable's matchers"", function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      function toBeFoo() {}
      function toBeBar() {}
      function toBeBaz() {}

      runableResources.addCustomAsyncMatchers({ toBeFoo });
      expect(runableResources.customAsyncMatchers()).toEqual({ toBeFoo });

      runableResources.addCustomAsyncMatchers({ toBeBar, toBeBaz });
      expect(runableResources.customAsyncMatchers()).toEqual({
        toBeFoo,
        toBeBar,
        toBeBaz
      });
    });
  });

  describe('#defaultSpyStrategy', function() {
    it('returns undefined for a newly initialized resource', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      expect(runableResources.defaultSpyStrategy()).toBeUndefined();
    });

    it('returns the value previously set by #setDefaultSpyStrategy', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      const fn = () => {};
      runableResources.setDefaultSpyStrategy(fn);

      expect(runableResources.defaultSpyStrategy()).toBe(fn);
    });

    it('is per-runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      runableResources.setDefaultSpyStrategy(() => {});
      currentRunableId = 2;
      runableResources.initForRunable(2);

      expect(runableResources.defaultSpyStrategy()).toBeUndefined();
    });

    it('does not require a current runable', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => null
      });
      expect(runableResources.defaultSpyStrategy()).toBeUndefined();
    });

    it(""inherits the parent runable's value"", function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      const fn = () => {};
      runableResources.setDefaultSpyStrategy(fn);
      currentRunableId = 2;
      runableResources.initForRunable(2, 1);

      expect(runableResources.defaultSpyStrategy()).toBe(fn);
    });
  });

  describe('#setDefaultSpyStrategy', function() {
    it('throws a user-facing error when there is no current runable', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => null
      });
      expect(function() {
        runableResources.setDefaultSpyStrategy();
      }).toThrowError(
        'Default spy strategy must be set in a before function or a spec'
      );
    });
  });

  describe('#makePrettyPrinter', function() {
    it('returns a pretty printer configured with the current customObjectFormatters', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => 1
      });
      runableResources.initForRunable(1);
      function cof() {}
      runableResources.customObjectFormatters().push(cof);
      spyOn(jasmineUnderTest, 'makePrettyPrinter').and.callThrough();
      const pp = runableResources.makePrettyPrinter();

      expect(jasmineUnderTest.makePrettyPrinter).toHaveBeenCalledOnceWith([
        cof
      ]);
      expect(pp).toBe(
        jasmineUnderTest.makePrettyPrinter.calls.first().returnValue
      );
    });
  });

  describe('#makeMatchersUtil', function() {
    describe('When there is a current runable', function() {
      it('returns a MatchersUtil configured with the current resources', function() {
        const runableResources = new jasmineUnderTest.RunableResources({
          globalErrors: stubGlobalErrors(),
          getCurrentRunableId: () => 1
        });
        runableResources.initForRunable(1);
        function cof() {}
        runableResources.customObjectFormatters().push(cof);
        function ceq() {}
        runableResources.customEqualityTesters().push(ceq);
        const expectedPP = {};
        const expectedMatchersUtil = {};
        spyOn(jasmineUnderTest, 'makePrettyPrinter').and.returnValue(
          expectedPP
        );
        spyOn(jasmineUnderTest, 'MatchersUtil').and.returnValue(
          expectedMatchersUtil
        );

        const matchersUtil = runableResources.makeMatchersUtil();

        expect(matchersUtil).toBe(expectedMatchersUtil);
        expect(jasmineUnderTest.makePrettyPrinter).toHaveBeenCalledOnceWith([
          cof
        ]);
        // We need === equality on the pp passed to MatchersUtil
        expect(jasmineUnderTest.MatchersUtil).toHaveBeenCalledOnceWith(
          jasmine.objectContaining({
            customTesters: [ceq]
          })
        );
        expect(jasmineUnderTest.MatchersUtil.calls.argsFor(0)[0].pp).toBe(
          expectedPP
        );
      });
    });

    describe('When there is no current runable', function() {
      it('returns a MatchersUtil configured with defaults', function() {
        const runableResources = new jasmineUnderTest.RunableResources({
          globalErrors: stubGlobalErrors(),
          getCurrentRunableId: () => null
        });
        const expectedMatchersUtil = {};
        spyOn(jasmineUnderTest, 'MatchersUtil').and.returnValue(
          expectedMatchersUtil
        );

        const matchersUtil = runableResources.makeMatchersUtil();

        expect(matchersUtil).toBe(expectedMatchersUtil);
        // We need === equality on the pp passed to MatchersUtil
        expect(jasmineUnderTest.MatchersUtil).toHaveBeenCalledTimes(1);
        expect(jasmineUnderTest.MatchersUtil.calls.argsFor(0)[0].pp).toBe(
          jasmineUnderTest.basicPrettyPrinter_
        );
        expect(
          jasmineUnderTest.MatchersUtil.calls.argsFor(0)[0].customTesters
        ).toBeUndefined();
      });
    });
  });

  describe('.spyFactory', function() {
    describe('When there is no current runable', function() {
      it('is configured with default strategies and matchersUtil', function() {
        const runableResources = new jasmineUnderTest.RunableResources({
          globalErrors: stubGlobalErrors(),
          getCurrentRunableId: () => null
        });
        spyOn(jasmineUnderTest, 'Spy');
        const matchersUtil = {};
        spyOn(runableResources, 'makeMatchersUtil').and.returnValue(
          matchersUtil
        );

        runableResources.spyFactory.createSpy('foo');

        expect(jasmineUnderTest.Spy).toHaveBeenCalledWith(
          'foo',
          is(matchersUtil),
          jasmine.objectContaining({
            customStrategies: {},
            defaultStrategyFn: undefined
          })
        );
      });
    });

    describe('When there is a current runable', function() {
      it(""is configured with the current runable's strategies and matchersUtil"", function() {
        const runableResources = new jasmineUnderTest.RunableResources({
          globalErrors: stubGlobalErrors(),
          getCurrentRunableId: () => 1
        });
        runableResources.initForRunable(1);
        function customStrategy() {}
        function defaultStrategy() {}
        runableResources.customSpyStrategies().foo = customStrategy;
        runableResources.setDefaultSpyStrategy(defaultStrategy);
        spyOn(jasmineUnderTest, 'Spy');
        const matchersUtil = {};
        spyOn(runableResources, 'makeMatchersUtil').and.returnValue(
          matchersUtil
        );

        runableResources.spyFactory.createSpy('foo');

        expect(jasmineUnderTest.Spy).toHaveBeenCalledWith(
          'foo',
          is(matchersUtil),
          jasmine.objectContaining({
            customStrategies: { foo: customStrategy },
            defaultStrategyFn: defaultStrategy
          })
        );
      });
    });

    function is(expected) {
      return {
        asymmetricMatch: function(actual) {
          return actual === expected;
        },
        jasmineToString: function(pp) {
          return '<same instance as ' + pp(expected) + '>';
        }
      };
    }
  });

  describe('.spyRegistry', function() {
    it(""writes to the current runable's spies"", function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => 1
      });
      runableResources.initForRunable(1);
      function foo() {}
      const spyObj = { foo };
      runableResources.spyRegistry.spyOn(spyObj, 'foo');

      expect(runableResources.spies()).toEqual([
        jasmine.objectContaining({
          restoreObjectToOriginalState: jasmine.any(Function)
        })
      ]);
      expect(jasmineUnderTest.isSpy(spyObj.foo)).toBeTrue();

      runableResources.spyRegistry.clearSpies();
      expect(spyObj.foo).toBe(foo);
    });
  });

  describe('#clearForRunable', function() {
    it('removes resources for the specified runable', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => 1
      });
      runableResources.initForRunable(1);
      expect(function() {
        runableResources.spies();
      }).not.toThrow();
      runableResources.clearForRunable(1);
      expect(function() {
        runableResources.spies();
      }).toThrowError('Spies must be created in a before function or a spec');
    });

    it('clears spies', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => 1
      });
      runableResources.initForRunable(1);
      function foo() {}
      const spyObj = { foo };
      runableResources.spyRegistry.spyOn(spyObj, 'foo');
      expect(spyObj.foo).not.toBe(foo);

      runableResources.clearForRunable(1);
      expect(spyObj.foo).toBe(foo);
    });

    it('clears the global error spy', function() {
      const globalErrors = jasmine.createSpyObj('globalErrors', [
        'removeOverrideListener'
      ]);
      const runableResources = new jasmineUnderTest.RunableResources({
        getCurrentRunableId: () => 1,
        globalErrors
      });
      runableResources.initForRunable(1);

      runableResources.clearForRunable(1);
      expect(globalErrors.removeOverrideListener).toHaveBeenCalled();
    });

    it('does not remove resources for other runables', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => 1
      });
      runableResources.initForRunable(1);
      function cof() {}
      runableResources.customObjectFormatters().push(cof);
      runableResources.clearForRunable(2);
      expect(runableResources.customObjectFormatters()).toEqual([cof]);
    });
  });

  function behavesLikeAPerRunableMutableArray(
    methodName,
    errorMsg,
    inherits = true
  ) {
    it('is initially empty', function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      expect(runableResources[methodName]()).toEqual([]);
    });

    it('is mutable', function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      function newItem() {}
      runableResources[methodName]().push(newItem);
      expect(runableResources[methodName]()).toEqual([newItem]);
    });

    it('is per-runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      runableResources[methodName]().push(() => {});
      runableResources.initForRunable(2);
      currentRunableId = 2;
      expect(runableResources[methodName]()).toEqual([]);
    });

    it('throws a user-facing error when there is no current runable', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => null
      });
      expect(function() {
        runableResources[methodName]();
      }).toThrowError(errorMsg);
    });

    if (inherits) {
      it('inherits from the parent runable', function() {
        let currentRunableId = 1;
        const runableResources = new jasmineUnderTest.RunableResources({
          globalErrors: stubGlobalErrors(),
          getCurrentRunableId: () => currentRunableId
        });
        runableResources.initForRunable(1);
        function parentItem() {}
        runableResources[methodName]().push(parentItem);
        runableResources.initForRunable(2, 1);
        currentRunableId = 2;
        function childItem() {}
        runableResources[methodName]().push(childItem);
        expect(runableResources[methodName]()).toEqual([parentItem, childItem]);

        currentRunableId = 1;
        expect(runableResources[methodName]()).toEqual([parentItem]);
      });
    }
  }

  function behavesLikeAPerRunableMutableObject(methodName, errorMsg) {
    it('is initially empty', function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);

      expect(runableResources[methodName]()).toEqual({});
    });

    it('is mutable', function() {
      const currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      function newItem() {}
      runableResources[methodName]().foo = newItem;
      expect(runableResources[methodName]()).toEqual({ foo: newItem });
    });

    it('is per-runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      runableResources[methodName]().foo = function() {};
      runableResources.initForRunable(2);
      currentRunableId = 2;
      expect(runableResources[methodName]()).toEqual({});
    });

    it('throws a user-facing error when there is no current runable', function() {
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => null
      });
      expect(function() {
        runableResources[methodName]();
      }).toThrowError(errorMsg);
    });

    it('inherits from the parent runable', function() {
      let currentRunableId = 1;
      const runableResources = new jasmineUnderTest.RunableResources({
        globalErrors: stubGlobalErrors(),
        getCurrentRunableId: () => currentRunableId
      });
      runableResources.initForRunable(1);
      function parentItem() {}
      runableResources[methodName]().parentName = parentItem;
      runableResources.initForRunable(2, 1);
      currentRunableId = 2;
      function childItem() {}
      runableResources[methodName]().childName = childItem;
      expect(runableResources[methodName]()).toEqual({
        parentName: parentItem,
        childName: childItem
      });

      currentRunableId = 1;
      expect(runableResources[methodName]()).toEqual({
        parentName: parentItem
      });
    });
  }

  function stubGlobalErrors() {
    return {
      removeOverrideListener() {}
    };
  }
})",snuts
/spec/core/RunableResourcesSpec.js,VerboseStatement,"{'startLine':195,'endLine':229}","it('returns a MatchersUtil configured with the current resources', function() {
        const runableResources = new jasmineUnderTest.RunableResources({
          globalErrors: stubGlobalErrors(),
          getCurrentRunableId: () => 1
        });
        runableResources.initForRunable(1);
        function cof() {}
        runableResources.customObjectFormatters().push(cof);
        function ceq() {}
        runableResources.customEqualityTesters().push(ceq);
        const expectedPP = {};
        const expectedMatchersUtil = {};
        spyOn(jasmineUnderTest, 'makePrettyPrinter').and.returnValue(
          expectedPP
        );
        spyOn(jasmineUnderTest, 'MatchersUtil').and.returnValue(
          expectedMatchersUtil
        );

        const matchersUtil = runableResources.makeMatchersUtil();

        expect(matchersUtil).toBe(expectedMatchersUtil);
        expect(jasmineUnderTest.makePrettyPrinter).toHaveBeenCalledOnceWith([
          cof
        ]);
        // We need === equality on the pp passed to MatchersUtil
        expect(jasmineUnderTest.MatchersUtil).toHaveBeenCalledOnceWith(
          jasmine.objectContaining({
            customTesters: [ceq]
          })
        );
        expect(jasmineUnderTest.MatchersUtil.calls.argsFor(0)[0].pp).toBe(
          expectedPP
        );
      })",snuts
/spec/core/ReportDispatcherSpec.js,VerboseStatement,"{'startLine':14,'endLine':67}","it('dispatches requested methods to added reporters', function() {
    const runQueue = jasmine.createSpy('runQueue'),
      dispatcher = new jasmineUnderTest.ReportDispatcher(
        ['foo', 'bar'],
        runQueue
      ),
      reporter = jasmine.createSpyObj('reporter', ['foo', 'bar']),
      anotherReporter = jasmine.createSpyObj('reporter', ['foo', 'bar']);

    dispatcher.addReporter(reporter);
    dispatcher.addReporter(anotherReporter);

    dispatcher.foo(123, 456);

    expect(runQueue).toHaveBeenCalledWith(
      jasmine.objectContaining({
        queueableFns: [
          { fn: jasmine.any(Function) },
          { fn: jasmine.any(Function) }
        ],
        isReporter: true
      })
    );

    let fns = runQueue.calls.mostRecent().args[0].queueableFns;
    fns[0].fn();
    expect(reporter.foo).toHaveBeenCalledWith(123, 456);
    expect(reporter.foo.calls.mostRecent().object).toBe(reporter);

    fns[1].fn();
    expect(anotherReporter.foo).toHaveBeenCalledWith(123, 456);
    expect(anotherReporter.foo.calls.mostRecent().object).toBe(anotherReporter);

    runQueue.calls.reset();

    dispatcher.bar('a', 'b');

    expect(runQueue).toHaveBeenCalledWith(
      jasmine.objectContaining({
        queueableFns: [
          { fn: jasmine.any(Function) },
          { fn: jasmine.any(Function) }
        ],
        isReporter: true
      })
    );

    fns = runQueue.calls.mostRecent().args[0].queueableFns;
    fns[0].fn();
    expect(reporter.bar).toHaveBeenCalledWith('a', 'b');

    fns[1].fn();
    expect(anotherReporter.bar).toHaveBeenCalledWith('a', 'b');
  })",snuts
/spec/core/ReportDispatcherSpec.js,VerboseStatement,"{'startLine':133,'endLine':170}","it('allows registered reporters to be cleared', function() {
    const runQueue = jasmine.createSpy('runQueue'),
      dispatcher = new jasmineUnderTest.ReportDispatcher(
        ['foo', 'bar'],
        runQueue
      ),
      reporter1 = jasmine.createSpyObj('reporter1', ['foo', 'bar']),
      reporter2 = jasmine.createSpyObj('reporter2', ['foo', 'bar']);

    dispatcher.addReporter(reporter1);
    dispatcher.foo(123);
    expect(runQueue).toHaveBeenCalledWith(
      jasmine.objectContaining({
        queueableFns: [{ fn: jasmine.any(Function) }],
        isReporter: true
      })
    );

    let fns = runQueue.calls.mostRecent().args[0].queueableFns;
    fns[0].fn();
    expect(reporter1.foo).toHaveBeenCalledWith(123);

    dispatcher.clearReporters();
    dispatcher.addReporter(reporter2);
    dispatcher.bar(456);

    expect(runQueue).toHaveBeenCalledWith(
      jasmine.objectContaining({
        queueableFns: [{ fn: jasmine.any(Function) }],
        isReporter: true
      })
    );

    fns = runQueue.calls.mostRecent().args[0].queueableFns;
    fns[0].fn();
    expect(reporter1.bar).not.toHaveBeenCalled();
    expect(reporter2.bar).toHaveBeenCalledWith(456);
  })",snuts
/spec/core/QueueRunnerSpec.js,IdenticalTestDescription,"{'startLine':183,'endLine':203}","it('explicitly fails and moves to the next function', function(done) {
            const err = new Error('foo'),
              queueableFn1 = {
                fn: function() {
                  return Promise.resolve(err);
                }
              },
              queueableFn2 = { fn: jasmine.createSpy('fn2') },
              failFn = jasmine.createSpy('fail'),
              queueRunner = new jasmineUnderTest.QueueRunner({
                queueableFns: [queueableFn1, queueableFn2],
                fail: failFn,
                onComplete: function() {
                  expect(failFn).toHaveBeenCalledWith(err);
                  expect(queueableFn2.fn).toHaveBeenCalled();
                  done();
                }
              });

            queueRunner.execute();
          })",snuts
/spec/core/QueueRunnerSpec.js,IdenticalTestDescription,"{'startLine':1025,'endLine':1034}","it('runs the functions on the scope of a UserContext', function() {
      let context;
      this.fn.and.callFake(function() {
        context = this;
      });

      this.queueRunner.execute();

      expect(context).toBe(this.context);
    })",snuts
/spec/core/QueueRunnerSpec.js,NonFunctionalStatement,"{'startLine':258,'endLine':258}","it(""sets a timeout if requested for asynchronous functions so they don't go on forever"", function() {
      const timeout = 3,
        beforeFn = { fn: function(done) {}, type: 'before', timeout: timeout },
        queueableFn = { fn: jasmine.createSpy('fn'), type: 'queueable' },
        onComplete = jasmine.createSpy('onComplete'),
        onException = jasmine.createSpy('onException'),
        queueRunner = new jasmineUnderTest.QueueRunner({
          queueableFns: [beforeFn, queueableFn],
          onComplete: onComplete,
          onException: onException
        });

      queueRunner.execute();
      expect(queueableFn.fn).not.toHaveBeenCalled();

      jasmine.clock().tick(timeout);

      expect(onException).toHaveBeenCalledWith(jasmine.any(Error));
      expect(queueableFn.fn).toHaveBeenCalled();
      expect(onComplete).toHaveBeenCalled();
    })",snuts
/spec/core/QueueRunnerSpec.js,NonFunctionalStatement,"{'startLine':305,'endLine':305}","it('by default does not set a timeout for asynchronous functions', function() {
      const beforeFn = { fn: function(done) {} },
        queueableFn = { fn: jasmine.createSpy('fn') },
        onComplete = jasmine.createSpy('onComplete'),
        onException = jasmine.createSpy('onException'),
        queueRunner = new jasmineUnderTest.QueueRunner({
          queueableFns: [beforeFn, queueableFn],
          onComplete: onComplete,
          onException: onException
        });

      queueRunner.execute();
      expect(queueableFn.fn).not.toHaveBeenCalled();

      jasmine.clock().tick(jasmineUnderTest.DEFAULT_TIMEOUT_INTERVAL);

      expect(onException).not.toHaveBeenCalled();
      expect(queueableFn.fn).not.toHaveBeenCalled();
      expect(onComplete).not.toHaveBeenCalled();
    })",snuts
/spec/core/QueueRunnerSpec.js,NonFunctionalStatement,"{'startLine':569,'endLine':569}","describe('with a function that returns a promise', function() {
    function StubPromise() {}

    StubPromise.prototype.then = function(resolve, reject) {
      this.resolveHandler = resolve;
      this.rejectHandler = reject;
    };

    beforeEach(function() {
      jasmine.clock().install();
    });

    afterEach(function() {
      jasmine.clock().uninstall();
    });

    it('runs the function asynchronously, advancing once the promise is settled', function() {
      const onComplete = jasmine.createSpy('onComplete'),
        fnCallback = jasmine.createSpy('fnCallback'),
        p1 = new StubPromise(),
        p2 = new StubPromise(),
        queueableFn1 = {
          fn: function() {
            setTimeout(function() {
              p1.resolveHandler();
            }, 100);
            return p1;
          }
        },
        queueableFn2 = {
          fn: function() {
            fnCallback();
            setTimeout(function() {
              p2.resolveHandler();
            }, 100);
            return p2;
          }
        },
        queueRunner = new jasmineUnderTest.QueueRunner({
          queueableFns: [queueableFn1, queueableFn2],
          onComplete: onComplete
        });

      queueRunner.execute();
      expect(fnCallback).not.toHaveBeenCalled();
      expect(onComplete).not.toHaveBeenCalled();

      jasmine.clock().tick(100);

      expect(fnCallback).toHaveBeenCalled();
      expect(onComplete).not.toHaveBeenCalled();

      jasmine.clock().tick(100);

      expect(onComplete).toHaveBeenCalled();
    });

    it('handles a rejected promise like an unhandled exception', function() {
      const promise = new StubPromise(),
        queueableFn1 = {
          fn: function() {
            setTimeout(function() {
              promise.rejectHandler('foo');
            }, 100);
            return promise;
          }
        },
        queueableFn2 = { fn: jasmine.createSpy('fn2') },
        onExceptionCallback = jasmine.createSpy('on exception callback'),
        queueRunner = new jasmineUnderTest.QueueRunner({
          queueableFns: [queueableFn1, queueableFn2],
          onException: onExceptionCallback
        });

      queueRunner.execute();

      expect(onExceptionCallback).not.toHaveBeenCalled();
      expect(queueableFn2.fn).not.toHaveBeenCalled();

      jasmine.clock().tick(100);

      expect(onExceptionCallback).toHaveBeenCalledWith('foo');
      expect(queueableFn2.fn).toHaveBeenCalled();
    });

    it('issues an error if the function also takes a parameter', function() {
      const queueableFn = {
          fn: function(done) {
            return new StubPromise();
          }
        },
        onException = jasmine.createSpy('onException'),
        queueRunner = new jasmineUnderTest.QueueRunner({
          queueableFns: [queueableFn],
          onException: onException
        });

      queueRunner.execute();

      expect(onException).toHaveBeenCalledWith(
        new Error(
          'An asynchronous ' +
            'before/it/after function took a done callback but also returned a ' +
            'promise. ' +
            'Either remove the done callback (recommended) or change the function ' +
            'to not return a promise.'
        )
      );
    });

    it('issues a more specific error if the function is `async`', function() {
      async function fn(done) {}
      const onException = jasmine.createSpy('onException'),
        queueRunner = new jasmineUnderTest.QueueRunner({
          queueableFns: [{ fn: fn }],
          onException: onException
        });

      queueRunner.execute();

      expect(onException).toHaveBeenCalledWith(
        new Error(
          'An asynchronous ' +
            'before/it/after function was defined with the async keyword but ' +
            'also took a done callback. Either remove the done callback ' +
            '(recommended) or remove the async keyword.'
        )
      );
    });
  })",snuts
/spec/core/QueueRunnerSpec.js,NonFunctionalStatement,"{'startLine':679,'endLine':679}","it('issues a more specific error if the function is `async`', function() {
      async function fn(done) {}
      const onException = jasmine.createSpy('onException'),
        queueRunner = new jasmineUnderTest.QueueRunner({
          queueableFns: [{ fn: fn }],
          onException: onException
        });

      queueRunner.execute();

      expect(onException).toHaveBeenCalledWith(
        new Error(
          'An asynchronous ' +
            'before/it/after function was defined with the async keyword but ' +
            'also took a done callback. Either remove the done callback ' +
            '(recommended) or remove the async keyword.'
        )
      );
    })",snuts
/spec/core/QueueRunnerSpec.js,NonFunctionalStatement,"{'startLine':748,'endLine':748}","it('instantiates the skip policy', function() {
      const SkipPolicy = jasmine.createSpy('SkipPolicy ctor');
      const queueableFns = [{ fn: () => {} }, { fn: () => {} }];

      new jasmineUnderTest.QueueRunner({
        queueableFns,
        SkipPolicy
      });

      expect(SkipPolicy).toHaveBeenCalledWith(queueableFns);
    })",snuts
/spec/core/QueueRunnerSpec.js,NonFunctionalStatement,"{'startLine':748,'endLine':748}","it('instantiates the skip policy', function() {
      const SkipPolicy = jasmine.createSpy('SkipPolicy ctor');
      const queueableFns = [{ fn: () => {} }, { fn: () => {} }];

      new jasmineUnderTest.QueueRunner({
        queueableFns,
        SkipPolicy
      });

      expect(SkipPolicy).toHaveBeenCalledWith(queueableFns);
    })",snuts
/spec/core/QueueRunnerSpec.js,NonFunctionalStatement,"{'startLine':792,'endLine':792}","it('throws if the skip policy returns the current fn', function() {
      const skipPolicy = { skipTo: i => i };
      const queueableFns = [{ fn: () => {} }];
      const queueRunner = new jasmineUnderTest.QueueRunner({
        queueableFns,
        SkipPolicy: function() {
          return skipPolicy;
        }
      });

      expect(function() {
        queueRunner.execute();
      }).toThrowError(""Can't skip to the same queueable fn that just finished"");
    })",snuts
/spec/core/QueueRunnerSpec.js,NonFunctionalStatement,"{'startLine':834,'endLine':834}","it('does not skip when a cleanup function throws', function() {
      const queueableFn = { fn: function() {} },
        cleanupFn1 = {
          fn: function() {
            throw new Error('error');
          },
          type: 'afterEach'
        },
        cleanupFn2 = {
          fn: jasmine.createSpy('cleanupFn2'),
          type: 'afterEach'
        },
        queueRunner = new jasmineUnderTest.QueueRunner({
          queueableFns: [queueableFn, cleanupFn1, cleanupFn2],
          SkipPolicy: jasmineUnderTest.CompleteOnFirstErrorSkipPolicy
        });

      queueRunner.execute();
      expect(cleanupFn2.fn).toHaveBeenCalled();
    })",snuts
/spec/core/QueueRunnerSpec.js,SubOptimalAssert,"{'startLine':420,'endLine':420}","it('should return a null when you call done', function() {
      // Some promises want handlers to return anything but undefined to help catch ""forgotten returns"".
      let doneReturn;
      const queueableFn = {
        fn: function(done) {
          doneReturn = done();
        }
      };
      const queueRunner = new jasmineUnderTest.QueueRunner({
        queueableFns: [queueableFn]
      });

      queueRunner.execute();
      expect(doneReturn).toBe(null);
    })",snuts
/spec/core/QueueRunnerSpec.js,VerboseStatement,"{'startLine':68,'endLine':120}","it('supports asynchronous functions, only advancing to next function after a done() callback', function() {
      //TODO: it would be nice if spy arity could match the fake, so we could do something like:
      //createSpy('asyncfn').and.callFake(function(done) {});

      const onComplete = jasmine.createSpy('onComplete'),
        beforeCallback = jasmine.createSpy('beforeCallback'),
        fnCallback = jasmine.createSpy('fnCallback'),
        afterCallback = jasmine.createSpy('afterCallback'),
        queueableFn1 = {
          fn: function(done) {
            beforeCallback();
            setTimeout(done, 100);
          }
        },
        queueableFn2 = {
          fn: function(done) {
            fnCallback();
            setTimeout(done, 100);
          }
        },
        queueableFn3 = {
          fn: function(done) {
            afterCallback();
            setTimeout(done, 100);
          }
        },
        queueRunner = new jasmineUnderTest.QueueRunner({
          queueableFns: [queueableFn1, queueableFn2, queueableFn3],
          onComplete: onComplete
        });

      queueRunner.execute();

      expect(beforeCallback).toHaveBeenCalled();
      expect(fnCallback).not.toHaveBeenCalled();
      expect(afterCallback).not.toHaveBeenCalled();
      expect(onComplete).not.toHaveBeenCalled();

      jasmine.clock().tick(100);

      expect(fnCallback).toHaveBeenCalled();
      expect(afterCallback).not.toHaveBeenCalled();
      expect(onComplete).not.toHaveBeenCalled();

      jasmine.clock().tick(100);

      expect(afterCallback).toHaveBeenCalled();
      expect(onComplete).not.toHaveBeenCalled();

      jasmine.clock().tick(100);

      expect(onComplete).toHaveBeenCalled();
    })",snuts
/spec/core/PrettyPrintSpec.js,AnonymousTest,"{'startLine':87,'endLine':90}","it('includes symbols', function() {
      const pp = jasmineUnderTest.makePrettyPrinter();
      expect(pp([1, Symbol('foo'), 2])).toEqual('[ 1, Symbol(foo), 2 ]');
    })",snuts
/spec/core/PrettyPrintSpec.js,SensitiveEquality,"{'startLine':354,'endLine':354}","it('should stringify Date objects properly', function() {
    const pp = jasmineUnderTest.makePrettyPrinter();
    const now = new Date();
    expect(pp(now)).toEqual('Date(' + now.toString() + ')');
  })",snuts
/spec/core/PrettyPrintSpec.js,IdenticalTestDescription,"{'startLine':568,'endLine':584}","it('should use the first custom object formatter that does not return undefined', function() {
      const customObjectFormatters = [
          function() {
            return undefined;
          },
          function(obj) {
            return '2nd: ' + obj.foo;
          },
          function(obj) {
            return '3rd: ' + obj.foo;
          }
        ],
        pp = jasmineUnderTest.makePrettyPrinter(customObjectFormatters),
        obj = { foo: 'bar' };

      expect(pp.customFormat_(obj)).toEqual('2nd: bar');
    })",snuts
/spec/core/PrettyPrintSpec.js,NonFunctionalStatement,"{'startLine':166,'endLine':166}","it('should stringify objects properly', function() {
    const pp = jasmineUnderTest.makePrettyPrinter();
    expect(pp({ foo: 'bar' })).toEqual(""Object({ foo: 'bar' })"");
    expect(
      pp({
        foo: 'bar',
        baz: 3,
        nullValue: null,
        undefinedValue: jasmine.undefined
      })
    ).toEqual(
      ""Object({ foo: 'bar', baz: 3, nullValue: null, undefinedValue: undefined })""
    );
    expect(pp({ foo: function() {}, bar: [1, 2, 3] })).toEqual(
      ""Object({ foo: Function 'foo', bar: [ 1, 2, 3 ] })""
    );
  })",snuts
/spec/core/PrettyPrintSpec.js,NonFunctionalStatement,"{'startLine':260,'endLine':260}","it(""should print 'null' as the constructor of an object with its own constructor property"", function() {
    const pp = jasmineUnderTest.makePrettyPrinter();
    expect(pp({ constructor: function() {} })).toContain('null({');
    expect(pp({ constructor: 'foo' })).toContain('null({');
  })",snuts
/spec/core/PrettyPrintSpec.js,NonFunctionalStatement,"{'startLine':266,'endLine':266}","it('should not include inherited properties when stringifying an object', function() {
    const pp = jasmineUnderTest.makePrettyPrinter();
    const SomeClass = function SomeClass() {};
    SomeClass.prototype.foo = 'inherited foo';
    const instance = new SomeClass();
    instance.bar = 'my own bar';
    expect(pp(instance)).toEqual(""SomeClass({ bar: 'my own bar' })"");
  })",snuts
/spec/core/PrettyPrintSpec.js,NonFunctionalStatement,"{'startLine':371,'endLine':371}","it('should stringify spy objects properly', function() {
      const TestObject = {
        someFunction: function() {}
      };

      const spyRegistry = new jasmineUnderTest.SpyRegistry({
        currentSpies: function() {
          return [];
        },
        createSpy: function(name, originalFn) {
          return jasmineUnderTest.Spy(name, originalFn);
        }
      });

      spyRegistry.spyOn(TestObject, 'someFunction');
      expect(pp(TestObject.someFunction)).toEqual('spy on someFunction');

      expect(pp(env.createSpy('something'))).toEqual('spy on something');
    })",snuts
/spec/core/PrettyPrintSpec.js,NonFunctionalStatement,"{'startLine':391,'endLine':391}","it('should stringify spyOn toString properly', function() {
      const TestObject = {
          someFunction: function() {}
        },
        env = new jasmineUnderTest.Env(),
        pp = jasmineUnderTest.makePrettyPrinter();

      const spyRegistry = new jasmineUnderTest.SpyRegistry({
        currentSpies: function() {
          return [];
        },
        createSpy: function(name, originalFn) {
          return jasmineUnderTest.Spy(name, originalFn);
        }
      });

      spyRegistry.spyOn(TestObject, 'toString');
      const testSpyObj = env.createSpyObj('TheClassName', ['toString']);

      expect(pp(testSpyObj)).toEqual('spy on TheClassName.toString');
    })",snuts
/spec/core/PrettyPrintSpec.js,NonFunctionalStatement,"{'startLine':469,'endLine':469}","it('should stringify objects from anonymous constructors with custom toString', function() {
    const pp = jasmineUnderTest.makePrettyPrinter();
    const MyAnonymousConstructor = (function() {
      return function() {};
    })();
    MyAnonymousConstructor.toString = function() {
      return '';
    };

    const a = new MyAnonymousConstructor();

    expect(pp(a)).toEqual('<anonymous>({  })');
  })",snuts
/spec/core/PrettyPrintSpec.js,NonFunctionalStatement,"{'startLine':483,'endLine':483}","it('stringifies functions with names', function() {
    const pp = jasmineUnderTest.makePrettyPrinter();
    expect(pp(foo)).toEqual(""Function 'foo'"");
    function foo() {}
  })",snuts
/spec/core/PrettyPrintSpec.js,NonFunctionalStatement,"{'startLine':488,'endLine':488}","it('stringifies functions without names', function() {
    const pp = jasmineUnderTest.makePrettyPrinter();
    expect(pp(function() {})).toEqual('Function');
  })",snuts
/spec/core/ParallelReportDispatcherSpec.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}","it('dispatches the standard reporter events', async function() {
    const subject = new jasmineUnderTest.ParallelReportDispatcher(() => {}, {
      globalErrors: mockGlobalErrors()
    });
    const events = [
      'jasmineStarted',
      'jasmineDone',
      'suiteStarted',
      'suiteDone',
      'specStarted',
      'specDone'
    ];
    const reporter = jasmine.createSpyObj('reporter', events);
    subject.addReporter(reporter);

    for (const eventName of events) {
      const payload = { payloadFor: eventName };
      await subject[eventName](payload);
      expect(reporter[eventName]).toHaveBeenCalledWith(payload);
    }
  })",snuts
/spec/core/ParallelReportDispatcherSpec.js,NonFunctionalStatement,"{'startLine':26,'endLine':26}","it('installs and uninstalls the global error handler', function() {
    const globalErrors = mockGlobalErrors();
    const subject = new jasmineUnderTest.ParallelReportDispatcher(() => {}, {
      globalErrors
    });

    subject.installGlobalErrors();
    expect(globalErrors.install).toHaveBeenCalled();

    subject.uninstallGlobalErrors();
    expect(globalErrors.uninstall).toHaveBeenCalled();
  })",snuts
/spec/core/ParallelReportDispatcherSpec.js,VerboseStatement,"{'startLine':37,'endLine':65}","it('handles global errors from async reporters', async function() {
    const globalErrors = mockGlobalErrors();
    const onError = jasmine.createSpy('onError');
    const subject = new jasmineUnderTest.ParallelReportDispatcher(onError, {
      globalErrors
    });
    const reporter = jasmine.createSpyObj('reporter', [
      'jasmineStarted',
      'jasmineDone'
    ]);
    let resolveStarted;
    reporter.jasmineStarted.and.callFake(function() {
      return new Promise(function(res) {
        resolveStarted = res;
      });
    });
    subject.addReporter(reporter);

    const promise = subject.jasmineStarted({});
    expect(globalErrors.pushListener).toHaveBeenCalled();
    expect(globalErrors.popListener).not.toHaveBeenCalled();
    const error = new Error('nope');
    globalErrors.pushListener.calls.argsFor(0)[0](error);
    expect(onError).toHaveBeenCalledWith(error);

    resolveStarted();
    await promise;
    expect(globalErrors.popListener).toHaveBeenCalled();
  })",snuts
/spec/core/ParallelReportDispatcherSpec.js,VerboseStatement,"{'startLine':92,'endLine':120}","it('handles done.fail() from callback-style async reporters', function() {
    const globalErrors = mockGlobalErrors();
    const onError = jasmine.createSpy('onError');
    const subject = new jasmineUnderTest.ParallelReportDispatcher(onError, {
      globalErrors
    });
    const reporter = jasmine.createSpyObj('reporter', [
      'jasmineStarted',
      'jasmineDone'
    ]);
    let callback;
    reporter.jasmineStarted = function(event, cb) {
      callback = cb;
    };
    subject.addReporter(reporter);

    subject.jasmineStarted({});

    expect(callback).toBeInstanceOf(Function);
    const error = new Error('nope');
    callback.fail(error);
    expect(onError).toHaveBeenCalledWith(error);
    onError.calls.reset();

    callback.fail();
    expect(onError).toHaveBeenCalledWith(
      new Error('A reporter called done.fail()')
    );
  })",snuts
/spec/core/MockDateSpec.js,NonFunctionalStatement,"{'startLine':18,'endLine':18}","it('replaces the global Date when it is installed', function() {
    const globalDate = jasmine
        .createSpy('global Date')
        .and.callFake(function() {
          return {
            getTime: function() {}
          };
        }),
      fakeGlobal = { Date: globalDate },
      mockDate = new jasmineUnderTest.MockDate(fakeGlobal);

    expect(fakeGlobal.Date).toEqual(globalDate);
    mockDate.install();

    expect(fakeGlobal.Date).not.toEqual(globalDate);
  })",snuts
/spec/core/MockDateSpec.js,NonFunctionalStatement,"{'startLine':35,'endLine':35}","it('replaces the global Date on uninstall', function() {
    const globalDate = jasmine
        .createSpy('global Date')
        .and.callFake(function() {
          return {
            getTime: function() {}
          };
        }),
      fakeGlobal = { Date: globalDate },
      mockDate = new jasmineUnderTest.MockDate(fakeGlobal);

    mockDate.install();
    mockDate.uninstall();

    expect(fakeGlobal.Date).toEqual(globalDate);
  })",snuts
/spec/core/MockDateSpec.js,NonFunctionalStatement,"{'startLine':99,'endLine':99}","it('fakes current time when using Date.now()', function() {
    const globalDate = jasmine
        .createSpy('global Date')
        .and.callFake(function() {
          return {
            getTime: function() {
              return 1000;
            }
          };
        }),
      fakeGlobal = { Date: globalDate };

    globalDate.now = function() {};
    const mockDate = new jasmineUnderTest.MockDate(fakeGlobal);

    mockDate.install();

    expect(fakeGlobal.Date.now()).toEqual(1000);
  })",snuts
/spec/core/MockDateSpec.js,NonFunctionalStatement,"{'startLine':119,'endLine':119}","it('makes time passes using tick', function() {
    const globalDate = jasmine
        .createSpy('global Date')
        .and.callFake(function() {
          return {
            getTime: function() {
              return 1000;
            }
          };
        }),
      fakeGlobal = { Date: globalDate };

    globalDate.now = function() {};
    const mockDate = new jasmineUnderTest.MockDate(fakeGlobal);

    mockDate.install();

    mockDate.tick(100);

    expect(fakeGlobal.Date.now()).toEqual(1100);

    mockDate.tick(1000);

    expect(fakeGlobal.Date.now()).toEqual(2100);
  })",snuts
/spec/core/MockDateSpec.js,NonFunctionalStatement,"{'startLine':145,'endLine':145}","it('allows to increase 0 milliseconds using tick', function() {
    const globalDate = jasmine
        .createSpy('global Date')
        .and.callFake(function() {
          return {
            getTime: function() {
              return 1000;
            }
          };
        }),
      fakeGlobal = { Date: globalDate };

    globalDate.now = function() {};
    const mockDate = new jasmineUnderTest.MockDate(fakeGlobal);

    mockDate.install();

    mockDate.tick(0);
    expect(fakeGlobal.Date.now()).toEqual(1000);

    mockDate.tick();
    expect(fakeGlobal.Date.now()).toEqual(1000);
  })",snuts
/spec/core/MockDateSpec.js,SubOptimalAssert,"{'startLine':84,'endLine':84}","it('makes real dates', function() {
    const fakeGlobal = { Date: Date },
      mockDate = new jasmineUnderTest.MockDate(fakeGlobal);

    mockDate.install();
    expect(new fakeGlobal.Date()).toEqual(jasmine.any(Date));
    expect(new fakeGlobal.Date() instanceof fakeGlobal.Date).toBe(true);
  })",snuts
/spec/core/JsApiReporterSpec.js,GeneralFixture,"{'startLine':105,'endLine':107}","beforeEach(function() {
      reporter = new jasmineUnderTest.JsApiReporter({});
      suiteStarted1 = {
        id: 1
      };
      suiteResult1 = {
        id: 1,
        status: 'failed',
        failedExpectations: [{ message: 'My After All Exception' }]
      };
      suiteResult2 = {
        id: 2,
        status: 'passed'
      };

      reporter.suiteStarted(suiteStarted1);
      reporter.suiteDone(suiteResult1);
      reporter.suiteDone(suiteResult2);
    })",snuts
/spec/core/JsApiReporterSpec.js,IdenticalTestDescription,"{'startLine':127,'endLine':130}","it('should return a slice of results', function() {
      expect(reporter.suiteResults(0, 1)).toEqual([suiteResult1]);
      expect(reporter.suiteResults(1, 1)).toEqual([suiteResult2]);
    })",snuts
/spec/core/GlobalErrorsSpec.js,AnonymousTest,"{'startLine':99,'endLine':112}","it('uninstalls itself', function() {
    const globals = browserGlobals();
    const errors = new jasmineUnderTest.GlobalErrors(
      globals.global,
      () => ({})
    );
    function unrelatedListener() {}

    errors.install();
    globals.global.addEventListener('error', unrelatedListener);
    errors.uninstall();

    expect(globals.listeners.error).toEqual([unrelatedListener]);
  })",snuts
/spec/core/GlobalErrorsSpec.js,IdenticalTestDescription,"{'startLine':462,'endLine':475}","it('immediately reports the rejection', function() {
          const handler = jasmine.createSpy('errorHandler');

          errors.install();
          errors.pushListener(handler);

          const event = { reason: 'nope' };
          dispatchEvent(globals.listeners, 'unhandledrejection', event);

          expect(handler).toHaveBeenCalledWith(
            'Unhandled promise rejection: nope',
            event
          );
        })",snuts
/spec/core/GlobalErrorsSpec.js,IdenticalTestDescription,"{'startLine':479,'endLine':493}","it('does not immediately report the rejection', function() {
          const handler = jasmine.createSpy('errorHandler');

          errors.install();
          errors.pushListener(handler);

          const promise = Promise.reject('nope');
          promise.catch(() => {});
          dispatchEvent(globals.listeners, 'unhandledrejection', {
            reason: 'nope',
            promise
          });

          expect(handler).not.toHaveBeenCalled();
        })",snuts
/spec/core/GlobalErrorsSpec.js,IdenticalTestDescription,"{'startLine':496,'endLine':513}","it('reports rejections that have not been handled', function() {
            const handler = jasmine.createSpy('errorHandler');
            errors.install();
            errors.pushListener(handler);

            const promise = Promise.reject('nope');
            promise.catch(() => {});
            dispatchEvent(globals.listeners, 'unhandledrejection', {
              reason: 'nope',
              promise
            });
            errors.reportUnhandledRejections();

            expect(handler).toHaveBeenCalledWith(
              'Unhandled promise rejection: nope',
              { reason: 'nope', promise }
            );
          })",snuts
/spec/core/GlobalErrorsSpec.js,IdenticalTestDescription,"{'startLine':515,'endLine':530}","it('does not report rejections that have been handled', function() {
            const handler = jasmine.createSpy('errorHandler');
            errors.install();
            errors.pushListener(handler);

            const promise = Promise.reject('nope');
            promise.catch(() => {});
            dispatchEvent(globals.listeners, 'unhandledrejection', {
              reason: 'nope',
              promise
            });
            dispatchEvent(globals.listeners, 'rejectionhandled', { promise });
            errors.reportUnhandledRejections();

            expect(handler).not.toHaveBeenCalled();
          })",snuts
/spec/core/GlobalErrorsSpec.js,IdenticalTestDescription,"{'startLine':532,'endLine':550}","it('does not report the same rejection on subsequent calls', function() {
            const handler = jasmine.createSpy('errorHandler');

            errors.install();
            errors.pushListener(handler);

            const promise = Promise.reject('nope');
            promise.catch(() => {});
            dispatchEvent(globals.listeners, 'unhandledrejection', {
              reason: 'nope',
              promise
            });
            errors.reportUnhandledRejections();
            expect(handler).toHaveBeenCalled();
            handler.calls.reset();

            errors.reportUnhandledRejections();
            expect(handler).not.toHaveBeenCalled();
          })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':33,'endLine':33}","it('is not affected by overriding global.onerror', function() {
    const globals = browserGlobals();
    const handler = jasmine.createSpy('errorHandler');
    const errors = new jasmineUnderTest.GlobalErrors(
      globals.global,
      () => ({})
    );

    errors.install();
    errors.pushListener(handler);

    globals.global.onerror = () => {};

    const error = new Error('nope');
    dispatchEvent(globals.listeners, 'error', { error });

    expect(handler).toHaveBeenCalledWith(
      jasmine.is(error),
      jasmine.objectContaining({ error: jasmine.is(error) })
    );
  })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':105,'endLine':105}","it('uninstalls itself', function() {
    const globals = browserGlobals();
    const errors = new jasmineUnderTest.GlobalErrors(
      globals.global,
      () => ({})
    );
    function unrelatedListener() {}

    errors.install();
    globals.global.addEventListener('error', unrelatedListener);
    errors.uninstall();

    expect(globals.listeners.error).toEqual([unrelatedListener]);
  })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':140,'endLine':140}","it('reports uncaught exceptions in node.js', function() {
    const globals = nodeGlobals();
    const errors = new jasmineUnderTest.GlobalErrors(
      globals.global,
      () => ({})
    );
    const handler = jasmine.createSpy('errorHandler');
    function originalHandler() {}
    globals.listeners.uncaughtException = [originalHandler];

    errors.install();
    expect(globals.listeners.uncaughtException).toEqual([
      jasmine.any(Function)
    ]);
    expect(globals.listeners.uncaughtException).not.toEqual([
      originalHandler()
    ]);

    errors.pushListener(handler);

    dispatchEvent(globals.listeners, 'uncaughtException', new Error('bar'));

    expect(handler).toHaveBeenCalledWith(new Error('bar'), undefined);
    expect(handler.calls.argsFor(0)[0].jasmineMessage).toBe(
      'Uncaught exception: Error: bar'
    );

    errors.uninstall();

    expect(globals.listeners.uncaughtException).toEqual([originalHandler]);
  })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':173,'endLine':173}","it('reports rejections with `Error` reasons', function() {
      const globals = nodeGlobals();
      const errors = new jasmineUnderTest.GlobalErrors(
        globals.global,
        () => ({})
      );
      const handler = jasmine.createSpy('errorHandler');
      function originalHandler() {}
      globals.listeners.unhandledRejection = [originalHandler];

      errors.install();
      expect(globals.listeners.unhandledRejection).toEqual([
        jasmine.any(Function)
      ]);
      expect(globals.listeners.unhandledRejection).not.toEqual([
        originalHandler()
      ]);

      errors.pushListener(handler);

      dispatchEvent(globals.listeners, 'unhandledRejection', new Error('bar'));

      expect(handler).toHaveBeenCalledWith(new Error('bar'), undefined);
      expect(handler.calls.argsFor(0)[0].jasmineMessage).toBe(
        'Unhandled promise rejection: Error: bar'
      );

      errors.uninstall();

      expect(globals.listeners.unhandledRejection).toEqual([originalHandler]);
    })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':255,'endLine':255}","it('subscribes and unsubscribes from the rejectionHandled event', function() {
        function originalHandler() {}
        globals.global.process.on('rejectionHandled', originalHandler);
        errors.install();

        expect(globals.listeners.rejectionHandled).toEqual([
          jasmine.any(Function)
        ]);
        expect(globals.listeners.rejectionHandled).not.toEqual([
          originalHandler
        ]);

        errors.uninstall();
        expect(globals.listeners.rejectionHandled).toEqual([originalHandler]);
      })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':299,'endLine':299}","it('does not immediately report the rejection', function() {
          const handler = jasmine.createSpy('errorHandler');

          errors.install();
          errors.pushListener(handler);

          const promise = Promise.reject('nope');
          promise.catch(() => {});
          dispatchEvent(
            globals.listeners,
            'unhandledRejection',
            'nope',
            promise
          );

          expect(handler).not.toHaveBeenCalled();
        })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':318,'endLine':318}","it('reports rejections that have not been handled', function() {
            const handler = jasmine.createSpy('errorHandler');
            errors.install();
            errors.pushListener(handler);

            const reason = new Error('nope');
            const promise = Promise.reject(reason);
            promise.catch(() => {});
            dispatchEvent(
              globals.listeners,
              'unhandledRejection',
              reason,
              promise
            );
            errors.reportUnhandledRejections();

            expect(handler).toHaveBeenCalledWith(new Error('nope'), undefined);
            expect(handler.calls.argsFor(0)[0].jasmineMessage).toBe(
              'Unhandled promise rejection: Error: nope'
            );
          })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':340,'endLine':340}","it('does not report rejections that have been handled', function() {
            const handler = jasmine.createSpy('errorHandler');
            errors.install();
            errors.pushListener(handler);

            const reason = new Error('nope');
            const promise = Promise.reject(reason);
            promise.catch(() => {});
            dispatchEvent(
              globals.listeners,
              'unhandledRejection',
              reason,
              promise
            );
            dispatchEvent(globals.listeners, 'rejectionHandled', promise);
            errors.reportUnhandledRejections();

            expect(handler).not.toHaveBeenCalled();
          })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':360,'endLine':360}","it('does not report the same rejection on subsequent calls', function() {
            const handler = jasmine.createSpy('errorHandler');

            errors.install();
            errors.pushListener(handler);

            const promise = Promise.reject('nope');
            promise.catch(() => {});
            dispatchEvent(
              globals.listeners,
              'unhandledRejection',
              'nope',
              promise
            );
            errors.reportUnhandledRejections();
            expect(handler).toHaveBeenCalled();
            handler.calls.reset();

            errors.reportUnhandledRejections();
            expect(handler).not.toHaveBeenCalled();
          })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':486,'endLine':486}","it('does not immediately report the rejection', function() {
          const handler = jasmine.createSpy('errorHandler');

          errors.install();
          errors.pushListener(handler);

          const promise = Promise.reject('nope');
          promise.catch(() => {});
          dispatchEvent(globals.listeners, 'unhandledrejection', {
            reason: 'nope',
            promise
          });

          expect(handler).not.toHaveBeenCalled();
        })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':502,'endLine':502}","it('reports rejections that have not been handled', function() {
            const handler = jasmine.createSpy('errorHandler');
            errors.install();
            errors.pushListener(handler);

            const promise = Promise.reject('nope');
            promise.catch(() => {});
            dispatchEvent(globals.listeners, 'unhandledrejection', {
              reason: 'nope',
              promise
            });
            errors.reportUnhandledRejections();

            expect(handler).toHaveBeenCalledWith(
              'Unhandled promise rejection: nope',
              { reason: 'nope', promise }
            );
          })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':521,'endLine':521}","it('does not report rejections that have been handled', function() {
            const handler = jasmine.createSpy('errorHandler');
            errors.install();
            errors.pushListener(handler);

            const promise = Promise.reject('nope');
            promise.catch(() => {});
            dispatchEvent(globals.listeners, 'unhandledrejection', {
              reason: 'nope',
              promise
            });
            dispatchEvent(globals.listeners, 'rejectionhandled', { promise });
            errors.reportUnhandledRejections();

            expect(handler).not.toHaveBeenCalled();
          })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':539,'endLine':539}","it('does not report the same rejection on subsequent calls', function() {
            const handler = jasmine.createSpy('errorHandler');

            errors.install();
            errors.pushListener(handler);

            const promise = Promise.reject('nope');
            promise.catch(() => {});
            dispatchEvent(globals.listeners, 'unhandledrejection', {
              reason: 'nope',
              promise
            });
            errors.reportUnhandledRejections();
            expect(handler).toHaveBeenCalled();
            handler.calls.reset();

            errors.reportUnhandledRejections();
            expect(handler).not.toHaveBeenCalled();
          })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':609,'endLine':609}","it('overrides the existing handlers in browsers until removed', function() {
      const globals = browserGlobals();
      const handler0 = jasmine.createSpy('handler0');
      const handler1 = jasmine.createSpy('handler1');
      const overrideHandler = jasmine.createSpy('overrideHandler');
      const errors = new jasmineUnderTest.GlobalErrors(
        globals.global,
        () => ({})
      );

      errors.install();
      errors.pushListener(handler0);
      errors.setOverrideListener(overrideHandler, () => {});
      errors.pushListener(handler1);
      dispatchEvent(globals.listeners, 'error', { error: 'foo' });

      expect(overrideHandler).toHaveBeenCalledWith('foo');
      expect(handler0).not.toHaveBeenCalled();
      expect(handler1).not.toHaveBeenCalled();

      errors.removeOverrideListener();

      const event = { error: 'baz' };
      dispatchEvent(globals.listeners, 'error', event);
      expect(overrideHandler).not.toHaveBeenCalledWith('baz');
      expect(handler1).toHaveBeenCalledWith('baz', event);
    })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':665,'endLine':665}","it('handles unhandled promise rejections in browsers', function() {
      const globals = browserGlobals();
      const handler = jasmine.createSpy('handler');
      const overrideHandler = jasmine.createSpy('overrideHandler');
      const errors = new jasmineUnderTest.GlobalErrors(
        globals.global,
        () => ({})
      );

      errors.install();
      errors.pushListener(handler);
      errors.setOverrideListener(overrideHandler, () => {});

      const reason = new Error('bar');

      dispatchEvent(globals.listeners, 'unhandledrejection', { reason });

      expect(overrideHandler).toHaveBeenCalledWith(
        jasmine.objectContaining({
          jasmineMessage: 'Unhandled promise rejection: Error: bar',
          message: reason.message,
          stack: reason.stack
        })
      );
      expect(handler).not.toHaveBeenCalled();
    })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':693,'endLine':693}","it('handles unhandled promise rejections in Node', function() {
      const globals = nodeGlobals();
      const handler0 = jasmine.createSpy('handler0');
      const handler1 = jasmine.createSpy('handler1');
      const overrideHandler = jasmine.createSpy('overrideHandler');
      const errors = new jasmineUnderTest.GlobalErrors(
        globals.global,
        () => ({})
      );

      errors.install();
      errors.pushListener(handler0);
      errors.setOverrideListener(overrideHandler, () => {});
      errors.pushListener(handler1);

      dispatchEvent(globals.listeners, 'unhandledRejection', new Error('nope'));

      expect(overrideHandler).toHaveBeenCalledWith(new Error('nope'));
      expect(handler0).not.toHaveBeenCalled();
      expect(handler1).not.toHaveBeenCalled();
    })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':706,'endLine':706}","it('throws if there is already an override handler', function() {
      const errors = new jasmineUnderTest.GlobalErrors(browserGlobals().global);

      errors.setOverrideListener(() => {}, () => {});
      expect(function() {
        errors.setOverrideListener(() => {}, () => {});
      }).toThrowError(""Can't set more than one override listener at a time"");
    })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':706,'endLine':706}","it('throws if there is already an override handler', function() {
      const errors = new jasmineUnderTest.GlobalErrors(browserGlobals().global);

      errors.setOverrideListener(() => {}, () => {});
      expect(function() {
        errors.setOverrideListener(() => {}, () => {});
      }).toThrowError(""Can't set more than one override listener at a time"");
    })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':708,'endLine':708}","it('throws if there is already an override handler', function() {
      const errors = new jasmineUnderTest.GlobalErrors(browserGlobals().global);

      errors.setOverrideListener(() => {}, () => {});
      expect(function() {
        errors.setOverrideListener(() => {}, () => {});
      }).toThrowError(""Can't set more than one override listener at a time"");
    })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':708,'endLine':708}","it('throws if there is already an override handler', function() {
      const errors = new jasmineUnderTest.GlobalErrors(browserGlobals().global);

      errors.setOverrideListener(() => {}, () => {});
      expect(function() {
        errors.setOverrideListener(() => {}, () => {});
      }).toThrowError(""Can't set more than one override listener at a time"");
    })",snuts
/spec/core/GlobalErrorsSpec.js,NonFunctionalStatement,"{'startLine':718,'endLine':718}","it(""calls the handler's onRemove callback"", function() {
      const onRemove = jasmine.createSpy('onRemove');
      const errors = new jasmineUnderTest.GlobalErrors(browserGlobals().global);

      errors.setOverrideListener(() => {}, onRemove);
      errors.removeOverrideListener();

      expect(onRemove).toHaveBeenCalledWith();
    })",snuts
/spec/core/GlobalErrorsSpec.js,VerboseStatement,"{'startLine':133,'endLine':163}","it('reports uncaught exceptions in node.js', function() {
    const globals = nodeGlobals();
    const errors = new jasmineUnderTest.GlobalErrors(
      globals.global,
      () => ({})
    );
    const handler = jasmine.createSpy('errorHandler');
    function originalHandler() {}
    globals.listeners.uncaughtException = [originalHandler];

    errors.install();
    expect(globals.listeners.uncaughtException).toEqual([
      jasmine.any(Function)
    ]);
    expect(globals.listeners.uncaughtException).not.toEqual([
      originalHandler()
    ]);

    errors.pushListener(handler);

    dispatchEvent(globals.listeners, 'uncaughtException', new Error('bar'));

    expect(handler).toHaveBeenCalledWith(new Error('bar'), undefined);
    expect(handler.calls.argsFor(0)[0].jasmineMessage).toBe(
      'Uncaught exception: Error: bar'
    );

    errors.uninstall();

    expect(globals.listeners.uncaughtException).toEqual([originalHandler]);
  })",snuts
/spec/core/GlobalErrorsSpec.js,VerboseStatement,"{'startLine':166,'endLine':196}","it('reports rejections with `Error` reasons', function() {
      const globals = nodeGlobals();
      const errors = new jasmineUnderTest.GlobalErrors(
        globals.global,
        () => ({})
      );
      const handler = jasmine.createSpy('errorHandler');
      function originalHandler() {}
      globals.listeners.unhandledRejection = [originalHandler];

      errors.install();
      expect(globals.listeners.unhandledRejection).toEqual([
        jasmine.any(Function)
      ]);
      expect(globals.listeners.unhandledRejection).not.toEqual([
        originalHandler()
      ]);

      errors.pushListener(handler);

      dispatchEvent(globals.listeners, 'unhandledRejection', new Error('bar'));

      expect(handler).toHaveBeenCalledWith(new Error('bar'), undefined);
      expect(handler.calls.argsFor(0)[0].jasmineMessage).toBe(
        'Unhandled promise rejection: Error: bar'
      );

      errors.uninstall();

      expect(globals.listeners.unhandledRejection).toEqual([originalHandler]);
    })",snuts
/spec/core/GlobalErrorsSpec.js,VerboseStatement,"{'startLine':597,'endLine':623}","it('overrides the existing handlers in browsers until removed', function() {
      const globals = browserGlobals();
      const handler0 = jasmine.createSpy('handler0');
      const handler1 = jasmine.createSpy('handler1');
      const overrideHandler = jasmine.createSpy('overrideHandler');
      const errors = new jasmineUnderTest.GlobalErrors(
        globals.global,
        () => ({})
      );

      errors.install();
      errors.pushListener(handler0);
      errors.setOverrideListener(overrideHandler, () => {});
      errors.pushListener(handler1);
      dispatchEvent(globals.listeners, 'error', { error: 'foo' });

      expect(overrideHandler).toHaveBeenCalledWith('foo');
      expect(handler0).not.toHaveBeenCalled();
      expect(handler1).not.toHaveBeenCalled();

      errors.removeOverrideListener();

      const event = { error: 'baz' };
      dispatchEvent(globals.listeners, 'error', event);
      expect(overrideHandler).not.toHaveBeenCalledWith('baz');
      expect(handler1).toHaveBeenCalledWith('baz', event);
    })",snuts
/spec/core/GlobalErrorsSpec.js,VerboseStatement,"{'startLine':625,'endLine':652}","it('overrides the existing handlers in Node until removed', function() {
      const globals = nodeGlobals();
      const handler0 = jasmine.createSpy('handler0');
      const handler1 = jasmine.createSpy('handler1');
      const overrideHandler = jasmine.createSpy('overrideHandler');
      const errors = new jasmineUnderTest.GlobalErrors(
        globals.global,
        () => ({})
      );

      errors.install();
      errors.pushListener(handler0);
      errors.setOverrideListener(overrideHandler);
      errors.pushListener(handler1);

      dispatchEvent(globals.listeners, 'uncaughtException', new Error('foo'));

      expect(overrideHandler).toHaveBeenCalledWith(new Error('foo'));
      expect(handler0).not.toHaveBeenCalled();
      expect(handler1).not.toHaveBeenCalled();

      overrideHandler.calls.reset();
      errors.removeOverrideListener();

      dispatchEvent(globals.listeners, 'uncaughtException', new Error('bar'));
      expect(overrideHandler).not.toHaveBeenCalled();
      expect(handler1).toHaveBeenCalledWith(new Error('bar'), undefined);
    })",snuts
/spec/core/ExpectationSpec.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}","it('makes custom matchers available to this expectation', function() {
    const matchers = {
        toFoo: function() {},
        toBar: function() {}
      },
      expectation = jasmineUnderTest.Expectation.factory({
        customMatchers: matchers
      });

    expect(expectation.toFoo).toBeDefined();
    expect(expectation.toBar).toBeDefined();
  })",snuts
/spec/core/ExpectationSpec.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}","it('makes custom matchers available to this expectation', function() {
    const matchers = {
        toFoo: function() {},
        toBar: function() {}
      },
      expectation = jasmineUnderTest.Expectation.factory({
        customMatchers: matchers
      });

    expect(expectation.toFoo).toBeDefined();
    expect(expectation.toBar).toBeDefined();
  })",snuts
/spec/core/ExpectationSpec.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}","it('.addCoreMatchers makes matchers available to any expectation', function() {
    const coreMatchers = {
      toQuux: function() {}
    };

    jasmineUnderTest.Expectation.addCoreMatchers(coreMatchers);

    const expectation = jasmineUnderTest.Expectation.factory({});

    expect(expectation.toQuux).toBeDefined();
  })",snuts
/spec/core/ExpectationFilterChainSpec.js,AnonymousTest,"{'startLine':30,'endLine':34}","it('returns undefined', function() {
        const chain = new jasmineUnderTest.ExpectationFilterChain();
        chain.addFilter({});
        expect(chain.selectComparisonFunc()).toBeUndefined();
      })",snuts
/spec/core/ExpectationFilterChainSpec.js,AnonymousTest,"{'startLine':56,'endLine':60}","it('returns undefined', function() {
        const chain = new jasmineUnderTest.ExpectationFilterChain();
        chain.addFilter({});
        expect(chain.buildFailureMessage()).toBeUndefined();
      })",snuts
/spec/core/ExpectationFilterChainSpec.js,IdenticalTestDescription,"{'startLine':56,'endLine':60}","it('returns undefined', function() {
        const chain = new jasmineUnderTest.ExpectationFilterChain();
        chain.addFilter({});
        expect(chain.buildFailureMessage()).toBeUndefined();
      })",snuts
/spec/core/ExceptionsSpec.js,NonFunctionalStatement,"{'startLine':36,'endLine':36}","it('should handle exceptions thrown directly in top-level describe blocks and continue', async function() {
    const secondDescribe = jasmine
      .createSpy('second describe')
      .and.callFake(function() {
        env.it('has a test', function() {});
      });
    env.describe('a suite that throws an exception', function() {
      env.it('is a test that should pass', function() {
        this.expect(true).toEqual(true);
      });

      throw new Error('top level error');
    });
    env.describe(""a suite that doesn't throw an exception"", secondDescribe);

    await env.execute();

    expect(secondDescribe).toHaveBeenCalled();
  })",snuts
/spec/core/ExceptionFormatterSpec.js,ConditionalTestLogic,"{'startLine':185,'endLine':187}","it('filters Jasmine stack frames in this environment', function() {
      const error = new Error('an error');
      const subject = new jasmineUnderTest.ExceptionFormatter({
        jasmineFile: jasmine.util.jasmineFile()
      });
      const result = subject.stack(error);
      jasmine.debugLog('Original stack trace: ' + error.stack);
      jasmine.debugLog('Filtered stack trace: ' + result);
      const lines = result.split('\n');

      if (lines[0].match(/an error/)) {
        lines.shift();
      }

      expect(lines[0]).toMatch(/ExceptionFormatterSpec.js/);
      expect(lines[1]).toMatch(/<Jasmine>/);

      // Node has some number of additional frames below Jasmine.
      for (let i = 2; i < lines.length; i++) {
        expect(lines[i]).not.toMatch(/jasmine.js/);
      }
    })",snuts
/spec/core/ExceptionFormatterSpec.js,ConditionalTestLogic,"{'startLine':202,'endLine':204}","it('handles multiline error messages in this environment', function() {
      const msg = 'an error\nwith two lines';
      const error = new Error(msg);

      if (error.stack.indexOf(msg) === -1) {
        pending(""Stack traces don't have messages in this environment"");
      }
      const subject = new jasmineUnderTest.ExceptionFormatter({
        jasmineFile: jasmine.util.jasmineFile()
      });
      const result = subject.stack(error);
      const lines = result.split('\n');

      expect(lines[0]).toMatch(/an error/);
      expect(lines[1]).toMatch(/with two lines/);
      expect(lines[2]).toMatch(/ExceptionFormatterSpec.js/);
      expect(lines[3]).toMatch(/<Jasmine>/);
    })",snuts
/spec/core/ExceptionFormatterSpec.js,NonFunctionalStatement,"{'startLine':54,'endLine':54}","it('formats empty exceptions with toString format', function() {
      const EmptyError = function() {};
      EmptyError.prototype.toString = function() {
        return '[EmptyError]';
      };
      const emptyError = new EmptyError();

      const exceptionFormatter = new jasmineUnderTest.ExceptionFormatter(),
        message = exceptionFormatter.message(emptyError);

      expect(message).toEqual('[EmptyError] thrown');
    })",snuts
/spec/core/ExceptionFormatterSpec.js,NonFunctionalStatement,"{'startLine':335,'endLine':335}","it('does not throw if cause is a non Error', function() {
        const formatter = new jasmineUnderTest.ExceptionFormatter();

        expect(function() {
          formatter.stack(
            new Error('error', {
              cause: function() {}
            })
          );
        }).not.toThrowError();

        expect(function() {
          formatter.stack(
            new Error('error', {
              cause: 'another error'
            })
          );
        }).not.toThrowError();
      })",snuts
/spec/core/ExceptionFormatterSpec.js,VerboseStatement,"{'startLine':295,'endLine':327}","it('recursively includes the cause in the stack trace in this environment', function() {
        const subject = new jasmineUnderTest.ExceptionFormatter();
        const rootCause = new Error('root cause');
        const proximateCause = new Error('proximate cause', {
          cause: rootCause
        });
        const symptom = new Error('symptom', { cause: proximateCause });

        const lines = subject.stack(symptom).split('\n');
        // Not all environments include the message in the stack trace.
        const hasRootMessage = lines[0].indexOf('symptom') !== -1;
        const firstSymptomStackIx = hasRootMessage ? 1 : 0;

        expect(lines[firstSymptomStackIx])
          .withContext('first symptom stack frame')
          .toContain('ExceptionFormatterSpec.js');
        const proximateCauseMsgIx = lines.indexOf(
          'Caused by: Error: proximate cause'
        );
        expect(proximateCauseMsgIx)
          .withContext('index of proximate cause message')
          .toBeGreaterThan(firstSymptomStackIx);
        expect(lines[proximateCauseMsgIx + 1])
          .withContext('first proximate cause stack frame')
          .toContain('ExceptionFormatterSpec.js');
        const rootCauseMsgIx = lines.indexOf('Caused by: Error: root cause');
        expect(rootCauseMsgIx)
          .withContext('index of root cause message')
          .toBeGreaterThan(proximateCauseMsgIx + 1);
        expect(lines[rootCauseMsgIx + 1])
          .withContext('first root cause stack frame')
          .toContain('ExceptionFormatterSpec.js');
      })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':308,'endLine':314}","it('throws an error when it receives a non-fn argument', function() {
      expect(function() {
        env.it('undefined arg', null);
      }).toThrowError(
        /it expects a function argument; received \[object (Null|DOMWindow|Object)\]/
      );
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':359,'endLine':365}","it('throws an error when it receives a non-fn argument', function() {
      expect(function() {
        env.xit('undefined arg', null);
      }).toThrowError(
        /xit expects a function argument; received \[object (Null|DOMWindow|Object)\]/
      );
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':367,'endLine':371}","it('does not throw when it is not given a fn argument', function() {
      expect(function() {
        env.xit('pending spec');
      }).not.toThrow();
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':373,'endLine':377}","it('accepts an async function', function() {
      expect(function() {
        env.xit('async', async function() {});
      }).not.toThrow();
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':383,'endLine':389}","it('throws an error when it receives a non-fn argument', function() {
      expect(function() {
        env.fit('undefined arg', undefined);
      }).toThrowError(
        /fit expects a function argument; received \[object (Undefined|DOMWindow|Object)\]/
      );
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':391,'endLine':395}","it('throws an error when the timeout value is too large for setTimeout', function() {
      expect(function() {
        env.fit('huge timeout', function() {}, 2147483648);
      }).toThrowError('Timeout value cannot be greater than 2147483647');
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':397,'endLine':402}","it('throws an error in parallel mode', function() {
      env.setParallelLoadingState('specs');
      expect(function() {
        env.fit('a spec', function() {});
      }).toThrowError(""'fit' is not available in parallel mode"");
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':406,'endLine':412}","it('throws an error when it receives a non-fn argument', function() {
      expect(function() {
        env.beforeEach(undefined);
      }).toThrowError(
        /beforeEach expects a function argument; received \[object (Undefined|DOMWindow|Object)\]/
      );
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':414,'endLine':418}","it('accepts an async function', function() {
      expect(function() {
        env.beforeEach(async function() {});
      }).not.toThrow();
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':420,'endLine':424}","it('throws an error when the timeout value is too large for setTimeout', function() {
      expect(function() {
        env.beforeEach(function() {}, 2147483648);
      }).toThrowError('Timeout value cannot be greater than 2147483647');
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':450,'endLine':456}","it('throws an error when it receives a non-fn argument', function() {
      expect(function() {
        env.beforeAll(undefined);
      }).toThrowError(
        /beforeAll expects a function argument; received \[object (Undefined|DOMWindow|Object)\]/
      );
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':458,'endLine':462}","it('accepts an async function', function() {
      expect(function() {
        env.beforeAll(async function() {});
      }).not.toThrow();
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':464,'endLine':468}","it('throws an error when the timeout value is too large for setTimeout', function() {
      expect(function() {
        env.beforeAll(function() {}, 2147483648);
      }).toThrowError('Timeout value cannot be greater than 2147483647');
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':513,'endLine':519}","it('throws an error when it receives a non-fn argument', function() {
      expect(function() {
        env.afterEach(undefined);
      }).toThrowError(
        /afterEach expects a function argument; received \[object (Undefined|DOMWindow|Object)\]/
      );
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':521,'endLine':525}","it('accepts an async function', function() {
      expect(function() {
        env.afterEach(async function() {});
      }).not.toThrow();
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':527,'endLine':531}","it('throws an error when the timeout value is too large for setTimeout', function() {
      expect(function() {
        env.afterEach(function() {}, 2147483648);
      }).toThrowError('Timeout value cannot be greater than 2147483647');
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':533,'endLine':540}","it('throws when called at the top level in a spec file in parallel mode', function() {
      env.setParallelLoadingState('specs');
      expect(function() {
        env.afterEach(function() {});
      }).toThrowError(
        'In parallel mode, afterEach must be in a describe block or in a helper file'
      );
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':542,'endLine':545}","it('does not throw when called at the top level in a helper file in parallel mode', function() {
      env.setParallelLoadingState('helpers');
      env.afterEach(function() {});
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':547,'endLine':553}","it('does not throw when called in a describe in a spec file in parallel mode', function() {
      env.setParallelLoadingState('specs');
      env.describe('a suite', function() {
        env.afterEach(function() {});
        env.it('a spec');
      });
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':557,'endLine':563}","it('throws an error when it receives a non-fn argument', function() {
      expect(function() {
        env.afterAll(undefined);
      }).toThrowError(
        /afterAll expects a function argument; received \[object (Undefined|DOMWindow|Object)\]/
      );
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':565,'endLine':569}","it('accepts an async function', function() {
      expect(function() {
        env.afterAll(async function() {});
      }).not.toThrow();
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':571,'endLine':575}","it('throws an error when the timeout value is too large for setTimeout', function() {
      expect(function() {
        env.afterAll(function() {}, 2147483648);
      }).toThrowError('Timeout value cannot be greater than 2147483647');
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':578,'endLine':593}","it('throws an error when called at the top level', function() {
        env.setParallelLoadingState('helpers');
        check();
        env.setParallelLoadingState('specs');
        check();

        function check() {
          expect(function() {
            env.afterAll(function() {});
          }).toThrowError(
            ""In parallel mode, 'afterAll' must be in a describe block. "" +
              'Use the globalTeardown config property for exactly-once ' +
              'teardown in parallel mode.'
          );
        }
      })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':595,'endLine':615}","it('does not throw an error when called in a describe', function() {
        env.setParallelLoadingState('helpers');
        check();
        env.setParallelLoadingState('specs');
        check();

        function check() {
          let done = false;

          env.describe('a suite', function() {
            expect(function() {
              env.it('a spec');
              env.afterAll(function() {});
            }).not.toThrow();

            done = true;
          });

          expect(done).toBeTrue();
        }
      })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':814,'endLine':824}","it('throws when called in parallel mode', function() {
      env.setParallelLoadingState('helpers');
      expect(function() {
        env.clearReporters();
      }).toThrowError('Reporters cannot be removed via Env in parallel mode');

      env.setParallelLoadingState('specs');
      expect(function() {
        env.clearReporters();
      }).toThrowError('Reporters cannot be removed via Env in parallel mode');
    })",snuts
/spec/core/EnvSpec.js,IdenticalTestDescription,"{'startLine':828,'endLine':838}","it('throws when called in parallel mode', function() {
      env.setParallelLoadingState('helpers');
      expect(function() {
        env.configure({});
      }).toThrowError('Jasmine cannot be configured via Env in parallel mode');

      env.setParallelLoadingState('specs');
      expect(function() {
        env.configure({});
      }).toThrowError('Jasmine cannot be configured via Env in parallel mode');
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':106,'endLine':106}","it('can configure specs to throw errors on expectation failures', function() {
    env.configure({ stopSpecOnExpectationFailure: true });

    spyOn(jasmineUnderTest, 'Spec').and.callThrough();
    env.it('foo', function() {});
    expect(jasmineUnderTest.Spec).toHaveBeenCalledWith(
      jasmine.objectContaining({
        throwOnExpectationFailure: true
      })
    );
  })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':118,'endLine':118}","it('can configure suites to throw errors on expectation failures', function() {
    env.configure({ stopSpecOnExpectationFailure: true });

    spyOn(jasmineUnderTest, 'Suite');
    env.describe('foo', function() {});
    expect(jasmineUnderTest.Suite).toHaveBeenCalledWith(
      jasmine.objectContaining({
        throwOnExpectationFailure: true
      })
    );
  })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':154,'endLine':154}","it('defaults to multiple failures for specs', function() {
    spyOn(jasmineUnderTest, 'Spec').and.callThrough();
    env.it('bar', function() {});
    expect(jasmineUnderTest.Spec).toHaveBeenCalledWith(
      jasmine.objectContaining({
        throwOnExpectationFailure: false
      })
    );
  })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':164,'endLine':164}","it('defaults to multiple failures for suites', function() {
    spyOn(jasmineUnderTest, 'Suite');
    env.describe('foo', function() {});
    expect(jasmineUnderTest.Suite).toHaveBeenCalledWith(
      jasmine.objectContaining({
        throwOnExpectationFailure: false
      })
    );
  })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':208,'endLine':208}","it('throws an error when given arguments', function() {
      expect(function() {
        env.describe('done method', function(done) {});
      }).toThrowError('describe does not expect any arguments');
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':242,'endLine':242}","it('throws an error when it receives a non-fn argument', function() {
      // Some versions of PhantomJS return [object DOMWindow] when
      // Object.prototype.toString.apply is called with `undefined` or `null`.
      // In a similar fashion, IE8 gives [object Object] for both `undefined`
      // and `null`. We mostly just want these tests to check that using
      // anything other than a function throws an error.
      expect(function() {
        env.describe('undefined arg', undefined);
      }).toThrowError(
        /describe expects a function argument; received \[object (Undefined|DOMWindow|Object)\]/
      );
      expect(function() {
        env.describe('null arg', null);
      }).toThrowError(
        /describe expects a function argument; received \[object (Null|DOMWindow|Object)\]/
      );

      expect(function() {
        env.describe('array arg', []);
      }).toThrowError(
        'describe expects a function argument; received [object Array]'
      );
      expect(function() {
        env.describe('object arg', {});
      }).toThrowError(
        'describe expects a function argument; received [object Object]'
      );

      expect(function() {
        env.describe('fn arg', function() {
          env.it('has a spec', function() {});
        });
      }).not.toThrowError(
        'describe expects a function argument; received [object Function]'
      );
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':253,'endLine':253}","it('throws an error when it has no children', function() {
      let ran = false;
      env.describe('parent suite', function() {
        expect(function() {
          env.describe('child suite', function() {});
        }).toThrowError(
          'describe with no children (describe() or it()): parent suite child suite'
        );
        ran = true;
      });

      expect(ran).toBeTrue();
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':286,'endLine':286}","it('returns a spec metadata object', function() {
      let spec;

      env.describe('a suite', function() {
        spec = env[methodName]('a spec', function() {});
      });

      expect(spec.description)
        .withContext('description')
        .toEqual('a spec');
      expect(spec.getFullName())
        .withContext('getFullName')
        .toEqual('a suite a spec');
      expect(spec.id)
        .withContext('id')
        .toBeInstanceOf(String);
      expect(spec.id)
        .withContext('id')
        .not.toEqual('');
      expect(spec.pend).toBeFalsy();
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':324,'endLine':324}","it('accepts an async function', function() {
      expect(function() {
        env.it('async', async function() {});
      }).not.toThrow();
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':330,'endLine':330}","it('throws an error when the timeout value is too large for setTimeout', function() {
      expect(function() {
        env.it('huge timeout', function() {}, 2147483648);
      }).toThrowError('Timeout value cannot be greater than 2147483647');
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':343,'endLine':343}","it('calls spec.exclude with ""Temporarily disabled with xit""', function() {
      const excludeSpy = jasmine.createSpy();
      spyOn(jasmineUnderTest.SuiteBuilder.prototype, 'it_').and.returnValue({
        exclude: excludeSpy
      });
      env.xit('foo', function() {});
      expect(excludeSpy).toHaveBeenCalledWith('Temporarily disabled with xit');
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':355,'endLine':355}","it('calls spec.pend with ""Temporarily disabled with xit""', function() {
      const pendSpy = jasmine.createSpy();
      const realExclude = jasmineUnderTest.Spec.prototype.exclude;

      spyOn(jasmineUnderTest.SuiteBuilder.prototype, 'it_').and.returnValue({
        exclude: realExclude,
        pend: pendSpy
      });
      env.xit('foo', function() {});
      expect(pendSpy).toHaveBeenCalledWith('Temporarily disabled with xit');
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':375,'endLine':375}","it('accepts an async function', function() {
      expect(function() {
        env.xit('async', async function() {});
      }).not.toThrow();
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':393,'endLine':393}","it('throws an error when the timeout value is too large for setTimeout', function() {
      expect(function() {
        env.fit('huge timeout', function() {}, 2147483648);
      }).toThrowError('Timeout value cannot be greater than 2147483647');
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':400,'endLine':400}","it('throws an error in parallel mode', function() {
      env.setParallelLoadingState('specs');
      expect(function() {
        env.fit('a spec', function() {});
      }).toThrowError(""'fit' is not available in parallel mode"");
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':416,'endLine':416}","it('accepts an async function', function() {
      expect(function() {
        env.beforeEach(async function() {});
      }).not.toThrow();
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':422,'endLine':422}","it('throws an error when the timeout value is too large for setTimeout', function() {
      expect(function() {
        env.beforeEach(function() {}, 2147483648);
      }).toThrowError('Timeout value cannot be greater than 2147483647');
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':429,'endLine':429}","it('throws when called at the top level in a spec file in parallel mode', function() {
      env.setParallelLoadingState('specs');
      expect(function() {
        env.beforeEach(function() {});
      }).toThrowError(
        'In parallel mode, beforeEach must be in a describe block or in a helper file'
      );
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':437,'endLine':437}","it('does not throw when called at the top level in a helper file in parallel mode', function() {
      env.setParallelLoadingState('helpers');
      env.beforeEach(function() {});
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':443,'endLine':443}","it('does not throw when called in a describe in a spec file in parallel mode', function() {
      env.setParallelLoadingState('specs');
      env.describe('a suite', function() {
        env.beforeEach(function() {});
        env.it('a spec');
      });
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':460,'endLine':460}","it('accepts an async function', function() {
      expect(function() {
        env.beforeAll(async function() {});
      }).not.toThrow();
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':466,'endLine':466}","it('throws an error when the timeout value is too large for setTimeout', function() {
      expect(function() {
        env.beforeAll(function() {}, 2147483648);
      }).toThrowError('Timeout value cannot be greater than 2147483647');
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':479,'endLine':479}","it('throws an error when called at the top level', function() {
        env.setParallelLoadingState('helpers');
        check();
        env.setParallelLoadingState('specs');
        check();

        function check() {
          expect(function() {
            env.beforeAll(function() {});
          }).toThrowError(
            ""In parallel mode, 'beforeAll' must be in a describe block. "" +
              'Use the globalSetup config property for exactly-once setup in' +
              ' parallel mode.'
          );
        }
      })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':500,'endLine':500}","it('does not throw an error when called in a describe', function() {
        env.setParallelLoadingState('helpers');
        check();
        env.setParallelLoadingState('specs');
        check();

        function check() {
          let done = false;

          env.describe('a suite', function() {
            expect(function() {
              env.it('a spec');
              env.beforeAll(function() {});
            }).not.toThrow();

            done = true;
          });

          expect(done).toBeTrue();
        }
      })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':523,'endLine':523}","it('accepts an async function', function() {
      expect(function() {
        env.afterEach(async function() {});
      }).not.toThrow();
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':529,'endLine':529}","it('throws an error when the timeout value is too large for setTimeout', function() {
      expect(function() {
        env.afterEach(function() {}, 2147483648);
      }).toThrowError('Timeout value cannot be greater than 2147483647');
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':536,'endLine':536}","it('throws when called at the top level in a spec file in parallel mode', function() {
      env.setParallelLoadingState('specs');
      expect(function() {
        env.afterEach(function() {});
      }).toThrowError(
        'In parallel mode, afterEach must be in a describe block or in a helper file'
      );
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':544,'endLine':544}","it('does not throw when called at the top level in a helper file in parallel mode', function() {
      env.setParallelLoadingState('helpers');
      env.afterEach(function() {});
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':550,'endLine':550}","it('does not throw when called in a describe in a spec file in parallel mode', function() {
      env.setParallelLoadingState('specs');
      env.describe('a suite', function() {
        env.afterEach(function() {});
        env.it('a spec');
      });
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':567,'endLine':567}","it('accepts an async function', function() {
      expect(function() {
        env.afterAll(async function() {});
      }).not.toThrow();
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':573,'endLine':573}","it('throws an error when the timeout value is too large for setTimeout', function() {
      expect(function() {
        env.afterAll(function() {}, 2147483648);
      }).toThrowError('Timeout value cannot be greater than 2147483647');
    })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':586,'endLine':586}","it('throws an error when called at the top level', function() {
        env.setParallelLoadingState('helpers');
        check();
        env.setParallelLoadingState('specs');
        check();

        function check() {
          expect(function() {
            env.afterAll(function() {});
          }).toThrowError(
            ""In parallel mode, 'afterAll' must be in a describe block. "" +
              'Use the globalTeardown config property for exactly-once ' +
              'teardown in parallel mode.'
          );
        }
      })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':607,'endLine':607}","it('does not throw an error when called in a describe', function() {
        env.setParallelLoadingState('helpers');
        check();
        env.setParallelLoadingState('specs');
        check();

        function check() {
          let done = false;

          env.describe('a suite', function() {
            expect(function() {
              env.it('a spec');
              env.afterAll(function() {});
            }).not.toThrow();

            done = true;
          });

          expect(done).toBeTrue();
        }
      })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':661,'endLine':661}","it('creates an expectationFactory that uses the current custom equality testers and object formatters', async function() {
    function customEqualityTester() {}
    function customObjectFormatter() {}
    function prettyPrinter() {}
    const RealSpec = jasmineUnderTest.Spec;
    let specInstance;
    let expectationFactory;
    spyOn(jasmineUnderTest, 'MatchersUtil');
    spyOn(jasmineUnderTest, 'makePrettyPrinter').and.returnValue(prettyPrinter);
    spyOn(jasmineUnderTest, 'Spec').and.callFake(function(options) {
      expectationFactory = options.expectationFactory;
      specInstance = new RealSpec(options);
      return specInstance;
    });

    env.it('spec', function() {
      env.addCustomEqualityTester(customEqualityTester);
      env.addCustomObjectFormatter(customObjectFormatter);
      expectationFactory('actual', specInstance);
    });

    await env.execute();
    expect(jasmineUnderTest.makePrettyPrinter).toHaveBeenCalledWith([
      customObjectFormatter
    ]);
    expect(jasmineUnderTest.MatchersUtil).toHaveBeenCalledWith({
      customTesters: [customEqualityTester],
      pp: prettyPrinter
    });
  })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':662,'endLine':662}","it('creates an expectationFactory that uses the current custom equality testers and object formatters', async function() {
    function customEqualityTester() {}
    function customObjectFormatter() {}
    function prettyPrinter() {}
    const RealSpec = jasmineUnderTest.Spec;
    let specInstance;
    let expectationFactory;
    spyOn(jasmineUnderTest, 'MatchersUtil');
    spyOn(jasmineUnderTest, 'makePrettyPrinter').and.returnValue(prettyPrinter);
    spyOn(jasmineUnderTest, 'Spec').and.callFake(function(options) {
      expectationFactory = options.expectationFactory;
      specInstance = new RealSpec(options);
      return specInstance;
    });

    env.it('spec', function() {
      env.addCustomEqualityTester(customEqualityTester);
      env.addCustomObjectFormatter(customObjectFormatter);
      expectationFactory('actual', specInstance);
    });

    await env.execute();
    expect(jasmineUnderTest.makePrettyPrinter).toHaveBeenCalledWith([
      customObjectFormatter
    ]);
    expect(jasmineUnderTest.MatchersUtil).toHaveBeenCalledWith({
      customTesters: [customEqualityTester],
      pp: prettyPrinter
    });
  })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':663,'endLine':663}","it('creates an expectationFactory that uses the current custom equality testers and object formatters', async function() {
    function customEqualityTester() {}
    function customObjectFormatter() {}
    function prettyPrinter() {}
    const RealSpec = jasmineUnderTest.Spec;
    let specInstance;
    let expectationFactory;
    spyOn(jasmineUnderTest, 'MatchersUtil');
    spyOn(jasmineUnderTest, 'makePrettyPrinter').and.returnValue(prettyPrinter);
    spyOn(jasmineUnderTest, 'Spec').and.callFake(function(options) {
      expectationFactory = options.expectationFactory;
      specInstance = new RealSpec(options);
      return specInstance;
    });

    env.it('spec', function() {
      env.addCustomEqualityTester(customEqualityTester);
      env.addCustomObjectFormatter(customObjectFormatter);
      expectationFactory('actual', specInstance);
    });

    await env.execute();
    expect(jasmineUnderTest.makePrettyPrinter).toHaveBeenCalledWith([
      customObjectFormatter
    ]);
    expect(jasmineUnderTest.MatchersUtil).toHaveBeenCalledWith({
      customTesters: [customEqualityTester],
      pp: prettyPrinter
    });
  })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':692,'endLine':692}","it('creates an asyncExpectationFactory that uses the current custom equality testers and object formatters', async function() {
    function customEqualityTester() {}
    function customObjectFormatter() {}
    function prettyPrinter() {}
    const RealSpec = jasmineUnderTest.Spec;
    let specInstance;
    let asyncExpectationFactory;
    spyOn(jasmineUnderTest, 'MatchersUtil');
    spyOn(jasmineUnderTest, 'makePrettyPrinter').and.returnValue(prettyPrinter);
    spyOn(jasmineUnderTest, 'Spec').and.callFake(function(options) {
      asyncExpectationFactory = options.asyncExpectationFactory;
      specInstance = new RealSpec(options);
      return specInstance;
    });

    env.it('spec', function() {
      env.addCustomEqualityTester(customEqualityTester);
      env.addCustomObjectFormatter(customObjectFormatter);
      asyncExpectationFactory('actual', specInstance);
    });

    await env.execute();

    expect(jasmineUnderTest.makePrettyPrinter).toHaveBeenCalledWith([
      customObjectFormatter
    ]);
    expect(jasmineUnderTest.MatchersUtil).toHaveBeenCalledWith({
      customTesters: [customEqualityTester],
      pp: prettyPrinter
    });
  })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':693,'endLine':693}","it('creates an asyncExpectationFactory that uses the current custom equality testers and object formatters', async function() {
    function customEqualityTester() {}
    function customObjectFormatter() {}
    function prettyPrinter() {}
    const RealSpec = jasmineUnderTest.Spec;
    let specInstance;
    let asyncExpectationFactory;
    spyOn(jasmineUnderTest, 'MatchersUtil');
    spyOn(jasmineUnderTest, 'makePrettyPrinter').and.returnValue(prettyPrinter);
    spyOn(jasmineUnderTest, 'Spec').and.callFake(function(options) {
      asyncExpectationFactory = options.asyncExpectationFactory;
      specInstance = new RealSpec(options);
      return specInstance;
    });

    env.it('spec', function() {
      env.addCustomEqualityTester(customEqualityTester);
      env.addCustomObjectFormatter(customObjectFormatter);
      asyncExpectationFactory('actual', specInstance);
    });

    await env.execute();

    expect(jasmineUnderTest.makePrettyPrinter).toHaveBeenCalledWith([
      customObjectFormatter
    ]);
    expect(jasmineUnderTest.MatchersUtil).toHaveBeenCalledWith({
      customTesters: [customEqualityTester],
      pp: prettyPrinter
    });
  })",snuts
/spec/core/EnvSpec.js,NonFunctionalStatement,"{'startLine':694,'endLine':694}","it('creates an asyncExpectationFactory that uses the current custom equality testers and object formatters', async function() {
    function customEqualityTester() {}
    function customObjectFormatter() {}
    function prettyPrinter() {}
    const RealSpec = jasmineUnderTest.Spec;
    let specInstance;
    let asyncExpectationFactory;
    spyOn(jasmineUnderTest, 'MatchersUtil');
    spyOn(jasmineUnderTest, 'makePrettyPrinter').and.returnValue(prettyPrinter);
    spyOn(jasmineUnderTest, 'Spec').and.callFake(function(options) {
      asyncExpectationFactory = options.asyncExpectationFactory;
      specInstance = new RealSpec(options);
      return specInstance;
    });

    env.it('spec', function() {
      env.addCustomEqualityTester(customEqualityTester);
      env.addCustomObjectFormatter(customObjectFormatter);
      asyncExpectationFactory('actual', specInstance);
    });

    await env.execute();

    expect(jasmineUnderTest.makePrettyPrinter).toHaveBeenCalledWith([
      customObjectFormatter
    ]);
    expect(jasmineUnderTest.MatchersUtil).toHaveBeenCalledWith({
      customTesters: [customEqualityTester],
      pp: prettyPrinter
    });
  })",snuts
/spec/core/EnvSpec.js,VerboseStatement,"{'startLine':29,'endLine':82}","it('returns an object that describes the tree of suites and specs', function() {
      spyOn(env, 'deprecated');

      env.it('a top level spec');
      env.describe('a suite', function() {
        env.it('a spec');
        env.describe('a nested suite', function() {
          env.it('a nested spec');
        });
      });

      const suite = env.topSuite();
      expect(suite).not.toBeInstanceOf(jasmineUnderTest.Suite);
      expect(suite.description).toEqual('Jasmine__TopLevel__Suite');
      expect(suite.getFullName()).toEqual('');
      expect(suite.children.length).toEqual(2);

      expect(suite.children[0]).not.toBeInstanceOf(jasmineUnderTest.Spec);
      expect(suite.children[0].description).toEqual('a top level spec');
      expect(suite.children[0].getFullName()).toEqual('a top level spec');
      expect(suite.children[0].children).toBeFalsy();

      expect(suite.children[1]).not.toBeInstanceOf(jasmineUnderTest.Suite);
      expect(suite.children[1].description).toEqual('a suite');
      expect(suite.children[1].getFullName()).toEqual('a suite');
      expect(suite.children[1].parentSuite).toBe(suite);
      expect(suite.children[1].children.length).toEqual(2);

      expect(suite.children[1].children[0]).not.toBeInstanceOf(
        jasmineUnderTest.Spec
      );
      expect(suite.children[1].children[0].description).toEqual('a spec');
      expect(suite.children[1].children[0].getFullName()).toEqual(
        'a suite a spec'
      );
      expect(suite.children[1].children[0].children).toBeFalsy();

      expect(suite.children[1].children[1].description).toEqual(
        'a nested suite'
      );
      expect(suite.children[1].children[1].getFullName()).toEqual(
        'a suite a nested suite'
      );
      expect(suite.children[1].children[1].parentSuite).toBe(suite.children[1]);
      expect(suite.children[1].children[1].children.length).toEqual(1);

      expect(suite.children[1].children[1].children[0].description).toEqual(
        'a nested spec'
      );
      expect(suite.children[1].children[1].children[0].getFullName()).toEqual(
        'a suite a nested suite a nested spec'
      );
      expect(suite.children[1].children[1].children[0].children).toBeFalsy();
    })",snuts
/spec/core/EnvSpec.js,VerboseStatement,"{'startLine':173,'endLine':200}","it('returns a suite metadata object', function() {
      let innerSuite;
      let spec;
      const suite = env[methodName]('outer suite', function() {
        innerSuite = env[methodName]('inner suite', function() {
          spec = env.it('a spec');
        });
      });

      expect(suite.parentSuite).toEqual(
        jasmine.objectContaining({
          description: 'Jasmine__TopLevel__Suite'
        })
      );
      expect(suite.parentSuite.pend).toBeUndefined();
      expect(suite.pend).toBeUndefined();
      expect(suite.description).toEqual('outer suite');
      expect(suite.getFullName()).toEqual('outer suite');
      expect(suite.id).toBeInstanceOf(String);
      expect(suite.id).not.toEqual('');
      expect(suite.children.length).toEqual(1);
      expect(suite.children[0]).toBe(innerSuite);
      expect(innerSuite.children.length).toEqual(1);
      expect(innerSuite.children[0]).toBe(spec);
      expect(innerSuite.getFullName()).toEqual('outer suite inner suite');
      expect(innerSuite.parentSuite).toBe(suite);
      expect(spec.getFullName()).toEqual('outer suite inner suite a spec');
    })",snuts
/spec/core/DeprecatorSpec.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}","it('logs the mesage without context when the runnable is the top suite', function() {
      const runnable = { addDeprecationWarning: function() {} };
      const deprecator = new jasmineUnderTest.Deprecator(runnable);
      deprecator.verboseDeprecations(true);

      deprecator.addDeprecationWarning(runnable, 'the message', {
        omitStackTrace: true
      });

      expect(console.error).toHaveBeenCalledWith('DEPRECATION: the message');
    })",snuts
/spec/core/DeprecatorSpec.js,NonFunctionalStatement,"{'startLine':22,'endLine':22}","it('logs the message in a descendant suite', function() {
      const runnable = {
        addDeprecationWarning: function() {},
        getFullName: function() {
          return 'the suite';
        },
        children: []
      };
      const deprecator = new jasmineUnderTest.Deprecator({});
      deprecator.verboseDeprecations(true);

      deprecator.addDeprecationWarning(runnable, 'the message', {
        omitStackTrace: true
      });

      expect(console.error).toHaveBeenCalledWith(
        'DEPRECATION: the message (in suite: the suite)'
      );
    })",snuts
/spec/core/DeprecatorSpec.js,NonFunctionalStatement,"{'startLine':42,'endLine':42}","it('logs and reports the message in a spec', function() {
      const runnable = {
        addDeprecationWarning: function() {},
        getFullName: function() {
          return 'the spec';
        }
      };
      const deprecator = new jasmineUnderTest.Deprecator({});
      deprecator.verboseDeprecations(true);

      deprecator.addDeprecationWarning(runnable, 'the message', {
        omitStackTrace: true
      });

      expect(console.error).toHaveBeenCalledWith(
        'DEPRECATION: the message (in spec: the spec)'
      );
    })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,ConditionalTestLogic,"{'startLine':118,'endLine':120}","it('executes recurring functions interleaved with regular functions in the correct order', function() {
    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler();
    const fn = jasmine.createSpy('fn');
    let recurringCallCount = 0;
    const recurring = jasmine.createSpy('recurring').and.callFake(function() {
      recurringCallCount++;
      if (recurringCallCount < 5) {
        expect(fn).not.toHaveBeenCalled();
      }
    });

    scheduler.scheduleFunction(recurring, 10, [], true);
    scheduler.scheduleFunction(fn, 50);

    scheduler.tick(60);

    expect(recurring).toHaveBeenCalled();
    expect(recurring.calls.count()).toBe(6);
    expect(fn).toHaveBeenCalled();
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,ConditionalTestLogic,"{'startLine':173,'endLine':175}","it('executes recurring functions interleaved with regular functions and functions scheduled during a tick in the correct order', function() {
    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler();
    const fn = jasmine.createSpy('fn');
    let recurringCallCount = 0;
    const recurring = jasmine.createSpy('recurring').and.callFake(function() {
      recurringCallCount++;
      if (recurringCallCount < 5) {
        expect(fn).not.toHaveBeenCalled();
      }
    });
    const innerFn = jasmine.createSpy('innerFn').and.callFake(function() {
      expect(recurring.calls.count()).toBe(4);
      expect(fn).not.toHaveBeenCalled();
    });
    const scheduling = jasmine.createSpy('scheduling').and.callFake(function() {
      expect(recurring.calls.count()).toBe(3);
      expect(fn).not.toHaveBeenCalled();
      scheduler.scheduleFunction(innerFn, 10); // 41ms absolute
    });

    scheduler.scheduleFunction(recurring, 10, [], true);
    scheduler.scheduleFunction(fn, 50);
    scheduler.scheduleFunction(scheduling, 31);

    scheduler.tick(60);

    expect(recurring).toHaveBeenCalled();
    expect(recurring.calls.count()).toBe(6);
    expect(fn).toHaveBeenCalled();
    expect(scheduling).toHaveBeenCalled();
    expect(innerFn).toHaveBeenCalled();
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,ConditionalTestLogic,"{'startLine':322,'endLine':324}","it('does not conflict with native timer IDs', function() {
    const NODE_JS =
      typeof process !== 'undefined' &&
      process.versions &&
      typeof process.versions.node === 'string';
    if (NODE_JS) {
      pending('numeric timer ID conflicts only relevant for browsers.');
    }
    const nativeTimeoutId = setTimeout(function() {}, 100);

    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler();
    const fn = jasmine.createSpy('fn');

    for (let i = 0; i < nativeTimeoutId; i++) {
      scheduler.scheduleFunction(fn, 0, [], false);
    }
    scheduler.removeFunctionWithId(nativeTimeoutId);
    scheduler.tick(1);

    expect(fn).toHaveBeenCalledTimes(nativeTimeoutId);
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,NonFunctionalStatement,"{'startLine':89,'endLine':89}","it('increments scheduled fns ids unless one is passed', function() {
    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler();

    const initial = scheduler.scheduleFunction(function() {}, 0);
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 1);
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 2);
    expect(scheduler.scheduleFunction(function() {}, 0, [], false, 123)).toBe(
      123
    );
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 3);
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,NonFunctionalStatement,"{'startLine':90,'endLine':90}","it('increments scheduled fns ids unless one is passed', function() {
    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler();

    const initial = scheduler.scheduleFunction(function() {}, 0);
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 1);
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 2);
    expect(scheduler.scheduleFunction(function() {}, 0, [], false, 123)).toBe(
      123
    );
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 3);
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,NonFunctionalStatement,"{'startLine':91,'endLine':91}","it('increments scheduled fns ids unless one is passed', function() {
    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler();

    const initial = scheduler.scheduleFunction(function() {}, 0);
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 1);
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 2);
    expect(scheduler.scheduleFunction(function() {}, 0, [], false, 123)).toBe(
      123
    );
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 3);
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,NonFunctionalStatement,"{'startLine':92,'endLine':92}","it('increments scheduled fns ids unless one is passed', function() {
    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler();

    const initial = scheduler.scheduleFunction(function() {}, 0);
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 1);
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 2);
    expect(scheduler.scheduleFunction(function() {}, 0, [], false, 123)).toBe(
      123
    );
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 3);
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,NonFunctionalStatement,"{'startLine':95,'endLine':95}","it('increments scheduled fns ids unless one is passed', function() {
    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler();

    const initial = scheduler.scheduleFunction(function() {}, 0);
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 1);
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 2);
    expect(scheduler.scheduleFunction(function() {}, 0, [], false, 123)).toBe(
      123
    );
    expect(scheduler.scheduleFunction(function() {}, 0)).toBe(initial + 3);
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,NonFunctionalStatement,"{'startLine':308,'endLine':308}","it('updates the mockDate per scheduled time', function() {
    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      tickDate = jasmine.createSpy('tickDate');

    scheduler.scheduleFunction(function() {});
    scheduler.scheduleFunction(function() {}, 1);

    scheduler.tick(1, tickDate);

    expect(tickDate).toHaveBeenCalledWith(0);
    expect(tickDate).toHaveBeenCalledWith(1);
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,NonFunctionalStatement,"{'startLine':309,'endLine':309}","it('updates the mockDate per scheduled time', function() {
    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      tickDate = jasmine.createSpy('tickDate');

    scheduler.scheduleFunction(function() {});
    scheduler.scheduleFunction(function() {}, 1);

    scheduler.tick(1, tickDate);

    expect(tickDate).toHaveBeenCalledWith(0);
    expect(tickDate).toHaveBeenCalledWith(1);
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,NonFunctionalStatement,"{'startLine':325,'endLine':325}","it('does not conflict with native timer IDs', function() {
    const NODE_JS =
      typeof process !== 'undefined' &&
      process.versions &&
      typeof process.versions.node === 'string';
    if (NODE_JS) {
      pending('numeric timer ID conflicts only relevant for browsers.');
    }
    const nativeTimeoutId = setTimeout(function() {}, 100);

    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler();
    const fn = jasmine.createSpy('fn');

    for (let i = 0; i < nativeTimeoutId; i++) {
      scheduler.scheduleFunction(fn, 0, [], false);
    }
    scheduler.removeFunctionWithId(nativeTimeoutId);
    scheduler.tick(1);

    expect(fn).toHaveBeenCalledTimes(nativeTimeoutId);
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,NonFunctionalStatement,"{'startLine':344,'endLine':344}","describe('ticking inside a scheduled function', function() {
    let clock;

    // Runner function calls the callback until it returns false
    function runWork(workCallback) {
      while (workCallback()) {}
    }

    // Make a worker that takes a little time and tracks when it finished
    function mockWork(times) {
      return () => {
        clock.tick(1);
        const now = new Date().getTime();
        expect(lastWork)
          .withContext('Previous function calls should always be in the past')
          .toBeLessThan(now);
        lastWork = now;
        times--;
        return times > 0;
      };
    }
    let lastWork = 0;

    beforeEach(() => {
      clock = jasmineUnderTest.getEnv().clock;
      clock.install();
      clock.mockDate(new Date(1));
    });

    afterEach(function() {
      jasmineUnderTest.getEnv().clock.uninstall();
    });

    it('preserves monotonically-increasing current time', () => {
      const work1 = mockWork(3);
      setTimeout(() => {
        runWork(work1);
      }, 1);
      clock.tick(1);
      expect(lastWork)
        .withContext('tick should advance past last-scheduled function')
        .toBeLessThanOrEqual(new Date().getTime());

      const work2 = mockWork(3);
      setTimeout(() => {
        runWork(work2);
      }, 1);
      clock.tick(1);
      expect(lastWork)
        .withContext('tick should advance past last-scheduled function')
        .toBeLessThanOrEqual(new Date().getTime());
    });
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,VerboseStatement,"{'startLine':167,'endLine':198}","it('executes recurring functions interleaved with regular functions and functions scheduled during a tick in the correct order', function() {
    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler();
    const fn = jasmine.createSpy('fn');
    let recurringCallCount = 0;
    const recurring = jasmine.createSpy('recurring').and.callFake(function() {
      recurringCallCount++;
      if (recurringCallCount < 5) {
        expect(fn).not.toHaveBeenCalled();
      }
    });
    const innerFn = jasmine.createSpy('innerFn').and.callFake(function() {
      expect(recurring.calls.count()).toBe(4);
      expect(fn).not.toHaveBeenCalled();
    });
    const scheduling = jasmine.createSpy('scheduling').and.callFake(function() {
      expect(recurring.calls.count()).toBe(3);
      expect(fn).not.toHaveBeenCalled();
      scheduler.scheduleFunction(innerFn, 10); // 41ms absolute
    });

    scheduler.scheduleFunction(recurring, 10, [], true);
    scheduler.scheduleFunction(fn, 50);
    scheduler.scheduleFunction(scheduling, 31);

    scheduler.tick(60);

    expect(recurring).toHaveBeenCalled();
    expect(recurring.calls.count()).toBe(6);
    expect(fn).toHaveBeenCalled();
    expect(scheduling).toHaveBeenCalled();
    expect(innerFn).toHaveBeenCalled();
  })",snuts
/spec/core/DelayedFunctionSchedulerSpec.js,VerboseStatement,"{'startLine':283,'endLine':302}","it('runs the only a single scheduled funtion in a time slot', function() {
    const scheduler = new jasmineUnderTest.DelayedFunctionScheduler();
    const fn1 = jasmine.createSpy('fn');
    const fn2 = jasmine.createSpy('fn2');
    const tickSpy = jasmine.createSpy('tick');

    scheduler.scheduleFunction(fn1, 10, [], false, 'foo1');
    scheduler.scheduleFunction(fn2, 10, [], false, 'foo2');

    scheduler.runNextQueuedFunction(tickSpy);

    expect(fn1).toHaveBeenCalled();
    expect(fn2).not.toHaveBeenCalled();
    expect(tickSpy).toHaveBeenCalledWith(10);

    tickSpy.calls.reset();
    scheduler.runNextQueuedFunction(tickSpy);
    expect(fn2).toHaveBeenCalled();
    expect(tickSpy).toHaveBeenCalledWith(0);
  })",snuts
/spec/core/ConfigurationSpec.js,AnonymousTest,"{'startLine':21,'endLine':35}","it('provides defaults', function() {
    const subject = new jasmineUnderTest.Configuration();
    expect(subject.random).toEqual(true);
    expect(subject.seed).toBeNull();
    expect(subject.stopOnSpecFailure).toEqual(false);
    expect(subject.stopSpecOnExpectationFailure).toEqual(false);
    expect(subject.failSpecWithNoExpectations).toEqual(false);
    expect(subject.specFilter).toEqual(jasmine.any(Function));
    expect(subject.specFilter()).toEqual(true);
    expect(subject.hideDisabled).toEqual(false);
    expect(subject.autoCleanClosures).toEqual(true);
    expect(subject.forbidDuplicateNames).toEqual(false);
    expect(subject.verboseDeprecations).toEqual(false);
    expect(subject.detectLateRejectionHandling).toEqual(false);
  })",snuts
/spec/core/ConfigurationSpec.js,NonFunctionalStatement,"{'startLine':116,'endLine':116}","it('sets specFilter when truthy', function() {
      const subject = new jasmineUnderTest.Configuration();
      const orig = subject.specFilter;

      subject.update({ specFilter: undefined });
      expect(subject.specFilter).toBe(orig);

      subject.update({ specFilter: false });
      expect(subject.specFilter).toBe(orig);

      function newSpecFilter() {}
      subject.update({ specFilter: newSpecFilter });
      expect(subject.specFilter).toBe(newSpecFilter);
    })",snuts
/spec/core/CompleteOnFirstErrorSkipPolicySpec.js,NonFunctionalStatement,"{'startLine':48,'endLine':48}","it('runs cleanup fns defined by the current and containing suites', function() {
          const parentSuite = { description: 'parentSuite' };
          const suite = { description: 'suite', parentSuite };
          const fns = [
            {
              suite: suite
            },
            {
              fn: () => {}
            },
            {
              fn: () => {},
              suite: suite,
              type: arbitraryCleanupType()
            },
            {
              fn: () => {},
              suite: parentSuite,
              type: arbitraryCleanupType()
            }
          ];
          const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(
            fns
          );

          policy.fnErrored(0);
          expect(policy.skipTo(0)).toEqual(2);
          expect(policy.skipTo(2)).toEqual(3);
        })",snuts
/spec/core/CompleteOnFirstErrorSkipPolicySpec.js,NonFunctionalStatement,"{'startLine':51,'endLine':51}","it('runs cleanup fns defined by the current and containing suites', function() {
          const parentSuite = { description: 'parentSuite' };
          const suite = { description: 'suite', parentSuite };
          const fns = [
            {
              suite: suite
            },
            {
              fn: () => {}
            },
            {
              fn: () => {},
              suite: suite,
              type: arbitraryCleanupType()
            },
            {
              fn: () => {},
              suite: parentSuite,
              type: arbitraryCleanupType()
            }
          ];
          const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(
            fns
          );

          policy.fnErrored(0);
          expect(policy.skipTo(0)).toEqual(2);
          expect(policy.skipTo(2)).toEqual(3);
        })",snuts
/spec/core/CompleteOnFirstErrorSkipPolicySpec.js,NonFunctionalStatement,"{'startLine':56,'endLine':56}","it('runs cleanup fns defined by the current and containing suites', function() {
          const parentSuite = { description: 'parentSuite' };
          const suite = { description: 'suite', parentSuite };
          const fns = [
            {
              suite: suite
            },
            {
              fn: () => {}
            },
            {
              fn: () => {},
              suite: suite,
              type: arbitraryCleanupType()
            },
            {
              fn: () => {},
              suite: parentSuite,
              type: arbitraryCleanupType()
            }
          ];
          const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(
            fns
          );

          policy.fnErrored(0);
          expect(policy.skipTo(0)).toEqual(2);
          expect(policy.skipTo(2)).toEqual(3);
        })",snuts
/spec/core/CompleteOnFirstErrorSkipPolicySpec.js,NonFunctionalStatement,"{'startLine':75,'endLine':75}","it('skips cleanup fns defined by nested suites', function() {
          const parentSuite = { description: 'parentSuite' };
          const suite = { description: 'suite', parentSuite };
          const fns = [
            {
              fn: () => {},
              type: 'beforeEach',
              suite: parentSuite
            },
            {
              fn: () => {}
            },
            {
              fn: () => {},
              suite: suite,
              type: arbitraryCleanupType()
            },
            {
              fn: () => {},
              suite: parentSuite,
              type: arbitraryCleanupType()
            }
          ];
          const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(
            fns
          );

          policy.fnErrored(0);
          expect(policy.skipTo(0)).toEqual(3);
        })",snuts
/spec/core/CompleteOnFirstErrorSkipPolicySpec.js,NonFunctionalStatement,"{'startLine':80,'endLine':80}","it('skips cleanup fns defined by nested suites', function() {
          const parentSuite = { description: 'parentSuite' };
          const suite = { description: 'suite', parentSuite };
          const fns = [
            {
              fn: () => {},
              type: 'beforeEach',
              suite: parentSuite
            },
            {
              fn: () => {}
            },
            {
              fn: () => {},
              suite: suite,
              type: arbitraryCleanupType()
            },
            {
              fn: () => {},
              suite: parentSuite,
              type: arbitraryCleanupType()
            }
          ];
          const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(
            fns
          );

          policy.fnErrored(0);
          expect(policy.skipTo(0)).toEqual(3);
        })",snuts
/spec/core/CompleteOnFirstErrorSkipPolicySpec.js,NonFunctionalStatement,"{'startLine':83,'endLine':83}","it('skips cleanup fns defined by nested suites', function() {
          const parentSuite = { description: 'parentSuite' };
          const suite = { description: 'suite', parentSuite };
          const fns = [
            {
              fn: () => {},
              type: 'beforeEach',
              suite: parentSuite
            },
            {
              fn: () => {}
            },
            {
              fn: () => {},
              suite: suite,
              type: arbitraryCleanupType()
            },
            {
              fn: () => {},
              suite: parentSuite,
              type: arbitraryCleanupType()
            }
          ];
          const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(
            fns
          );

          policy.fnErrored(0);
          expect(policy.skipTo(0)).toEqual(3);
        })",snuts
/spec/core/CompleteOnFirstErrorSkipPolicySpec.js,NonFunctionalStatement,"{'startLine':88,'endLine':88}","it('skips cleanup fns defined by nested suites', function() {
          const parentSuite = { description: 'parentSuite' };
          const suite = { description: 'suite', parentSuite };
          const fns = [
            {
              fn: () => {},
              type: 'beforeEach',
              suite: parentSuite
            },
            {
              fn: () => {}
            },
            {
              fn: () => {},
              suite: suite,
              type: arbitraryCleanupType()
            },
            {
              fn: () => {},
              suite: parentSuite,
              type: arbitraryCleanupType()
            }
          ];
          const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(
            fns
          );

          policy.fnErrored(0);
          expect(policy.skipTo(0)).toEqual(3);
        })",snuts
/spec/core/CompleteOnFirstErrorSkipPolicySpec.js,NonFunctionalStatement,"{'startLine':104,'endLine':104}","it('does not skip cleanup fns that have no suite, such as the spec complete fn', function() {
        const fns = [
          { fn: () => {} },
          {
            fn: () => {},
            type: arbitraryCleanupType()
          }
        ];
        const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(fns);

        policy.fnErrored(0);
        expect(policy.skipTo(0)).toEqual(1);
      })",snuts
/spec/core/CompleteOnFirstErrorSkipPolicySpec.js,NonFunctionalStatement,"{'startLine':106,'endLine':106}","it('does not skip cleanup fns that have no suite, such as the spec complete fn', function() {
        const fns = [
          { fn: () => {} },
          {
            fn: () => {},
            type: arbitraryCleanupType()
          }
        ];
        const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(fns);

        policy.fnErrored(0);
        expect(policy.skipTo(0)).toEqual(1);
      })",snuts
/spec/core/CompleteOnFirstErrorSkipPolicySpec.js,NonFunctionalStatement,"{'startLine':122,'endLine':122}","describe('CompleteOnFirstErrorSkipPolicy', function() {
  describe('#skipTo', function() {
    describe('Before anything has errored', function() {
      it('returns the next index', function() {
        const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(
          arrayOfArbitraryFns(4),
          4
        );
        expect(policy.skipTo(1)).toEqual(2);
      });
    });

    describe('After something has errored', function() {
      it('skips non cleanup fns', function() {
        const fns = arrayOfArbitraryFns(4);
        fns[2].type = arbitraryCleanupType();
        fns[3].type = arbitraryCleanupType();
        const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(fns);

        policy.fnErrored(0);
        expect(policy.skipTo(0)).toEqual(2);
        expect(policy.skipTo(2)).toEqual(3);
        expect(policy.skipTo(3)).toEqual(4);
      });

      for (const type of ['afterEach', 'specCleanup', 'afterAll']) {
        it(`does not skip ${type} fns`, function() {
          const fns = arrayOfArbitraryFns(2);
          fns[1].type = type;
          const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(
            fns
          );

          policy.fnErrored(0);
          expect(policy.skipTo(0)).toEqual(1);
        });
      }

      describe('When the error was in a beforeEach fn', function() {
        it('runs cleanup fns defined by the current and containing suites', function() {
          const parentSuite = { description: 'parentSuite' };
          const suite = { description: 'suite', parentSuite };
          const fns = [
            {
              suite: suite
            },
            {
              fn: () => {}
            },
            {
              fn: () => {},
              suite: suite,
              type: arbitraryCleanupType()
            },
            {
              fn: () => {},
              suite: parentSuite,
              type: arbitraryCleanupType()
            }
          ];
          const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(
            fns
          );

          policy.fnErrored(0);
          expect(policy.skipTo(0)).toEqual(2);
          expect(policy.skipTo(2)).toEqual(3);
        });

        it('skips cleanup fns defined by nested suites', function() {
          const parentSuite = { description: 'parentSuite' };
          const suite = { description: 'suite', parentSuite };
          const fns = [
            {
              fn: () => {},
              type: 'beforeEach',
              suite: parentSuite
            },
            {
              fn: () => {}
            },
            {
              fn: () => {},
              suite: suite,
              type: arbitraryCleanupType()
            },
            {
              fn: () => {},
              suite: parentSuite,
              type: arbitraryCleanupType()
            }
          ];
          const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(
            fns
          );

          policy.fnErrored(0);
          expect(policy.skipTo(0)).toEqual(3);
        });
      });

      it('does not skip cleanup fns that have no suite, such as the spec complete fn', function() {
        const fns = [
          { fn: () => {} },
          {
            fn: () => {},
            type: arbitraryCleanupType()
          }
        ];
        const policy = new jasmineUnderTest.CompleteOnFirstErrorSkipPolicy(fns);

        policy.fnErrored(0);
        expect(policy.skipTo(0)).toEqual(1);
      });
    });
  });

  function arrayOfArbitraryFns(n) {
    const result = [];

    for (let i = 0; i < n; i++) {
      result.push({ fn: () => {} });
    }

    return result;
  }

  function arbitraryCleanupType() {
    return 'specCleanup';
  }
})",snuts
/spec/core/ClockSpec.js,IdenticalTestDescription,"{'startLine':519,'endLine':560}","it('schedules the delayed function with the fake timer', function() {
      const fakeSetInterval = jasmine.createSpy('setInterval'),
        scheduleFunction = jasmine.createSpy('scheduleFunction'),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setInterval: fakeSetInterval },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        ),
        timeout = new clock.FakeTimeout();

      clock.install();
      clock.setInterval(delayedFn, 0, 'a', 'b');

      expect(fakeSetInterval).not.toHaveBeenCalled();

      if (!NODE_JS) {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          true
        );
      } else {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          true,
          timeout
        );
      }
    })",snuts
/spec/core/ClockSpec.js,IdenticalTestDescription,"{'startLine':562,'endLine':592}","it('returns an id for the delayed function', function() {
      const fakeSetInterval = jasmine.createSpy('setInterval'),
        scheduleId = 123,
        scheduleFunction = jasmine
          .createSpy('scheduleFunction')
          .and.returnValue(scheduleId),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setInterval: fakeSetInterval },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      const interval = clock.setInterval(delayedFn, 0);

      if (!NODE_JS) {
        expect(interval).toEqual(123);
      } else {
        expect(interval.constructor.name).toEqual('FakeTimeout');
      }
    })",snuts
/spec/core/ClockSpec.js,IdenticalTestDescription,"{'startLine':596,'endLine':623}","it('clears the scheduled function with the scheduler', function() {
      const clearInterval = jasmine.createSpy('clearInterval'),
        delayedFunctionScheduler = jasmine.createSpyObj(
          'delayedFunctionScheduler',
          ['removeFunctionWithId']
        ),
        fakeGlobal = { setInterval: clearInterval },
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      clock.clearInterval(123);

      expect(clearInterval).not.toHaveBeenCalled();
      expect(
        delayedFunctionScheduler.removeFunctionWithId
      ).toHaveBeenCalledWith(123);
    })",snuts
/spec/core/ClockSpec.js,ConditionalTestLogic,"{'startLine':437,'endLine':451}","it('schedules the delayed function with the fake timer', function() {
      const fakeSetTimeout = jasmine.createSpy('setTimeout'),
        scheduleFunction = jasmine.createSpy('scheduleFunction'),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setTimeout: fakeSetTimeout },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        ),
        timeout = new clock.FakeTimeout();

      clock.install();
      clock.setTimeout(delayedFn, 0, 'a', 'b');

      expect(fakeSetTimeout).not.toHaveBeenCalled();

      if (!NODE_JS) {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b']
        );
      } else {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          false,
          timeout
        );
      }
    })",snuts
/spec/core/ClockSpec.js,ConditionalTestLogic,"{'startLine':479,'endLine':483}","it('returns an id for the delayed function', function() {
      const fakeSetTimeout = jasmine.createSpy('setTimeout'),
        scheduleId = 123,
        scheduleFunction = jasmine
          .createSpy('scheduleFunction')
          .and.returnValue(scheduleId),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setTimeout: fakeSetTimeout },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      const timeout = clock.setTimeout(delayedFn, 0);

      if (!NODE_JS) {
        expect(timeout).toEqual(123);
      } else {
        expect(timeout.constructor.name).toEqual('FakeTimeout');
      }
    })",snuts
/spec/core/ClockSpec.js,ConditionalTestLogic,"{'startLine':544,'endLine':559}","it('schedules the delayed function with the fake timer', function() {
      const fakeSetInterval = jasmine.createSpy('setInterval'),
        scheduleFunction = jasmine.createSpy('scheduleFunction'),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setInterval: fakeSetInterval },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        ),
        timeout = new clock.FakeTimeout();

      clock.install();
      clock.setInterval(delayedFn, 0, 'a', 'b');

      expect(fakeSetInterval).not.toHaveBeenCalled();

      if (!NODE_JS) {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          true
        );
      } else {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          true,
          timeout
        );
      }
    })",snuts
/spec/core/ClockSpec.js,ConditionalTestLogic,"{'startLine':587,'endLine':591}","it('returns an id for the delayed function', function() {
      const fakeSetInterval = jasmine.createSpy('setInterval'),
        scheduleId = 123,
        scheduleFunction = jasmine
          .createSpy('scheduleFunction')
          .and.returnValue(scheduleId),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setInterval: fakeSetInterval },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      const interval = clock.setInterval(delayedFn, 0);

      if (!NODE_JS) {
        expect(interval).toEqual(123);
      } else {
        expect(interval.constructor.name).toEqual('FakeTimeout');
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}","it('does not replace setTimeout until it is installed', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeGlobal = { setTimeout: fakeSetTimeout },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    fakeGlobal.setTimeout(delayedFn, 0);

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();

    fakeSetTimeout.calls.reset();

    clock.install();
    fakeGlobal.setTimeout(delayedFn, 0);

    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();
    expect(fakeSetTimeout).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}","it('does not replace setTimeout until it is installed', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeGlobal = { setTimeout: fakeSetTimeout },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    fakeGlobal.setTimeout(delayedFn, 0);

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();

    fakeSetTimeout.calls.reset();

    clock.install();
    fakeGlobal.setTimeout(delayedFn, 0);

    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();
    expect(fakeSetTimeout).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':18,'endLine':18}","it('does not replace setTimeout until it is installed', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeGlobal = { setTimeout: fakeSetTimeout },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    fakeGlobal.setTimeout(delayedFn, 0);

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();

    fakeSetTimeout.calls.reset();

    clock.install();
    fakeGlobal.setTimeout(delayedFn, 0);

    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();
    expect(fakeSetTimeout).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':50,'endLine':50}","it('does not replace clearTimeout until it is installed', function() {
    const fakeClearTimeout = jasmine.createSpy('global cleartimeout'),
      fakeGlobal = { clearTimeout: fakeClearTimeout },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['removeFunctionWithId']
      ),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    fakeGlobal.clearTimeout('foo');

    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(
      delayedFunctionScheduler.removeFunctionWithId
    ).not.toHaveBeenCalled();

    fakeClearTimeout.calls.reset();

    clock.install();
    fakeGlobal.clearTimeout('foo');

    expect(delayedFunctionScheduler.removeFunctionWithId).toHaveBeenCalled();
    expect(fakeClearTimeout).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':51,'endLine':51}","it('does not replace clearTimeout until it is installed', function() {
    const fakeClearTimeout = jasmine.createSpy('global cleartimeout'),
      fakeGlobal = { clearTimeout: fakeClearTimeout },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['removeFunctionWithId']
      ),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    fakeGlobal.clearTimeout('foo');

    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(
      delayedFunctionScheduler.removeFunctionWithId
    ).not.toHaveBeenCalled();

    fakeClearTimeout.calls.reset();

    clock.install();
    fakeGlobal.clearTimeout('foo');

    expect(delayedFunctionScheduler.removeFunctionWithId).toHaveBeenCalled();
    expect(fakeClearTimeout).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':52,'endLine':52}","it('does not replace clearTimeout until it is installed', function() {
    const fakeClearTimeout = jasmine.createSpy('global cleartimeout'),
      fakeGlobal = { clearTimeout: fakeClearTimeout },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['removeFunctionWithId']
      ),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    fakeGlobal.clearTimeout('foo');

    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(
      delayedFunctionScheduler.removeFunctionWithId
    ).not.toHaveBeenCalled();

    fakeClearTimeout.calls.reset();

    clock.install();
    fakeGlobal.clearTimeout('foo');

    expect(delayedFunctionScheduler.removeFunctionWithId).toHaveBeenCalled();
    expect(fakeClearTimeout).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':87,'endLine':87}","it('does not replace setInterval until it is installed', function() {
    const fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeGlobal = { setInterval: fakeSetInterval },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    fakeGlobal.setInterval(delayedFn, 0);

    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 0);
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();

    fakeSetInterval.calls.reset();

    clock.install();
    fakeGlobal.setInterval(delayedFn, 0);

    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();
    expect(fakeSetInterval).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':88,'endLine':88}","it('does not replace setInterval until it is installed', function() {
    const fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeGlobal = { setInterval: fakeSetInterval },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    fakeGlobal.setInterval(delayedFn, 0);

    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 0);
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();

    fakeSetInterval.calls.reset();

    clock.install();
    fakeGlobal.setInterval(delayedFn, 0);

    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();
    expect(fakeSetInterval).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':89,'endLine':89}","it('does not replace setInterval until it is installed', function() {
    const fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeGlobal = { setInterval: fakeSetInterval },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    fakeGlobal.setInterval(delayedFn, 0);

    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 0);
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();

    fakeSetInterval.calls.reset();

    clock.install();
    fakeGlobal.setInterval(delayedFn, 0);

    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();
    expect(fakeSetInterval).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':121,'endLine':121}","it('does not replace clearInterval until it is installed', function() {
    const fakeClearInterval = jasmine.createSpy('global clearinterval'),
      fakeGlobal = { clearInterval: fakeClearInterval },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['removeFunctionWithId']
      ),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    fakeGlobal.clearInterval('foo');

    expect(fakeClearInterval).toHaveBeenCalledWith('foo');
    expect(
      delayedFunctionScheduler.removeFunctionWithId
    ).not.toHaveBeenCalled();

    fakeClearInterval.calls.reset();

    clock.install();
    fakeGlobal.clearInterval('foo');

    expect(delayedFunctionScheduler.removeFunctionWithId).toHaveBeenCalled();
    expect(fakeClearInterval).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':122,'endLine':122}","it('does not replace clearInterval until it is installed', function() {
    const fakeClearInterval = jasmine.createSpy('global clearinterval'),
      fakeGlobal = { clearInterval: fakeClearInterval },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['removeFunctionWithId']
      ),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    fakeGlobal.clearInterval('foo');

    expect(fakeClearInterval).toHaveBeenCalledWith('foo');
    expect(
      delayedFunctionScheduler.removeFunctionWithId
    ).not.toHaveBeenCalled();

    fakeClearInterval.calls.reset();

    clock.install();
    fakeGlobal.clearInterval('foo');

    expect(delayedFunctionScheduler.removeFunctionWithId).toHaveBeenCalled();
    expect(fakeClearInterval).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':123,'endLine':123}","it('does not replace clearInterval until it is installed', function() {
    const fakeClearInterval = jasmine.createSpy('global clearinterval'),
      fakeGlobal = { clearInterval: fakeClearInterval },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['removeFunctionWithId']
      ),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    fakeGlobal.clearInterval('foo');

    expect(fakeClearInterval).toHaveBeenCalledWith('foo');
    expect(
      delayedFunctionScheduler.removeFunctionWithId
    ).not.toHaveBeenCalled();

    fakeClearInterval.calls.reset();

    clock.install();
    fakeGlobal.clearInterval('foo');

    expect(delayedFunctionScheduler.removeFunctionWithId).toHaveBeenCalled();
    expect(fakeClearInterval).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':150,'endLine':150}","it('does not install if the current setTimeout is not the original function on the global', function() {
    const originalFakeSetTimeout = function() {},
      replacedSetTimeout = function() {},
      fakeGlobal = { setTimeout: originalFakeSetTimeout },
      delayedFunctionSchedulerFactory = jasmine.createSpy(
        'delayedFunctionSchedulerFactory'
      ),
      mockDate = {},
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        delayedFunctionSchedulerFactory,
        mockDate
      );

    fakeGlobal.setTimeout = replacedSetTimeout;

    expect(function() {
      clock.install();
    }).toThrowError(/unable to install/);

    expect(delayedFunctionSchedulerFactory).not.toHaveBeenCalled();
    expect(fakeGlobal.setTimeout).toBe(replacedSetTimeout);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':151,'endLine':151}","it('does not install if the current setTimeout is not the original function on the global', function() {
    const originalFakeSetTimeout = function() {},
      replacedSetTimeout = function() {},
      fakeGlobal = { setTimeout: originalFakeSetTimeout },
      delayedFunctionSchedulerFactory = jasmine.createSpy(
        'delayedFunctionSchedulerFactory'
      ),
      mockDate = {},
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        delayedFunctionSchedulerFactory,
        mockDate
      );

    fakeGlobal.setTimeout = replacedSetTimeout;

    expect(function() {
      clock.install();
    }).toThrowError(/unable to install/);

    expect(delayedFunctionSchedulerFactory).not.toHaveBeenCalled();
    expect(fakeGlobal.setTimeout).toBe(replacedSetTimeout);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':174,'endLine':174}","it('does not install if the current clearTimeout is not the original function on the global', function() {
    const originalFakeClearTimeout = function() {},
      replacedClearTimeout = function() {},
      fakeGlobal = { clearTimeout: originalFakeClearTimeout },
      delayedFunctionSchedulerFactory = jasmine.createSpy(
        'delayedFunctionSchedulerFactory'
      ),
      mockDate = {},
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        delayedFunctionSchedulerFactory,
        mockDate
      );

    fakeGlobal.clearTimeout = replacedClearTimeout;

    expect(function() {
      clock.install();
    }).toThrowError(/unable to install/);

    expect(delayedFunctionSchedulerFactory).not.toHaveBeenCalled();
    expect(fakeGlobal.clearTimeout).toBe(replacedClearTimeout);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':175,'endLine':175}","it('does not install if the current clearTimeout is not the original function on the global', function() {
    const originalFakeClearTimeout = function() {},
      replacedClearTimeout = function() {},
      fakeGlobal = { clearTimeout: originalFakeClearTimeout },
      delayedFunctionSchedulerFactory = jasmine.createSpy(
        'delayedFunctionSchedulerFactory'
      ),
      mockDate = {},
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        delayedFunctionSchedulerFactory,
        mockDate
      );

    fakeGlobal.clearTimeout = replacedClearTimeout;

    expect(function() {
      clock.install();
    }).toThrowError(/unable to install/);

    expect(delayedFunctionSchedulerFactory).not.toHaveBeenCalled();
    expect(fakeGlobal.clearTimeout).toBe(replacedClearTimeout);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':198,'endLine':198}","it('does not install if the current setInterval is not the original function on the global', function() {
    const originalFakeSetInterval = function() {},
      replacedSetInterval = function() {},
      fakeGlobal = { setInterval: originalFakeSetInterval },
      delayedFunctionSchedulerFactory = jasmine.createSpy(
        'delayedFunctionSchedulerFactory'
      ),
      mockDate = {},
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        delayedFunctionSchedulerFactory,
        mockDate
      );

    fakeGlobal.setInterval = replacedSetInterval;

    expect(function() {
      clock.install();
    }).toThrowError(/unable to install/);

    expect(delayedFunctionSchedulerFactory).not.toHaveBeenCalled();
    expect(fakeGlobal.setInterval).toBe(replacedSetInterval);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':199,'endLine':199}","it('does not install if the current setInterval is not the original function on the global', function() {
    const originalFakeSetInterval = function() {},
      replacedSetInterval = function() {},
      fakeGlobal = { setInterval: originalFakeSetInterval },
      delayedFunctionSchedulerFactory = jasmine.createSpy(
        'delayedFunctionSchedulerFactory'
      ),
      mockDate = {},
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        delayedFunctionSchedulerFactory,
        mockDate
      );

    fakeGlobal.setInterval = replacedSetInterval;

    expect(function() {
      clock.install();
    }).toThrowError(/unable to install/);

    expect(delayedFunctionSchedulerFactory).not.toHaveBeenCalled();
    expect(fakeGlobal.setInterval).toBe(replacedSetInterval);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':222,'endLine':222}","it('does not install if the current clearInterval is not the original function on the global', function() {
    const originalFakeClearInterval = function() {},
      replacedClearInterval = function() {},
      fakeGlobal = { clearInterval: originalFakeClearInterval },
      delayedFunctionSchedulerFactory = jasmine.createSpy(
        'delayedFunctionSchedulerFactory'
      ),
      mockDate = {},
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        delayedFunctionSchedulerFactory,
        mockDate
      );

    fakeGlobal.clearInterval = replacedClearInterval;

    expect(function() {
      clock.install();
    }).toThrowError(/unable to install/);

    expect(delayedFunctionSchedulerFactory).not.toHaveBeenCalled();
    expect(fakeGlobal.clearInterval).toBe(replacedClearInterval);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':223,'endLine':223}","it('does not install if the current clearInterval is not the original function on the global', function() {
    const originalFakeClearInterval = function() {},
      replacedClearInterval = function() {},
      fakeGlobal = { clearInterval: originalFakeClearInterval },
      delayedFunctionSchedulerFactory = jasmine.createSpy(
        'delayedFunctionSchedulerFactory'
      ),
      mockDate = {},
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        delayedFunctionSchedulerFactory,
        mockDate
      );

    fakeGlobal.clearInterval = replacedClearInterval;

    expect(function() {
      clock.install();
    }).toThrowError(/unable to install/);

    expect(delayedFunctionSchedulerFactory).not.toHaveBeenCalled();
    expect(fakeGlobal.clearInterval).toBe(replacedClearInterval);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':262,'endLine':262}","it('restores the global timer functions on uninstall', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeClearTimeout = jasmine.createSpy('global clearTimeout'),
      fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeClearInterval = jasmine.createSpy('global clearInterval'),
      fakeGlobal = {
        setTimeout: fakeSetTimeout,
        clearTimeout: fakeClearTimeout,
        setInterval: fakeSetInterval,
        clearInterval: fakeClearInterval
      },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction', 'reset']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();
    clock.uninstall();
    fakeGlobal.setTimeout(delayedFn, 0);
    fakeGlobal.clearTimeout('foo');
    fakeGlobal.setInterval(delayedFn, 10);
    fakeGlobal.clearInterval('bar');

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 10);
    expect(fakeClearInterval).toHaveBeenCalledWith('bar');
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':263,'endLine':263}","it('restores the global timer functions on uninstall', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeClearTimeout = jasmine.createSpy('global clearTimeout'),
      fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeClearInterval = jasmine.createSpy('global clearInterval'),
      fakeGlobal = {
        setTimeout: fakeSetTimeout,
        clearTimeout: fakeClearTimeout,
        setInterval: fakeSetInterval,
        clearInterval: fakeClearInterval
      },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction', 'reset']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();
    clock.uninstall();
    fakeGlobal.setTimeout(delayedFn, 0);
    fakeGlobal.clearTimeout('foo');
    fakeGlobal.setInterval(delayedFn, 10);
    fakeGlobal.clearInterval('bar');

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 10);
    expect(fakeClearInterval).toHaveBeenCalledWith('bar');
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':264,'endLine':264}","it('restores the global timer functions on uninstall', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeClearTimeout = jasmine.createSpy('global clearTimeout'),
      fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeClearInterval = jasmine.createSpy('global clearInterval'),
      fakeGlobal = {
        setTimeout: fakeSetTimeout,
        clearTimeout: fakeClearTimeout,
        setInterval: fakeSetInterval,
        clearInterval: fakeClearInterval
      },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction', 'reset']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();
    clock.uninstall();
    fakeGlobal.setTimeout(delayedFn, 0);
    fakeGlobal.clearTimeout('foo');
    fakeGlobal.setInterval(delayedFn, 10);
    fakeGlobal.clearInterval('bar');

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 10);
    expect(fakeClearInterval).toHaveBeenCalledWith('bar');
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':305,'endLine':305}","it('can be installed for the duration of a passed in function and uninstalled when done', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeClearTimeout = jasmine.createSpy('global clearTimeout'),
      fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeClearInterval = jasmine.createSpy('global clearInterval'),
      fakeGlobal = {
        setTimeout: fakeSetTimeout,
        clearTimeout: fakeClearTimeout,
        setInterval: fakeSetInterval,
        clearInterval: fakeClearInterval
      },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction', 'reset', 'removeFunctionWithId']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );
    let passedFunctionCalled = false;

    clock.withMock(function() {
      fakeGlobal.setTimeout(delayedFn, 0);
      fakeGlobal.clearTimeout('foo');
      fakeGlobal.setInterval(delayedFn, 10);
      fakeGlobal.clearInterval('bar');
      passedFunctionCalled = true;
    });

    expect(passedFunctionCalled).toBe(true);

    expect(fakeSetTimeout).not.toHaveBeenCalled();
    expect(fakeClearTimeout).not.toHaveBeenCalled();
    expect(fakeSetInterval).not.toHaveBeenCalled();
    expect(fakeClearInterval).not.toHaveBeenCalled();
    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();

    delayedFunctionScheduler.scheduleFunction.calls.reset();

    fakeGlobal.setTimeout(delayedFn, 0);
    fakeGlobal.clearTimeout('foo');
    fakeGlobal.setInterval(delayedFn, 10);
    fakeGlobal.clearInterval('bar');

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 10);
    expect(fakeClearInterval).toHaveBeenCalledWith('bar');
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':306,'endLine':306}","it('can be installed for the duration of a passed in function and uninstalled when done', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeClearTimeout = jasmine.createSpy('global clearTimeout'),
      fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeClearInterval = jasmine.createSpy('global clearInterval'),
      fakeGlobal = {
        setTimeout: fakeSetTimeout,
        clearTimeout: fakeClearTimeout,
        setInterval: fakeSetInterval,
        clearInterval: fakeClearInterval
      },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction', 'reset', 'removeFunctionWithId']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );
    let passedFunctionCalled = false;

    clock.withMock(function() {
      fakeGlobal.setTimeout(delayedFn, 0);
      fakeGlobal.clearTimeout('foo');
      fakeGlobal.setInterval(delayedFn, 10);
      fakeGlobal.clearInterval('bar');
      passedFunctionCalled = true;
    });

    expect(passedFunctionCalled).toBe(true);

    expect(fakeSetTimeout).not.toHaveBeenCalled();
    expect(fakeClearTimeout).not.toHaveBeenCalled();
    expect(fakeSetInterval).not.toHaveBeenCalled();
    expect(fakeClearInterval).not.toHaveBeenCalled();
    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();

    delayedFunctionScheduler.scheduleFunction.calls.reset();

    fakeGlobal.setTimeout(delayedFn, 0);
    fakeGlobal.clearTimeout('foo');
    fakeGlobal.setInterval(delayedFn, 10);
    fakeGlobal.clearInterval('bar');

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 10);
    expect(fakeClearInterval).toHaveBeenCalledWith('bar');
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':307,'endLine':307}","it('can be installed for the duration of a passed in function and uninstalled when done', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeClearTimeout = jasmine.createSpy('global clearTimeout'),
      fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeClearInterval = jasmine.createSpy('global clearInterval'),
      fakeGlobal = {
        setTimeout: fakeSetTimeout,
        clearTimeout: fakeClearTimeout,
        setInterval: fakeSetInterval,
        clearInterval: fakeClearInterval
      },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction', 'reset', 'removeFunctionWithId']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );
    let passedFunctionCalled = false;

    clock.withMock(function() {
      fakeGlobal.setTimeout(delayedFn, 0);
      fakeGlobal.clearTimeout('foo');
      fakeGlobal.setInterval(delayedFn, 10);
      fakeGlobal.clearInterval('bar');
      passedFunctionCalled = true;
    });

    expect(passedFunctionCalled).toBe(true);

    expect(fakeSetTimeout).not.toHaveBeenCalled();
    expect(fakeClearTimeout).not.toHaveBeenCalled();
    expect(fakeSetInterval).not.toHaveBeenCalled();
    expect(fakeClearInterval).not.toHaveBeenCalled();
    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();

    delayedFunctionScheduler.scheduleFunction.calls.reset();

    fakeGlobal.setTimeout(delayedFn, 0);
    fakeGlobal.clearTimeout('foo');
    fakeGlobal.setInterval(delayedFn, 10);
    fakeGlobal.clearInterval('bar');

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 10);
    expect(fakeClearInterval).toHaveBeenCalledWith('bar');
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':365,'endLine':365}","it('can be installed for the duration of a passed in function and uninstalled if an error is thrown', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeClearTimeout = jasmine.createSpy('global clearTimeout'),
      fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeClearInterval = jasmine.createSpy('global clearInterval'),
      fakeGlobal = {
        setTimeout: fakeSetTimeout,
        clearTimeout: fakeClearTimeout,
        setInterval: fakeSetInterval,
        clearInterval: fakeClearInterval
      },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction', 'reset', 'removeFunctionWithId']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );
    let passedFunctionCalled = false;

    expect(function() {
      clock.withMock(function() {
        fakeGlobal.setTimeout(delayedFn, 0);
        fakeGlobal.clearTimeout('foo');
        fakeGlobal.setInterval(delayedFn, 10);
        fakeGlobal.clearInterval('bar');
        passedFunctionCalled = true;
        throw 'oops';
      });
    }).toThrow('oops');

    expect(passedFunctionCalled).toBe(true);

    expect(fakeSetTimeout).not.toHaveBeenCalled();
    expect(fakeClearTimeout).not.toHaveBeenCalled();
    expect(fakeSetInterval).not.toHaveBeenCalled();
    expect(fakeClearInterval).not.toHaveBeenCalled();
    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();

    delayedFunctionScheduler.scheduleFunction.calls.reset();

    fakeGlobal.setTimeout(delayedFn, 0);
    fakeGlobal.clearTimeout('foo');
    fakeGlobal.setInterval(delayedFn, 10);
    fakeGlobal.clearInterval('bar');

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 10);
    expect(fakeClearInterval).toHaveBeenCalledWith('bar');
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':366,'endLine':366}","it('can be installed for the duration of a passed in function and uninstalled if an error is thrown', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeClearTimeout = jasmine.createSpy('global clearTimeout'),
      fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeClearInterval = jasmine.createSpy('global clearInterval'),
      fakeGlobal = {
        setTimeout: fakeSetTimeout,
        clearTimeout: fakeClearTimeout,
        setInterval: fakeSetInterval,
        clearInterval: fakeClearInterval
      },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction', 'reset', 'removeFunctionWithId']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );
    let passedFunctionCalled = false;

    expect(function() {
      clock.withMock(function() {
        fakeGlobal.setTimeout(delayedFn, 0);
        fakeGlobal.clearTimeout('foo');
        fakeGlobal.setInterval(delayedFn, 10);
        fakeGlobal.clearInterval('bar');
        passedFunctionCalled = true;
        throw 'oops';
      });
    }).toThrow('oops');

    expect(passedFunctionCalled).toBe(true);

    expect(fakeSetTimeout).not.toHaveBeenCalled();
    expect(fakeClearTimeout).not.toHaveBeenCalled();
    expect(fakeSetInterval).not.toHaveBeenCalled();
    expect(fakeClearInterval).not.toHaveBeenCalled();
    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();

    delayedFunctionScheduler.scheduleFunction.calls.reset();

    fakeGlobal.setTimeout(delayedFn, 0);
    fakeGlobal.clearTimeout('foo');
    fakeGlobal.setInterval(delayedFn, 10);
    fakeGlobal.clearInterval('bar');

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 10);
    expect(fakeClearInterval).toHaveBeenCalledWith('bar');
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':367,'endLine':367}","it('can be installed for the duration of a passed in function and uninstalled if an error is thrown', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeClearTimeout = jasmine.createSpy('global clearTimeout'),
      fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeClearInterval = jasmine.createSpy('global clearInterval'),
      fakeGlobal = {
        setTimeout: fakeSetTimeout,
        clearTimeout: fakeClearTimeout,
        setInterval: fakeSetInterval,
        clearInterval: fakeClearInterval
      },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction', 'reset', 'removeFunctionWithId']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );
    let passedFunctionCalled = false;

    expect(function() {
      clock.withMock(function() {
        fakeGlobal.setTimeout(delayedFn, 0);
        fakeGlobal.clearTimeout('foo');
        fakeGlobal.setInterval(delayedFn, 10);
        fakeGlobal.clearInterval('bar');
        passedFunctionCalled = true;
        throw 'oops';
      });
    }).toThrow('oops');

    expect(passedFunctionCalled).toBe(true);

    expect(fakeSetTimeout).not.toHaveBeenCalled();
    expect(fakeClearTimeout).not.toHaveBeenCalled();
    expect(fakeSetInterval).not.toHaveBeenCalled();
    expect(fakeClearInterval).not.toHaveBeenCalled();
    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();

    delayedFunctionScheduler.scheduleFunction.calls.reset();

    fakeGlobal.setTimeout(delayedFn, 0);
    fakeGlobal.clearTimeout('foo');
    fakeGlobal.setInterval(delayedFn, 10);
    fakeGlobal.clearInterval('bar');

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 10);
    expect(fakeClearInterval).toHaveBeenCalledWith('bar');
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':419,'endLine':419}","it('schedules the delayed function with the fake timer', function() {
      const fakeSetTimeout = jasmine.createSpy('setTimeout'),
        scheduleFunction = jasmine.createSpy('scheduleFunction'),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setTimeout: fakeSetTimeout },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        ),
        timeout = new clock.FakeTimeout();

      clock.install();
      clock.setTimeout(delayedFn, 0, 'a', 'b');

      expect(fakeSetTimeout).not.toHaveBeenCalled();

      if (!NODE_JS) {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b']
        );
      } else {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          false,
          timeout
        );
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':420,'endLine':420}","it('schedules the delayed function with the fake timer', function() {
      const fakeSetTimeout = jasmine.createSpy('setTimeout'),
        scheduleFunction = jasmine.createSpy('scheduleFunction'),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setTimeout: fakeSetTimeout },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        ),
        timeout = new clock.FakeTimeout();

      clock.install();
      clock.setTimeout(delayedFn, 0, 'a', 'b');

      expect(fakeSetTimeout).not.toHaveBeenCalled();

      if (!NODE_JS) {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b']
        );
      } else {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          false,
          timeout
        );
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':421,'endLine':421}","it('schedules the delayed function with the fake timer', function() {
      const fakeSetTimeout = jasmine.createSpy('setTimeout'),
        scheduleFunction = jasmine.createSpy('scheduleFunction'),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setTimeout: fakeSetTimeout },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        ),
        timeout = new clock.FakeTimeout();

      clock.install();
      clock.setTimeout(delayedFn, 0, 'a', 'b');

      expect(fakeSetTimeout).not.toHaveBeenCalled();

      if (!NODE_JS) {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b']
        );
      } else {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          false,
          timeout
        );
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':464,'endLine':464}","it('returns an id for the delayed function', function() {
      const fakeSetTimeout = jasmine.createSpy('setTimeout'),
        scheduleId = 123,
        scheduleFunction = jasmine
          .createSpy('scheduleFunction')
          .and.returnValue(scheduleId),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setTimeout: fakeSetTimeout },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      const timeout = clock.setTimeout(delayedFn, 0);

      if (!NODE_JS) {
        expect(timeout).toEqual(123);
      } else {
        expect(timeout.constructor.name).toEqual('FakeTimeout');
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':465,'endLine':465}","it('returns an id for the delayed function', function() {
      const fakeSetTimeout = jasmine.createSpy('setTimeout'),
        scheduleId = 123,
        scheduleFunction = jasmine
          .createSpy('scheduleFunction')
          .and.returnValue(scheduleId),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setTimeout: fakeSetTimeout },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      const timeout = clock.setTimeout(delayedFn, 0);

      if (!NODE_JS) {
        expect(timeout).toEqual(123);
      } else {
        expect(timeout.constructor.name).toEqual('FakeTimeout');
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':466,'endLine':466}","it('returns an id for the delayed function', function() {
      const fakeSetTimeout = jasmine.createSpy('setTimeout'),
        scheduleId = 123,
        scheduleFunction = jasmine
          .createSpy('scheduleFunction')
          .and.returnValue(scheduleId),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setTimeout: fakeSetTimeout },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      const timeout = clock.setTimeout(delayedFn, 0);

      if (!NODE_JS) {
        expect(timeout).toEqual(123);
      } else {
        expect(timeout.constructor.name).toEqual('FakeTimeout');
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':496,'endLine':496}","it('clears the scheduled function with the scheduler', function() {
      const fakeClearTimeout = jasmine.createSpy('clearTimeout'),
        delayedFunctionScheduler = jasmine.createSpyObj(
          'delayedFunctionScheduler',
          ['removeFunctionWithId']
        ),
        fakeGlobal = { setTimeout: fakeClearTimeout },
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      clock.clearTimeout(123);

      expect(fakeClearTimeout).not.toHaveBeenCalled();
      expect(
        delayedFunctionScheduler.removeFunctionWithId
      ).toHaveBeenCalledWith(123);
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':497,'endLine':497}","it('clears the scheduled function with the scheduler', function() {
      const fakeClearTimeout = jasmine.createSpy('clearTimeout'),
        delayedFunctionScheduler = jasmine.createSpyObj(
          'delayedFunctionScheduler',
          ['removeFunctionWithId']
        ),
        fakeGlobal = { setTimeout: fakeClearTimeout },
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      clock.clearTimeout(123);

      expect(fakeClearTimeout).not.toHaveBeenCalled();
      expect(
        delayedFunctionScheduler.removeFunctionWithId
      ).toHaveBeenCalledWith(123);
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':498,'endLine':498}","it('clears the scheduled function with the scheduler', function() {
      const fakeClearTimeout = jasmine.createSpy('clearTimeout'),
        delayedFunctionScheduler = jasmine.createSpyObj(
          'delayedFunctionScheduler',
          ['removeFunctionWithId']
        ),
        fakeGlobal = { setTimeout: fakeClearTimeout },
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      clock.clearTimeout(123);

      expect(fakeClearTimeout).not.toHaveBeenCalled();
      expect(
        delayedFunctionScheduler.removeFunctionWithId
      ).toHaveBeenCalledWith(123);
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':526,'endLine':526}","it('schedules the delayed function with the fake timer', function() {
      const fakeSetInterval = jasmine.createSpy('setInterval'),
        scheduleFunction = jasmine.createSpy('scheduleFunction'),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setInterval: fakeSetInterval },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        ),
        timeout = new clock.FakeTimeout();

      clock.install();
      clock.setInterval(delayedFn, 0, 'a', 'b');

      expect(fakeSetInterval).not.toHaveBeenCalled();

      if (!NODE_JS) {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          true
        );
      } else {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          true,
          timeout
        );
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':527,'endLine':527}","it('schedules the delayed function with the fake timer', function() {
      const fakeSetInterval = jasmine.createSpy('setInterval'),
        scheduleFunction = jasmine.createSpy('scheduleFunction'),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setInterval: fakeSetInterval },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        ),
        timeout = new clock.FakeTimeout();

      clock.install();
      clock.setInterval(delayedFn, 0, 'a', 'b');

      expect(fakeSetInterval).not.toHaveBeenCalled();

      if (!NODE_JS) {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          true
        );
      } else {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          true,
          timeout
        );
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':528,'endLine':528}","it('schedules the delayed function with the fake timer', function() {
      const fakeSetInterval = jasmine.createSpy('setInterval'),
        scheduleFunction = jasmine.createSpy('scheduleFunction'),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setInterval: fakeSetInterval },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        ),
        timeout = new clock.FakeTimeout();

      clock.install();
      clock.setInterval(delayedFn, 0, 'a', 'b');

      expect(fakeSetInterval).not.toHaveBeenCalled();

      if (!NODE_JS) {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          true
        );
      } else {
        expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalledWith(
          delayedFn,
          0,
          ['a', 'b'],
          true,
          timeout
        );
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':572,'endLine':572}","it('returns an id for the delayed function', function() {
      const fakeSetInterval = jasmine.createSpy('setInterval'),
        scheduleId = 123,
        scheduleFunction = jasmine
          .createSpy('scheduleFunction')
          .and.returnValue(scheduleId),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setInterval: fakeSetInterval },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      const interval = clock.setInterval(delayedFn, 0);

      if (!NODE_JS) {
        expect(interval).toEqual(123);
      } else {
        expect(interval.constructor.name).toEqual('FakeTimeout');
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':573,'endLine':573}","it('returns an id for the delayed function', function() {
      const fakeSetInterval = jasmine.createSpy('setInterval'),
        scheduleId = 123,
        scheduleFunction = jasmine
          .createSpy('scheduleFunction')
          .and.returnValue(scheduleId),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setInterval: fakeSetInterval },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      const interval = clock.setInterval(delayedFn, 0);

      if (!NODE_JS) {
        expect(interval).toEqual(123);
      } else {
        expect(interval.constructor.name).toEqual('FakeTimeout');
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':574,'endLine':574}","it('returns an id for the delayed function', function() {
      const fakeSetInterval = jasmine.createSpy('setInterval'),
        scheduleId = 123,
        scheduleFunction = jasmine
          .createSpy('scheduleFunction')
          .and.returnValue(scheduleId),
        delayedFunctionScheduler = { scheduleFunction: scheduleFunction },
        fakeGlobal = { setInterval: fakeSetInterval },
        delayedFn = jasmine.createSpy('delayedFn'),
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      const interval = clock.setInterval(delayedFn, 0);

      if (!NODE_JS) {
        expect(interval).toEqual(123);
      } else {
        expect(interval.constructor.name).toEqual('FakeTimeout');
      }
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':604,'endLine':604}","it('clears the scheduled function with the scheduler', function() {
      const clearInterval = jasmine.createSpy('clearInterval'),
        delayedFunctionScheduler = jasmine.createSpyObj(
          'delayedFunctionScheduler',
          ['removeFunctionWithId']
        ),
        fakeGlobal = { setInterval: clearInterval },
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      clock.clearInterval(123);

      expect(clearInterval).not.toHaveBeenCalled();
      expect(
        delayedFunctionScheduler.removeFunctionWithId
      ).toHaveBeenCalledWith(123);
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':605,'endLine':605}","it('clears the scheduled function with the scheduler', function() {
      const clearInterval = jasmine.createSpy('clearInterval'),
        delayedFunctionScheduler = jasmine.createSpyObj(
          'delayedFunctionScheduler',
          ['removeFunctionWithId']
        ),
        fakeGlobal = { setInterval: clearInterval },
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      clock.clearInterval(123);

      expect(clearInterval).not.toHaveBeenCalled();
      expect(
        delayedFunctionScheduler.removeFunctionWithId
      ).toHaveBeenCalledWith(123);
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':606,'endLine':606}","it('clears the scheduled function with the scheduler', function() {
      const clearInterval = jasmine.createSpy('clearInterval'),
        delayedFunctionScheduler = jasmine.createSpyObj(
          'delayedFunctionScheduler',
          ['removeFunctionWithId']
        ),
        fakeGlobal = { setInterval: clearInterval },
        mockDate = {
          install: function() {},
          tick: function() {},
          uninstall: function() {}
        },
        clock = new jasmineUnderTest.Clock(
          fakeGlobal,
          function() {
            return delayedFunctionScheduler;
          },
          mockDate
        );

      clock.install();
      clock.clearInterval(123);

      expect(clearInterval).not.toHaveBeenCalled();
      expect(
        delayedFunctionScheduler.removeFunctionWithId
      ).toHaveBeenCalledWith(123);
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':645,'endLine':645}","it('can run setTimeouts/setIntervals synchronously', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFn3 = jasmine.createSpy('delayedFn3'),
      recurring1 = jasmine.createSpy('recurring1'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: setTimeout },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    clock.setTimeout(delayedFn1, 0);
    const intervalId = clock.setInterval(recurring1, 50);
    clock.setTimeout(delayedFn2, 100);
    clock.setTimeout(delayedFn3, 200);

    expect(delayedFn1).not.toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(0);

    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(50);

    expect(recurring1).toHaveBeenCalled();
    expect(recurring1.calls.count()).toBe(1);
    expect(delayedFn2).not.toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(50);

    expect(recurring1.calls.count()).toBe(2);
    expect(delayedFn2).toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(100);

    expect(recurring1.calls.count()).toBe(4);
    expect(delayedFn3).toHaveBeenCalled();

    clock.clearInterval(intervalId);
    clock.tick(50);

    expect(recurring1.calls.count()).toBe(4);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':646,'endLine':646}","it('can run setTimeouts/setIntervals synchronously', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFn3 = jasmine.createSpy('delayedFn3'),
      recurring1 = jasmine.createSpy('recurring1'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: setTimeout },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    clock.setTimeout(delayedFn1, 0);
    const intervalId = clock.setInterval(recurring1, 50);
    clock.setTimeout(delayedFn2, 100);
    clock.setTimeout(delayedFn3, 200);

    expect(delayedFn1).not.toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(0);

    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(50);

    expect(recurring1).toHaveBeenCalled();
    expect(recurring1.calls.count()).toBe(1);
    expect(delayedFn2).not.toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(50);

    expect(recurring1.calls.count()).toBe(2);
    expect(delayedFn2).toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(100);

    expect(recurring1.calls.count()).toBe(4);
    expect(delayedFn3).toHaveBeenCalled();

    clock.clearInterval(intervalId);
    clock.tick(50);

    expect(recurring1.calls.count()).toBe(4);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':647,'endLine':647}","it('can run setTimeouts/setIntervals synchronously', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFn3 = jasmine.createSpy('delayedFn3'),
      recurring1 = jasmine.createSpy('recurring1'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: setTimeout },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    clock.setTimeout(delayedFn1, 0);
    const intervalId = clock.setInterval(recurring1, 50);
    clock.setTimeout(delayedFn2, 100);
    clock.setTimeout(delayedFn3, 200);

    expect(delayedFn1).not.toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(0);

    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(50);

    expect(recurring1).toHaveBeenCalled();
    expect(recurring1.calls.count()).toBe(1);
    expect(delayedFn2).not.toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(50);

    expect(recurring1.calls.count()).toBe(2);
    expect(delayedFn2).toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(100);

    expect(recurring1.calls.count()).toBe(4);
    expect(delayedFn3).toHaveBeenCalled();

    clock.clearInterval(intervalId);
    clock.tick(50);

    expect(recurring1.calls.count()).toBe(4);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':706,'endLine':706}","beforeEach(() => {
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler();
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      };
      // window setTimeout to window to make firefox happy
      const _setTimeout =
        typeof window !== 'undefined' ? setTimeout.bind(window) : setTimeout;
      // passing a fake global allows us to preserve the real timing functions for use in tests
      const _global = { setTimeout: _setTimeout, setInterval: setInterval };
      clock = new jasmineUnderTest.Clock(
        _global,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );
      clock.install().autoTick();
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':707,'endLine':707}","beforeEach(() => {
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler();
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      };
      // window setTimeout to window to make firefox happy
      const _setTimeout =
        typeof window !== 'undefined' ? setTimeout.bind(window) : setTimeout;
      // passing a fake global allows us to preserve the real timing functions for use in tests
      const _global = { setTimeout: _setTimeout, setInterval: setInterval };
      clock = new jasmineUnderTest.Clock(
        _global,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );
      clock.install().autoTick();
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':708,'endLine':708}","beforeEach(() => {
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler();
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      };
      // window setTimeout to window to make firefox happy
      const _setTimeout =
        typeof window !== 'undefined' ? setTimeout.bind(window) : setTimeout;
      // passing a fake global allows us to preserve the real timing functions for use in tests
      const _global = { setTimeout: _setTimeout, setInterval: setInterval };
      clock = new jasmineUnderTest.Clock(
        _global,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );
      clock.install().autoTick();
    })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':855,'endLine':855}","it('can clear a previously set timeout', function() {
    const clearedFn = jasmine.createSpy('clearedFn'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    const timeoutId = clock.setTimeout(clearedFn, 100);
    expect(clearedFn).not.toHaveBeenCalled();

    clock.clearTimeout(timeoutId);
    clock.tick(100);

    expect(clearedFn).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':856,'endLine':856}","it('can clear a previously set timeout', function() {
    const clearedFn = jasmine.createSpy('clearedFn'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    const timeoutId = clock.setTimeout(clearedFn, 100);
    expect(clearedFn).not.toHaveBeenCalled();

    clock.clearTimeout(timeoutId);
    clock.tick(100);

    expect(clearedFn).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':857,'endLine':857}","it('can clear a previously set timeout', function() {
    const clearedFn = jasmine.createSpy('clearedFn'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    const timeoutId = clock.setTimeout(clearedFn, 100);
    expect(clearedFn).not.toHaveBeenCalled();

    clock.clearTimeout(timeoutId);
    clock.tick(100);

    expect(clearedFn).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':860,'endLine':860}","it('can clear a previously set timeout', function() {
    const clearedFn = jasmine.createSpy('clearedFn'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    const timeoutId = clock.setTimeout(clearedFn, 100);
    expect(clearedFn).not.toHaveBeenCalled();

    clock.clearTimeout(timeoutId);
    clock.tick(100);

    expect(clearedFn).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':882,'endLine':882}","it(""can clear a previously set interval using that interval's handler"", function() {
    const spy = jasmine.createSpy('spy'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setInterval: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    const intervalId = clock.setInterval(function() {
      spy();
      clock.clearInterval(intervalId);
    }, 100);
    clock.tick(200);

    expect(spy.calls.count()).toEqual(1);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':883,'endLine':883}","it(""can clear a previously set interval using that interval's handler"", function() {
    const spy = jasmine.createSpy('spy'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setInterval: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    const intervalId = clock.setInterval(function() {
      spy();
      clock.clearInterval(intervalId);
    }, 100);
    clock.tick(200);

    expect(spy.calls.count()).toEqual(1);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':884,'endLine':884}","it(""can clear a previously set interval using that interval's handler"", function() {
    const spy = jasmine.createSpy('spy'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setInterval: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    const intervalId = clock.setInterval(function() {
      spy();
      clock.clearInterval(intervalId);
    }, 100);
    clock.tick(200);

    expect(spy.calls.count()).toEqual(1);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':887,'endLine':887}","it(""can clear a previously set interval using that interval's handler"", function() {
    const spy = jasmine.createSpy('spy'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setInterval: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    const intervalId = clock.setInterval(function() {
      spy();
      clock.clearInterval(intervalId);
    }, 100);
    clock.tick(200);

    expect(spy.calls.count()).toEqual(1);
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':909,'endLine':909}","it('correctly schedules functions after the Clock has advanced', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    clock.tick(100);
    clock.setTimeout(delayedFn1, 10, ['some', 'arg']);
    clock.tick(5);
    expect(delayedFn1).not.toHaveBeenCalled();
    clock.tick(5);
    expect(delayedFn1).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':910,'endLine':910}","it('correctly schedules functions after the Clock has advanced', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    clock.tick(100);
    clock.setTimeout(delayedFn1, 10, ['some', 'arg']);
    clock.tick(5);
    expect(delayedFn1).not.toHaveBeenCalled();
    clock.tick(5);
    expect(delayedFn1).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':911,'endLine':911}","it('correctly schedules functions after the Clock has advanced', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    clock.tick(100);
    clock.setTimeout(delayedFn1, 10, ['some', 'arg']);
    clock.tick(5);
    expect(delayedFn1).not.toHaveBeenCalled();
    clock.tick(5);
    expect(delayedFn1).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':914,'endLine':914}","it('correctly schedules functions after the Clock has advanced', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    clock.tick(100);
    clock.setTimeout(delayedFn1, 10, ['some', 'arg']);
    clock.tick(5);
    expect(delayedFn1).not.toHaveBeenCalled();
    clock.tick(5);
    expect(delayedFn1).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':936,'endLine':936}","it('correctly schedules functions while the Clock is advancing', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    delayedFn1.and.callFake(function() {
      clock.setTimeout(delayedFn2, 0);
    });
    clock.install();
    clock.setTimeout(delayedFn1, 5);

    clock.tick(5);
    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();

    clock.tick();
    expect(delayedFn2).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':937,'endLine':937}","it('correctly schedules functions while the Clock is advancing', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    delayedFn1.and.callFake(function() {
      clock.setTimeout(delayedFn2, 0);
    });
    clock.install();
    clock.setTimeout(delayedFn1, 5);

    clock.tick(5);
    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();

    clock.tick();
    expect(delayedFn2).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':938,'endLine':938}","it('correctly schedules functions while the Clock is advancing', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    delayedFn1.and.callFake(function() {
      clock.setTimeout(delayedFn2, 0);
    });
    clock.install();
    clock.setTimeout(delayedFn1, 5);

    clock.tick(5);
    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();

    clock.tick();
    expect(delayedFn2).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':941,'endLine':941}","it('correctly schedules functions while the Clock is advancing', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    delayedFn1.and.callFake(function() {
      clock.setTimeout(delayedFn2, 0);
    });
    clock.install();
    clock.setTimeout(delayedFn1, 5);

    clock.tick(5);
    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();

    clock.tick();
    expect(delayedFn2).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':967,'endLine':967}","it('correctly calls functions scheduled while the Clock is advancing', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    delayedFn1.and.callFake(function() {
      clock.setTimeout(delayedFn2, 1);
    });
    clock.install();
    clock.setTimeout(delayedFn1, 5);

    clock.tick(6);
    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':968,'endLine':968}","it('correctly calls functions scheduled while the Clock is advancing', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    delayedFn1.and.callFake(function() {
      clock.setTimeout(delayedFn2, 1);
    });
    clock.install();
    clock.setTimeout(delayedFn1, 5);

    clock.tick(6);
    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':969,'endLine':969}","it('correctly calls functions scheduled while the Clock is advancing', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    delayedFn1.and.callFake(function() {
      clock.setTimeout(delayedFn2, 1);
    });
    clock.install();
    clock.setTimeout(delayedFn1, 5);

    clock.tick(6);
    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':972,'endLine':972}","it('correctly calls functions scheduled while the Clock is advancing', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    delayedFn1.and.callFake(function() {
      clock.setTimeout(delayedFn2, 1);
    });
    clock.install();
    clock.setTimeout(delayedFn1, 5);

    clock.tick(6);
    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':995,'endLine':995}","it('correctly schedules functions scheduled while the Clock is advancing but after the Clock is uninstalled', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    delayedFn1.and.callFake(function() {
      clock.uninstall();
      clock.install();
      clock.setTimeout(delayedFn2, 0);
    });

    clock.install();
    clock.setTimeout(delayedFn1, 1);

    clock.tick(1);
    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();

    clock.tick(1);
    expect(delayedFn2).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':996,'endLine':996}","it('correctly schedules functions scheduled while the Clock is advancing but after the Clock is uninstalled', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    delayedFn1.and.callFake(function() {
      clock.uninstall();
      clock.install();
      clock.setTimeout(delayedFn2, 0);
    });

    clock.install();
    clock.setTimeout(delayedFn1, 1);

    clock.tick(1);
    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();

    clock.tick(1);
    expect(delayedFn2).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':997,'endLine':997}","it('correctly schedules functions scheduled while the Clock is advancing but after the Clock is uninstalled', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    delayedFn1.and.callFake(function() {
      clock.uninstall();
      clock.install();
      clock.setTimeout(delayedFn2, 0);
    });

    clock.install();
    clock.setTimeout(delayedFn1, 1);

    clock.tick(1);
    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();

    clock.tick(1);
    expect(delayedFn2).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,NonFunctionalStatement,"{'startLine':1000,'endLine':1000}","it('correctly schedules functions scheduled while the Clock is advancing but after the Clock is uninstalled', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: function() {} },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    delayedFn1.and.callFake(function() {
      clock.uninstall();
      clock.install();
      clock.setTimeout(delayedFn2, 0);
    });

    clock.install();
    clock.setTimeout(delayedFn1, 1);

    clock.tick(1);
    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();

    clock.tick(1);
    expect(delayedFn2).toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,SubOptimalAssert,"{'startLine':832,'endLine':832}","it('speeds up the execution of the timers in all browsers', async () => {
      const startTimeMs = performance.now() / 1000;
      await new Promise(resolve => clock.setTimeout(resolve, 5000));
      await new Promise(resolve => clock.setTimeout(resolve, 5000));
      await new Promise(resolve => clock.setTimeout(resolve, 5000));
      await new Promise(resolve => clock.setTimeout(resolve, 5000));
      const endTimeMs = performance.now() / 1000;
      // Ensure we didn't take 20s to complete the awaits above and, in fact, can do it in a fraction of a second
      expect(endTimeMs - startTimeMs).toBeLessThan(100);
    })",snuts
/spec/core/ClockSpec.js,SubOptimalAssert,"{'startLine':1044,'endLine':1044}","it('does not mock the Date object by default', function() {
    const delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      global = { Date: Date },
      mockDate = new jasmineUnderTest.MockDate(global),
      clock = new jasmineUnderTest.Clock(
        { setTimeout: setTimeout },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    expect(global.Date).toEqual(Date);

    const now = new global.Date().getTime();

    clock.tick(50);

    expect(new global.Date().getTime() - now).not.toEqual(50);
  })",snuts
/spec/core/ClockSpec.js,SubOptimalAssert,"{'startLine':1065,'endLine':1065}","it('mocks the Date object and sets it to current time', function() {
    const delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      global = { Date: Date },
      mockDate = new jasmineUnderTest.MockDate(global),
      clock = new jasmineUnderTest.Clock(
        { setTimeout: setTimeout },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install().mockDate();

    const now = new global.Date().getTime();

    clock.tick(50);

    expect(new global.Date().getTime() - now).toEqual(50);

    let timeoutDate = 0;
    clock.setTimeout(function() {
      timeoutDate = new global.Date().getTime();
    }, 100);

    clock.tick(100);

    expect(timeoutDate - now).toEqual(150);
  })",snuts
/spec/core/ClockSpec.js,SubOptimalAssert,"{'startLine':1074,'endLine':1074}","it('mocks the Date object and sets it to current time', function() {
    const delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      global = { Date: Date },
      mockDate = new jasmineUnderTest.MockDate(global),
      clock = new jasmineUnderTest.Clock(
        { setTimeout: setTimeout },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install().mockDate();

    const now = new global.Date().getTime();

    clock.tick(50);

    expect(new global.Date().getTime() - now).toEqual(50);

    let timeoutDate = 0;
    clock.setTimeout(function() {
      timeoutDate = new global.Date().getTime();
    }, 100);

    clock.tick(100);

    expect(timeoutDate - now).toEqual(150);
  })",snuts
/spec/core/ClockSpec.js,VerboseStatement,"{'startLine':288,'endLine':346}","it('can be installed for the duration of a passed in function and uninstalled when done', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeClearTimeout = jasmine.createSpy('global clearTimeout'),
      fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeClearInterval = jasmine.createSpy('global clearInterval'),
      fakeGlobal = {
        setTimeout: fakeSetTimeout,
        clearTimeout: fakeClearTimeout,
        setInterval: fakeSetInterval,
        clearInterval: fakeClearInterval
      },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction', 'reset', 'removeFunctionWithId']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );
    let passedFunctionCalled = false;

    clock.withMock(function() {
      fakeGlobal.setTimeout(delayedFn, 0);
      fakeGlobal.clearTimeout('foo');
      fakeGlobal.setInterval(delayedFn, 10);
      fakeGlobal.clearInterval('bar');
      passedFunctionCalled = true;
    });

    expect(passedFunctionCalled).toBe(true);

    expect(fakeSetTimeout).not.toHaveBeenCalled();
    expect(fakeClearTimeout).not.toHaveBeenCalled();
    expect(fakeSetInterval).not.toHaveBeenCalled();
    expect(fakeClearInterval).not.toHaveBeenCalled();
    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();

    delayedFunctionScheduler.scheduleFunction.calls.reset();

    fakeGlobal.setTimeout(delayedFn, 0);
    fakeGlobal.clearTimeout('foo');
    fakeGlobal.setInterval(delayedFn, 10);
    fakeGlobal.clearInterval('bar');

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 10);
    expect(fakeClearInterval).toHaveBeenCalledWith('bar');
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,VerboseStatement,"{'startLine':348,'endLine':409}","it('can be installed for the duration of a passed in function and uninstalled if an error is thrown', function() {
    const fakeSetTimeout = jasmine.createSpy('global setTimeout'),
      fakeClearTimeout = jasmine.createSpy('global clearTimeout'),
      fakeSetInterval = jasmine.createSpy('global setInterval'),
      fakeClearInterval = jasmine.createSpy('global clearInterval'),
      fakeGlobal = {
        setTimeout: fakeSetTimeout,
        clearTimeout: fakeClearTimeout,
        setInterval: fakeSetInterval,
        clearInterval: fakeClearInterval
      },
      delayedFunctionScheduler = jasmine.createSpyObj(
        'delayedFunctionScheduler',
        ['scheduleFunction', 'reset', 'removeFunctionWithId']
      ),
      delayedFn = jasmine.createSpy('delayedFn'),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        fakeGlobal,
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );
    let passedFunctionCalled = false;

    expect(function() {
      clock.withMock(function() {
        fakeGlobal.setTimeout(delayedFn, 0);
        fakeGlobal.clearTimeout('foo');
        fakeGlobal.setInterval(delayedFn, 10);
        fakeGlobal.clearInterval('bar');
        passedFunctionCalled = true;
        throw 'oops';
      });
    }).toThrow('oops');

    expect(passedFunctionCalled).toBe(true);

    expect(fakeSetTimeout).not.toHaveBeenCalled();
    expect(fakeClearTimeout).not.toHaveBeenCalled();
    expect(fakeSetInterval).not.toHaveBeenCalled();
    expect(fakeClearInterval).not.toHaveBeenCalled();
    expect(delayedFunctionScheduler.scheduleFunction).toHaveBeenCalled();

    delayedFunctionScheduler.scheduleFunction.calls.reset();

    fakeGlobal.setTimeout(delayedFn, 0);
    fakeGlobal.clearTimeout('foo');
    fakeGlobal.setInterval(delayedFn, 10);
    fakeGlobal.clearInterval('bar');

    expect(fakeSetTimeout).toHaveBeenCalledWith(delayedFn, 0);
    expect(fakeClearTimeout).toHaveBeenCalledWith('foo');
    expect(fakeSetInterval).toHaveBeenCalledWith(delayedFn, 10);
    expect(fakeClearInterval).toHaveBeenCalledWith('bar');
    expect(delayedFunctionScheduler.scheduleFunction).not.toHaveBeenCalled();
  })",snuts
/spec/core/ClockSpec.js,VerboseStatement,"{'startLine':638,'endLine':696}","it('can run setTimeouts/setIntervals synchronously', function() {
    const delayedFn1 = jasmine.createSpy('delayedFn1'),
      delayedFn2 = jasmine.createSpy('delayedFn2'),
      delayedFn3 = jasmine.createSpy('delayedFn3'),
      recurring1 = jasmine.createSpy('recurring1'),
      delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      mockDate = {
        install: function() {},
        tick: function() {},
        uninstall: function() {}
      },
      clock = new jasmineUnderTest.Clock(
        { setTimeout: setTimeout },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      );

    clock.install();

    clock.setTimeout(delayedFn1, 0);
    const intervalId = clock.setInterval(recurring1, 50);
    clock.setTimeout(delayedFn2, 100);
    clock.setTimeout(delayedFn3, 200);

    expect(delayedFn1).not.toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(0);

    expect(delayedFn1).toHaveBeenCalled();
    expect(delayedFn2).not.toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(50);

    expect(recurring1).toHaveBeenCalled();
    expect(recurring1.calls.count()).toBe(1);
    expect(delayedFn2).not.toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(50);

    expect(recurring1.calls.count()).toBe(2);
    expect(delayedFn2).toHaveBeenCalled();
    expect(delayedFn3).not.toHaveBeenCalled();

    clock.tick(100);

    expect(recurring1.calls.count()).toBe(4);
    expect(delayedFn3).toHaveBeenCalled();

    clock.clearInterval(intervalId);
    clock.tick(50);

    expect(recurring1.calls.count()).toBe(4);
  })",snuts
/spec/core/ClockSpec.js,VerboseStatement,"{'startLine':1128,'endLine':1165}","it('mocks the Date object and updates the date per delayed function', function() {
    const delayedFunctionScheduler = new jasmineUnderTest.DelayedFunctionScheduler(),
      global = { Date: Date },
      mockDate = new jasmineUnderTest.MockDate(global),
      clock = new jasmineUnderTest.Clock(
        { setTimeout: setTimeout },
        function() {
          return delayedFunctionScheduler;
        },
        mockDate
      ),
      baseTime = new Date();

    clock.install().mockDate(baseTime);

    const actualTimes = [];
    const pushCurrentTime = function() {
      actualTimes.push(global.Date().getTime());
    };
    delayedFunctionScheduler.scheduleFunction(pushCurrentTime);
    delayedFunctionScheduler.scheduleFunction(pushCurrentTime, 1);
    delayedFunctionScheduler.scheduleFunction(pushCurrentTime, 3);

    clock.tick(1);
    expect(global.Date().getTime()).toEqual(baseTime.getTime() + 1);

    clock.tick(3);
    expect(global.Date().getTime()).toEqual(baseTime.getTime() + 4);

    clock.tick(1);
    expect(global.Date().getTime()).toEqual(baseTime.getTime() + 5);

    expect(actualTimes).toEqual([
      baseTime.getTime(),
      baseTime.getTime() + 1,
      baseTime.getTime() + 3
    ]);
  })",snuts
/spec/core/ClearStackSpec.js,AnonymousTest,"{'startLine':102,'endLine':115}","it('uses MessageChannel', function() {
      const global = {
        ...makeGlobal(),
        MessageChannel: fakeMessageChannel
      };
      const clearStack = jasmineUnderTest.getClearStack(global);
      let called = false;

      clearStack(function() {
        called = true;
      });

      expect(called).toBe(true);
    })",snuts
/spec/core/ClearStackSpec.js,AnonymousTest,"{'startLine':166,'endLine':181}","it('uses queueMicrotask', function() {
      const global = {
        ...makeGlobal(),
        queueMicrotask: function(fn) {
          fn();
        }
      };
      const clearStack = jasmineUnderTest.getClearStack(global);
      let called = false;

      clearStack(function() {
        called = true;
      });

      expect(called).toBe(true);
    })",snuts
/spec/core/ClearStackSpec.js,AnonymousTest,"{'startLine':211,'endLine':226}","it('uses queueMicrotask', function() {
      const global = {
        ...makeGlobal(),
        queueMicrotask: function(fn) {
          fn();
        }
      };
      const clearStack = jasmineUnderTest.getClearStack(global);
      let called = false;

      clearStack(function() {
        called = true;
      });

      expect(called).toBe(true);
    })",snuts
/spec/core/ClearStackSpec.js,IdenticalTestDescription,"{'startLine':211,'endLine':226}","it('uses queueMicrotask', function() {
      const global = {
        ...makeGlobal(),
        queueMicrotask: function(fn) {
          fn();
        }
      };
      const clearStack = jasmineUnderTest.getClearStack(global);
      let called = false;

      clearStack(function() {
        called = true;
      });

      expect(called).toBe(true);
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':42,'endLine':42}","it('uses MessageChannel to reduce setTimeout clamping', function() {
      const fakeChannel = fakeMessageChannel();
      spyOn(fakeChannel.port2, 'postMessage');
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const global = {
        navigator: {
          userAgent:
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.0.8 (KHTML, like Gecko) Version/15.1 Safari/605.0.8'
        },
        MessageChannel: function() {
          return fakeChannel;
        },
        queueMicrotask
      };

      const clearStack = jasmineUnderTest.getClearStack(global);

      for (let i = 0; i < 9; i++) {
        clearStack(function() {});
      }

      expect(fakeChannel.port2.postMessage).not.toHaveBeenCalled();

      clearStack(function() {});

      expect(fakeChannel.port2.postMessage).toHaveBeenCalledTimes(1);
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':47,'endLine':47}","it('uses MessageChannel to reduce setTimeout clamping', function() {
      const fakeChannel = fakeMessageChannel();
      spyOn(fakeChannel.port2, 'postMessage');
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const global = {
        navigator: {
          userAgent:
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.0.8 (KHTML, like Gecko) Version/15.1 Safari/605.0.8'
        },
        MessageChannel: function() {
          return fakeChannel;
        },
        queueMicrotask
      };

      const clearStack = jasmineUnderTest.getClearStack(global);

      for (let i = 0; i < 9; i++) {
        clearStack(function() {});
      }

      expect(fakeChannel.port2.postMessage).not.toHaveBeenCalled();

      clearStack(function() {});

      expect(fakeChannel.port2.postMessage).toHaveBeenCalledTimes(1);
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':131,'endLine':131}","it('uses setTimeout instead of MessageChannel every 10 calls to make sure we release the CPU', function() {
      const fakeChannel = fakeMessageChannel();
      spyOn(fakeChannel.port2, 'postMessage');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        setTimeout,
        MessageChannel: function() {
          return fakeChannel;
        }
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      for (let i = 0; i < 9; i++) {
        clearStack(function() {});
      }

      expect(fakeChannel.port2.postMessage).toHaveBeenCalled();
      expect(setTimeout).not.toHaveBeenCalled();

      clearStack(function() {});
      expect(fakeChannel.port2.postMessage).toHaveBeenCalledTimes(9);
      expect(setTimeout).toHaveBeenCalledTimes(1);

      clearStack(function() {});
      expect(fakeChannel.port2.postMessage).toHaveBeenCalledTimes(10);
      expect(setTimeout).toHaveBeenCalledTimes(1);
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':137,'endLine':137}","it('uses setTimeout instead of MessageChannel every 10 calls to make sure we release the CPU', function() {
      const fakeChannel = fakeMessageChannel();
      spyOn(fakeChannel.port2, 'postMessage');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        setTimeout,
        MessageChannel: function() {
          return fakeChannel;
        }
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      for (let i = 0; i < 9; i++) {
        clearStack(function() {});
      }

      expect(fakeChannel.port2.postMessage).toHaveBeenCalled();
      expect(setTimeout).not.toHaveBeenCalled();

      clearStack(function() {});
      expect(fakeChannel.port2.postMessage).toHaveBeenCalledTimes(9);
      expect(setTimeout).toHaveBeenCalledTimes(1);

      clearStack(function() {});
      expect(fakeChannel.port2.postMessage).toHaveBeenCalledTimes(10);
      expect(setTimeout).toHaveBeenCalledTimes(1);
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':141,'endLine':141}","it('uses setTimeout instead of MessageChannel every 10 calls to make sure we release the CPU', function() {
      const fakeChannel = fakeMessageChannel();
      spyOn(fakeChannel.port2, 'postMessage');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        setTimeout,
        MessageChannel: function() {
          return fakeChannel;
        }
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      for (let i = 0; i < 9; i++) {
        clearStack(function() {});
      }

      expect(fakeChannel.port2.postMessage).toHaveBeenCalled();
      expect(setTimeout).not.toHaveBeenCalled();

      clearStack(function() {});
      expect(fakeChannel.port2.postMessage).toHaveBeenCalledTimes(9);
      expect(setTimeout).toHaveBeenCalledTimes(1);

      clearStack(function() {});
      expect(fakeChannel.port2.postMessage).toHaveBeenCalledTimes(10);
      expect(setTimeout).toHaveBeenCalledTimes(1);
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':194,'endLine':194}","it('uses setTimeout instead of queueMicrotask every 10 calls to make sure we release the CPU', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      for (let i = 0; i < 9; i++) {
        clearStack(function() {});
      }

      expect(queueMicrotask).toHaveBeenCalled();
      expect(setTimeout).not.toHaveBeenCalled();

      clearStack(function() {});
      expect(queueMicrotask).toHaveBeenCalledTimes(9);
      expect(setTimeout).toHaveBeenCalledTimes(1);

      clearStack(function() {});
      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).toHaveBeenCalledTimes(1);
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':200,'endLine':200}","it('uses setTimeout instead of queueMicrotask every 10 calls to make sure we release the CPU', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      for (let i = 0; i < 9; i++) {
        clearStack(function() {});
      }

      expect(queueMicrotask).toHaveBeenCalled();
      expect(setTimeout).not.toHaveBeenCalled();

      clearStack(function() {});
      expect(queueMicrotask).toHaveBeenCalledTimes(9);
      expect(setTimeout).toHaveBeenCalledTimes(1);

      clearStack(function() {});
      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).toHaveBeenCalledTimes(1);
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':204,'endLine':204}","it('uses setTimeout instead of queueMicrotask every 10 calls to make sure we release the CPU', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      for (let i = 0; i < 9; i++) {
        clearStack(function() {});
      }

      expect(queueMicrotask).toHaveBeenCalled();
      expect(setTimeout).not.toHaveBeenCalled();

      clearStack(function() {});
      expect(queueMicrotask).toHaveBeenCalledTimes(9);
      expect(setTimeout).toHaveBeenCalledTimes(1);

      clearStack(function() {});
      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).toHaveBeenCalledTimes(1);
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':238,'endLine':238}","it('does not use setTimeout', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});

      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).not.toHaveBeenCalled();
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':239,'endLine':239}","it('does not use setTimeout', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});

      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).not.toHaveBeenCalled();
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':240,'endLine':240}","it('does not use setTimeout', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});

      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).not.toHaveBeenCalled();
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':241,'endLine':241}","it('does not use setTimeout', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});

      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).not.toHaveBeenCalled();
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':242,'endLine':242}","it('does not use setTimeout', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});

      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).not.toHaveBeenCalled();
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':243,'endLine':243}","it('does not use setTimeout', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});

      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).not.toHaveBeenCalled();
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':244,'endLine':244}","it('does not use setTimeout', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});

      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).not.toHaveBeenCalled();
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':245,'endLine':245}","it('does not use setTimeout', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});

      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).not.toHaveBeenCalled();
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':246,'endLine':246}","it('does not use setTimeout', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});

      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).not.toHaveBeenCalled();
    })",snuts
/spec/core/ClearStackSpec.js,NonFunctionalStatement,"{'startLine':247,'endLine':247}","it('does not use setTimeout', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});

      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).not.toHaveBeenCalled();
    })",snuts
/spec/core/ClearStackSpec.js,VerboseStatement,"{'startLine':117,'endLine':144}","it('uses setTimeout instead of MessageChannel every 10 calls to make sure we release the CPU', function() {
      const fakeChannel = fakeMessageChannel();
      spyOn(fakeChannel.port2, 'postMessage');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        setTimeout,
        MessageChannel: function() {
          return fakeChannel;
        }
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      for (let i = 0; i < 9; i++) {
        clearStack(function() {});
      }

      expect(fakeChannel.port2.postMessage).toHaveBeenCalled();
      expect(setTimeout).not.toHaveBeenCalled();

      clearStack(function() {});
      expect(fakeChannel.port2.postMessage).toHaveBeenCalledTimes(9);
      expect(setTimeout).toHaveBeenCalledTimes(1);

      clearStack(function() {});
      expect(fakeChannel.port2.postMessage).toHaveBeenCalledTimes(10);
      expect(setTimeout).toHaveBeenCalledTimes(1);
    })",snuts
/spec/core/ClearStackSpec.js,VerboseStatement,"{'startLine':228,'endLine':251}","it('does not use setTimeout', function() {
      const queueMicrotask = jasmine.createSpy('queueMicrotask');
      const setTimeout = jasmine.createSpy('setTimeout');
      const global = {
        ...makeGlobal(),
        queueMicrotask,
        setTimeout
      };
      const clearStack = jasmineUnderTest.getClearStack(global);

      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});
      clearStack(function() {});

      expect(queueMicrotask).toHaveBeenCalledTimes(10);
      expect(setTimeout).not.toHaveBeenCalled();
    })",snuts
/spec/core/CallTrackerSpec.js,SubOptimalAssert,"{'startLine':44,'endLine':44}","it(""tracks the 'this' object from each execution"", function() {
    const callTracker = new jasmineUnderTest.CallTracker();

    const this0 = {},
      this1 = {};
    callTracker.track({ object: this0, args: [] });
    callTracker.track({ object: this1, args: [] });
    callTracker.track({ args: [] });

    expect(callTracker.thisFor(0)).toBe(this0);
    expect(callTracker.thisFor(1)).toBe(this1);
    expect(callTracker.thisFor(2)).toBe(undefined);
  })",snuts
/spec/core/AsyncExpectationSpec.js,NonFunctionalStatement,"{'startLine':35,'endLine':35}","it('converts a fail to a pass', function() {
      const addExpectationResult = jasmine.createSpy('addExpectationResult'),
        actual = Promise.reject(new Error('nope')),
        expectation = jasmineUnderTest.Expectation.asyncFactory({
          matchersUtil: new jasmineUnderTest.MatchersUtil({
            pp: function() {}
          }),
          actual: actual,
          addExpectationResult: addExpectationResult
        });

      return expectation.not.toBeResolved().then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(
          true,
          jasmine.objectContaining({
            passed: true,
            message: ''
          })
        );
      });
    })",snuts
/spec/core/AsyncExpectationSpec.js,NonFunctionalStatement,"{'startLine':214,'endLine':214}","it('makes custom matchers available to this expectation', function() {
      const asyncMatchers = {
          toFoo: function() {},
          toBar: function() {}
        },
        expectation = jasmineUnderTest.Expectation.asyncFactory({
          customAsyncMatchers: asyncMatchers
        });

      expect(expectation.toFoo).toBeDefined();
      expect(expectation.toBar).toBeDefined();
    })",snuts
/spec/core/AsyncExpectationSpec.js,NonFunctionalStatement,"{'startLine':215,'endLine':215}","it('makes custom matchers available to this expectation', function() {
      const asyncMatchers = {
          toFoo: function() {},
          toBar: function() {}
        },
        expectation = jasmineUnderTest.Expectation.asyncFactory({
          customAsyncMatchers: asyncMatchers
        });

      expect(expectation.toFoo).toBeDefined();
      expect(expectation.toBar).toBeDefined();
    })",snuts
/spec/core/AsyncExpectationSpec.js,NonFunctionalStatement,"{'startLine':706,'endLine':706}","describe('AsyncExpectation', function() {
  beforeEach(function() {
    jasmineUnderTest.Expectation.addAsyncCoreMatchers(
      jasmineUnderTest.asyncMatchers
    );
  });

  describe('#not', function() {
    it('converts a pass to a fail', function() {
      const addExpectationResult = jasmine.createSpy('addExpectationResult'),
        actual = Promise.resolve(),
        pp = jasmineUnderTest.makePrettyPrinter(),
        expectation = jasmineUnderTest.Expectation.asyncFactory({
          matchersUtil: new jasmineUnderTest.MatchersUtil({ pp: pp }),
          actual: actual,
          addExpectationResult: addExpectationResult
        });

      return expectation.not.toBeResolved().then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(
          false,
          jasmine.objectContaining({
            passed: false,
            message: 'Expected [object Promise] not to be resolved.'
          })
        );
      });
    });

    it('converts a fail to a pass', function() {
      const addExpectationResult = jasmine.createSpy('addExpectationResult'),
        actual = Promise.reject(new Error('nope')),
        expectation = jasmineUnderTest.Expectation.asyncFactory({
          matchersUtil: new jasmineUnderTest.MatchersUtil({
            pp: function() {}
          }),
          actual: actual,
          addExpectationResult: addExpectationResult
        });

      return expectation.not.toBeResolved().then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(
          true,
          jasmine.objectContaining({
            passed: true,
            message: ''
          })
        );
      });
    });
  });

  it('propagates rejections from the comparison function', function() {
    const error = new Error('ExpectationSpec failure');

    const addExpectationResult = jasmine.createSpy('addExpectationResult'),
      actual = dummyPromise(),
      expectation = jasmineUnderTest.Expectation.asyncFactory({
        actual: actual,
        addExpectationResult: addExpectationResult
      });

    spyOn(expectation, 'toBeResolved').and.returnValue(Promise.reject(error));

    return expectation.toBeResolved().then(
      function() {
        fail('Expected a rejection');
      },
      function(e) {
        expect(e).toBe(error);
      }
    );
  });

  describe('#withContext', function() {
    it('prepends the context to the generated failure message', function() {
      const matchersUtil = {
          pp: function(val) {
            return val.toString();
          }
        },
        addExpectationResult = jasmine.createSpy('addExpectationResult'),
        expectation = jasmineUnderTest.Expectation.asyncFactory({
          actual: Promise.reject('rejected'),
          addExpectationResult: addExpectationResult,
          matchersUtil: matchersUtil
        });

      return expectation
        .withContext('Some context')
        .toBeResolved()
        .then(function() {
          expect(addExpectationResult).toHaveBeenCalledWith(
            false,
            jasmine.objectContaining({
              message:
                'Some context: Expected a promise to be resolved but it was rejected with rejected.'
            })
          );
        });
    });

    it('prepends the context to a custom failure message', function() {
      const matchersUtil = {
          buildFailureMessage: function() {
            return 'failure message';
          },
          pp: jasmineUnderTest.makePrettyPrinter()
        },
        addExpectationResult = jasmine.createSpy('addExpectationResult'),
        expectation = jasmineUnderTest.Expectation.asyncFactory({
          actual: Promise.reject('b'),
          addExpectationResult: addExpectationResult,
          matchersUtil: matchersUtil
        });

      return expectation
        .withContext('Some context')
        .toBeResolvedTo('a')
        .then(function() {
          expect(addExpectationResult).toHaveBeenCalledWith(
            false,
            jasmine.objectContaining({
              message:
                ""Some context: Expected a promise to be resolved to 'a' "" +
                ""but it was rejected with 'b'.""
            })
          );
        });
    });

    it('prepends the context to a custom failure message from a matcher', async function() {
      const matchersUtil = {
        buildFailureMessage() {
          return 'failure message';
        },
        pp(v) {
          return v.toString();
        }
      };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');
      const actual = Promise.reject(new Error('nope'));
      const expectation = jasmineUnderTest.Expectation.asyncFactory({
        actual: actual,
        addExpectationResult: addExpectationResult,
        matchersUtil: matchersUtil
      });

      await expectation.withContext('Some context').toBeResolved();

      expect(addExpectationResult).toHaveBeenCalledWith(
        false,
        jasmine.objectContaining({
          message:
            'Some context: Expected a promise to be resolved but it ' +
            'was rejected with Error: nope.'
        })
      );
    });

    it('works with #not', function() {
      const addExpectationResult = jasmine.createSpy('addExpectationResult'),
        actual = Promise.resolve(),
        pp = jasmineUnderTest.makePrettyPrinter(),
        expectation = jasmineUnderTest.Expectation.asyncFactory({
          actual: actual,
          addExpectationResult: addExpectationResult,
          matchersUtil: new jasmineUnderTest.MatchersUtil({ pp: pp })
        });

      return expectation
        .withContext('Some context')
        .not.toBeResolved()
        .then(function() {
          expect(addExpectationResult).toHaveBeenCalledWith(
            false,
            jasmine.objectContaining({
              message:
                'Some context: Expected [object Promise] not to be resolved.'
            })
          );
        });
    });

    it('works with #not and a custom message', function() {
      const addExpectationResult = jasmine.createSpy('addExpectationResult'),
        actual = Promise.resolve('a'),
        expectation = jasmineUnderTest.Expectation.asyncFactory({
          actual: actual,
          addExpectationResult: addExpectationResult,
          matchersUtil: new jasmineUnderTest.MatchersUtil({
            pp: jasmineUnderTest.makePrettyPrinter()
          })
        });

      return expectation
        .withContext('Some context')
        .not.toBeResolvedTo('a')
        .then(function() {
          expect(addExpectationResult).toHaveBeenCalledWith(
            false,
            jasmine.objectContaining({
              message:
                ""Some context: Expected a promise not to be resolved to 'a'.""
            })
          );
        });
    });
  });

  describe('async matchers', function() {
    it('makes custom matchers available to this expectation', function() {
      const asyncMatchers = {
          toFoo: function() {},
          toBar: function() {}
        },
        expectation = jasmineUnderTest.Expectation.asyncFactory({
          customAsyncMatchers: asyncMatchers
        });

      expect(expectation.toFoo).toBeDefined();
      expect(expectation.toBar).toBeDefined();
    });

    it(""wraps matchers's compare functions, passing in matcher dependencies"", function() {
      const fakeCompare = function() {
          return Promise.resolve({ pass: true });
        },
        matcherFactory = jasmine
          .createSpy('matcher')
          .and.returnValue({ compare: fakeCompare }),
        matchers = {
          toFoo: matcherFactory
        },
        matchersUtil = {
          buildFailureMessage: jasmine.createSpy('buildFailureMessage')
        },
        addExpectationResult = jasmine.createSpy('addExpectationResult'),
        expectation = jasmineUnderTest.Expectation.asyncFactory({
          matchersUtil: matchersUtil,
          customAsyncMatchers: matchers,
          actual: 'an actual',
          addExpectationResult: addExpectationResult
        });

      return expectation.toFoo('hello').then(function() {
        expect(matcherFactory).toHaveBeenCalledWith(matchersUtil);
      });
    });

    it(""wraps matchers's compare functions, passing the actual and expected"", function() {
      const fakeCompare = jasmine
          .createSpy('fake-compare')
          .and.returnValue(Promise.resolve({ pass: true })),
        matchers = {
          toFoo: function() {
            return {
              compare: fakeCompare
            };
          }
        },
        matchersUtil = {
          buildFailureMessage: jasmine.createSpy('buildFailureMessage')
        },
        addExpectationResult = jasmine.createSpy('addExpectationResult'),
        expectation = jasmineUnderTest.Expectation.asyncFactory({
          matchersUtil: matchersUtil,
          customAsyncMatchers: matchers,
          actual: 'an actual',
          addExpectationResult: addExpectationResult
        });

      return expectation.toFoo('hello').then(function() {
        expect(fakeCompare).toHaveBeenCalledWith('an actual', 'hello');
      });
    });

    it('reports a passing result to the spec when the comparison passes', function() {
      const matchers = {
        toFoo: function() {
          return {
            compare: function() {
              return Promise.resolve({ pass: true });
            }
          };
        }
      };
      const matchersUtil = {
        buildFailureMessage: jasmine.createSpy('buildFailureMessage')
      };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');

      const expectation = jasmineUnderTest.Expectation.asyncFactory({
        customAsyncMatchers: matchers,
        matchersUtil: matchersUtil,
        actual: 'an actual',
        addExpectationResult: addExpectationResult
      });

      return expectation.toFoo('hello').then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(true, {
          matcherName: 'toFoo',
          passed: true,
          message: '',
          error: undefined,
          expected: 'hello',
          actual: 'an actual',
          errorForStack: jasmine.any(Error)
        });
      });
    });

    it('reports a failing result to the spec when the comparison fails', function() {
      const matchers = {
          toFoo: function() {
            return {
              compare: function() {
                return Promise.resolve({ pass: false });
              }
            };
          }
        },
        matchersUtil = {
          buildFailureMessage: function() {
            return '';
          }
        };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');

      const expectation = jasmineUnderTest.Expectation.asyncFactory({
        customAsyncMatchers: matchers,
        matchersUtil: matchersUtil,
        actual: 'an actual',
        addExpectationResult: addExpectationResult
      });

      return expectation.toFoo('hello').then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(false, {
          matcherName: 'toFoo',
          passed: false,
          expected: 'hello',
          actual: 'an actual',
          message: '',
          error: undefined,
          errorForStack: jasmine.any(Error)
        });
      });
    });

    it('reports a failing result and a custom fail message to the spec when the comparison fails', function() {
      const matchers = {
        toFoo: function() {
          return {
            compare: function() {
              return Promise.resolve({
                pass: false,
                message: 'I am a custom message'
              });
            }
          };
        }
      };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');

      const expectation = jasmineUnderTest.Expectation.asyncFactory({
        actual: 'an actual',
        customAsyncMatchers: matchers,
        addExpectationResult: addExpectationResult
      });

      return expectation.toFoo('hello').then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(false, {
          matcherName: 'toFoo',
          passed: false,
          expected: 'hello',
          actual: 'an actual',
          message: 'I am a custom message',
          error: undefined,
          errorForStack: jasmine.any(Error)
        });
      });
    });

    it('reports a failing result with a custom fail message function to the spec when the comparison fails', function() {
      const matchers = {
        toFoo: function() {
          return {
            compare: function() {
              return Promise.resolve({
                pass: false,
                message: function() {
                  return 'I am a custom message';
                }
              });
            }
          };
        }
      };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');

      const expectation = jasmineUnderTest.Expectation.asyncFactory({
        customAsyncMatchers: matchers,
        actual: 'an actual',
        addExpectationResult: addExpectationResult
      });

      return expectation.toFoo('hello').then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(false, {
          matcherName: 'toFoo',
          passed: false,
          expected: 'hello',
          actual: 'an actual',
          message: 'I am a custom message',
          error: undefined,
          errorForStack: jasmine.any(Error)
        });
      });
    });

    it('reports a passing result to the spec when the comparison fails for a negative expectation', function() {
      const matchers = {
        toFoo: function() {
          return {
            compare: function() {
              return Promise.resolve({ pass: false });
            }
          };
        }
      };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');
      const actual = 'an actual';

      const expectation = jasmineUnderTest.Expectation.asyncFactory({
        customAsyncMatchers: matchers,
        actual: 'an actual',
        addExpectationResult: addExpectationResult
      }).not;

      return expectation.toFoo('hello').then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(true, {
          matcherName: 'toFoo',
          passed: true,
          message: '',
          error: undefined,
          expected: 'hello',
          actual: actual,
          errorForStack: jasmine.any(Error)
        });
      });
    });

    it('reports a failing result to the spec when the comparison passes for a negative expectation', function() {
      const matchers = {
          toFoo: function() {
            return {
              compare: function() {
                return Promise.resolve({ pass: true });
              }
            };
          }
        },
        matchersUtil = {
          buildFailureMessage: function() {
            return 'default message';
          }
        };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');
      const actual = 'an actual';

      const expectation = jasmineUnderTest.Expectation.asyncFactory({
        customAsyncMatchers: matchers,
        actual: 'an actual',
        matchersUtil: matchersUtil,
        addExpectationResult: addExpectationResult
      }).not;

      return expectation.toFoo('hello').then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(false, {
          matcherName: 'toFoo',
          passed: false,
          expected: 'hello',
          actual: actual,
          message: 'default message',
          error: undefined,
          errorForStack: jasmine.any(Error)
        });
      });
    });

    it('reports a failing result and a custom fail message to the spec when the comparison passes for a negative expectation', function() {
      const matchers = {
        toFoo: function() {
          return {
            compare: function() {
              return Promise.resolve({
                pass: true,
                message: 'I am a custom message'
              });
            }
          };
        }
      };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');
      const actual = 'an actual';

      const expectation = jasmineUnderTest.Expectation.asyncFactory({
        customAsyncMatchers: matchers,
        actual: 'an actual',
        addExpectationResult: addExpectationResult
      }).not;

      return expectation.toFoo('hello').then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(false, {
          matcherName: 'toFoo',
          passed: false,
          expected: 'hello',
          actual: actual,
          message: 'I am a custom message',
          error: undefined,
          errorForStack: jasmine.any(Error)
        });
      });
    });

    it(""reports a passing result to the spec when the 'not' comparison passes, given a negativeCompare"", function() {
      const matchers = {
        toFoo: function() {
          return {
            compare: function() {
              return Promise.resolve({ pass: true });
            },
            negativeCompare: function() {
              return Promise.resolve({ pass: true });
            }
          };
        }
      };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');
      const actual = 'an actual';

      const expectation = jasmineUnderTest.Expectation.asyncFactory({
        customAsyncMatchers: matchers,
        actual: 'an actual',
        addExpectationResult: addExpectationResult
      }).not;

      return expectation.toFoo('hello').then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(true, {
          matcherName: 'toFoo',
          passed: true,
          expected: 'hello',
          actual: actual,
          message: '',
          error: undefined,
          errorForStack: jasmine.any(Error)
        });
      });
    });

    it(""reports a failing result and a custom fail message to the spec when the 'not' comparison fails, given a negativeCompare"", function() {
      const matchers = {
        toFoo: function() {
          return {
            compare: function() {
              return Promise.resolve({ pass: true });
            },
            negativeCompare: function() {
              return Promise.resolve({
                pass: false,
                message: ""I'm a custom message""
              });
            }
          };
        }
      };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');
      const actual = 'an actual';

      const expectation = jasmineUnderTest.Expectation.asyncFactory({
        customAsyncMatchers: matchers,
        actual: 'an actual',
        addExpectationResult: addExpectationResult
      }).not;

      return expectation.toFoo('hello').then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(false, {
          matcherName: 'toFoo',
          passed: false,
          expected: 'hello',
          actual: actual,
          message: ""I'm a custom message"",
          error: undefined,
          errorForStack: jasmine.any(Error)
        });
      });
    });

    it('reports errorWithStack when a custom error message is returned', function() {
      const customError = new Error('I am a custom error');
      const matchers = {
        toFoo: function() {
          return {
            compare: function() {
              return Promise.resolve({
                pass: false,
                message: 'I am a custom message',
                error: customError
              });
            }
          };
        }
      };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');

      const expectation = jasmineUnderTest.Expectation.asyncFactory({
        actual: 'an actual',
        customAsyncMatchers: matchers,
        addExpectationResult: addExpectationResult
      });

      return expectation.toFoo('hello').then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(false, {
          matcherName: 'toFoo',
          passed: false,
          expected: 'hello',
          actual: 'an actual',
          message: 'I am a custom message',
          error: undefined,
          errorForStack: jasmine.any(Error)
        });
      });
    });

    it(""reports a custom message to the spec when a 'not' comparison fails"", function() {
      const matchers = {
        toFoo: function() {
          return {
            compare: function() {
              return Promise.resolve({
                pass: true,
                message: 'I am a custom message'
              });
            }
          };
        }
      };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');

      const expectation = jasmineUnderTest.Expectation.asyncFactory({
        actual: 'an actual',
        customAsyncMatchers: matchers,
        addExpectationResult: addExpectationResult
      }).not;

      return expectation.toFoo('hello').then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(false, {
          matcherName: 'toFoo',
          passed: false,
          expected: 'hello',
          actual: 'an actual',
          message: 'I am a custom message',
          error: undefined,
          errorForStack: jasmine.any(Error)
        });
      });
    });

    it(""reports a custom message func to the spec when a 'not' comparison fails"", function() {
      const matchers = {
        toFoo: function() {
          return {
            compare: function() {
              return Promise.resolve({
                pass: true,
                message: function() {
                  return 'I am a custom message';
                }
              });
            }
          };
        }
      };
      const addExpectationResult = jasmine.createSpy('addExpectationResult');

      let expectation = jasmineUnderTest.Expectation.asyncFactory({
        actual: 'an actual',
        customAsyncMatchers: matchers,
        addExpectationResult: addExpectationResult
      }).not;

      return expectation.toFoo('hello').then(function() {
        expect(addExpectationResult).toHaveBeenCalledWith(false, {
          matcherName: 'toFoo',
          passed: false,
          expected: 'hello',
          actual: 'an actual',
          message: 'I am a custom message',
          error: undefined,
          errorForStack: jasmine.any(Error)
        });
      });
    });
  });

  function dummyPromise() {
    return new Promise(function() {});
  }
})",snuts
/spec/core/integration/SpecRunningSpec.js,AnonymousTest,"{'startLine':33,'endLine':70}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",snuts
/spec/core/integration/SpecRunningSpec.js,IdenticalTestDescription,"{'startLine':1156,'endLine':1256}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.describe('a suite', function() {
        env.beforeAll(function() {
          throw new Error('nope');
        });

        env.beforeEach(outerBeforeEach);
        env.it('a spec', outerIt);
        env.describe('a nested suite', function() {
          env.beforeAll(nestedBeforeAll);
          env.beforeEach(nestedBeforeEach);
          env.it('a nested spec', nestedIt);
          env.afterEach(nestedAfterEach);
        });
        env.afterEach(outerAfterEach);
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",snuts
/spec/core/integration/SpecRunningSpec.js,ConditionalTestLogic,"{'startLine':1391,'endLine':1393}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",snuts
/spec/core/integration/SpecRunningSpec.js,ConditionalTestLogic,"{'startLine':1397,'endLine':1399}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",snuts
/spec/core/integration/SpecRunningSpec.js,ConditionalTestLogic,"{'startLine':1405,'endLine':1407}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}","it('should assign spec ids sequentially', function() {
    let it0, it1, it2, it3, it4;
    env.describe('test suite', function() {
      it0 = env.it('spec 0', function() {});
      it1 = env.it('spec 1', function() {});
      it2 = env.xit('spec 2', function() {});
      it3 = env.it('spec 3', function() {});
    });
    env.describe('test suite 2', function() {
      it4 = env.it('spec 4', function() {});
    });

    expect(it0.id).toEqual('spec0');
    expect(it1.id).toEqual('spec1');
    expect(it2.id).toEqual('spec2');
    expect(it3.id).toEqual('spec3');
    expect(it4.id).toEqual('spec4');
  })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':18,'endLine':18}","it('should assign spec ids sequentially', function() {
    let it0, it1, it2, it3, it4;
    env.describe('test suite', function() {
      it0 = env.it('spec 0', function() {});
      it1 = env.it('spec 1', function() {});
      it2 = env.xit('spec 2', function() {});
      it3 = env.it('spec 3', function() {});
    });
    env.describe('test suite 2', function() {
      it4 = env.it('spec 4', function() {});
    });

    expect(it0.id).toEqual('spec0');
    expect(it1.id).toEqual('spec1');
    expect(it2.id).toEqual('spec2');
    expect(it3.id).toEqual('spec3');
    expect(it4.id).toEqual('spec4');
  })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':19,'endLine':19}","it('should assign spec ids sequentially', function() {
    let it0, it1, it2, it3, it4;
    env.describe('test suite', function() {
      it0 = env.it('spec 0', function() {});
      it1 = env.it('spec 1', function() {});
      it2 = env.xit('spec 2', function() {});
      it3 = env.it('spec 3', function() {});
    });
    env.describe('test suite 2', function() {
      it4 = env.it('spec 4', function() {});
    });

    expect(it0.id).toEqual('spec0');
    expect(it1.id).toEqual('spec1');
    expect(it2.id).toEqual('spec2');
    expect(it3.id).toEqual('spec3');
    expect(it4.id).toEqual('spec4');
  })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':20,'endLine':20}","it('should assign spec ids sequentially', function() {
    let it0, it1, it2, it3, it4;
    env.describe('test suite', function() {
      it0 = env.it('spec 0', function() {});
      it1 = env.it('spec 1', function() {});
      it2 = env.xit('spec 2', function() {});
      it3 = env.it('spec 3', function() {});
    });
    env.describe('test suite 2', function() {
      it4 = env.it('spec 4', function() {});
    });

    expect(it0.id).toEqual('spec0');
    expect(it1.id).toEqual('spec1');
    expect(it2.id).toEqual('spec2');
    expect(it3.id).toEqual('spec3');
    expect(it4.id).toEqual('spec4');
  })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':23,'endLine':23}","it('should assign spec ids sequentially', function() {
    let it0, it1, it2, it3, it4;
    env.describe('test suite', function() {
      it0 = env.it('spec 0', function() {});
      it1 = env.it('spec 1', function() {});
      it2 = env.xit('spec 2', function() {});
      it3 = env.it('spec 3', function() {});
    });
    env.describe('test suite 2', function() {
      it4 = env.it('spec 4', function() {});
    });

    expect(it0.id).toEqual('spec0');
    expect(it1.id).toEqual('spec1');
    expect(it2.id).toEqual('spec2');
    expect(it3.id).toEqual('spec3');
    expect(it4.id).toEqual('spec4');
  })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':641,'endLine':641}","it('refuses to re-enter suites with a beforeAll', async function() {
    const actions = [];
    let spec1;
    let spec2;
    let spec3;

    env.describe('top', function() {
      env.beforeAll(function() {});

      spec1 = env.it('spec1', function() {
        actions.push('spec1');
      });

      spec2 = env.it('spec2', function() {
        actions.push('spec2');
      });
    });

    spec3 = env.it('spec3', function() {
      actions.push('spec3');
    });

    const promise = env.execute([spec2.id, spec3.id, spec1.id]);
    await expectAsync(promise).toBeRejectedWithError(/beforeAll/);
    expect(actions).toEqual([]);
  })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':668,'endLine':668}","it('refuses to re-enter suites with a afterAll', async function() {
    const actions = [];
    let spec1;
    let spec2;
    let spec3;

    env.describe('top', function() {
      env.afterAll(function() {});

      spec1 = env.it('spec1', function() {
        actions.push('spec1');
      });

      spec2 = env.it('spec2', function() {
        actions.push('spec2');
      });
    });

    spec3 = env.it('spec3', function() {
      actions.push('spec3');
    });

    const promise = env.execute([spec2.id, spec3.id, spec1.id]);
    await expectAsync(promise).toBeRejectedWithError(/afterAll/);
    expect(actions).toEqual([]);
  })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':928,'endLine':928}","it('runs all reporter callbacks even if one fails', async function() {
      const laterReporter = jasmine.createSpyObj('laterReporter', ['specDone']);

      env.it('a spec', function() {});
      env.addReporter({
        specDone: function() {
          throw new Error('nope');
        }
      });
      env.addReporter(laterReporter);

      await env.execute();

      expect(laterReporter.specDone).toHaveBeenCalled();
    })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':953,'endLine':953}","it('skips cleanup functions that are defined in child suites when a beforeEach errors', async function() {
      const parentAfterEachFn = jasmine.createSpy('parentAfterEachFn');
      const childAfterEachFn = jasmine.createSpy('childAfterEachFn');

      env.describe('parent suite', function() {
        env.beforeEach(function() {
          throw new Error('nope');
        });

        env.afterEach(parentAfterEachFn);

        env.describe('child suite', function() {
          env.it('a spec', function() {});
          env.afterEach(childAfterEachFn);
        });
      });

      await env.execute();

      expect(parentAfterEachFn).toHaveBeenCalled();
      expect(childAfterEachFn).not.toHaveBeenCalled();
    })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':1269,'endLine':1269}","it('runs afterAll functions in the current suite and outer scopes', async function() {
      const outerAfterAll = jasmine.createSpy('outerAfterAll');
      const nestedAfterAll = jasmine.createSpy('nestedAfterAll');
      const secondNestedAfterAll = jasmine.createSpy('secondNestedAfterAll');

      env.describe('a nested suite', function() {
        env.beforeAll(function() {
          throw new Error('nope');
        });

        env.describe('more nesting', function() {
          env.it('a nested spec', function() {});
          env.afterAll(secondNestedAfterAll);
        });

        env.afterAll(nestedAfterAll);
      });
      env.afterAll(outerAfterAll);

      await env.execute();

      expect(secondNestedAfterAll).not.toHaveBeenCalled();
      expect(nestedAfterAll).toHaveBeenCalled();
      expect(outerAfterAll).toHaveBeenCalled();
    })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':1401,'endLine':1401}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':1414,'endLine':1414}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':1418,'endLine':1418}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':1515,'endLine':1515}","it('should be able to filter out different tests in subsequent runs', async function() {
      const specResults = {};
      let focussedSpec = 'spec1';

      env.configure({
        specFilter: function(spec) {
          return spec.description === focussedSpec;
        }
      });

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {});
        env.it('spec2', function() {});
        env.it('spec3', function() {});
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'excluded',
        spec3: 'excluded'
      });

      focussedSpec = 'spec2';
      await env.execute();
      expect(specResults).toEqual({
        spec1: 'excluded',
        spec2: 'passed',
        spec3: 'excluded'
      });

      focussedSpec = 'spec3';
      await env.execute();
      expect(specResults).toEqual({
        spec1: 'excluded',
        spec2: 'excluded',
        spec3: 'passed'
      });
    })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':1516,'endLine':1516}","it('should be able to filter out different tests in subsequent runs', async function() {
      const specResults = {};
      let focussedSpec = 'spec1';

      env.configure({
        specFilter: function(spec) {
          return spec.description === focussedSpec;
        }
      });

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {});
        env.it('spec2', function() {});
        env.it('spec3', function() {});
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'excluded',
        spec3: 'excluded'
      });

      focussedSpec = 'spec2';
      await env.execute();
      expect(specResults).toEqual({
        spec1: 'excluded',
        spec2: 'passed',
        spec3: 'excluded'
      });

      focussedSpec = 'spec3';
      await env.execute();
      expect(specResults).toEqual({
        spec1: 'excluded',
        spec2: 'excluded',
        spec3: 'passed'
      });
    })",snuts
/spec/core/integration/SpecRunningSpec.js,NonFunctionalStatement,"{'startLine':1517,'endLine':1517}","it('should be able to filter out different tests in subsequent runs', async function() {
      const specResults = {};
      let focussedSpec = 'spec1';

      env.configure({
        specFilter: function(spec) {
          return spec.description === focussedSpec;
        }
      });

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {});
        env.it('spec2', function() {});
        env.it('spec3', function() {});
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'excluded',
        spec3: 'excluded'
      });

      focussedSpec = 'spec2';
      await env.execute();
      expect(specResults).toEqual({
        spec1: 'excluded',
        spec2: 'passed',
        spec3: 'excluded'
      });

      focussedSpec = 'spec3';
      await env.execute();
      expect(specResults).toEqual({
        spec1: 'excluded',
        spec2: 'excluded',
        spec3: 'passed'
      });
    })",snuts
/spec/core/integration/SpecRunningSpec.js,VerboseStatement,"{'startLine':33,'endLine':70}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",snuts
/spec/core/integration/SpecRunningSpec.js,VerboseStatement,"{'startLine':1054,'endLine':1152}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.beforeAll(function() {
        throw new Error('nope');
      });

      env.beforeEach(outerBeforeEach);
      env.it('a spec', outerIt);
      env.describe('a nested suite', function() {
        env.beforeAll(nestedBeforeAll);
        env.beforeEach(nestedBeforeEach);
        env.it('a nested spec', nestedIt);
        env.afterEach(nestedAfterEach);
      });
      env.afterEach(outerAfterEach);

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",snuts
/spec/core/integration/SpecRunningSpec.js,VerboseStatement,"{'startLine':1156,'endLine':1256}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.describe('a suite', function() {
        env.beforeAll(function() {
          throw new Error('nope');
        });

        env.beforeEach(outerBeforeEach);
        env.it('a spec', outerIt);
        env.describe('a nested suite', function() {
          env.beforeAll(nestedBeforeAll);
          env.beforeEach(nestedBeforeEach);
          env.it('a nested spec', nestedIt);
          env.afterEach(nestedAfterEach);
        });
        env.afterEach(outerAfterEach);
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",snuts
/spec/core/integration/ParallelSpec.js,NonFunctionalStatement,"{'startLine':14,'endLine':14}","it('removes specs and suites from previous batches', async function() {
    env.describe('a suite', function() {
      env.it('a spec', function() {});
    });
    env.it('a spec', function() {});

    await env.execute();
    env.parallelReset();

    env.describe('a suite in a new batch', function() {
      env.it('a spec in a new batch', function() {});
    });
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);
    env.addReporter(reporter);

    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalledOnceWith(
      jasmine.objectContaining({
        fullName: 'a suite in a new batch'
      })
    );
    expect(reporter.specDone).toHaveBeenCalledOnceWith(
      jasmine.objectContaining({
        fullName: 'a suite in a new batch a spec in a new batch'
      })
    );
  })",snuts
/spec/core/integration/ParallelSpec.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}","it('removes specs and suites from previous batches', async function() {
    env.describe('a suite', function() {
      env.it('a spec', function() {});
    });
    env.it('a spec', function() {});

    await env.execute();
    env.parallelReset();

    env.describe('a suite in a new batch', function() {
      env.it('a spec in a new batch', function() {});
    });
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);
    env.addReporter(reporter);

    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalledOnceWith(
      jasmine.objectContaining({
        fullName: 'a suite in a new batch'
      })
    );
    expect(reporter.specDone).toHaveBeenCalledOnceWith(
      jasmine.objectContaining({
        fullName: 'a suite in a new batch a spec in a new batch'
      })
    );
  })",snuts
/spec/core/integration/ParallelSpec.js,NonFunctionalStatement,"{'startLine':22,'endLine':22}","it('removes specs and suites from previous batches', async function() {
    env.describe('a suite', function() {
      env.it('a spec', function() {});
    });
    env.it('a spec', function() {});

    await env.execute();
    env.parallelReset();

    env.describe('a suite in a new batch', function() {
      env.it('a spec in a new batch', function() {});
    });
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);
    env.addReporter(reporter);

    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalledOnceWith(
      jasmine.objectContaining({
        fullName: 'a suite in a new batch'
      })
    );
    expect(reporter.specDone).toHaveBeenCalledOnceWith(
      jasmine.objectContaining({
        fullName: 'a suite in a new batch a spec in a new batch'
      })
    );
  })",snuts
/spec/core/integration/ParallelSpec.js,NonFunctionalStatement,"{'startLine':55,'endLine':55}","it('preserves top-level before and after fns from previous batches', async function() {
    const beforeAll = jasmine.createSpy('beforeAll');
    const beforeEach = jasmine.createSpy('beforeEach');
    const afterEach = jasmine.createSpy('afterEach');
    const afterAll = jasmine.createSpy('afterAll');
    env.beforeAll(beforeAll);
    env.beforeEach(beforeEach);
    env.afterEach(afterEach);
    env.afterAll(afterAll);

    env.parallelReset();
    env.it('a spec', function() {});
    await env.execute();

    expect(beforeAll).toHaveBeenCalled();
    expect(beforeEach).toHaveBeenCalled();
    expect(afterEach).toHaveBeenCalled();
    expect(afterAll).toHaveBeenCalled();
  })",snuts
/spec/core/integration/ParallelSpec.js,NonFunctionalStatement,"{'startLine':65,'endLine':65}","it('does not remember focused runables from previous batches', async function() {
    env.fit('a focused spec', function() {});
    env.parallelReset();
    env.it('a spec', function() {});
    const reporter = jasmine.createSpyObj('reporter', [
      'specDone',
      'jasmineDone'
    ]);
    env.addReporter(reporter);
    await env.execute();

    expect(reporter.specDone).toHaveBeenCalledOnceWith(
      jasmine.objectContaining({
        fullName: 'a spec',
        status: 'passed'
      })
    );
    expect(reporter.jasmineDone).toHaveBeenCalledWith(
      jasmine.objectContaining({ overallStatus: 'passed' })
    );
  })",snuts
/spec/core/integration/ParallelSpec.js,NonFunctionalStatement,"{'startLine':67,'endLine':67}","it('does not remember focused runables from previous batches', async function() {
    env.fit('a focused spec', function() {});
    env.parallelReset();
    env.it('a spec', function() {});
    const reporter = jasmine.createSpyObj('reporter', [
      'specDone',
      'jasmineDone'
    ]);
    env.addReporter(reporter);
    await env.execute();

    expect(reporter.specDone).toHaveBeenCalledOnceWith(
      jasmine.objectContaining({
        fullName: 'a spec',
        status: 'passed'
      })
    );
    expect(reporter.jasmineDone).toHaveBeenCalledWith(
      jasmine.objectContaining({ overallStatus: 'passed' })
    );
  })",snuts
/spec/core/integration/ParallelSpec.js,NonFunctionalStatement,"{'startLine':92,'endLine':92}","it('does not remember failures from previous batches', async function() {
    env.it('a failing spec', function() {
      env.expect(true).toBe(false);
    });
    await env.execute();
    env.parallelReset();
    env.it('a spec', function() {});
    const reporter = jasmine.createSpyObj('reporter', [
      'specDone',
      'jasmineDone'
    ]);
    env.addReporter(reporter);
    await env.execute();

    expect(reporter.jasmineDone).toHaveBeenCalledWith(
      jasmine.objectContaining({ overallStatus: 'passed' })
    );
  })",snuts
/spec/core/integration/ParallelSpec.js,NonFunctionalStatement,"{'startLine':150,'endLine':150}","it('reports errors thrown from describe', async function() {
    const reporter = jasmine.createSpyObj('reporter', ['suiteDone']);
    env.addReporter(reporter);

    env.describe('borken', function() {
      throw new Error('nope');
    });
    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'borken',
        status: 'failed',
        failedExpectations: [
          jasmine.objectContaining({
            message: jasmine.stringContaining('Error: nope')
          })
        ]
      })
    );

    // Errors in subsequent suites should also be reported
    reporter.suiteDone.calls.reset();
    env.parallelReset();
    env.describe('zarro boogs', function() {
      throw new Error('nor that either');
    });
    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalledOnceWith(
      jasmine.objectContaining({
        description: 'zarro boogs',
        status: 'failed',
        failedExpectations: [
          jasmine.objectContaining({
            message: jasmine.stringContaining('Error: nor that either')
          })
        ]
      })
    );

    // Failure state should not persist across resets
    reporter.suiteDone.calls.reset();
    env.parallelReset();
    env.describe('actually works', function() {
      env.it('a spec', function() {});
    });
    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalledOnceWith(
      jasmine.objectContaining({
        description: 'actually works',
        status: 'passed',
        failedExpectations: []
      })
    );
  })",snuts
/spec/core/integration/ParallelSpec.js,VerboseStatement,"{'startLine':44,'endLine':62}","it('preserves top-level before and after fns from previous batches', async function() {
    const beforeAll = jasmine.createSpy('beforeAll');
    const beforeEach = jasmine.createSpy('beforeEach');
    const afterEach = jasmine.createSpy('afterEach');
    const afterAll = jasmine.createSpy('afterAll');
    env.beforeAll(beforeAll);
    env.beforeEach(beforeEach);
    env.afterEach(afterEach);
    env.afterAll(afterAll);

    env.parallelReset();
    env.it('a spec', function() {});
    await env.execute();

    expect(beforeAll).toHaveBeenCalled();
    expect(beforeEach).toHaveBeenCalled();
    expect(afterEach).toHaveBeenCalled();
    expect(afterAll).toHaveBeenCalled();
  })",snuts
/spec/core/integration/ParallelSpec.js,VerboseStatement,"{'startLine':105,'endLine':161}","it('reports errors thrown from describe', async function() {
    const reporter = jasmine.createSpyObj('reporter', ['suiteDone']);
    env.addReporter(reporter);

    env.describe('borken', function() {
      throw new Error('nope');
    });
    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'borken',
        status: 'failed',
        failedExpectations: [
          jasmine.objectContaining({
            message: jasmine.stringContaining('Error: nope')
          })
        ]
      })
    );

    // Errors in subsequent suites should also be reported
    reporter.suiteDone.calls.reset();
    env.parallelReset();
    env.describe('zarro boogs', function() {
      throw new Error('nor that either');
    });
    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalledOnceWith(
      jasmine.objectContaining({
        description: 'zarro boogs',
        status: 'failed',
        failedExpectations: [
          jasmine.objectContaining({
            message: jasmine.stringContaining('Error: nor that either')
          })
        ]
      })
    );

    // Failure state should not persist across resets
    reporter.suiteDone.calls.reset();
    env.parallelReset();
    env.describe('actually works', function() {
      env.it('a spec', function() {});
    });
    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalledOnceWith(
      jasmine.objectContaining({
        description: 'actually works',
        status: 'passed',
        failedExpectations: []
      })
    );
  })",snuts
/spec/core/integration/MatchersSpec.js,AnonymousTest,"{'startLine':13,'endLine':36}","it('passes', async function() {
      env.it('a spec', function() {
        expectations(env);
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await env.execute();

      expect(reporter.specDone).toHaveBeenCalledTimes(1);
      const result = reporter.specDone.calls.argsFor(0)[0];
      expect(result.status).toEqual('passed');
      expect(result.passedExpectations.length)
        .withContext('Number of passed expectations')
        .toEqual(1);
      expect(result.failedExpectations.length)
        .withContext('Number of failed expectations')
        .toEqual(0);
      expect(
        result.failedExpectations[0] && result.failedExpectations[0].message
      )
        .withContext('Failure message')
        .toBeUndefined();
    })",snuts
/spec/core/integration/MatchersSpec.js,AnonymousTest,"{'startLine':40,'endLine':66}","it('fails', async function() {
      env.it('a spec', function() {
        expectations(env);
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await env.execute();

      expect(reporter.specDone).toHaveBeenCalledTimes(1);
      const result = reporter.specDone.calls.argsFor(0)[0];
      expect(result.status).toEqual('failed');
      expect(result.failedExpectations.length)
        .withContext('Number of failed expectations')
        .toEqual(1);
      expect(result.failedExpectations[0].message)
        .withContext('Failed with a thrown error rather than a matcher failure')
        .not.toMatch(/^Error: /);
      expect(result.failedExpectations[0].message)
        .withContext(
          'Failed with a thrown type error rather than a matcher failure'
        )
        .not.toMatch(/^TypeError: /);
      expect(result.failedExpectations[0].matcherName)
        .withContext('Matcher name')
        .not.toEqual('');
    })",snuts
/spec/core/integration/MatchersSpec.js,AnonymousTest,"{'startLine':93,'endLine':116}","it('passes', async function() {
      env.it('a spec', function() {
        return expectations(env);
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await env.execute();

      expect(reporter.specDone).toHaveBeenCalledTimes(1);
      const result = reporter.specDone.calls.argsFor(0)[0];
      expect(result.status).toEqual('passed');
      expect(result.passedExpectations.length)
        .withContext('Number of passed expectations')
        .toEqual(1);
      expect(result.failedExpectations.length)
        .withContext('Number of failed expectations')
        .toEqual(0);
      expect(
        result.failedExpectations[0] && result.failedExpectations[0].message
      )
        .withContext('Failure message')
        .toBeUndefined();
    })",snuts
/spec/core/integration/MatchersSpec.js,AnonymousTest,"{'startLine':120,'endLine':141}","it('fails', async function() {
      env.it('a spec', function() {
        return expectations(env);
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await env.execute();

      expect(reporter.specDone).toHaveBeenCalledTimes(1);
      const result = reporter.specDone.calls.argsFor(0)[0];
      expect(result.status).toEqual('failed');
      expect(result.failedExpectations.length)
        .withContext('Number of failed expectations')
        .toEqual(1);
      expect(result.failedExpectations[0].message)
        .withContext('Failed with a thrown error rather than a matcher failure')
        .not.toMatch(/^Error: /);
      expect(result.failedExpectations[0].matcherName)
        .withContext('Matcher name')
        .not.toEqual('');
    })",snuts
/spec/core/integration/MatchersSpec.js,SensitiveEquality,"{'startLine':359,'endLine':359}","describe('toBeResolvedTo', function() {
    verifyPassesAsync(function(env) {
      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });
      return env.expectAsync(Promise.resolve('5')).toBeResolvedTo(5);
    });

    verifyFailsAsync(function(env) {
      return env.expectAsync(Promise.resolve('foo')).toBeResolvedTo('bar');
    });

    verifyFailsWithCustomObjectFormattersAsync({
      formatter: function(val) {
        return '|' + val + '|';
      },
      expectations: function(env) {
        return env.expectAsync(Promise.resolve('x')).toBeResolvedTo('y');
      },
      expectedMessage:
        'Expected a promise to be resolved to |y| ' +
        'but it was resolved to |x|.'
    });
  })",snuts
/spec/core/integration/MatchersSpec.js,SensitiveEquality,"{'startLine':394,'endLine':394}","describe('toBeRejectedWith', function() {
    verifyPassesAsync(function(env) {
      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });
      return env.expectAsync(Promise.reject('5')).toBeRejectedWith(5);
    });

    verifyFailsAsync(function(env) {
      return env.expectAsync(Promise.resolve()).toBeRejectedWith('nope');
    });

    verifyFailsWithCustomObjectFormattersAsync({
      formatter: function(val) {
        return '|' + val + '|';
      },
      expectations: function(env) {
        return env.expectAsync(Promise.reject('x')).toBeRejectedWith('y');
      },
      expectedMessage:
        'Expected a promise to be rejected with |y| ' +
        'but it was rejected with |x|.'
    });
  })",snuts
/spec/core/integration/MatchersSpec.js,SensitiveEquality,"{'startLine':501,'endLine':501}","describe('toContain', function() {
    verifyPasses(function(env) {
      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });
      env.expect(['1', '2', '3']).toContain(2);
    });

    verifyFails(function(env) {
      env.expect('bar').toContain('oo');
    });
  })",snuts
/spec/core/integration/MatchersSpec.js,SensitiveEquality,"{'startLine':514,'endLine':514}","describe('toEqual', function() {
    verifyPasses(function(env) {
      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });
      env.expect(5).toEqual('5');
    });

    verifyFails(function(env) {
      env.expect('a').toEqual('b');
    });

    verifyFailsWithCustomObjectFormatters({
      formatter: function(val) {
        if (val === 5) {
          return 'five';
        } else if (val === 4) {
          return 'four';
        }
      },
      expectations: function(env) {
        env.expect([{ foo: 4 }]).toEqual([{ foo: 5 }]);
      },
      expectedMessage: 'Expected $[0].foo = four to equal five.'
    });
  })",snuts
/spec/core/integration/MatchersSpec.js,SensitiveEquality,"{'startLine':597,'endLine':597}","describe('toHaveBeenCalledWith', function() {
    verifyPasses(function(env) {
      const spy = env.createSpy();
      spy('5');
      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });
      env.expect(spy).toHaveBeenCalledWith(5);
    });

    verifyFails(function(env) {
      const spy = env.createSpy();
      env.expect(spy).toHaveBeenCalledWith('foo');
    });

    verifyFailsWithCustomObjectFormatters({
      formatter: function(val) {
        return '|' + val + '|';
      },
      expectations: function(env) {
        const spy = env.createSpy('foo');
        env.expect(spy).toHaveBeenCalledWith('x');
      },
      expectedMessage:
        'Expected spy foo to have been called with:\n' +
        '  |x|\n' +
        'but it was never called.'
    });
  })",snuts
/spec/core/integration/MatchersSpec.js,SensitiveEquality,"{'startLine':627,'endLine':627}","describe('toHaveBeenCalledOnceWith', function() {
    verifyPasses(function(env) {
      const spy = env.createSpy();
      spy('5', 3);
      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });
      env.expect(spy).toHaveBeenCalledOnceWith(5, 3);
    });

    verifyFails(function(env) {
      const spy = env.createSpy();
      env.expect(spy).toHaveBeenCalledOnceWith(5, 3);
    });
  })",snuts
/spec/core/integration/MatchersSpec.js,SensitiveEquality,"{'startLine':720,'endLine':720}","describe('toThrow', function() {
    verifyPasses(function(env) {
      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });
      env
        .expect(function() {
          throw '5';
        })
        .toThrow(5);
    });

    verifyFails(function(env) {
      env.expect(function() {}).toThrow();
    });

    verifyFailsWithCustomObjectFormatters({
      formatter: function(val) {
        return '|' + val + '|';
      },
      expectations: function(env) {
        env
          .expect(function() {
            throw 'x';
          })
          .not.toThrow();
      },
      expectedMessage: 'Expected function not to throw, but it threw |x|.'
    });
  })",snuts
/spec/core/integration/MatchersSpec.js,GeneralFixture,"{'startLine':694,'endLine':694}","beforeEach(function() {
      spyObj = env.createSpyObj('NewClass', ['spyA', 'spyB']);
    })",snuts
/spec/core/integration/MatchersSpec.js,IdenticalTestDescription,"{'startLine':93,'endLine':116}","it('passes', async function() {
      env.it('a spec', function() {
        return expectations(env);
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await env.execute();

      expect(reporter.specDone).toHaveBeenCalledTimes(1);
      const result = reporter.specDone.calls.argsFor(0)[0];
      expect(result.status).toEqual('passed');
      expect(result.passedExpectations.length)
        .withContext('Number of passed expectations')
        .toEqual(1);
      expect(result.failedExpectations.length)
        .withContext('Number of failed expectations')
        .toEqual(0);
      expect(
        result.failedExpectations[0] && result.failedExpectations[0].message
      )
        .withContext('Failure message')
        .toBeUndefined();
    })",snuts
/spec/core/integration/MatchersSpec.js,IdenticalTestDescription,"{'startLine':120,'endLine':141}","it('fails', async function() {
      env.it('a spec', function() {
        return expectations(env);
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await env.execute();

      expect(reporter.specDone).toHaveBeenCalledTimes(1);
      const result = reporter.specDone.calls.argsFor(0)[0];
      expect(result.status).toEqual('failed');
      expect(result.failedExpectations.length)
        .withContext('Number of failed expectations')
        .toEqual(1);
      expect(result.failedExpectations[0].message)
        .withContext('Failed with a thrown error rather than a matcher failure')
        .not.toMatch(/^Error: /);
      expect(result.failedExpectations[0].matcherName)
        .withContext('Matcher name')
        .not.toEqual('');
    })",snuts
/spec/core/integration/MatchersSpec.js,IdenticalTestDescription,"{'startLine':145,'endLine':165}","it('uses custom object formatters', async function() {
      const env = new jasmineUnderTest.Env();
      env.it('a spec', function() {
        env.addCustomObjectFormatter(config.formatter);
        return config.expectations(env);
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await env.execute();

      expect(reporter.specDone).toHaveBeenCalledTimes(1);
      const result = reporter.specDone.calls.argsFor(0)[0];
      expect(result.status).toEqual('failed');
      expect(result.failedExpectations.length)
        .withContext('Number of failed expectations')
        .toEqual(1);
      expect(result.failedExpectations[0].message).toEqual(
        config.expectedMessage
      );
    })",snuts
/spec/core/integration/MatchersSpec.js,NonFunctionalStatement,"{'startLine':245,'endLine':245}","describe('toBeInstanceOf', function() {
    function Ctor() {}

    verifyPasses(function(env) {
      env.expect(new Ctor()).toBeInstanceOf(Ctor);
    });

    verifyFails(function(env) {
      env.expect({}).toBeInstanceOf(Ctor);
    });
  })",snuts
/spec/core/integration/MatchersSpec.js,NonFunctionalStatement,"{'startLine':668,'endLine':668}","beforeEach(function() {
      spyObj = env.createSpyObj('NewClass', ['spyA', 'spyB']);
      spyObj.otherMethod = function() {};
    })",snuts
/spec/core/integration/MatchersSpec.js,NonFunctionalStatement,"{'startLine':730,'endLine':730}","describe('toThrow', function() {
    verifyPasses(function(env) {
      env.addCustomEqualityTester(function(a, b) {
        return a.toString() === b.toString();
      });
      env
        .expect(function() {
          throw '5';
        })
        .toThrow(5);
    });

    verifyFails(function(env) {
      env.expect(function() {}).toThrow();
    });

    verifyFailsWithCustomObjectFormatters({
      formatter: function(val) {
        return '|' + val + '|';
      },
      expectations: function(env) {
        env
          .expect(function() {
            throw 'x';
          })
          .not.toThrow();
      },
      expectedMessage: 'Expected function not to throw, but it threw |x|.'
    });
  })",snuts
/spec/core/integration/MatchersSpec.js,NonFunctionalStatement,"{'startLine':758,'endLine':758}","describe('toThrowError', function() {
    verifyPasses(function(env) {
      env
        .expect(function() {
          throw new Error();
        })
        .toThrowError();
    });

    verifyFails(function(env) {
      env.expect(function() {}).toThrowError();
    });

    verifyFailsWithCustomObjectFormatters({
      formatter: function(val) {
        return '|' + val + '|';
      },
      expectations: function(env) {
        env
          .expect(function() {
            throw 'x';
          })
          .toThrowError();
      },
      expectedMessage: 'Expected function to throw an Error, but it threw |x|.'
    });
  })",snuts
/spec/core/integration/MatchersSpec.js,NonFunctionalStatement,"{'startLine':863,'endLine':863}","it('fails when the promise is pending', async function() {
      const promise = new Promise(function() {});

      env.it('a spec', function() {
        return env.expectAsync(promise).already.toBeResolved();
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await env.execute();

      expect(reporter.specDone).toHaveBeenCalledTimes(1);
      const result = reporter.specDone.calls.argsFor(0)[0];
      expect(result.status).toEqual('failed');
      expect(result.failedExpectations.length)
        .withContext('Number of failed expectations')
        .toEqual(1);
      expect(result.failedExpectations[0].message).toEqual(
        'Expected a promise to be settled ' +
          '(via expectAsync(...).already) but it was pending.'
      );
      expect(result.failedExpectations[0].matcherName)
        .withContext('Matcher name')
        .not.toEqual('');
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,IdenticalTestDescription,"{'startLine':275,'endLine':339}","it('routes unhandled exceptions to an ancestor suite', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        const realClearStack = jasmineUnderTest.getClearStack(global);
        const clearStackCallbacks = {};
        let clearStackCallCount = 0;
        spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
          clearStackCallCount++;

          if (clearStackCallbacks[clearStackCallCount]) {
            clearStackCallbacks[clearStackCallCount]();
          }

          realClearStack(fn);
        });

        env.cleanup_();
        env = new jasmineUnderTest.Env();

        let suiteErrors = [];
        env.addReporter({
          suiteDone: function(result) {
            const messages = result.failedExpectations.map(e => e.message);
            suiteErrors = suiteErrors.concat(messages);

            if (result.description === 'A nested suite') {
              clearStackCallbacks[clearStackCallCount + 1] = function() {
                dispatchErrorEvent(global, 'error', {
                  error: 'fail at the end of the reporter queue'
                });
              };
              clearStackCallbacks[clearStackCallCount + 2] = function() {
                dispatchErrorEvent(global, 'error', {
                  error: 'fail at the end of the suite queue'
                });
              };
            }
          }
        });

        env.describe('A suite', function() {
          env.describe('A nested suite', function() {
            env.it('a spec', function() {});
          });
        });

        await env.execute();

        expect(suiteErrors).toEqual([
          'fail at the end of the reporter queue thrown',
          'fail at the end of the suite queue thrown'
        ]);
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,IdenticalTestDescription,"{'startLine':623,'endLine':687}","it('routes unhandled promise rejections to an ancestor suite', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        const realClearStack = jasmineUnderTest.getClearStack(global);
        const clearStackCallbacks = {};
        let clearStackCallCount = 0;
        spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
          clearStackCallCount++;

          if (clearStackCallbacks[clearStackCallCount]) {
            clearStackCallbacks[clearStackCallCount]();
          }

          realClearStack(fn);
        });

        env.cleanup_();
        env = new jasmineUnderTest.Env();

        let suiteErrors = [];
        env.addReporter({
          suiteDone: function(result) {
            const messages = result.failedExpectations.map(e => e.message);
            suiteErrors = suiteErrors.concat(messages);

            if (result.description === 'A nested suite') {
              clearStackCallbacks[clearStackCallCount + 1] = function() {
                dispatchErrorEvent(global, 'unhandledrejection', {
                  reason: 'fail at the end of the reporter queue'
                });
              };
              clearStackCallbacks[clearStackCallCount + 2] = function() {
                dispatchErrorEvent(global, 'unhandledrejection', {
                  reason: 'fail at the end of the suite queue'
                });
              };
            }
          }
        });

        env.describe('A suite', function() {
          env.describe('A nested suite', function() {
            env.it('a spec', function() {});
          });
        });

        await env.execute();

        expect(suiteErrors).toEqual([
          'Unhandled promise rejection: fail at the end of the reporter queue thrown',
          'Unhandled promise rejection: fail at the end of the suite queue thrown'
        ]);
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':179,'endLine':181}","it('routes unhandled exceptions to an ancestor suite', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn) {
            clearTimeout(fn);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        const realClearStack = jasmineUnderTest.getClearStack(global);
        const clearStackCallbacks = {};
        let clearStackCallCount = 0;
        spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
          clearStackCallCount++;

          if (clearStackCallbacks[clearStackCallCount]) {
            clearStackCallbacks[clearStackCallCount]();
          }

          realClearStack(fn);
        });

        env.cleanup_();
        env = new jasmineUnderTest.Env();

        let suiteErrors = [];
        env.addReporter({
          suiteDone: function(result) {
            const messages = result.failedExpectations.map(e => e.message);
            suiteErrors = suiteErrors.concat(messages);
          },
          specDone: function() {
            clearStackCallbacks[clearStackCallCount + 1] = function() {
              dispatchErrorEvent(global, 'error', {
                error: 'fail at the end of the reporter queue'
              });
            };
            clearStackCallbacks[clearStackCallCount + 2] = function() {
              dispatchErrorEvent(global, 'error', {
                error: 'fail at the end of the spec queue'
              });
            };
          }
        });

        env.describe('A suite', function() {
          env.it('is finishing when the failure occurs', function() {});
        });

        await env.execute();

        expect(suiteErrors).toEqual([
          'fail at the end of the reporter queue thrown',
          'fail at the end of the spec queue thrown'
        ]);
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':296,'endLine':298}","it('routes unhandled exceptions to an ancestor suite', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        const realClearStack = jasmineUnderTest.getClearStack(global);
        const clearStackCallbacks = {};
        let clearStackCallCount = 0;
        spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
          clearStackCallCount++;

          if (clearStackCallbacks[clearStackCallCount]) {
            clearStackCallbacks[clearStackCallCount]();
          }

          realClearStack(fn);
        });

        env.cleanup_();
        env = new jasmineUnderTest.Env();

        let suiteErrors = [];
        env.addReporter({
          suiteDone: function(result) {
            const messages = result.failedExpectations.map(e => e.message);
            suiteErrors = suiteErrors.concat(messages);

            if (result.description === 'A nested suite') {
              clearStackCallbacks[clearStackCallCount + 1] = function() {
                dispatchErrorEvent(global, 'error', {
                  error: 'fail at the end of the reporter queue'
                });
              };
              clearStackCallbacks[clearStackCallCount + 2] = function() {
                dispatchErrorEvent(global, 'error', {
                  error: 'fail at the end of the suite queue'
                });
              };
            }
          }
        });

        env.describe('A suite', function() {
          env.describe('A nested suite', function() {
            env.it('a spec', function() {});
          });
        });

        await env.execute();

        expect(suiteErrors).toEqual([
          'fail at the end of the reporter queue thrown',
          'fail at the end of the suite queue thrown'
        ]);
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':312,'endLine':323}","it('routes unhandled exceptions to an ancestor suite', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        const realClearStack = jasmineUnderTest.getClearStack(global);
        const clearStackCallbacks = {};
        let clearStackCallCount = 0;
        spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
          clearStackCallCount++;

          if (clearStackCallbacks[clearStackCallCount]) {
            clearStackCallbacks[clearStackCallCount]();
          }

          realClearStack(fn);
        });

        env.cleanup_();
        env = new jasmineUnderTest.Env();

        let suiteErrors = [];
        env.addReporter({
          suiteDone: function(result) {
            const messages = result.failedExpectations.map(e => e.message);
            suiteErrors = suiteErrors.concat(messages);

            if (result.description === 'A nested suite') {
              clearStackCallbacks[clearStackCallCount + 1] = function() {
                dispatchErrorEvent(global, 'error', {
                  error: 'fail at the end of the reporter queue'
                });
              };
              clearStackCallbacks[clearStackCallCount + 2] = function() {
                dispatchErrorEvent(global, 'error', {
                  error: 'fail at the end of the suite queue'
                });
              };
            }
          }
        });

        env.describe('A suite', function() {
          env.describe('A nested suite', function() {
            env.it('a spec', function() {});
          });
        });

        await env.execute();

        expect(suiteErrors).toEqual([
          'fail at the end of the reporter queue thrown',
          'fail at the end of the suite queue thrown'
        ]);
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':410,'endLine':414}","it('routes all errors that occur during stack clearing somewhere', async function() {
      const global = {
        ...browserEventMethods(),
        setTimeout: function(fn, delay) {
          return setTimeout(fn, delay);
        },
        clearTimeout: function(fn) {
          clearTimeout(fn);
        },
        queueMicrotask: function(fn) {
          queueMicrotask(fn);
        }
      };
      spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

      const realClearStack = jasmineUnderTest.getClearStack(global);
      let clearStackCallCount = 0;
      let jasmineDone = false;
      const expectedErrors = [];
      const expectedErrorsAfterJasmineDone = [];
      spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
        clearStackCallCount++;
        const msg = `Error in clearStack #${clearStackCallCount}`;

        if (jasmineDone) {
          expectedErrorsAfterJasmineDone.push(`${msg} thrown`);
        } else {
          expectedErrors.push(`${msg} thrown`);
        }

        dispatchErrorEvent(global, 'error', { error: msg });
        realClearStack(fn);
      });
      spyOn(console, 'error');

      env.cleanup_();
      env = new jasmineUnderTest.Env();

      const receivedErrors = [];
      function logErrors(event) {
        for (const failure of event.failedExpectations) {
          receivedErrors.push(failure.message);
        }
      }
      env.addReporter({
        specDone: logErrors,
        suiteDone: logErrors,
        jasmineDone: function(event) {
          jasmineDone = true;
          logErrors(event);
        }
      });

      env.describe('A suite', function() {
        env.it('is finishing when the failure occurs', function() {});
      });

      await env.execute();

      expect(receivedErrors.length).toEqual(expectedErrors.length);

      for (const e of expectedErrors) {
        expect(receivedErrors).toContain(e);
      }

      for (const message of expectedErrorsAfterJasmineDone) {
        /* eslint-disable-next-line no-console */
        expect(console.error).toHaveBeenCalledWith(
          jasmine.objectContaining({ message })
        );
      }
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':525,'endLine':527}","it('routes unhandled promise rejections to an ancestor suite', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn) {
            clearTimeout(fn);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        const realClearStack = jasmineUnderTest.getClearStack(global);
        const clearStackCallbacks = {};
        let clearStackCallCount = 0;
        spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
          clearStackCallCount++;

          if (clearStackCallbacks[clearStackCallCount]) {
            clearStackCallbacks[clearStackCallCount]();
          }

          realClearStack(fn);
        });

        env.cleanup_();
        env = new jasmineUnderTest.Env();

        let suiteErrors = [];
        env.addReporter({
          suiteDone: function(result) {
            const messages = result.failedExpectations.map(e => e.message);
            suiteErrors = suiteErrors.concat(messages);
          },
          specDone: function() {
            clearStackCallbacks[clearStackCallCount + 1] = function() {
              dispatchErrorEvent(global, 'unhandledrejection', {
                reason: 'fail at the end of the reporter queue'
              });
            };
            clearStackCallbacks[clearStackCallCount + 2] = function() {
              dispatchErrorEvent(global, 'unhandledrejection', {
                reason: 'fail at the end of the spec queue'
              });
            };
          }
        });

        env.describe('A suite', function() {
          env.it('is finishing when the failure occurs', function() {});
        });

        await env.execute();

        expect(suiteErrors).toEqual([
          'Unhandled promise rejection: fail at the end of the reporter queue thrown',
          'Unhandled promise rejection: fail at the end of the spec queue thrown'
        ]);
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':644,'endLine':646}","it('routes unhandled promise rejections to an ancestor suite', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        const realClearStack = jasmineUnderTest.getClearStack(global);
        const clearStackCallbacks = {};
        let clearStackCallCount = 0;
        spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
          clearStackCallCount++;

          if (clearStackCallbacks[clearStackCallCount]) {
            clearStackCallbacks[clearStackCallCount]();
          }

          realClearStack(fn);
        });

        env.cleanup_();
        env = new jasmineUnderTest.Env();

        let suiteErrors = [];
        env.addReporter({
          suiteDone: function(result) {
            const messages = result.failedExpectations.map(e => e.message);
            suiteErrors = suiteErrors.concat(messages);

            if (result.description === 'A nested suite') {
              clearStackCallbacks[clearStackCallCount + 1] = function() {
                dispatchErrorEvent(global, 'unhandledrejection', {
                  reason: 'fail at the end of the reporter queue'
                });
              };
              clearStackCallbacks[clearStackCallCount + 2] = function() {
                dispatchErrorEvent(global, 'unhandledrejection', {
                  reason: 'fail at the end of the suite queue'
                });
              };
            }
          }
        });

        env.describe('A suite', function() {
          env.describe('A nested suite', function() {
            env.it('a spec', function() {});
          });
        });

        await env.execute();

        expect(suiteErrors).toEqual([
          'Unhandled promise rejection: fail at the end of the reporter queue thrown',
          'Unhandled promise rejection: fail at the end of the suite queue thrown'
        ]);
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':660,'endLine':671}","it('routes unhandled promise rejections to an ancestor suite', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        const realClearStack = jasmineUnderTest.getClearStack(global);
        const clearStackCallbacks = {};
        let clearStackCallCount = 0;
        spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
          clearStackCallCount++;

          if (clearStackCallbacks[clearStackCallCount]) {
            clearStackCallbacks[clearStackCallCount]();
          }

          realClearStack(fn);
        });

        env.cleanup_();
        env = new jasmineUnderTest.Env();

        let suiteErrors = [];
        env.addReporter({
          suiteDone: function(result) {
            const messages = result.failedExpectations.map(e => e.message);
            suiteErrors = suiteErrors.concat(messages);

            if (result.description === 'A nested suite') {
              clearStackCallbacks[clearStackCallCount + 1] = function() {
                dispatchErrorEvent(global, 'unhandledrejection', {
                  reason: 'fail at the end of the reporter queue'
                });
              };
              clearStackCallbacks[clearStackCallCount + 2] = function() {
                dispatchErrorEvent(global, 'unhandledrejection', {
                  reason: 'fail at the end of the suite queue'
                });
              };
            }
          }
        });

        env.describe('A suite', function() {
          env.describe('A nested suite', function() {
            env.it('a spec', function() {});
          });
        });

        await env.execute();

        expect(suiteErrors).toEqual([
          'Unhandled promise rejection: fail at the end of the reporter queue thrown',
          'Unhandled promise rejection: fail at the end of the suite queue thrown'
        ]);
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':761,'endLine':765}","it('routes all unhandled promise rejections that occur during stack clearing somewhere', async function() {
      const global = {
        ...browserEventMethods(),
        setTimeout: function(fn, delay) {
          return setTimeout(fn, delay);
        },
        clearTimeout: function(fn) {
          clearTimeout(fn);
        },
        queueMicrotask: function(fn) {
          queueMicrotask(fn);
        }
      };
      spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

      const realClearStack = jasmineUnderTest.getClearStack(global);
      let clearStackCallCount = 0;
      let jasmineDone = false;
      const expectedErrors = [];
      const expectedErrorsAfterJasmineDone = [];
      spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
        clearStackCallCount++;
        const reason = `Error in clearStack #${clearStackCallCount}`;
        const expectedMsg = `Unhandled promise rejection: ${reason} thrown`;

        if (jasmineDone) {
          expectedErrorsAfterJasmineDone.push(expectedMsg);
        } else {
          expectedErrors.push(expectedMsg);
        }

        dispatchErrorEvent(global, 'unhandledrejection', { reason });
        realClearStack(fn);
      });
      spyOn(console, 'error');

      env.cleanup_();
      env = new jasmineUnderTest.Env();

      const receivedErrors = [];
      function logErrors(event) {
        for (const failure of event.failedExpectations) {
          receivedErrors.push(failure.message);
        }
      }
      env.addReporter({
        specDone: logErrors,
        suiteDone: logErrors,
        jasmineDone: function(event) {
          jasmineDone = true;
          logErrors(event);
        }
      });

      env.describe('A suite', function() {
        env.it('is finishing when the failure occurs', function() {});
      });

      await env.execute();

      expect(receivedErrors.length).toEqual(expectedErrors.length);

      for (const e of expectedErrors) {
        expect(receivedErrors).toContain(e);
      }

      for (const message of expectedErrorsAfterJasmineDone) {
        /* eslint-disable-next-line no-console */
        expect(console.error).toHaveBeenCalledWith(
          jasmine.objectContaining({ message })
        );
      }
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':1094,'endLine':1099}","it('allows global errors to be suppressed and spied on', async function() {
      env.it('a passing spec', async function() {
        await env.spyOnGlobalErrorsAsync(async spy => {
          setTimeout(() => {
            throw new Error('nope');
          });
          await new Promise(resolve => setTimeout(resolve));
          env.expect(spy).toHaveBeenCalledWith(new Error('nope'));
        });
      });

      env.it('a failing spec', async function() {
        await env.spyOnGlobalErrorsAsync(async spy => {
          setTimeout(() => {
            throw new Error('yep');
          });
          await new Promise(resolve => setTimeout(resolve));
          env.expect(spy).toHaveBeenCalledWith(new Error('nope'));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(2);
          expect(globalErrorSpy).toHaveBeenCalledWith(new Error('nope'));
          expect(globalErrorSpy).toHaveBeenCalledWith(new Error('yep'));
        }
      });

      const passingResult = resultForRunable(
        reporter.specDone,
        'a passing spec'
      );
      expect(passingResult.status).toEqual('passed');
      expect(passingResult.failedExpectations).toEqual([]);

      const failingResult = resultForRunable(
        reporter.specDone,
        'a failing spec'
      );
      expect(failingResult.status).toEqual('failed');
      expect(failingResult.failedExpectations[0].message).toMatch(
        /Expected \$\[0] = Error: yep to equal Error: nope\./
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':1150,'endLine':1156}","it('cleans up if the global error spy is left installed in a beforeAll', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.beforeAll(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const suiteResult = resultForRunable(reporter.suiteDone, 'Suite 1');
      expect(suiteResult.status).toEqual('failed');
      expect(suiteResult.failedExpectations.length).toEqual(1);
      expect(suiteResult.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const specResult = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(specResult.status).toEqual('failed');
      expect(specResult.failedExpectations.length).toEqual(1);
      expect(specResult.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':1205,'endLine':1211}","it('cleans up if the global error spy is left installed in an afterAll', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.afterAll(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'Suite 1',
        [leftInstalledMessage]
      );

      const suiteResult = resultForRunable(reporter.suiteDone, 'Suite 1');
      expect(suiteResult.status).toEqual('failed');
      expect(suiteResult.failedExpectations.length).toEqual(1);
      expect(suiteResult.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const specResult = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(specResult.status).toEqual('failed');
      expect(specResult.failedExpectations.length).toEqual(1);
      expect(specResult.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':1266,'endLine':1272}","it('cleans up if the global error spy is left installed in a beforeEach', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.beforeEach(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);

      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const spec1Result = resultForRunable(reporter.specDone, 'Suite 1 a spec');
      expect(spec1Result.status).toEqual('failed');
      expect(spec1Result.failedExpectations.length).toEqual(1);
      expect(spec1Result.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const spec2Result = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(spec2Result.status).toEqual('failed');
      expect(spec2Result.failedExpectations.length).toEqual(1);
      expect(spec2Result.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':1312,'endLine':1318}","it('cleans up if the global error spy is left installed in an it', async function() {
      env.configure({ random: false });

      env.it('spec 1', async function() {
        env.spyOnGlobalErrorsAsync(function() {
          // Never resolves
          return new Promise(() => {});
        });
      });

      env.it('spec 2', async function() {
        setTimeout(function() {
          throw new Error('should fail the spec');
        });
        await new Promise(resolve => setTimeout(resolve));
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const spec1Result = resultForRunable(reporter.specDone, 'spec 1');
      expect(spec1Result.status).toEqual('failed');
      expect(spec1Result.failedExpectations.length).toEqual(1);
      expect(spec1Result.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const spec2Result = resultForRunable(reporter.specDone, 'spec 2');
      expect(spec2Result.status).toEqual('failed');
      expect(spec2Result.failedExpectations.length).toEqual(1);
      expect(spec2Result.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,ConditionalTestLogic,"{'startLine':1367,'endLine':1373}","it('cleans up if the global error spy is left installed in an afterEach', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.afterEach(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const spec1Result = resultForRunable(reporter.specDone, 'Suite 1 a spec');
      expect(spec1Result.status).toEqual('failed');
      expect(spec1Result.failedExpectations.length).toEqual(1);
      expect(spec1Result.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const spec2Result = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(spec2Result.status).toEqual('failed');
      expect(spec2Result.failedExpectations.length).toEqual(1);
      expect(spec2Result.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':26,'endLine':26}","it('reports errors that occur during loading', async function() {
    const global = {
      ...browserEventMethods(),
      setTimeout: function(fn, delay) {
        return setTimeout(fn, delay);
      },
      clearTimeout: function(fn, delay) {
        clearTimeout(fn, delay);
      },
      queueMicrotask: function(fn) {
        queueMicrotask(fn);
      },
      onerror: function() {}
    };
    spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

    env.cleanup_();
    env = new jasmineUnderTest.Env();
    const reporter = jasmine.createSpyObj('reporter', [
      'jasmineDone',
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);
    dispatchErrorEvent(global, 'error', {
      message: 'Uncaught SyntaxError: Unexpected end of input',
      error: undefined,
      filename: 'borkenSpec.js',
      lineno: 42
    });
    const error = new Error('ENOCHEESE');
    dispatchErrorEvent(global, 'error', { error });

    await env.execute();

    const e = reporter.jasmineDone.calls.argsFor(0)[0];
    expect(e.failedExpectations).toEqual([
      {
        passed: false,
        globalErrorType: 'load',
        message: 'Uncaught SyntaxError: Unexpected end of input',
        stack: undefined,
        filename: 'borkenSpec.js',
        lineno: 42
      },
      {
        passed: false,
        globalErrorType: 'load',
        message: 'ENOCHEESE',
        stack: error.stack,
        filename: undefined,
        lineno: undefined
      }
    ]);
  })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':210,'endLine':210}","it('routes unhandled exceptions to an ancestor suite', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn) {
            clearTimeout(fn);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        const realClearStack = jasmineUnderTest.getClearStack(global);
        const clearStackCallbacks = {};
        let clearStackCallCount = 0;
        spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
          clearStackCallCount++;

          if (clearStackCallbacks[clearStackCallCount]) {
            clearStackCallbacks[clearStackCallCount]();
          }

          realClearStack(fn);
        });

        env.cleanup_();
        env = new jasmineUnderTest.Env();

        let suiteErrors = [];
        env.addReporter({
          suiteDone: function(result) {
            const messages = result.failedExpectations.map(e => e.message);
            suiteErrors = suiteErrors.concat(messages);
          },
          specDone: function() {
            clearStackCallbacks[clearStackCallCount + 1] = function() {
              dispatchErrorEvent(global, 'error', {
                error: 'fail at the end of the reporter queue'
              });
            };
            clearStackCallbacks[clearStackCallCount + 2] = function() {
              dispatchErrorEvent(global, 'error', {
                error: 'fail at the end of the spec queue'
              });
            };
          }
        });

        env.describe('A suite', function() {
          env.it('is finishing when the failure occurs', function() {});
        });

        await env.execute();

        expect(suiteErrors).toEqual([
          'fail at the end of the reporter queue thrown',
          'fail at the end of the spec queue thrown'
        ]);
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':259,'endLine':259}","it('routes unhandled exceptions to the running suite', async function() {
      const global = {
        ...browserEventMethods(),
        setTimeout: function(fn, delay) {
          return setTimeout(fn, delay);
        },
        clearTimeout: function(fn, delay) {
          clearTimeout(fn, delay);
        },
        queueMicrotask: function(fn) {
          queueMicrotask(fn);
        }
      };
      spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);
      env.cleanup_();
      env = new jasmineUnderTest.Env();
      const reporter = jasmine.createSpyObj('fakeReporter', [
        'specDone',
        'suiteDone'
      ]);

      env.addReporter(reporter);

      env.fdescribe('A suite', function() {
        env.it('fails', function(specDone) {
          setTimeout(function() {
            specDone();
            queueMicrotask(function() {
              queueMicrotask(function() {
                dispatchErrorEvent(global, 'error', { error: 'fail' });
              });
            });
          });
        });
      });

      env.describe('Ignored', function() {
        env.it('is not run', function() {});
      });

      await env.execute();

      expect(reporter.specDone).not.toHaveFailedExpectationsForRunnable(
        'A suite fails',
        ['fail thrown']
      );
      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'A suite',
        ['fail thrown']
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':329,'endLine':329}","it('routes unhandled exceptions to an ancestor suite', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        const realClearStack = jasmineUnderTest.getClearStack(global);
        const clearStackCallbacks = {};
        let clearStackCallCount = 0;
        spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
          clearStackCallCount++;

          if (clearStackCallbacks[clearStackCallCount]) {
            clearStackCallbacks[clearStackCallCount]();
          }

          realClearStack(fn);
        });

        env.cleanup_();
        env = new jasmineUnderTest.Env();

        let suiteErrors = [];
        env.addReporter({
          suiteDone: function(result) {
            const messages = result.failedExpectations.map(e => e.message);
            suiteErrors = suiteErrors.concat(messages);

            if (result.description === 'A nested suite') {
              clearStackCallbacks[clearStackCallCount + 1] = function() {
                dispatchErrorEvent(global, 'error', {
                  error: 'fail at the end of the reporter queue'
                });
              };
              clearStackCallbacks[clearStackCallCount + 2] = function() {
                dispatchErrorEvent(global, 'error', {
                  error: 'fail at the end of the suite queue'
                });
              };
            }
          }
        });

        env.describe('A suite', function() {
          env.describe('A nested suite', function() {
            env.it('a spec', function() {});
          });
        });

        await env.execute();

        expect(suiteErrors).toEqual([
          'fail at the end of the reporter queue thrown',
          'fail at the end of the suite queue thrown'
        ]);
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':368,'endLine':368}","it('logs the error to the console', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);
        env.cleanup_();
        env = new jasmineUnderTest.Env();

        spyOn(console, 'error');

        env.addReporter({
          jasmineDone: function() {
            dispatchErrorEvent(global, 'error', { error: 'a very late error' });
          }
        });

        env.it('a spec', function() {});

        await env.execute();

        /* eslint-disable-next-line no-console */
        expect(console.error).toHaveBeenCalledWith(
          'Jasmine received a result after the suite finished:'
        );
        /* eslint-disable-next-line no-console */
        expect(console.error).toHaveBeenCalledWith(
          jasmine.objectContaining({
            message: 'a very late error thrown',
            globalErrorType: 'afterAll'
          })
        );
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':440,'endLine':440}","it('routes all errors that occur during stack clearing somewhere', async function() {
      const global = {
        ...browserEventMethods(),
        setTimeout: function(fn, delay) {
          return setTimeout(fn, delay);
        },
        clearTimeout: function(fn) {
          clearTimeout(fn);
        },
        queueMicrotask: function(fn) {
          queueMicrotask(fn);
        }
      };
      spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

      const realClearStack = jasmineUnderTest.getClearStack(global);
      let clearStackCallCount = 0;
      let jasmineDone = false;
      const expectedErrors = [];
      const expectedErrorsAfterJasmineDone = [];
      spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
        clearStackCallCount++;
        const msg = `Error in clearStack #${clearStackCallCount}`;

        if (jasmineDone) {
          expectedErrorsAfterJasmineDone.push(`${msg} thrown`);
        } else {
          expectedErrors.push(`${msg} thrown`);
        }

        dispatchErrorEvent(global, 'error', { error: msg });
        realClearStack(fn);
      });
      spyOn(console, 'error');

      env.cleanup_();
      env = new jasmineUnderTest.Env();

      const receivedErrors = [];
      function logErrors(event) {
        for (const failure of event.failedExpectations) {
          receivedErrors.push(failure.message);
        }
      }
      env.addReporter({
        specDone: logErrors,
        suiteDone: logErrors,
        jasmineDone: function(event) {
          jasmineDone = true;
          logErrors(event);
        }
      });

      env.describe('A suite', function() {
        env.it('is finishing when the failure occurs', function() {});
      });

      await env.execute();

      expect(receivedErrors.length).toEqual(expectedErrors.length);

      for (const e of expectedErrors) {
        expect(receivedErrors).toContain(e);
      }

      for (const message of expectedErrorsAfterJasmineDone) {
        /* eslint-disable-next-line no-console */
        expect(console.error).toHaveBeenCalledWith(
          jasmine.objectContaining({ message })
        );
      }
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':556,'endLine':556}","it('routes unhandled promise rejections to an ancestor suite', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn) {
            clearTimeout(fn);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        const realClearStack = jasmineUnderTest.getClearStack(global);
        const clearStackCallbacks = {};
        let clearStackCallCount = 0;
        spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
          clearStackCallCount++;

          if (clearStackCallbacks[clearStackCallCount]) {
            clearStackCallbacks[clearStackCallCount]();
          }

          realClearStack(fn);
        });

        env.cleanup_();
        env = new jasmineUnderTest.Env();

        let suiteErrors = [];
        env.addReporter({
          suiteDone: function(result) {
            const messages = result.failedExpectations.map(e => e.message);
            suiteErrors = suiteErrors.concat(messages);
          },
          specDone: function() {
            clearStackCallbacks[clearStackCallCount + 1] = function() {
              dispatchErrorEvent(global, 'unhandledrejection', {
                reason: 'fail at the end of the reporter queue'
              });
            };
            clearStackCallbacks[clearStackCallCount + 2] = function() {
              dispatchErrorEvent(global, 'unhandledrejection', {
                reason: 'fail at the end of the spec queue'
              });
            };
          }
        });

        env.describe('A suite', function() {
          env.it('is finishing when the failure occurs', function() {});
        });

        await env.execute();

        expect(suiteErrors).toEqual([
          'Unhandled promise rejection: fail at the end of the reporter queue thrown',
          'Unhandled promise rejection: fail at the end of the spec queue thrown'
        ]);
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':607,'endLine':607}","it('routes unhandled promise rejections to the running suite', async function() {
      const global = {
        ...browserEventMethods(),
        setTimeout: function(fn, delay) {
          return setTimeout(fn, delay);
        },
        clearTimeout: function(fn, delay) {
          clearTimeout(fn, delay);
        },
        queueMicrotask: function(fn) {
          queueMicrotask(fn);
        }
      };
      spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);
      env.cleanup_();
      env = new jasmineUnderTest.Env();
      const reporter = jasmine.createSpyObj('fakeReporter', [
        'specDone',
        'suiteDone'
      ]);

      env.addReporter(reporter);

      env.fdescribe('A suite', function() {
        env.it('fails', function(specDone) {
          setTimeout(function() {
            specDone();
            queueMicrotask(function() {
              queueMicrotask(function() {
                dispatchErrorEvent(global, 'unhandledrejection', {
                  reason: 'fail'
                });
              });
            });
          });
        });
      });

      env.describe('Ignored', function() {
        env.it('is not run', function() {});
      });

      await env.execute();

      expect(reporter.specDone).not.toHaveFailedExpectationsForRunnable(
        'A suite fails',
        ['Unhandled promise rejection: fail thrown']
      );
      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'A suite',
        ['Unhandled promise rejection: fail thrown']
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':677,'endLine':677}","it('routes unhandled promise rejections to an ancestor suite', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        const realClearStack = jasmineUnderTest.getClearStack(global);
        const clearStackCallbacks = {};
        let clearStackCallCount = 0;
        spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
          clearStackCallCount++;

          if (clearStackCallbacks[clearStackCallCount]) {
            clearStackCallbacks[clearStackCallCount]();
          }

          realClearStack(fn);
        });

        env.cleanup_();
        env = new jasmineUnderTest.Env();

        let suiteErrors = [];
        env.addReporter({
          suiteDone: function(result) {
            const messages = result.failedExpectations.map(e => e.message);
            suiteErrors = suiteErrors.concat(messages);

            if (result.description === 'A nested suite') {
              clearStackCallbacks[clearStackCallCount + 1] = function() {
                dispatchErrorEvent(global, 'unhandledrejection', {
                  reason: 'fail at the end of the reporter queue'
                });
              };
              clearStackCallbacks[clearStackCallCount + 2] = function() {
                dispatchErrorEvent(global, 'unhandledrejection', {
                  reason: 'fail at the end of the suite queue'
                });
              };
            }
          }
        });

        env.describe('A suite', function() {
          env.describe('A nested suite', function() {
            env.it('a spec', function() {});
          });
        });

        await env.execute();

        expect(suiteErrors).toEqual([
          'Unhandled promise rejection: fail at the end of the reporter queue thrown',
          'Unhandled promise rejection: fail at the end of the suite queue thrown'
        ]);
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':718,'endLine':718}","it('logs the rejection to the console', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);
        env.cleanup_();
        env = new jasmineUnderTest.Env();

        spyOn(console, 'error');

        env.addReporter({
          jasmineDone: function() {
            dispatchErrorEvent(global, 'unhandledrejection', {
              reason: 'a very late error'
            });
          }
        });

        env.it('a spec', function() {});

        await env.execute();

        /* eslint-disable-next-line no-console */
        expect(console.error).toHaveBeenCalledWith(
          'Jasmine received a result after the suite finished:'
        );
        /* eslint-disable-next-line no-console */
        expect(console.error).toHaveBeenCalledWith(
          jasmine.objectContaining({
            message: 'Unhandled promise rejection: a very late error thrown',
            globalErrorType: 'afterAll'
          })
        );
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':791,'endLine':791}","it('routes all unhandled promise rejections that occur during stack clearing somewhere', async function() {
      const global = {
        ...browserEventMethods(),
        setTimeout: function(fn, delay) {
          return setTimeout(fn, delay);
        },
        clearTimeout: function(fn) {
          clearTimeout(fn);
        },
        queueMicrotask: function(fn) {
          queueMicrotask(fn);
        }
      };
      spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

      const realClearStack = jasmineUnderTest.getClearStack(global);
      let clearStackCallCount = 0;
      let jasmineDone = false;
      const expectedErrors = [];
      const expectedErrorsAfterJasmineDone = [];
      spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
        clearStackCallCount++;
        const reason = `Error in clearStack #${clearStackCallCount}`;
        const expectedMsg = `Unhandled promise rejection: ${reason} thrown`;

        if (jasmineDone) {
          expectedErrorsAfterJasmineDone.push(expectedMsg);
        } else {
          expectedErrors.push(expectedMsg);
        }

        dispatchErrorEvent(global, 'unhandledrejection', { reason });
        realClearStack(fn);
      });
      spyOn(console, 'error');

      env.cleanup_();
      env = new jasmineUnderTest.Env();

      const receivedErrors = [];
      function logErrors(event) {
        for (const failure of event.failedExpectations) {
          receivedErrors.push(failure.message);
        }
      }
      env.addReporter({
        specDone: logErrors,
        suiteDone: logErrors,
        jasmineDone: function(event) {
          jasmineDone = true;
          logErrors(event);
        }
      });

      env.describe('A suite', function() {
        env.it('is finishing when the failure occurs', function() {});
      });

      await env.execute();

      expect(receivedErrors.length).toEqual(expectedErrors.length);

      for (const e of expectedErrors) {
        expect(receivedErrors).toContain(e);
      }

      for (const message of expectedErrorsAfterJasmineDone) {
        /* eslint-disable-next-line no-console */
        expect(console.error).toHaveBeenCalledWith(
          jasmine.objectContaining({ message })
        );
      }
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':815,'endLine':815}","describe('When the unhandled rejection event has a promise', function() {
        function makeEvent(suffix) {
          const reason = `rejection ${suffix}`;
          const promise = Promise.reject(reason);
          promise.catch(() => {});
          return { reason, promise };
        }

        let global, reporter;

        beforeEach(function() {
          global = {
            ...browserEventMethods(),
            setTimeout: function(fn, delay) {
              return setTimeout(fn, delay);
            },
            clearTimeout: function(fn, delay) {
              clearTimeout(fn, delay);
            },
            queueMicrotask: function(fn) {
              queueMicrotask(fn);
            }
          };
          spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);
          env.cleanup_();
          env = new jasmineUnderTest.Env();
          env.configure({ detectLateRejectionHandling: true });

          reporter = jasmine.createSpyObj('fakeReporter', [
            'specDone',
            'suiteDone'
          ]);

          env.addReporter(reporter);
        });

        describe('During spec execution', function() {
          it('reports the rejection unless a corresponding rejection handled event occurs', async function() {
            env.describe('A suite', function() {
              env.it('fails', function(specDone) {
                setTimeout(function() {
                  const events = ['spec 1', 'spec 2'].map(makeEvent);

                  for (const e of events) {
                    dispatchErrorEvent(global, 'unhandledrejection', e);
                  }

                  dispatchErrorEvent(global, 'rejectionhandled', events[0]);
                  specDone();
                });
              });
            });

            await env.execute();

            expect(reporter.specDone).toHaveBeenCalledWith(
              jasmine.objectContaining({
                fullName: 'A suite fails',
                failedExpectations: [
                  // Only the second rejection should be reported, since the first
                  // one was eventually handled.
                  jasmine.objectContaining({
                    message:
                      'Unhandled promise rejection: rejection spec 2 thrown'
                  })
                ]
              })
            );
          });
        });

        describe('During beforeAll execution', function() {
          it('reports the rejection unless a corresponding rejection handled event occurs by the end of the beforeAll', async function() {
            env.describe('A suite', function() {
              let events;

              env.beforeAll(function(beforeAllDone) {
                setTimeout(function() {
                  events = ['suite 1', 'suite 2'].map(makeEvent);

                  for (const e of events) {
                    dispatchErrorEvent(global, 'unhandledrejection', e);
                  }

                  dispatchErrorEvent(global, 'rejectionhandled', events[0]);
                  beforeAllDone();
                });
              });

              env.it('is a spec', function(specDone) {
                setTimeout(function() {
                  // Should not prevent the second rejection from being reported
                  dispatchErrorEvent(global, 'rejectionhandled', events[1]);
                  specDone();
                });
              });
            });

            await env.execute();

            expect(reporter.suiteDone).toHaveBeenCalledWith(
              jasmine.objectContaining({
                fullName: 'A suite',
                failedExpectations: [
                  // Only the second rejection should be reported, since the first
                  // one was eventually handled.
                  jasmine.objectContaining({
                    message:
                      'Unhandled promise rejection: rejection suite 2 thrown'
                  })
                ]
              })
            );
          });
        });

        describe('During afterAll execution', function() {
          it('reports the rejection unless a corresponding rejection handled event occurs by the end of the afterAll', async function() {
            env.describe('A suite', function() {
              let events;

              env.afterAll(function(beforeAllDone) {
                setTimeout(function() {
                  events = ['suite 1', 'suite 2'].map(makeEvent);

                  for (const e of events) {
                    dispatchErrorEvent(global, 'unhandledrejection', e);
                  }

                  dispatchErrorEvent(global, 'rejectionhandled', events[0]);
                  beforeAllDone();
                });
              });

              env.it('is a spec', function() {});
            });

            await env.execute();

            expect(reporter.suiteDone).toHaveBeenCalledWith(
              jasmine.objectContaining({
                fullName: 'A suite',
                failedExpectations: [
                  // Only the second rejection should be reported, since the first
                  // one was eventually handled.
                  jasmine.objectContaining({
                    message:
                      'Unhandled promise rejection: rejection suite 2 thrown'
                  })
                ]
              })
            );
          });
        });
      })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':945,'endLine':945}","it('reports the rejection unless a corresponding rejection handled event occurs by the end of the afterAll', async function() {
            env.describe('A suite', function() {
              let events;

              env.afterAll(function(beforeAllDone) {
                setTimeout(function() {
                  events = ['suite 1', 'suite 2'].map(makeEvent);

                  for (const e of events) {
                    dispatchErrorEvent(global, 'unhandledrejection', e);
                  }

                  dispatchErrorEvent(global, 'rejectionhandled', events[0]);
                  beforeAllDone();
                });
              });

              env.it('is a spec', function() {});
            });

            await env.execute();

            expect(reporter.suiteDone).toHaveBeenCalledWith(
              jasmine.objectContaining({
                fullName: 'A suite',
                failedExpectations: [
                  // Only the second rejection should be reported, since the first
                  // one was eventually handled.
                  jasmine.objectContaining({
                    message:
                      'Unhandled promise rejection: rejection suite 2 thrown'
                  })
                ]
              })
            );
          })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':1126,'endLine':1126}","it('cleans up if the global error spy is left installed in a beforeAll', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.beforeAll(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const suiteResult = resultForRunable(reporter.suiteDone, 'Suite 1');
      expect(suiteResult.status).toEqual('failed');
      expect(suiteResult.failedExpectations.length).toEqual(1);
      expect(suiteResult.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const specResult = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(specResult.status).toEqual('failed');
      expect(specResult.failedExpectations.length).toEqual(1);
      expect(specResult.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':1130,'endLine':1130}","it('cleans up if the global error spy is left installed in a beforeAll', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.beforeAll(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const suiteResult = resultForRunable(reporter.suiteDone, 'Suite 1');
      expect(suiteResult.status).toEqual('failed');
      expect(suiteResult.failedExpectations.length).toEqual(1);
      expect(suiteResult.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const specResult = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(specResult.status).toEqual('failed');
      expect(specResult.failedExpectations.length).toEqual(1);
      expect(specResult.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':1181,'endLine':1181}","it('cleans up if the global error spy is left installed in an afterAll', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.afterAll(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'Suite 1',
        [leftInstalledMessage]
      );

      const suiteResult = resultForRunable(reporter.suiteDone, 'Suite 1');
      expect(suiteResult.status).toEqual('failed');
      expect(suiteResult.failedExpectations.length).toEqual(1);
      expect(suiteResult.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const specResult = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(specResult.status).toEqual('failed');
      expect(specResult.failedExpectations.length).toEqual(1);
      expect(specResult.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':1185,'endLine':1185}","it('cleans up if the global error spy is left installed in an afterAll', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.afterAll(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'Suite 1',
        [leftInstalledMessage]
      );

      const suiteResult = resultForRunable(reporter.suiteDone, 'Suite 1');
      expect(suiteResult.status).toEqual('failed');
      expect(suiteResult.failedExpectations.length).toEqual(1);
      expect(suiteResult.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const specResult = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(specResult.status).toEqual('failed');
      expect(specResult.failedExpectations.length).toEqual(1);
      expect(specResult.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':1241,'endLine':1241}","it('cleans up if the global error spy is left installed in a beforeEach', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.beforeEach(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);

      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const spec1Result = resultForRunable(reporter.specDone, 'Suite 1 a spec');
      expect(spec1Result.status).toEqual('failed');
      expect(spec1Result.failedExpectations.length).toEqual(1);
      expect(spec1Result.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const spec2Result = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(spec2Result.status).toEqual('failed');
      expect(spec2Result.failedExpectations.length).toEqual(1);
      expect(spec2Result.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':1245,'endLine':1245}","it('cleans up if the global error spy is left installed in a beforeEach', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.beforeEach(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);

      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const spec1Result = resultForRunable(reporter.specDone, 'Suite 1 a spec');
      expect(spec1Result.status).toEqual('failed');
      expect(spec1Result.failedExpectations.length).toEqual(1);
      expect(spec1Result.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const spec2Result = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(spec2Result.status).toEqual('failed');
      expect(spec2Result.failedExpectations.length).toEqual(1);
      expect(spec2Result.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':1296,'endLine':1296}","it('cleans up if the global error spy is left installed in an it', async function() {
      env.configure({ random: false });

      env.it('spec 1', async function() {
        env.spyOnGlobalErrorsAsync(function() {
          // Never resolves
          return new Promise(() => {});
        });
      });

      env.it('spec 2', async function() {
        setTimeout(function() {
          throw new Error('should fail the spec');
        });
        await new Promise(resolve => setTimeout(resolve));
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const spec1Result = resultForRunable(reporter.specDone, 'spec 1');
      expect(spec1Result.status).toEqual('failed');
      expect(spec1Result.failedExpectations.length).toEqual(1);
      expect(spec1Result.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const spec2Result = resultForRunable(reporter.specDone, 'spec 2');
      expect(spec2Result.status).toEqual('failed');
      expect(spec2Result.failedExpectations.length).toEqual(1);
      expect(spec2Result.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':1343,'endLine':1343}","it('cleans up if the global error spy is left installed in an afterEach', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.afterEach(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const spec1Result = resultForRunable(reporter.specDone, 'Suite 1 a spec');
      expect(spec1Result.status).toEqual('failed');
      expect(spec1Result.failedExpectations.length).toEqual(1);
      expect(spec1Result.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const spec2Result = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(spec2Result.status).toEqual('failed');
      expect(spec2Result.failedExpectations.length).toEqual(1);
      expect(spec2Result.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,NonFunctionalStatement,"{'startLine':1347,'endLine':1347}","it('cleans up if the global error spy is left installed in an afterEach', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.afterEach(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const spec1Result = resultForRunable(reporter.specDone, 'Suite 1 a spec');
      expect(spec1Result.status).toEqual('failed');
      expect(spec1Result.failedExpectations.length).toEqual(1);
      expect(spec1Result.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const spec2Result = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(spec2Result.status).toEqual('failed');
      expect(spec2Result.failedExpectations.length).toEqual(1);
      expect(spec2Result.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,VerboseStatement,"{'startLine':72,'endLine':113}","it('does not install a global error handler during loading', async function() {
      const originalOnerror = jasmine.createSpy('original onerror');
      const global = {
        ...browserEventMethods(),
        setTimeout: function(fn, delay) {
          return setTimeout(fn, delay);
        },
        clearTimeout: function(fn, delay) {
          clearTimeout(fn, delay);
        },
        queueMicrotask: function(fn) {
          queueMicrotask(fn);
        },
        onerror: originalOnerror
      };
      spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);
      const globalErrors = new jasmineUnderTest.GlobalErrors(global);
      const onerror = jasmine.createSpy('onerror');
      globalErrors.pushListener(onerror);

      env.cleanup_();
      env = new jasmineUnderTest.Env({
        suppressLoadErrors: true,
        GlobalErrors: function() {
          return globalErrors;
        }
      });
      const reporter = jasmine.createSpyObj('reporter', [
        'jasmineDone',
        'suiteDone',
        'specDone'
      ]);

      env.addReporter(reporter);
      global.onerror('Uncaught Error: ENOCHEESE');

      await env.execute();

      const e = reporter.jasmineDone.calls.argsFor(0)[0];
      expect(e.failedExpectations).toEqual([]);
      expect(originalOnerror).toHaveBeenCalledWith('Uncaught Error: ENOCHEESE');
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,VerboseStatement,"{'startLine':386,'endLine':457}","it('routes all errors that occur during stack clearing somewhere', async function() {
      const global = {
        ...browserEventMethods(),
        setTimeout: function(fn, delay) {
          return setTimeout(fn, delay);
        },
        clearTimeout: function(fn) {
          clearTimeout(fn);
        },
        queueMicrotask: function(fn) {
          queueMicrotask(fn);
        }
      };
      spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

      const realClearStack = jasmineUnderTest.getClearStack(global);
      let clearStackCallCount = 0;
      let jasmineDone = false;
      const expectedErrors = [];
      const expectedErrorsAfterJasmineDone = [];
      spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
        clearStackCallCount++;
        const msg = `Error in clearStack #${clearStackCallCount}`;

        if (jasmineDone) {
          expectedErrorsAfterJasmineDone.push(`${msg} thrown`);
        } else {
          expectedErrors.push(`${msg} thrown`);
        }

        dispatchErrorEvent(global, 'error', { error: msg });
        realClearStack(fn);
      });
      spyOn(console, 'error');

      env.cleanup_();
      env = new jasmineUnderTest.Env();

      const receivedErrors = [];
      function logErrors(event) {
        for (const failure of event.failedExpectations) {
          receivedErrors.push(failure.message);
        }
      }
      env.addReporter({
        specDone: logErrors,
        suiteDone: logErrors,
        jasmineDone: function(event) {
          jasmineDone = true;
          logErrors(event);
        }
      });

      env.describe('A suite', function() {
        env.it('is finishing when the failure occurs', function() {});
      });

      await env.execute();

      expect(receivedErrors.length).toEqual(expectedErrors.length);

      for (const e of expectedErrors) {
        expect(receivedErrors).toContain(e);
      }

      for (const message of expectedErrorsAfterJasmineDone) {
        /* eslint-disable-next-line no-console */
        expect(console.error).toHaveBeenCalledWith(
          jasmine.objectContaining({ message })
        );
      }
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,VerboseStatement,"{'startLine':736,'endLine':808}","it('routes all unhandled promise rejections that occur during stack clearing somewhere', async function() {
      const global = {
        ...browserEventMethods(),
        setTimeout: function(fn, delay) {
          return setTimeout(fn, delay);
        },
        clearTimeout: function(fn) {
          clearTimeout(fn);
        },
        queueMicrotask: function(fn) {
          queueMicrotask(fn);
        }
      };
      spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

      const realClearStack = jasmineUnderTest.getClearStack(global);
      let clearStackCallCount = 0;
      let jasmineDone = false;
      const expectedErrors = [];
      const expectedErrorsAfterJasmineDone = [];
      spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(function(fn) {
        clearStackCallCount++;
        const reason = `Error in clearStack #${clearStackCallCount}`;
        const expectedMsg = `Unhandled promise rejection: ${reason} thrown`;

        if (jasmineDone) {
          expectedErrorsAfterJasmineDone.push(expectedMsg);
        } else {
          expectedErrors.push(expectedMsg);
        }

        dispatchErrorEvent(global, 'unhandledrejection', { reason });
        realClearStack(fn);
      });
      spyOn(console, 'error');

      env.cleanup_();
      env = new jasmineUnderTest.Env();

      const receivedErrors = [];
      function logErrors(event) {
        for (const failure of event.failedExpectations) {
          receivedErrors.push(failure.message);
        }
      }
      env.addReporter({
        specDone: logErrors,
        suiteDone: logErrors,
        jasmineDone: function(event) {
          jasmineDone = true;
          logErrors(event);
        }
      });

      env.describe('A suite', function() {
        env.it('is finishing when the failure occurs', function() {});
      });

      await env.execute();

      expect(receivedErrors.length).toEqual(expectedErrors.length);

      for (const e of expectedErrors) {
        expect(receivedErrors).toContain(e);
      }

      for (const message of expectedErrorsAfterJasmineDone) {
        /* eslint-disable-next-line no-console */
        expect(console.error).toHaveBeenCalledWith(
          jasmine.objectContaining({ message })
        );
      }
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,VerboseStatement,"{'startLine':1119,'endLine':1172}","it('cleans up if the global error spy is left installed in a beforeAll', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.beforeAll(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const suiteResult = resultForRunable(reporter.suiteDone, 'Suite 1');
      expect(suiteResult.status).toEqual('failed');
      expect(suiteResult.failedExpectations.length).toEqual(1);
      expect(suiteResult.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const specResult = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(specResult.status).toEqual('failed');
      expect(specResult.failedExpectations.length).toEqual(1);
      expect(specResult.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,VerboseStatement,"{'startLine':1174,'endLine':1232}","it('cleans up if the global error spy is left installed in an afterAll', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.afterAll(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'Suite 1',
        [leftInstalledMessage]
      );

      const suiteResult = resultForRunable(reporter.suiteDone, 'Suite 1');
      expect(suiteResult.status).toEqual('failed');
      expect(suiteResult.failedExpectations.length).toEqual(1);
      expect(suiteResult.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const specResult = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(specResult.status).toEqual('failed');
      expect(specResult.failedExpectations.length).toEqual(1);
      expect(specResult.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,VerboseStatement,"{'startLine':1234,'endLine':1288}","it('cleans up if the global error spy is left installed in a beforeEach', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.beforeEach(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);

      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const spec1Result = resultForRunable(reporter.specDone, 'Suite 1 a spec');
      expect(spec1Result.status).toEqual('failed');
      expect(spec1Result.failedExpectations.length).toEqual(1);
      expect(spec1Result.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const spec2Result = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(spec2Result.status).toEqual('failed');
      expect(spec2Result.failedExpectations.length).toEqual(1);
      expect(spec2Result.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,VerboseStatement,"{'startLine':1290,'endLine':1334}","it('cleans up if the global error spy is left installed in an it', async function() {
      env.configure({ random: false });

      env.it('spec 1', async function() {
        env.spyOnGlobalErrorsAsync(function() {
          // Never resolves
          return new Promise(() => {});
        });
      });

      env.it('spec 2', async function() {
        setTimeout(function() {
          throw new Error('should fail the spec');
        });
        await new Promise(resolve => setTimeout(resolve));
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const spec1Result = resultForRunable(reporter.specDone, 'spec 1');
      expect(spec1Result.status).toEqual('failed');
      expect(spec1Result.failedExpectations.length).toEqual(1);
      expect(spec1Result.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const spec2Result = resultForRunable(reporter.specDone, 'spec 2');
      expect(spec2Result.status).toEqual('failed');
      expect(spec2Result.failedExpectations.length).toEqual(1);
      expect(spec2Result.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/GlobalErrorHandlingSpec.js,VerboseStatement,"{'startLine':1336,'endLine':1389}","it('cleans up if the global error spy is left installed in an afterEach', async function() {
      env.configure({ random: false });

      env.describe('Suite 1', function() {
        env.afterEach(async function() {
          env.spyOnGlobalErrorsAsync(function() {
            // Never resolves
            return new Promise(() => {});
          });
        });

        env.it('a spec', function() {});
      });

      env.describe('Suite 2', function() {
        env.it('a spec', async function() {
          setTimeout(function() {
            throw new Error('should fail the spec');
          });
          await new Promise(resolve => setTimeout(resolve));
        });
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone'
      ]);
      env.addReporter(reporter);
      await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
        await env.execute();

        if (isBrowser) {
          // Verify that there were no unexpected errors
          expect(globalErrorSpy).toHaveBeenCalledTimes(1);
          expect(globalErrorSpy).toHaveBeenCalledWith(
            new Error('should fail the spec')
          );
        }
      });

      const spec1Result = resultForRunable(reporter.specDone, 'Suite 1 a spec');
      expect(spec1Result.status).toEqual('failed');
      expect(spec1Result.failedExpectations.length).toEqual(1);
      expect(spec1Result.failedExpectations[0].message).toEqual(
        leftInstalledMessage
      );

      const spec2Result = resultForRunable(reporter.specDone, 'Suite 2 a spec');
      expect(spec2Result.status).toEqual('failed');
      expect(spec2Result.failedExpectations.length).toEqual(1);
      expect(spec2Result.failedExpectations[0].message).toMatch(
        /Error: should fail the spec/
      );
    })",snuts
/spec/core/integration/EnvSpec.js,AnonymousTest,"{'startLine':2617,'endLine':2630}","it('is ""passed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.it('passes', function() {});
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('passed');
      })",snuts
/spec/core/integration/EnvSpec.js,AnonymousTest,"{'startLine':2634,'endLine':2649}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.it('fails', function() {
          env.expect(true).toBe(false);
        });
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,AnonymousTest,"{'startLine':2686,'endLine':2702}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.beforeAll(function() {
          throw new Error('nope');
        });
        env.it('does not run', function() {});
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,AnonymousTest,"{'startLine':2706,'endLine':2724}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.describe('something', function() {
          env.beforeAll(function() {
            throw new Error('nope');
          });
          env.it('does not run', function() {});
        });
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,AnonymousTest,"{'startLine':2728,'endLine':2744}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.afterAll(function() {
          throw new Error('nope');
        });
        env.it('does not run', function() {});
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,AnonymousTest,"{'startLine':2748,'endLine':2766}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.describe('something', function() {
          env.afterAll(function() {
            throw new Error('nope');
          });
          env.it('does not run', function() {});
        });
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,AnonymousTest,"{'startLine':2770,'endLine':2803}","it('is ""failed""', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            return clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        env.cleanup_();
        env = new jasmineUnderTest.Env();
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        reporter.jasmineDone.and.callFake(function(e) {
          expect(e.overallStatus).toEqual('failed');
        });

        env.addReporter(reporter);
        env.it('passes', function() {});
        dispatchErrorEvent(global, { error: 'ENOCHEESE' });
        await env.execute();

        expect(reporter.jasmineDone).toHaveBeenCalled();
      })",snuts
/spec/core/integration/EnvSpec.js,AnonymousTest,"{'startLine':2807,'endLine':2821}","it('is ""incomplete""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('incomplete');
        expect(e.incompleteReason).toEqual('No specs found');
        expect(e.incompleteCode).toEqual('noSpecsFound');
      })",snuts
/spec/core/integration/EnvSpec.js,AnonymousTest,"{'startLine':2825,'endLine':2840}","it('is ""incomplete""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.fit('is focused', function() {});
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('incomplete');
        expect(e.incompleteReason).toEqual('fit() or fdescribe() was found');
        expect(e.incompleteCode).toEqual('focused');
      })",snuts
/spec/core/integration/EnvSpec.js,AnonymousTest,"{'startLine':2844,'endLine':2861}","it('is ""incomplete""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.fdescribe('something focused', function() {
          env.it('does a thing', function() {});
        });
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('incomplete');
        expect(e.incompleteReason).toEqual('fit() or fdescribe() was found');
        expect(e.incompleteCode).toEqual('focused');
      })",snuts
/spec/core/integration/EnvSpec.js,AnonymousTest,"{'startLine':2865,'endLine':2882}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.fit('is focused', function() {
          env.expect(true).toBe(false);
        });
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
        expect(e.incompleteReason).toBeUndefined();
        expect(e.incompleteCode).toBeUndefined();
      })",snuts
/spec/core/integration/EnvSpec.js,IdenticalTestDescription,"{'startLine':2686,'endLine':2702}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.beforeAll(function() {
          throw new Error('nope');
        });
        env.it('does not run', function() {});
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,IdenticalTestDescription,"{'startLine':2706,'endLine':2724}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.describe('something', function() {
          env.beforeAll(function() {
            throw new Error('nope');
          });
          env.it('does not run', function() {});
        });
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,IdenticalTestDescription,"{'startLine':2728,'endLine':2744}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.afterAll(function() {
          throw new Error('nope');
        });
        env.it('does not run', function() {});
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,IdenticalTestDescription,"{'startLine':2748,'endLine':2766}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.describe('something', function() {
          env.afterAll(function() {
            throw new Error('nope');
          });
          env.it('does not run', function() {});
        });
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,IdenticalTestDescription,"{'startLine':2770,'endLine':2803}","it('is ""failed""', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            return clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        env.cleanup_();
        env = new jasmineUnderTest.Env();
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        reporter.jasmineDone.and.callFake(function(e) {
          expect(e.overallStatus).toEqual('failed');
        });

        env.addReporter(reporter);
        env.it('passes', function() {});
        dispatchErrorEvent(global, { error: 'ENOCHEESE' });
        await env.execute();

        expect(reporter.jasmineDone).toHaveBeenCalled();
      })",snuts
/spec/core/integration/EnvSpec.js,IdenticalTestDescription,"{'startLine':2825,'endLine':2840}","it('is ""incomplete""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.fit('is focused', function() {});
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('incomplete');
        expect(e.incompleteReason).toEqual('fit() or fdescribe() was found');
        expect(e.incompleteCode).toEqual('focused');
      })",snuts
/spec/core/integration/EnvSpec.js,IdenticalTestDescription,"{'startLine':2844,'endLine':2861}","it('is ""incomplete""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.fdescribe('something focused', function() {
          env.it('does a thing', function() {});
        });
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('incomplete');
        expect(e.incompleteReason).toEqual('fit() or fdescribe() was found');
        expect(e.incompleteCode).toEqual('focused');
      })",snuts
/spec/core/integration/EnvSpec.js,IdenticalTestDescription,"{'startLine':2865,'endLine':2882}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.fit('is focused', function() {
          env.expect(true).toBe(false);
        });
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
        expect(e.incompleteReason).toBeUndefined();
        expect(e.incompleteCode).toBeUndefined();
      })",snuts
/spec/core/integration/EnvSpec.js,IdenticalTestDescription,"{'startLine':3748,'endLine':3769}","it('throws when the matcher fails', async function() {
      const promise = Promise.resolve('a');
      let thrown;

      env.it('a spec', async function() {
        try {
          await env.throwUnlessAsync(promise).toBeResolvedTo('b');
        } catch (e) {
          thrown = e;
        }
      });

      await env.execute();
      expect(thrown).toBeInstanceOf(Error);
      expect(thrown.passed).toEqual(false);
      expect(thrown.matcherName).toEqual('toBeResolvedTo');
      expect(thrown.message).toEqual(
        ""Expected a promise to be resolved to 'b' but it was resolved to 'a'.""
      );
      expect(thrown.actual).toBe(promise);
      expect(thrown.expected).toEqual('b');
    })",snuts
/spec/core/integration/EnvSpec.js,IdenticalTestDescription,"{'startLine':3771,'endLine':3785}","it('does not throw when the matcher passes', async function() {
      let threw = false;

      env.it('a spec', async function() {
        try {
          await env.throwUnlessAsync(Promise.resolve()).toBeResolved();
          // eslint-disable-next-line no-unused-vars
        } catch (e) {
          threw = true;
        }
      });

      await env.execute();
      expect(threw).toBe(false);
    })",snuts
/spec/core/integration/EnvSpec.js,IdenticalTestDescription,"{'startLine':3787,'endLine':3802}","it('does not cause a failure if the error does not propagate back to jasmine', async function() {
      env.it('a spec', async function() {
        try {
          await env.throwUnlessAsync(Promise.resolve()).toBeRejected();
          // eslint-disable-next-line no-unused-vars
        } catch (e) {}
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);

      await env.execute();
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({ status: 'passed' })
      );
    })",snuts
/spec/core/integration/EnvSpec.js,ConditionalTestLogic,"{'startLine':151,'endLine':154}","it('explicitly fails a spec', async function() {
    const specDone = jasmine.createSpy('specDone');

    env.addReporter({ specDone: specDone });

    env.describe('failing', function() {
      env.it('has a default message', function() {
        env.fail();
      });

      env.it('specifies a message', function() {
        env.fail('messy message');
      });

      env.it('has a message and stack trace from an Error', function() {
        env.fail(new Error('error message'));
      });

      env.it('pretty prints objects', function() {
        env.fail({ prop: 'value', arr: ['works', true] });
      });
    });

    await env.execute();

    expect(specDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'has a default message',
        failedExpectations: [
          jasmine.objectContaining({
            message: 'Failed'
          })
        ]
      })
    );
    expect(specDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'specifies a message',
        failedExpectations: [
          jasmine.objectContaining({
            message: 'Failed: messy message'
          })
        ]
      })
    );
    expect(specDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'has a message and stack trace from an Error',
        failedExpectations: [
          jasmine.objectContaining({
            message: 'Failed: error message',
            stack: {
              asymmetricMatch: function(other) {
                const split = other.split('\n');
                let firstLine = split[0];
                if (firstLine.indexOf('error message') >= 0) {
                  // Chrome inserts the message and a newline before the first stacktrace line.
                  firstLine = split[1];
                }
                return firstLine.indexOf('EnvSpec') >= 0;
              }
            }
          })
        ]
      })
    );
    expect(specDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'pretty prints objects',
        failedExpectations: [
          jasmine.objectContaining({
            message: ""Failed: Object({ prop: 'value', arr: [ 'works', true ] })""
          })
        ]
      })
    );
  })",snuts
/spec/core/integration/EnvSpec.js,ConditionalTestLogic,"{'startLine':197,'endLine':201}","it(""calls associated befores/specs/afters with the same 'this'"", async function() {
    env.configure({ random: false });
    env.describe('tests', function() {
      let firstTimeThrough = true;
      let firstSpecContext;
      let secondSpecContext;

      env.beforeEach(function() {
        if (firstTimeThrough) {
          firstSpecContext = this;
        } else {
          secondSpecContext = this;
        }
        expect(this).toEqual(new jasmineUnderTest.UserContext());
      });

      env.it('sync spec', function() {
        expect(this).toBe(firstSpecContext);
      });

      env.it('another sync spec', function() {
        expect(this).toBe(secondSpecContext);
      });

      env.afterEach(function() {
        if (firstTimeThrough) {
          expect(this).toBe(firstSpecContext);
          firstTimeThrough = false;
        } else {
          expect(this).toBe(secondSpecContext);
        }
      });
    });

    await env.execute();
  })",snuts
/spec/core/integration/EnvSpec.js,ConditionalTestLogic,"{'startLine':214,'endLine':219}","it(""calls associated befores/specs/afters with the same 'this'"", async function() {
    env.configure({ random: false });
    env.describe('tests', function() {
      let firstTimeThrough = true;
      let firstSpecContext;
      let secondSpecContext;

      env.beforeEach(function() {
        if (firstTimeThrough) {
          firstSpecContext = this;
        } else {
          secondSpecContext = this;
        }
        expect(this).toEqual(new jasmineUnderTest.UserContext());
      });

      env.it('sync spec', function() {
        expect(this).toBe(firstSpecContext);
      });

      env.it('another sync spec', function() {
        expect(this).toBe(secondSpecContext);
      });

      env.afterEach(function() {
        if (firstTimeThrough) {
          expect(this).toBe(firstSpecContext);
          firstTimeThrough = false;
        } else {
          expect(this).toBe(secondSpecContext);
        }
      });
    });

    await env.execute();
  })",snuts
/spec/core/integration/EnvSpec.js,ConditionalTestLogic,"{'startLine':973,'endLine':975}","it('Functions can be spied on and have their calls tracked', async function() {
    let originalFunctionWasCalled = false;
    const subject = {
      spiedFunc: function() {
        originalFunctionWasCalled = true;
        return 'original result';
      }
    };

    env.it('works with spies', function() {
      const spy = env
        .spyOn(subject, 'spiedFunc')
        .and.returnValue('stubbed result');

      expect(subject.spiedFunc).toEqual(spy);
      expect(subject.spiedFunc.calls.any()).toEqual(false);
      expect(subject.spiedFunc.calls.count()).toEqual(0);

      subject.spiedFunc('foo');

      expect(subject.spiedFunc.calls.any()).toEqual(true);
      expect(subject.spiedFunc.calls.count()).toEqual(1);
      expect(subject.spiedFunc.calls.mostRecent().args).toEqual(['foo']);
      expect(subject.spiedFunc.calls.mostRecent().object).toEqual(subject);
      expect(subject.spiedFunc.calls.mostRecent().returnValue).toEqual(
        'stubbed result'
      );
      expect(originalFunctionWasCalled).toEqual(false);

      subject.spiedFunc.and.callThrough();
      subject.spiedFunc('bar');
      expect(subject.spiedFunc.calls.count()).toEqual(2);
      expect(subject.spiedFunc.calls.mostRecent().args).toEqual(['bar']);
      expect(subject.spiedFunc.calls.mostRecent().returnValue).toEqual(
        'original result'
      );
      expect(originalFunctionWasCalled).toEqual(true);
    });

    env.it(
      'works with constructors when using callThrough spy strategy',
      function() {
        function MyClass(foo) {
          if (!(this instanceof MyClass)) {
            throw new Error('You must use the new keyword.');
          }
          this.foo = foo;
        }
        const subject = { MyClass: MyClass };
        const spy = env.spyOn(subject, 'MyClass').and.callThrough();

        expect(function() {
          const result = new spy('hello world');
          expect(result instanceof MyClass).toBeTruthy();
          expect(result.foo).toEqual('hello world');
        }).not.toThrow();

        expect(function() {
          const result = new spy(
            'passing',
            'extra',
            'arguments',
            'to',
            'constructor'
          );
          expect(result instanceof MyClass).toBeTruthy();
          expect(result.foo).toEqual('passing');
        }).not.toThrow();

        expect(function() {
          spy('hello world');
        }).toThrowError('You must use the new keyword.');
      }
    );

    await env.execute();
  })",snuts
/spec/core/integration/EnvSpec.js,ConditionalTestLogic,"{'startLine':2492,'endLine':2497}","it('should associate errors thrown from async code with the correct runnable', async function() {
    const reporter = jasmine.createSpyObj('fakeReport', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('async suite', function() {
      env.afterAll(function(innerDone) {
        setTimeout(function() {
          throw new Error('suite');
        }, 1);
      }, 50);

      env.it('spec', function() {});
    });

    env.describe('suite', function() {
      env.it(
        'async spec',
        function(innerDone) {
          setTimeout(function() {
            throw new Error('spec');
          }, 1);
        },
        50
      );
    });

    await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
      await env.execute();

      if (isBrowser) {
        // Verify that there were no unexpected errors
        expect(globalErrorSpy).toHaveBeenCalledTimes(2);
        expect(globalErrorSpy).toHaveBeenCalledWith(new Error('suite'));
        expect(globalErrorSpy).toHaveBeenCalledWith(new Error('spec'));
      }
    });

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'async suite',
      [/Error: suite/]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite async spec',
      [/Error: spec/]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,ConditionalTestLogic,"{'startLine':3180,'endLine':3182}","it('supports asymmetric equality testers that take a matchersUtil', async function() {
    const env = new jasmineUnderTest.Env();

    env.it('spec using custom asymmetric equality tester', function() {
      const customEqualityFn = function(a, b) {
        if (a === 2 && b === 'two') {
          return true;
        }
      };
      const arrayWithFirstElement = function(sample) {
        return {
          asymmetricMatch: function(actual, matchersUtil) {
            return matchersUtil.equals(sample, actual[0]);
          }
        };
      };

      env.addCustomEqualityTester(customEqualityFn);
      env.expect(['two']).toEqual(arrayWithFirstElement(2));
    });

    const specExpectations = function(result) {
      expect(result.status).toEqual('passed');
    };

    env.addReporter({ specDone: specExpectations });
    await env.execute();
  })",snuts
/spec/core/integration/EnvSpec.js,ConditionalTestLogic,"{'startLine':3500,'endLine':3502}","it('uses custom equality testers in Spy#withArgs', async function() {
    env.it('a spec', function() {
      const createSpySpy = env.createSpy('via createSpy');
      const spiedOn = { foo: function() {} };
      env.spyOn(spiedOn, 'foo');
      const spyObj = env.createSpyObj('spyObj', ['foo']);
      const spiedOnAllFuncs = { foo: function() {} };
      env.spyOnAllFunctions(spiedOnAllFuncs);

      for (const spy of [
        createSpySpy,
        spiedOn.foo,
        spyObj.foo,
        spiedOnAllFuncs.foo
      ]) {
        spy.and.returnValue('default strategy');
        spy.withArgs(42).and.returnValue('custom strategy');
      }

      env.addCustomEqualityTester(function(a, b) {
        if ((a === 'x' && b === 42) || (a === 42 && b === 'x')) {
          return true;
        }
      });

      env
        .expect(createSpySpy('x'))
        .withContext('createSpy')
        .toEqual('custom strategy');
      env
        .expect(spiedOn.foo('x'))
        .withContext('spyOn')
        .toEqual('custom strategy');
      env
        .expect(spyObj.foo('x'))
        .withContext('createSpyObj')
        .toEqual('custom strategy');
      env
        .expect(spiedOnAllFuncs.foo('x'))
        .withContext('spyOnAllFunctions')
        .toEqual('custom strategy');
    });

    let failedExpectations;
    env.addReporter({
      specDone: r => (failedExpectations = r.failedExpectations)
    });

    await env.execute();
    expect(failedExpectations).toEqual([]);
  })",snuts
/spec/core/integration/EnvSpec.js,ConditionalTestLogic,"{'startLine':3535,'endLine':3537}","it('uses custom object formatters in spy strategy argument mismatch errors', async function() {
    env.it('a spec', function() {
      env.addCustomObjectFormatter(function(value) {
        if (typeof value === 'string') {
          return 'custom:' + value;
        }
      });
      const spy = env
        .createSpy('foo')
        .withArgs('x')
        .and.returnValue('');
      spy('y');
    });

    let failedExpectations;
    env.addReporter({
      specDone: r => (failedExpectations = r.failedExpectations)
    });

    await env.execute();
    expect(failedExpectations).toEqual([
      jasmine.objectContaining({
        message: jasmine.stringContaining(
          'received a call with arguments [ custom:y ]'
        )
      })
    ]);
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':360,'endLine':360}","it('tags top-level afterAll failures with a type', async function() {
    const jasmineDone = jasmine.createSpy('jasmineDone');

    env.it('has a spec', function() {});

    env.afterAll(function() {
      throw 'nope';
    });

    env.addReporter({ jasmineDone: jasmineDone });

    await env.execute();

    const result = jasmineDone.calls.argsFor(0)[0];
    expect(result.failedExpectations[0].globalErrorType).toEqual('afterAll');
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':384,'endLine':384}","it('does not tag suite afterAll failures with a type', async function() {
    const reporter = {
      suiteDone: jasmine.createSpy('suiteDone').and.callFake(function(result) {
        expect(result.failedExpectations[0].globalErrorType).toBeFalsy();
      })
    };

    env.addReporter(reporter);

    env.describe('a suite', function() {
      env.it('has a spec', function() {});

      env.afterAll(function() {
        throw 'nope';
      });
    });

    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalled();
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':409,'endLine':409}","it('when the beforeAll fails, error at suite level', async function() {
    const reporter = jasmine.createSpyObj('fakeReporter', [
      'specDone',
      'suiteDone'
    ]);

    env.addReporter(reporter);

    env.describe('A suite', function() {
      env.beforeAll(function() {
        env.expect(1).toBe(2);
      });

      env.it('spec that will pass', function() {});

      env.describe('nesting', function() {
        env.it('another spec to pass', function() {});
      });
    });

    await env.execute();

    expect(reporter.specDone.calls.count()).toEqual(2);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'A suite spec that will pass',
      []
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'A suite nesting another spec to pass',
      []
    );
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('A suite', [
      'Expected 1 to be 2.'
    ]);
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':412,'endLine':412}","it('when the beforeAll fails, error at suite level', async function() {
    const reporter = jasmine.createSpyObj('fakeReporter', [
      'specDone',
      'suiteDone'
    ]);

    env.addReporter(reporter);

    env.describe('A suite', function() {
      env.beforeAll(function() {
        env.expect(1).toBe(2);
      });

      env.it('spec that will pass', function() {});

      env.describe('nesting', function() {
        env.it('another spec to pass', function() {});
      });
    });

    await env.execute();

    expect(reporter.specDone.calls.count()).toEqual(2);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'A suite spec that will pass',
      []
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'A suite nesting another spec to pass',
      []
    );
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('A suite', [
      'Expected 1 to be 2.'
    ]);
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':443,'endLine':443}","it('reports multiple calls to done in the top suite as errors', async function() {
    const reporter = jasmine.createSpyObj('fakeReporter', ['jasmineDone']);
    const message =
      'A top-level beforeAll or afterAll function called its ' +
      ""'done' callback more than once."";

    env.addReporter(reporter);
    env.beforeAll(function(innerDone) {
      innerDone();
      innerDone();
    });
    env.it('a spec, so the beforeAll runs', function() {});
    env.afterAll(function(innerDone) {
      innerDone();
      innerDone();
    });

    await env.execute();

    expect(reporter.jasmineDone).toHaveBeenCalled();
    const errors = reporter.jasmineDone.calls.argsFor(0)[0].failedExpectations;
    expect(errors.length).toEqual(2);
    expect(errors[0].message)
      .withContext('top beforeAll')
      .toContain(message);
    expect(errors[0].globalErrorType).toEqual('lateError');
    expect(errors[1].message)
      .withContext('top afterAll')
      .toContain(message);
    expect(errors[1].globalErrorType).toEqual('lateError');
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':483,'endLine':483}","it('reports multiple calls to done in a non-top suite as errors', async function() {
    const reporter = jasmine.createSpyObj('fakeReporter', [
      'jasmineDone',
      'suiteDone'
    ]);
    const message =
      ""An asynchronous beforeAll or afterAll function called its 'done' "" +
      'callback more than once.\n(in suite: a suite)';
    let lateDone;
    reporter.suiteDone.and.callFake(function() {
      lateDone();
    });

    env.addReporter(reporter);
    env.describe('a suite', function() {
      env.beforeAll(function(innerDone) {
        innerDone();
        innerDone();
      });
      env.it('a spec, so that before/afters run', function() {});
      env.afterAll(function(innerDone) {
        innerDone();
        innerDone();
        lateDone = innerDone;
      });
    });

    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalled();
    const suiteErrors = reporter.suiteDone.calls.argsFor(0)[0]
      .failedExpectations;
    expect(suiteErrors.length).toEqual(2);
    expect(suiteErrors[0].message)
      .withContext('suite beforeAll')
      .toContain(message);
    expect(suiteErrors[1].message)
      .withContext('suite afterAll')
      .toContain(message);

    expect(reporter.jasmineDone).toHaveBeenCalled();
    const topErrors = reporter.jasmineDone.calls.argsFor(0)[0]
      .failedExpectations;
    expect(topErrors.length).toEqual(1);
    expect(topErrors[0].message)
      .withContext('late suite afterAll')
      .toContain(message);
    expect(topErrors[0].globalErrorType).toEqual('lateError');
    expect(topErrors[0].globalErrorType).toEqual('lateError');
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':591,'endLine':591}","it('reports multiple calls to done in reporters as errors', async function() {
    const message =
      ""An asynchronous reporter callback called its 'done' callback more "" +
      'than once.';
    const reporter = jasmine.createSpyObj('fakeReport', ['jasmineDone']);
    reporter.specDone = function(result, done) {
      done();
      done();
    };
    env.addReporter(reporter);

    env.it('a spec', function() {});

    await env.execute();

    expect(reporter.jasmineDone).toHaveBeenCalled();
    const errors = reporter.jasmineDone.calls.argsFor(0)[0].failedExpectations;
    expect(errors.length).toEqual(1);
    expect(errors[0].message).toContain(message);
    expect(errors[0].globalErrorType).toEqual('lateError');
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':638,'endLine':638}","it('reports when an afterAll fails an expectation', async function() {
      const reporter = jasmine.createSpyObj('fakeReport', ['suiteDone']);

      env.addReporter(reporter);

      env.describe('my suite', function() {
        env.it('my spec', function() {});

        env.afterAll(function() {
          env.expect(1).toEqual(2);
          env.expect(2).toEqual(3);
        });
      });

      await env.execute();

      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'my suite',
        ['Expected 1 to equal 2.', 'Expected 2 to equal 3.']
      );
    })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':660,'endLine':660}","it('if there are no specs, it still reports correctly', async function() {
      const reporter = jasmine.createSpyObj('fakeReport', ['suiteDone']);
      env.addReporter(reporter);

      env.describe('outer suite', function() {
        env.describe('inner suite', function() {
          env.it('spec', function() {});
        });

        env.afterAll(function() {
          env.expect(1).toEqual(2);
          env.expect(2).toEqual(3);
        });
      });

      await env.execute();

      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'outer suite',
        ['Expected 1 to equal 2.', 'Expected 2 to equal 3.']
      );
    })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':684,'endLine':684}","it('reports when afterAll throws an exception', async function() {
      const error = new Error('After All Exception'),
        reporter = jasmine.createSpyObj('fakeReport', ['suiteDone']);

      env.addReporter(reporter);

      env.describe('my suite', function() {
        env.it('my spec', function() {});

        env.afterAll(function() {
          throw error;
        });
      });

      await env.execute();

      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'my suite',
        [/^Error: After All Exception/]
      );
    })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':705,'endLine':705}","it('reports when an async afterAll fails an expectation', async function() {
      const reporter = jasmine.createSpyObj('fakeReport', ['suiteDone']);

      env.addReporter(reporter);

      env.describe('my suite', function() {
        env.it('my spec', function() {});

        env.afterAll(function(afterAllDone) {
          env.expect(1).toEqual(2);
          afterAllDone();
        });
      });

      await env.execute();

      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'my suite',
        ['Expected 1 to equal 2.']
      );
    })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':728,'endLine':728}","it('reports when an async afterAll throws an exception', async function() {
      const error = new Error('After All Exception'),
        reporter = jasmine.createSpyObj('fakeReport', ['suiteDone']);

      env.addReporter(reporter);

      env.describe('my suite', function() {
        env.it('my spec', function() {});

        env.afterAll(function(afterAllDone) {
          throw error;
        });
      });

      await env.execute();

      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'my suite',
        [/^Error: After All Exception/]
      );
    })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':1031,'endLine':1031}","it('removes all spies added in a spec after the spec is complete', async function() {
    const originalFoo = function() {},
      testObj = {
        foo: originalFoo
      },
      firstSpec = jasmine.createSpy('firstSpec').and.callFake(function() {
        env.spyOn(testObj, 'foo');
      }),
      secondSpec = jasmine.createSpy('secondSpec').and.callFake(function() {
        expect(testObj.foo).toBe(originalFoo);
      });
    env.describe('test suite', function() {
      env.it('spec 0', firstSpec);
      env.it('spec 1', secondSpec);
    });

    env.configure({ random: false });
    await env.execute();

    expect(firstSpec).toHaveBeenCalled();
    expect(secondSpec).toHaveBeenCalled();
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':1054,'endLine':1054}","it('removes all spies added in a suite after the suite is complete', async function() {
    const originalFoo = function() {},
      testObj = {
        foo: originalFoo
      };

    env.describe('test suite', function() {
      env.beforeAll(function() {
        env.spyOn(testObj, 'foo');
      });

      env.it('spec 0', function() {
        expect(jasmineUnderTest.isSpy(testObj.foo)).toBe(true);
      });

      env.it('spec 1', function() {
        expect(jasmineUnderTest.isSpy(testObj.foo)).toBe(true);
      });
    });

    env.describe('another suite', function() {
      env.it('spec 2', function() {
        expect(jasmineUnderTest.isSpy(testObj.foo)).toBe(false);
      });
    });

    await env.execute();
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':1083,'endLine':1083}","it('removes a spy from the top suite after the run is complete', async function() {
    const originalFoo = function() {},
      testObj = {
        foo: originalFoo
      };

    env.beforeAll(function() {
      env.spyOn(testObj, 'foo');
    });

    env.it('spec', function() {
      expect(jasmineUnderTest.isSpy(testObj.foo)).toBe(true);
    });

    await env.execute();

    expect(jasmineUnderTest.isSpy(testObj.foo)).toBe(false);
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':1615,'endLine':1615}","it('should report as expected', async function() {
    const reporter = jasmine.createSpyObj('fakeReporter', [
      'jasmineStarted',
      'suiteStarted',
      'suiteDone',
      'specStarted',
      'specDone'
    ]);
    const suiteFullNameToId = {};
    reporter.suiteStarted.and.callFake(function(e) {
      suiteFullNameToId[e.fullName] = e.id;
    });

    // Clone args to work around Jasmine mutating the result after passing it
    // to the reporter event.
    // TODO: remove this once Jasmine no longer does that
    const clone = structuredClone.bind(globalThis);
    reporter.specStarted.calls.saveArgumentsByValue(clone);
    reporter.specDone.calls.saveArgumentsByValue(clone);
    reporter.specStarted.calls.saveArgumentsByValue(clone);
    reporter.suiteDone.calls.saveArgumentsByValue(clone);

    env.configure({ random: false });
    env.addReporter(reporter);

    env.it('a top level spec', function() {});

    env.describe('A Suite', function() {
      env.it('with a spec', function() {
        env.expect(true).toBe(true);
      });
      env.describe('with a nested suite', function() {
        env.xit(""with an x'ed spec"", function() {
          env.expect(true).toBe(true);
        });
        env.it('with a spec', function() {
          env.expect(true).toBe(false);
        });
      });

      env.describe('with only non-executable specs', function() {
        env.it('is pending');
        env.xit('is xed', function() {
          env.expect(true).toBe(true);
        });
      });
    });

    await env.execute();

    expect(reporter.jasmineStarted).toHaveBeenCalledWith({
      totalSpecsDefined: 6,
      order: jasmine.any(jasmineUnderTest.Order),
      parallel: false
    });

    expect(reporter.specStarted.calls.count()).toBe(6);
    expect(reporter.specDone.calls.count()).toBe(6);

    const baseSpecEvent = {
      passedExpectations: [],
      failedExpectations: [],
      deprecationWarnings: [],
      pendingReason: '',
      duration: null,
      properties: null,
      debugLogs: null,
      id: jasmine.any(String),
      filename: jasmine.any(String)
    };

    expect(reporter.specStarted.calls.argsFor(0)[0]).toEqual({
      ...baseSpecEvent,
      description: 'a top level spec',
      fullName: 'a top level spec',
      parentSuiteId: null
    });
    expect(reporter.specDone.calls.argsFor(0)[0]).toEqual({
      ...baseSpecEvent,
      description: 'a top level spec',
      fullName: 'a top level spec',
      status: 'passed',
      parentSuiteId: null,
      duration: jasmine.any(Number)
    });
    expect(reporter.specStarted.calls.argsFor(1)[0]).toEqual({
      ...baseSpecEvent,
      description: 'with a spec',
      fullName: 'A Suite with a spec',
      parentSuiteId: suiteFullNameToId['A Suite']
    });
    expect(reporter.specDone.calls.argsFor(1)[0]).toEqual({
      ...baseSpecEvent,
      description: 'with a spec',
      fullName: 'A Suite with a spec',
      status: 'passed',
      parentSuiteId: suiteFullNameToId['A Suite'],
      passedExpectations: [
        { matcherName: 'toBe', message: 'Passed.', stack: '', passed: true }
      ],
      duration: jasmine.any(Number)
    });

    expect(reporter.specStarted.calls.argsFor(2)[0]).toEqual({
      ...baseSpecEvent,
      description: ""with an x'ed spec"",
      fullName: ""A Suite with a nested suite with an x'ed spec"",
      parentSuiteId: suiteFullNameToId['A Suite with a nested suite'],
      pendingReason: 'Temporarily disabled with xit'
    });
    expect(reporter.specDone.calls.argsFor(2)[0]).toEqual({
      ...baseSpecEvent,
      description: ""with an x'ed spec"",
      fullName: ""A Suite with a nested suite with an x'ed spec"",
      status: 'pending',
      parentSuiteId: suiteFullNameToId['A Suite with a nested suite'],
      pendingReason: 'Temporarily disabled with xit',
      duration: jasmine.any(Number)
    });

    expect(reporter.specStarted.calls.argsFor(3)[0]).toEqual({
      ...baseSpecEvent,
      description: 'with a spec',
      fullName: 'A Suite with a nested suite with a spec',
      parentSuiteId: suiteFullNameToId['A Suite with a nested suite']
    });
    expect(reporter.specDone.calls.argsFor(3)[0]).toEqual({
      ...baseSpecEvent,
      description: 'with a spec',
      fullName: 'A Suite with a nested suite with a spec',
      status: 'failed',
      parentSuiteId: suiteFullNameToId['A Suite with a nested suite'],
      failedExpectations: [
        jasmine.objectContaining({
          matcherName: 'toBe',
          message: 'Expected true to be false.'
        })
      ],
      duration: jasmine.any(Number)
    });

    expect(reporter.specStarted.calls.argsFor(4)[0]).toEqual({
      ...baseSpecEvent,
      description: 'is pending',
      fullName: 'A Suite with only non-executable specs is pending',
      parentSuiteId: suiteFullNameToId['A Suite with only non-executable specs']
    });
    expect(reporter.specDone.calls.argsFor(4)[0]).toEqual({
      ...baseSpecEvent,
      description: 'is pending',
      status: 'pending',
      fullName: 'A Suite with only non-executable specs is pending',
      parentSuiteId:
        suiteFullNameToId['A Suite with only non-executable specs'],
      duration: jasmine.any(Number)
    });

    expect(reporter.specStarted.calls.argsFor(5)[0]).toEqual({
      ...baseSpecEvent,
      description: 'is xed',
      fullName: 'A Suite with only non-executable specs is xed',
      parentSuiteId:
        suiteFullNameToId['A Suite with only non-executable specs'],
      pendingReason: 'Temporarily disabled with xit'
    });
    expect(reporter.specDone.calls.argsFor(5)[0]).toEqual({
      ...baseSpecEvent,
      description: 'is xed',
      status: 'pending',
      fullName: 'A Suite with only non-executable specs is xed',
      parentSuiteId:
        suiteFullNameToId['A Suite with only non-executable specs'],
      pendingReason: 'Temporarily disabled with xit',
      duration: jasmine.any(Number)
    });

    expect(reporter.suiteStarted.calls.count()).toBe(3);
    expect(reporter.suiteDone.calls.count()).toBe(3);

    const baseSuiteEvent = {
      id: jasmine.any(String),
      filename: jasmine.any(String),
      failedExpectations: [],
      deprecationWarnings: [],
      duration: null,
      properties: null
    };

    expect(reporter.suiteStarted.calls.argsFor(0)[0]).toEqual({
      ...baseSuiteEvent,
      description: 'A Suite',
      fullName: 'A Suite',
      parentSuiteId: null
    });
    expect(reporter.suiteDone.calls.argsFor(2)[0]).toEqual({
      ...baseSuiteEvent,
      description: 'A Suite',
      fullName: 'A Suite',
      status: 'passed',
      parentSuiteId: null,
      duration: jasmine.any(Number)
    });

    expect(reporter.suiteStarted.calls.argsFor(1)[0]).toEqual({
      ...baseSuiteEvent,
      description: 'with a nested suite',
      fullName: 'A Suite with a nested suite',
      parentSuiteId: suiteFullNameToId['A Suite']
    });
    expect(reporter.suiteDone.calls.argsFor(0)[0]).toEqual({
      ...baseSuiteEvent,
      description: 'with a nested suite',
      status: 'passed',
      fullName: 'A Suite with a nested suite',
      parentSuiteId: suiteFullNameToId['A Suite'],
      duration: jasmine.any(Number)
    });

    expect(reporter.suiteStarted.calls.argsFor(2)[0]).toEqual({
      ...baseSuiteEvent,
      description: 'with only non-executable specs',
      fullName: 'A Suite with only non-executable specs',
      parentSuiteId: suiteFullNameToId['A Suite']
    });
    expect(reporter.suiteDone.calls.argsFor(1)[0]).toEqual({
      ...baseSuiteEvent,
      description: 'with only non-executable specs',
      status: 'passed',
      fullName: 'A Suite with only non-executable specs',
      parentSuiteId: suiteFullNameToId['A Suite'],
      duration: jasmine.any(Number)
    });
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':1836,'endLine':1836}","it('reports focused specs and suites as expected', async function() {
    const reporter = jasmine.createSpyObj('fakeReporter', [
      'suiteStarted',
      'suiteDone',
      'specStarted',
      'specDone'
    ]);
    const suiteFullNameToId = {};
    reporter.suiteStarted.and.callFake(function(e) {
      suiteFullNameToId[e.fullName] = e.id;
    });

    env.fit('a focused top level spec', function() {});

    env.describe('a suite', function() {
      env.fdescribe('a focused suite', function() {
        env.fit('a focused spec', function() {});
      });
    });

    env.addReporter(reporter);
    await env.execute();

    expect(reporter.specStarted).toHaveBeenCalledTimes(2);
    expect(reporter.specDone).toHaveBeenCalledTimes(2);

    expect(reporter.specStarted).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused top level spec',
        parentSuiteId: null
      })
    );
    expect(reporter.specDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused top level spec',
        status: 'passed',
        parentSuiteId: null
      })
    );

    expect(reporter.specStarted).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused spec',
        parentSuiteId: suiteFullNameToId['a suite a focused suite']
      })
    );
    expect(reporter.specDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused spec',
        status: 'passed',
        parentSuiteId: suiteFullNameToId['a suite a focused suite']
      })
    );

    expect(reporter.suiteStarted).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a suite',
        parentSuiteId: null
      })
    );
    expect(reporter.suiteDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a suite',
        status: 'passed',
        parentSuiteId: null
      })
    );

    expect(reporter.suiteStarted).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused suite',
        parentSuiteId: suiteFullNameToId['a suite']
      })
    );
    expect(reporter.suiteDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused suite',
        status: 'passed',
        parentSuiteId: suiteFullNameToId['a suite']
      })
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':1840,'endLine':1840}","it('reports focused specs and suites as expected', async function() {
    const reporter = jasmine.createSpyObj('fakeReporter', [
      'suiteStarted',
      'suiteDone',
      'specStarted',
      'specDone'
    ]);
    const suiteFullNameToId = {};
    reporter.suiteStarted.and.callFake(function(e) {
      suiteFullNameToId[e.fullName] = e.id;
    });

    env.fit('a focused top level spec', function() {});

    env.describe('a suite', function() {
      env.fdescribe('a focused suite', function() {
        env.fit('a focused spec', function() {});
      });
    });

    env.addReporter(reporter);
    await env.execute();

    expect(reporter.specStarted).toHaveBeenCalledTimes(2);
    expect(reporter.specDone).toHaveBeenCalledTimes(2);

    expect(reporter.specStarted).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused top level spec',
        parentSuiteId: null
      })
    );
    expect(reporter.specDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused top level spec',
        status: 'passed',
        parentSuiteId: null
      })
    );

    expect(reporter.specStarted).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused spec',
        parentSuiteId: suiteFullNameToId['a suite a focused suite']
      })
    );
    expect(reporter.specDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused spec',
        status: 'passed',
        parentSuiteId: suiteFullNameToId['a suite a focused suite']
      })
    );

    expect(reporter.suiteStarted).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a suite',
        parentSuiteId: null
      })
    );
    expect(reporter.suiteDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a suite',
        status: 'passed',
        parentSuiteId: null
      })
    );

    expect(reporter.suiteStarted).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused suite',
        parentSuiteId: suiteFullNameToId['a suite']
      })
    );
    expect(reporter.suiteDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused suite',
        status: 'passed',
        parentSuiteId: suiteFullNameToId['a suite']
      })
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2066,'endLine':2066}","it('should be possible to get full name from a spec', function() {
    let topLevelSpec, nestedSpec, doublyNestedSpec;

    env.describe('my tests', function() {
      topLevelSpec = env.it('are sometimes top level', function() {});
      env.describe('are sometimes', function() {
        nestedSpec = env.it('singly nested', function() {});
        env.describe('even', function() {
          doublyNestedSpec = env.it('doubly nested', function() {});
        });
      });
    });

    expect(topLevelSpec.getFullName()).toBe('my tests are sometimes top level');
    expect(nestedSpec.getFullName()).toBe(
      'my tests are sometimes singly nested'
    );
    expect(doublyNestedSpec.getFullName()).toBe(
      'my tests are sometimes even doubly nested'
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2068,'endLine':2068}","it('should be possible to get full name from a spec', function() {
    let topLevelSpec, nestedSpec, doublyNestedSpec;

    env.describe('my tests', function() {
      topLevelSpec = env.it('are sometimes top level', function() {});
      env.describe('are sometimes', function() {
        nestedSpec = env.it('singly nested', function() {});
        env.describe('even', function() {
          doublyNestedSpec = env.it('doubly nested', function() {});
        });
      });
    });

    expect(topLevelSpec.getFullName()).toBe('my tests are sometimes top level');
    expect(nestedSpec.getFullName()).toBe(
      'my tests are sometimes singly nested'
    );
    expect(doublyNestedSpec.getFullName()).toBe(
      'my tests are sometimes even doubly nested'
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2070,'endLine':2070}","it('should be possible to get full name from a spec', function() {
    let topLevelSpec, nestedSpec, doublyNestedSpec;

    env.describe('my tests', function() {
      topLevelSpec = env.it('are sometimes top level', function() {});
      env.describe('are sometimes', function() {
        nestedSpec = env.it('singly nested', function() {});
        env.describe('even', function() {
          doublyNestedSpec = env.it('doubly nested', function() {});
        });
      });
    });

    expect(topLevelSpec.getFullName()).toBe('my tests are sometimes top level');
    expect(nestedSpec.getFullName()).toBe(
      'my tests are sometimes singly nested'
    );
    expect(doublyNestedSpec.getFullName()).toBe(
      'my tests are sometimes even doubly nested'
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2235,'endLine':2235}","it('Custom matchers should be per spec', async function() {
    const matchers = {
      toFoo: function() {}
    };

    env.describe('testing custom matchers', function() {
      env.it('with a custom matcher', function() {
        env.addMatchers(matchers);
        expect(env.expect().toFoo).toBeDefined();
      });

      env.it('without a custom matcher', function() {
        expect(env.expect().toFoo).toBeUndefined();
      });
    });

    await env.execute();
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2254,'endLine':2254}","it('Custom matchers should be per suite', async function() {
    const matchers = {
      toFoo: function() {}
    };

    env.describe('testing custom matchers', function() {
      env.beforeAll(function() {
        env.addMatchers(matchers);
      });

      env.it('with a custom matcher', function() {
        expect(env.expect().toFoo).toBeDefined();
      });

      env.it('with the same custom matcher', function() {
        expect(env.expect().toFoo).toBeDefined();
      });
    });

    env.describe('another suite', function() {
      env.it('no longer has the custom matcher', function() {
        expect(env.expect().toFoo).not.toBeDefined();
      });
    });

    await env.execute();
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2281,'endLine':2281}","it('throws an exception if you try to create a spy outside of a runnable', async function() {
    const obj = { fn: function() {} };
    let exception;

    env.describe('a suite', function() {
      try {
        env.spyOn(obj, 'fn');
      } catch (e) {
        exception = e;
      }
      env.it('has a test', function() {});
    });

    await env.execute();

    expect(exception.message).toBe(
      'Spies must be created in a before function or a spec'
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2290,'endLine':2290}","it('throws an exception if you try to create a spy outside of a runnable', async function() {
    const obj = { fn: function() {} };
    let exception;

    env.describe('a suite', function() {
      try {
        env.spyOn(obj, 'fn');
      } catch (e) {
        exception = e;
      }
      env.it('has a test', function() {});
    });

    await env.execute();

    expect(exception.message).toBe(
      'Spies must be created in a before function or a spec'
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2313,'endLine':2313}","it('throws an exception if you try to add a matcher outside of a runnable', async function() {
    let exception;

    env.describe('a suite', function() {
      try {
        env.addMatchers({
          myMatcher: function() {
            return false;
          }
        });
      } catch (e) {
        exception = e;
      }
      env.it('has a test', function() {});
    });

    await env.execute();

    expect(exception.message).toBe(
      'Matchers must be added in a before function or a spec'
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2334,'endLine':2334}","it('throws an exception if you try to add a custom equality outside of a runnable', async function() {
    let exception;

    env.describe('a suite', function() {
      try {
        env.addCustomEqualityTester(function() {
          return true;
        });
      } catch (e) {
        exception = e;
      }
      env.it('has a test', function() {});
    });

    await env.execute();

    expect(exception.message).toBe(
      'Custom Equalities must be added in a before function or a spec'
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2355,'endLine':2355}","it('throws an exception if you try to getSpecProperty outside of a spec', async function() {
    const env = new jasmineUnderTest.Env();
    let exception;

    env.describe('a suite', function() {
      env.it('a spec');
      try {
        env.getSpecProperty('a prop');
      } catch (e) {
        exception = e;
      }
      env.it('has a test', function() {});
    });

    await env.execute();

    expect(exception.message).toBe(
      ""'getSpecProperty' was used when there was no current spec""
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2409,'endLine':2409}","it('throws an exception if you try to setSpecProperty outside of a spec', async function() {
    const env = new jasmineUnderTest.Env();
    let exception;

    env.describe('a suite', function() {
      env.it('a spec');
      try {
        env.setSpecProperty('a prop', 'val');
      } catch (e) {
        exception = e;
      }
      env.it('has a test', function() {});
    });

    await env.execute();

    expect(exception.message).toBe(
      ""'setSpecProperty' was used when there was no current spec""
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2474,'endLine':2474}","it('should associate errors thrown from async code with the correct runnable', async function() {
    const reporter = jasmine.createSpyObj('fakeReport', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('async suite', function() {
      env.afterAll(function(innerDone) {
        setTimeout(function() {
          throw new Error('suite');
        }, 1);
      }, 50);

      env.it('spec', function() {});
    });

    env.describe('suite', function() {
      env.it(
        'async spec',
        function(innerDone) {
          setTimeout(function() {
            throw new Error('spec');
          }, 1);
        },
        50
      );
    });

    await jasmine.spyOnGlobalErrorsAsync(async function(globalErrorSpy) {
      await env.execute();

      if (isBrowser) {
        // Verify that there were no unexpected errors
        expect(globalErrorSpy).toHaveBeenCalledTimes(2);
        expect(globalErrorSpy).toHaveBeenCalledWith(new Error('suite'));
        expect(globalErrorSpy).toHaveBeenCalledWith(new Error('spec'));
      }
    });

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'async suite',
      [/Error: suite/]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite async spec',
      [/Error: spec/]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2520,'endLine':2520}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2523,'endLine':2523}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2526,'endLine':2526}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2532,'endLine':2532}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2535,'endLine':2535}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2538,'endLine':2538}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2544,'endLine':2544}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2546,'endLine':2546}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2551,'endLine':2551}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2553,'endLine':2553}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2558,'endLine':2558}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2560,'endLine':2560}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2565,'endLine':2565}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2567,'endLine':2567}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2625,'endLine':2625}","it('is ""passed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.it('passes', function() {});
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('passed');
      })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2697,'endLine':2697}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.beforeAll(function() {
          throw new Error('nope');
        });
        env.it('does not run', function() {});
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2718,'endLine':2718}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.describe('something', function() {
          env.beforeAll(function() {
            throw new Error('nope');
          });
          env.it('does not run', function() {});
        });
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2739,'endLine':2739}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.afterAll(function() {
          throw new Error('nope');
        });
        env.it('does not run', function() {});
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2760,'endLine':2760}","it('is ""failed""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.describe('something', function() {
          env.afterAll(function() {
            throw new Error('nope');
          });
          env.it('does not run', function() {});
        });
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('failed');
      })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2798,'endLine':2798}","it('is ""failed""', async function() {
        const global = {
          ...browserEventMethods(),
          setTimeout: function(fn, delay) {
            return setTimeout(fn, delay);
          },
          clearTimeout: function(fn, delay) {
            return clearTimeout(fn, delay);
          },
          queueMicrotask: function(fn) {
            queueMicrotask(fn);
          }
        };
        spyOn(jasmineUnderTest, 'getGlobal').and.returnValue(global);

        env.cleanup_();
        env = new jasmineUnderTest.Env();
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        reporter.jasmineDone.and.callFake(function(e) {
          expect(e.overallStatus).toEqual('failed');
        });

        env.addReporter(reporter);
        env.it('passes', function() {});
        dispatchErrorEvent(global, { error: 'ENOCHEESE' });
        await env.execute();

        expect(reporter.jasmineDone).toHaveBeenCalled();
      })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2833,'endLine':2833}","it('is ""incomplete""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.fit('is focused', function() {});
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('incomplete');
        expect(e.incompleteReason).toEqual('fit() or fdescribe() was found');
        expect(e.incompleteCode).toEqual('focused');
      })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':2853,'endLine':2853}","it('is ""incomplete""', async function() {
        const reporter = jasmine.createSpyObj('reporter', [
          'jasmineDone',
          'suiteDone',
          'specDone'
        ]);

        env.addReporter(reporter);
        env.fdescribe('something focused', function() {
          env.it('does a thing', function() {});
        });
        await env.execute();

        const e = reporter.jasmineDone.calls.argsFor(0)[0];
        expect(e.overallStatus).toEqual('incomplete');
        expect(e.incompleteReason).toEqual('fit() or fdescribe() was found');
        expect(e.incompleteCode).toEqual('focused');
      })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3141,'endLine':3141}","it('reports an error when an async expectation occurs after the suite finishes', async function() {
    const jasmineDone = jasmine.createSpy('jasmineDone');
    let resolve;
    const promise = new Promise(function(res) {
      resolve = res;
    });

    env.configure({ random: false });

    env.describe('a suite', function() {
      env.afterAll(function() {
        // Note: we intentionally don't return the result of expectAsync.
        // This causes the suite to finish before the expectations are evaluated.
        env.expectAsync(promise).toBeResolved();
      });

      env.it('is a spec', function() {});
    });

    env.it('another spec', function(done) {
      // This is here to make sure that the async expectation evaluates
      // before the Jasmine under test finishes, especially on Safari 8 and 9.
      setTimeout(done, 10);
    });

    env.addReporter({
      suiteDone: function() {
        resolve();
      },
      jasmineDone: jasmineDone
    });

    await env.execute();

    const result = jasmineDone.calls.argsFor(0)[0];
    expect(result.failedExpectations).toEqual([
      jasmine.objectContaining({
        passed: false,
        globalErrorType: 'lateExpectation',
        message:
          'Suite ""a suite"" ran a ""toBeResolved"" expectation ' +
          'after it finished.\n' +
          '1. Did you forget to return or await the result of expectAsync?\n' +
          '2. Was done() invoked before an async operation completed?\n' +
          '3. Did an expectation follow a call to done()?',
        matcherName: 'toBeResolved'
      })
    ]);
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3222,'endLine':3222}","it('is resolved after reporter events are dispatched', function() {
      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone',
        'jasmineDone'
      ]);

      env.addReporter(reporter);
      env.describe('suite', function() {
        env.it('spec', function() {});
      });

      return env.execute(null).then(function() {
        expect(reporter.specDone).toHaveBeenCalled();
        expect(reporter.suiteDone).toHaveBeenCalled();
        expect(reporter.jasmineDone).toHaveBeenCalled();
      });
    })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3246,'endLine':3246}","it('is resolved after the stack is cleared', function(done) {
      const realClearStack = jasmineUnderTest.getClearStack(
          jasmineUnderTest.getGlobal()
        ),
        clearStackSpy = jasmine
          .createSpy('clearStack')
          .and.callFake(realClearStack);
      spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(clearStackSpy);

      // Create a new env that has the clearStack defined above
      env.cleanup_();
      env = new jasmineUnderTest.Env();

      env.describe('suite', function() {
        env.it('spec', function() {});
      });

      env.execute(null).then(function() {
        expect(clearStackSpy).toHaveBeenCalled(); // (many times)
        clearStackSpy.calls.reset();
        setTimeout(function() {
          expect(clearStackSpy).not.toHaveBeenCalled();
          done();
        });
      });
    })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3274,'endLine':3274}","it('is resolved after QueueRunner timeouts are cleared', function() {
      const setTimeoutSpy = spyOn(
        jasmineUnderTest.getGlobal(),
        'setTimeout'
      ).and.callThrough();
      const clearTimeoutSpy = spyOn(
        jasmineUnderTest.getGlobal(),
        'clearTimeout'
      ).and.callThrough();

      jasmineUnderTest.DEFAULT_TIMEOUT_INTERVAL = 123456; // a distinctive value

      env = new jasmineUnderTest.Env();

      env.describe('suite', function() {
        env.it('spec', function() {});
      });

      return env.execute(null).then(function() {
        const timeoutIds = setTimeoutSpy.calls
          .all()
          .filter(function(call) {
            return call.args[1] === 123456;
          })
          .map(function(call) {
            return call.returnValue;
          });

        expect(timeoutIds.length).toBeGreaterThan(0);

        timeoutIds.forEach(function(timeoutId) {
          expect(clearTimeoutSpy).toHaveBeenCalledWith(timeoutId);
        });
      });
    })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3331,'endLine':3331}","it('is called after reporter events are dispatched', async function() {
      const reporter = jasmine.createSpyObj('reporter', [
        'specDone',
        'suiteDone',
        'jasmineDone'
      ]);

      env.addReporter(reporter);
      env.describe('suite', function() {
        env.it('spec', function() {});
      });

      await env.execute();

      expect(reporter.specDone).toHaveBeenCalled();
      expect(reporter.suiteDone).toHaveBeenCalled();
      expect(reporter.jasmineDone).toHaveBeenCalled();
    })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3355,'endLine':3355}","it('is called after the stack is cleared', async function() {
      const realClearStack = jasmineUnderTest.getClearStack(
          jasmineUnderTest.getGlobal()
        ),
        clearStackSpy = jasmine
          .createSpy('clearStack')
          .and.callFake(realClearStack);
      spyOn(jasmineUnderTest, 'getClearStack').and.returnValue(clearStackSpy);

      // Create a new env that has the clearStack defined above
      env.cleanup_();
      env = new jasmineUnderTest.Env();

      env.describe('suite', function() {
        env.it('spec', function() {});
      });

      await env.execute();

      expect(clearStackSpy).toHaveBeenCalled(); // (many times)
      clearStackSpy.calls.reset();

      await new Promise(resolve => setTimeout(resolve));

      expect(clearStackSpy).not.toHaveBeenCalled();
    })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3383,'endLine':3383}","it('is called after QueueRunner timeouts are cleared', async function() {
      const setTimeoutSpy = spyOn(
        jasmineUnderTest.getGlobal(),
        'setTimeout'
      ).and.callThrough();
      const clearTimeoutSpy = spyOn(
        jasmineUnderTest.getGlobal(),
        'clearTimeout'
      ).and.callThrough();

      jasmineUnderTest.DEFAULT_TIMEOUT_INTERVAL = 123456; // a distinctive value

      env = new jasmineUnderTest.Env();

      env.describe('suite', function() {
        env.it('spec', function() {});
      });

      await env.execute();

      const timeoutIds = setTimeoutSpy.calls
        .all()
        .filter(function(call) {
          return call.args[1] === 123456;
        })
        .map(function(call) {
          return call.returnValue;
        });

      expect(timeoutIds.length).toBeGreaterThan(0);

      timeoutIds.forEach(function(timeoutId) {
        expect(clearTimeoutSpy).toHaveBeenCalledWith(timeoutId);
      });
    })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3461,'endLine':3461}","it('reports an error when debugLog is used when a spec is not running', async function() {
    const reporter = jasmine.createSpyObj('reporter', ['suiteDone']);

    env.describe('a suite', function() {
      env.beforeAll(function() {
        env.debugLog('a message');
      });

      env.it('a spec', function() {});
    });

    env.addReporter(reporter);
    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        failedExpectations: [
          jasmine.objectContaining({
            message: jasmine.stringContaining(
              ""'debugLog' was called when there was no current spec""
            )
          })
        ]
      })
    );
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3483,'endLine':3483}","it('uses custom equality testers in Spy#withArgs', async function() {
    env.it('a spec', function() {
      const createSpySpy = env.createSpy('via createSpy');
      const spiedOn = { foo: function() {} };
      env.spyOn(spiedOn, 'foo');
      const spyObj = env.createSpyObj('spyObj', ['foo']);
      const spiedOnAllFuncs = { foo: function() {} };
      env.spyOnAllFunctions(spiedOnAllFuncs);

      for (const spy of [
        createSpySpy,
        spiedOn.foo,
        spyObj.foo,
        spiedOnAllFuncs.foo
      ]) {
        spy.and.returnValue('default strategy');
        spy.withArgs(42).and.returnValue('custom strategy');
      }

      env.addCustomEqualityTester(function(a, b) {
        if ((a === 'x' && b === 42) || (a === 42 && b === 'x')) {
          return true;
        }
      });

      env
        .expect(createSpySpy('x'))
        .withContext('createSpy')
        .toEqual('custom strategy');
      env
        .expect(spiedOn.foo('x'))
        .withContext('spyOn')
        .toEqual('custom strategy');
      env
        .expect(spyObj.foo('x'))
        .withContext('createSpyObj')
        .toEqual('custom strategy');
      env
        .expect(spiedOnAllFuncs.foo('x'))
        .withContext('spyOnAllFunctions')
        .toEqual('custom strategy');
    });

    let failedExpectations;
    env.addReporter({
      specDone: r => (failedExpectations = r.failedExpectations)
    });

    await env.execute();
    expect(failedExpectations).toEqual([]);
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3486,'endLine':3486}","it('uses custom equality testers in Spy#withArgs', async function() {
    env.it('a spec', function() {
      const createSpySpy = env.createSpy('via createSpy');
      const spiedOn = { foo: function() {} };
      env.spyOn(spiedOn, 'foo');
      const spyObj = env.createSpyObj('spyObj', ['foo']);
      const spiedOnAllFuncs = { foo: function() {} };
      env.spyOnAllFunctions(spiedOnAllFuncs);

      for (const spy of [
        createSpySpy,
        spiedOn.foo,
        spyObj.foo,
        spiedOnAllFuncs.foo
      ]) {
        spy.and.returnValue('default strategy');
        spy.withArgs(42).and.returnValue('custom strategy');
      }

      env.addCustomEqualityTester(function(a, b) {
        if ((a === 'x' && b === 42) || (a === 42 && b === 'x')) {
          return true;
        }
      });

      env
        .expect(createSpySpy('x'))
        .withContext('createSpy')
        .toEqual('custom strategy');
      env
        .expect(spiedOn.foo('x'))
        .withContext('spyOn')
        .toEqual('custom strategy');
      env
        .expect(spyObj.foo('x'))
        .withContext('createSpyObj')
        .toEqual('custom strategy');
      env
        .expect(spiedOnAllFuncs.foo('x'))
        .withContext('spyOnAllFunctions')
        .toEqual('custom strategy');
    });

    let failedExpectations;
    env.addReporter({
      specDone: r => (failedExpectations = r.failedExpectations)
    });

    await env.execute();
    expect(failedExpectations).toEqual([]);
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3614,'endLine':3614}","it('reports suite and spec filenames', async function() {
    const methods = ['suiteStarted', 'suiteDone', 'specStarted', 'specDone'];
    const reporter = jasmine.createSpyObj('reporter', methods);
    env.addReporter(reporter);

    // Simulate calling through global it and describe,
    // which add another stack frame vs calling env methods directly
    function describeShim(name, fn) {
      env.describe(name, fn);
    }
    function itShim(name, fn) {
      env.it(name, fn);
    }

    describeShim('a suite', function() {
      itShim('a spec', function() {});
    });

    await env.execute();

    for (const method of methods) {
      expect(reporter[method])
        .withContext(method)
        .toHaveBeenCalledWith(
          jasmine.objectContaining({
            filename: jasmine.stringMatching(/EnvSpec\.js$/)
          })
        );
    }
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3645,'endLine':3645}","it('reports skipped suite and spec filenames', async function() {
    const methods = ['suiteStarted', 'suiteDone', 'specStarted', 'specDone'];
    const reporter = jasmine.createSpyObj('reporter', methods);
    env.addReporter(reporter);

    // Simulate calling through global it and describe,
    // which add another stack frame vs calling env methods directly
    function xdescribeShim(name, fn) {
      env.xdescribe(name, fn);
    }
    function xitShim(name, fn) {
      env.xit(name, fn);
    }

    xdescribeShim('a suite', function() {
      xitShim('a spec', function() {});
    });

    await env.execute();

    for (const method of methods) {
      expect(reporter[method])
        .withContext(method)
        .toHaveBeenCalledWith(
          jasmine.objectContaining({
            filename: jasmine.stringMatching(/EnvSpec\.js$/)
          })
        );
    }
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3676,'endLine':3676}","it('reports focused suite and spec filenames', async function() {
    const methods = ['suiteStarted', 'suiteDone', 'specStarted', 'specDone'];
    const reporter = jasmine.createSpyObj('reporter', methods);
    env.addReporter(reporter);

    // Simulate calling through global it and describe,
    // which add another stack frame vs calling env methods directly
    function fdescribeShim(name, fn) {
      env.fdescribe(name, fn);
    }
    function fitShim(name, fn) {
      env.fit(name, fn);
    }

    fdescribeShim('a suite', function() {
      fitShim('a spec', function() {});
    });

    await env.execute();

    for (const method of methods) {
      expect(reporter[method])
        .withContext(method)
        .toHaveBeenCalledWith(
          jasmine.objectContaining({
            filename: jasmine.stringMatching(/EnvSpec\.js$/)
          })
        );
    }
  })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3734,'endLine':3734}","it('does not cause a failure if the error does not propagate back to jasmine', async function() {
      env.it('a spec', function() {
        try {
          env.throwUnless(1).toEqual(2);
          // eslint-disable-next-line no-unused-vars
        } catch (e) {}
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);

      await env.execute();
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({ status: 'passed' })
      );
    })",snuts
/spec/core/integration/EnvSpec.js,NonFunctionalStatement,"{'startLine':3792,'endLine':3792}","it('does not cause a failure if the error does not propagate back to jasmine', async function() {
      env.it('a spec', async function() {
        try {
          await env.throwUnlessAsync(Promise.resolve()).toBeRejected();
          // eslint-disable-next-line no-unused-vars
        } catch (e) {}
      });

      const reporter = jasmine.createSpyObj('reporter', ['specDone']);
      env.addReporter(reporter);

      await env.execute();
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({ status: 'passed' })
      );
    })",snuts
/spec/core/integration/EnvSpec.js,SubOptimalAssert,"{'startLine':983,'endLine':983}","it('Functions can be spied on and have their calls tracked', async function() {
    let originalFunctionWasCalled = false;
    const subject = {
      spiedFunc: function() {
        originalFunctionWasCalled = true;
        return 'original result';
      }
    };

    env.it('works with spies', function() {
      const spy = env
        .spyOn(subject, 'spiedFunc')
        .and.returnValue('stubbed result');

      expect(subject.spiedFunc).toEqual(spy);
      expect(subject.spiedFunc.calls.any()).toEqual(false);
      expect(subject.spiedFunc.calls.count()).toEqual(0);

      subject.spiedFunc('foo');

      expect(subject.spiedFunc.calls.any()).toEqual(true);
      expect(subject.spiedFunc.calls.count()).toEqual(1);
      expect(subject.spiedFunc.calls.mostRecent().args).toEqual(['foo']);
      expect(subject.spiedFunc.calls.mostRecent().object).toEqual(subject);
      expect(subject.spiedFunc.calls.mostRecent().returnValue).toEqual(
        'stubbed result'
      );
      expect(originalFunctionWasCalled).toEqual(false);

      subject.spiedFunc.and.callThrough();
      subject.spiedFunc('bar');
      expect(subject.spiedFunc.calls.count()).toEqual(2);
      expect(subject.spiedFunc.calls.mostRecent().args).toEqual(['bar']);
      expect(subject.spiedFunc.calls.mostRecent().returnValue).toEqual(
        'original result'
      );
      expect(originalFunctionWasCalled).toEqual(true);
    });

    env.it(
      'works with constructors when using callThrough spy strategy',
      function() {
        function MyClass(foo) {
          if (!(this instanceof MyClass)) {
            throw new Error('You must use the new keyword.');
          }
          this.foo = foo;
        }
        const subject = { MyClass: MyClass };
        const spy = env.spyOn(subject, 'MyClass').and.callThrough();

        expect(function() {
          const result = new spy('hello world');
          expect(result instanceof MyClass).toBeTruthy();
          expect(result.foo).toEqual('hello world');
        }).not.toThrow();

        expect(function() {
          const result = new spy(
            'passing',
            'extra',
            'arguments',
            'to',
            'constructor'
          );
          expect(result instanceof MyClass).toBeTruthy();
          expect(result.foo).toEqual('passing');
        }).not.toThrow();

        expect(function() {
          spy('hello world');
        }).toThrowError('You must use the new keyword.');
      }
    );

    await env.execute();
  })",snuts
/spec/core/integration/EnvSpec.js,SubOptimalAssert,"{'startLine':995,'endLine':995}","it('Functions can be spied on and have their calls tracked', async function() {
    let originalFunctionWasCalled = false;
    const subject = {
      spiedFunc: function() {
        originalFunctionWasCalled = true;
        return 'original result';
      }
    };

    env.it('works with spies', function() {
      const spy = env
        .spyOn(subject, 'spiedFunc')
        .and.returnValue('stubbed result');

      expect(subject.spiedFunc).toEqual(spy);
      expect(subject.spiedFunc.calls.any()).toEqual(false);
      expect(subject.spiedFunc.calls.count()).toEqual(0);

      subject.spiedFunc('foo');

      expect(subject.spiedFunc.calls.any()).toEqual(true);
      expect(subject.spiedFunc.calls.count()).toEqual(1);
      expect(subject.spiedFunc.calls.mostRecent().args).toEqual(['foo']);
      expect(subject.spiedFunc.calls.mostRecent().object).toEqual(subject);
      expect(subject.spiedFunc.calls.mostRecent().returnValue).toEqual(
        'stubbed result'
      );
      expect(originalFunctionWasCalled).toEqual(false);

      subject.spiedFunc.and.callThrough();
      subject.spiedFunc('bar');
      expect(subject.spiedFunc.calls.count()).toEqual(2);
      expect(subject.spiedFunc.calls.mostRecent().args).toEqual(['bar']);
      expect(subject.spiedFunc.calls.mostRecent().returnValue).toEqual(
        'original result'
      );
      expect(originalFunctionWasCalled).toEqual(true);
    });

    env.it(
      'works with constructors when using callThrough spy strategy',
      function() {
        function MyClass(foo) {
          if (!(this instanceof MyClass)) {
            throw new Error('You must use the new keyword.');
          }
          this.foo = foo;
        }
        const subject = { MyClass: MyClass };
        const spy = env.spyOn(subject, 'MyClass').and.callThrough();

        expect(function() {
          const result = new spy('hello world');
          expect(result instanceof MyClass).toBeTruthy();
          expect(result.foo).toEqual('hello world');
        }).not.toThrow();

        expect(function() {
          const result = new spy(
            'passing',
            'extra',
            'arguments',
            'to',
            'constructor'
          );
          expect(result instanceof MyClass).toBeTruthy();
          expect(result.foo).toEqual('passing');
        }).not.toThrow();

        expect(function() {
          spy('hello world');
        }).toThrowError('You must use the new keyword.');
      }
    );

    await env.execute();
  })",snuts
/spec/core/integration/EnvSpec.js,VerboseStatement,"{'startLine':432,'endLine':462}","it('reports multiple calls to done in the top suite as errors', async function() {
    const reporter = jasmine.createSpyObj('fakeReporter', ['jasmineDone']);
    const message =
      'A top-level beforeAll or afterAll function called its ' +
      ""'done' callback more than once."";

    env.addReporter(reporter);
    env.beforeAll(function(innerDone) {
      innerDone();
      innerDone();
    });
    env.it('a spec, so the beforeAll runs', function() {});
    env.afterAll(function(innerDone) {
      innerDone();
      innerDone();
    });

    await env.execute();

    expect(reporter.jasmineDone).toHaveBeenCalled();
    const errors = reporter.jasmineDone.calls.argsFor(0)[0].failedExpectations;
    expect(errors.length).toEqual(2);
    expect(errors[0].message)
      .withContext('top beforeAll')
      .toContain(message);
    expect(errors[0].globalErrorType).toEqual('lateError');
    expect(errors[1].message)
      .withContext('top afterAll')
      .toContain(message);
    expect(errors[1].globalErrorType).toEqual('lateError');
  })",snuts
/spec/core/integration/EnvSpec.js,VerboseStatement,"{'startLine':464,'endLine':513}","it('reports multiple calls to done in a non-top suite as errors', async function() {
    const reporter = jasmine.createSpyObj('fakeReporter', [
      'jasmineDone',
      'suiteDone'
    ]);
    const message =
      ""An asynchronous beforeAll or afterAll function called its 'done' "" +
      'callback more than once.\n(in suite: a suite)';
    let lateDone;
    reporter.suiteDone.and.callFake(function() {
      lateDone();
    });

    env.addReporter(reporter);
    env.describe('a suite', function() {
      env.beforeAll(function(innerDone) {
        innerDone();
        innerDone();
      });
      env.it('a spec, so that before/afters run', function() {});
      env.afterAll(function(innerDone) {
        innerDone();
        innerDone();
        lateDone = innerDone;
      });
    });

    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalled();
    const suiteErrors = reporter.suiteDone.calls.argsFor(0)[0]
      .failedExpectations;
    expect(suiteErrors.length).toEqual(2);
    expect(suiteErrors[0].message)
      .withContext('suite beforeAll')
      .toContain(message);
    expect(suiteErrors[1].message)
      .withContext('suite afterAll')
      .toContain(message);

    expect(reporter.jasmineDone).toHaveBeenCalled();
    const topErrors = reporter.jasmineDone.calls.argsFor(0)[0]
      .failedExpectations;
    expect(topErrors.length).toEqual(1);
    expect(topErrors[0].message)
      .withContext('late suite afterAll')
      .toContain(message);
    expect(topErrors[0].globalErrorType).toEqual('lateError');
    expect(topErrors[0].globalErrorType).toEqual('lateError');
  })",snuts
/spec/core/integration/EnvSpec.js,VerboseStatement,"{'startLine':515,'endLine':578}","it('reports multiple calls to done in a spec as errors', async function() {
    const reporter = jasmine.createSpyObj('fakeReporter', [
      'specDone',
      'suiteDone',
      'jasmineDone'
    ]);
    const message =
      'An asynchronous spec, beforeEach, or afterEach function called its ' +
      ""'done' callback more than once.\n(in spec: a suite a spec)"";
    let lateDone;
    reporter.specDone.and.callFake(function() {
      lateDone();
    });
    reporter.suiteDone.and.callFake(function() {
      lateDone();
    });

    env.addReporter(reporter);
    env.describe('a suite', function() {
      env.beforeEach(function(innerDone) {
        innerDone();
        innerDone();
      });
      env.it('a spec', function(innerDone) {
        innerDone();
        innerDone();
      });
      env.afterEach(function(innerDone) {
        innerDone();
        innerDone();
        lateDone = innerDone;
      });
    });

    await env.execute();

    expect(reporter.specDone).toHaveBeenCalled();
    const specErrors = reporter.specDone.calls.argsFor(0)[0].failedExpectations;
    expect(specErrors.length).toEqual(3);
    expect(specErrors[0].message)
      .withContext('error caused by beforeEach')
      .toContain(message);
    expect(specErrors[1].message)
      .withContext('error caused by it')
      .toContain(message);
    expect(specErrors[2].message)
      .withContext('error caused by afterEach')
      .toContain(message);

    const suiteErrors = reporter.suiteDone.calls.argsFor(0)[0]
      .failedExpectations;
    expect(suiteErrors.length).toEqual(1);
    expect(suiteErrors[0].message)
      .withContext('late error caused by afterEach')
      .toContain(message);

    const topErrors = reporter.jasmineDone.calls.argsFor(0)[0]
      .failedExpectations;
    expect(topErrors.length).toEqual(1);
    expect(topErrors[0].message)
      .withContext('really late error caused by afterEach')
      .toContain(message);
    expect(topErrors[0].globalErrorType).toEqual('lateError');
  })",snuts
/spec/core/integration/EnvSpec.js,VerboseStatement,"{'startLine':1240,'endLine':1281}","it('should not use the mock clock for asynchronous timeouts', async function() {
      createMockedEnv();
      const reporter = jasmine.createSpyObj('fakeReporter', ['specDone']),
        clock = env.clock;

      reporter.specDone.and.callFake(function() {
        realSetTimeout(function() {
          jasmine.debugLog('Ticking after specDone');
          jasmine.clock().tick(1);
        }, 0);
      });

      env.addReporter(reporter);
      jasmineUnderTest.DEFAULT_TIMEOUT_INTERVAL = 500;

      env.beforeAll(function() {
        clock.install();
      });

      env.afterAll(function() {
        clock.uninstall();
      });

      env.it('spec that should not time out', function(innerDone) {
        clock.tick(1000);
        expect(true).toEqual(true);
        jasmine.debugLog('Calling realSetTimeout in spec');
        realSetTimeout(function() {
          jasmine.debugLog('Calling innerDone');
          innerDone();
        });
      });

      await env.execute();
      expect(reporter.specDone).toHaveBeenCalledTimes(1);
      const event = reporter.specDone.calls.argsFor(0)[0];
      jasmine.debugLog('Spec result: ' + jasmine.basicPrettyPrinter_(event));
      expect(event).toEqual(jasmine.objectContaining({ status: 'passed' }));
      jasmine.clock().tick(1);

      await new Promise(resolve => realSetTimeout(resolve));
    })",snuts
/spec/core/integration/EnvSpec.js,VerboseStatement,"{'startLine':1283,'endLine':1413}","it('should wait a custom interval before reporting async functions that fail to complete', async function() {
      createMockedEnv();
      const reporter = jasmine.createSpyObj('fakeReport', [
        'jasmineDone',
        'suiteDone',
        'specDone'
      ]);

      env.addReporter(reporter);
      jasmineUnderTest.DEFAULT_TIMEOUT_INTERVAL = 10000;

      env.describe('suite', function() {
        env.afterAll(function() {
          realSetTimeout(function() {
            try {
              jasmine.clock().tick(10);
              // eslint-disable-next-line no-unused-vars
            } catch (e) {
              // don't worry if the clock is already uninstalled
            }
          }, 100);
        });
        env.describe('beforeAll', function() {
          env.beforeAll(function(innerDone) {
            realSetTimeout(function() {
              jasmine.clock().tick(5001);
            }, 0);
          }, 5000);

          env.it('times out', function(innerDone) {
            realSetTimeout(function() {
              jasmine.clock().tick(1);
              innerDone();
            }, 0);
          });
        });

        env.describe('afterAll', function() {
          env.afterAll(function(innerDone) {
            realSetTimeout(function() {
              jasmine.clock().tick(2001);
            }, 0);
          }, 2000);

          env.it('times out', function(innerDone) {
            realSetTimeout(function() {
              jasmine.clock().tick(1);
              innerDone();
            }, 0);
          });
        });

        env.describe('beforeEach', function() {
          env.beforeEach(function(innerDone) {
            realSetTimeout(function() {
              jasmine.clock().tick(1001);
            }, 0);
          }, 1000);

          env.it('times out', function(innerDone) {
            realSetTimeout(function() {
              jasmine.clock().tick(1);
              innerDone();
            }, 0);
          });
        });

        env.describe('afterEach', function() {
          env.afterEach(function(innerDone) {
            realSetTimeout(function() {
              jasmine.clock().tick(4001);
            }, 0);
          }, 4000);

          env.it('times out', function(innerDone) {
            realSetTimeout(function() {
              jasmine.clock().tick(1);
              innerDone();
            }, 0);
          });
        });

        env.it(
          'it times out',
          function(innerDone) {
            realSetTimeout(function() {
              jasmine.clock().tick(6001);
            }, 0);
          },
          6000
        );
      });

      await env.execute();

      const r = reporter.jasmineDone.calls.argsFor(0)[0];
      expect(r.failedExpectations).toEqual([]);
      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'suite beforeAll',
        [
          /^Error: Timeout - Async function did not complete within 5000ms \(custom timeout\)/
        ]
      );
      expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
        'suite afterAll',
        [
          /^Error: Timeout - Async function did not complete within 2000ms \(custom timeout\)/
        ]
      );
      expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
        'suite beforeEach times out',
        [
          /^Error: Timeout - Async function did not complete within 1000ms \(custom timeout\)/
        ]
      );
      expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
        'suite afterEach times out',
        [
          /^Error: Timeout - Async function did not complete within 4000ms \(custom timeout\)/
        ]
      );
      expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
        'suite it times out',
        [
          /^Error: Timeout - Async function did not complete within 6000ms \(custom timeout\)/
        ]
      );

      jasmine.clock().tick(1);
      await new Promise(resolve => realSetTimeout(resolve));
    })",snuts
/spec/core/integration/EnvSpec.js,VerboseStatement,"{'startLine':1590,'endLine':1822}","it('should report as expected', async function() {
    const reporter = jasmine.createSpyObj('fakeReporter', [
      'jasmineStarted',
      'suiteStarted',
      'suiteDone',
      'specStarted',
      'specDone'
    ]);
    const suiteFullNameToId = {};
    reporter.suiteStarted.and.callFake(function(e) {
      suiteFullNameToId[e.fullName] = e.id;
    });

    // Clone args to work around Jasmine mutating the result after passing it
    // to the reporter event.
    // TODO: remove this once Jasmine no longer does that
    const clone = structuredClone.bind(globalThis);
    reporter.specStarted.calls.saveArgumentsByValue(clone);
    reporter.specDone.calls.saveArgumentsByValue(clone);
    reporter.specStarted.calls.saveArgumentsByValue(clone);
    reporter.suiteDone.calls.saveArgumentsByValue(clone);

    env.configure({ random: false });
    env.addReporter(reporter);

    env.it('a top level spec', function() {});

    env.describe('A Suite', function() {
      env.it('with a spec', function() {
        env.expect(true).toBe(true);
      });
      env.describe('with a nested suite', function() {
        env.xit(""with an x'ed spec"", function() {
          env.expect(true).toBe(true);
        });
        env.it('with a spec', function() {
          env.expect(true).toBe(false);
        });
      });

      env.describe('with only non-executable specs', function() {
        env.it('is pending');
        env.xit('is xed', function() {
          env.expect(true).toBe(true);
        });
      });
    });

    await env.execute();

    expect(reporter.jasmineStarted).toHaveBeenCalledWith({
      totalSpecsDefined: 6,
      order: jasmine.any(jasmineUnderTest.Order),
      parallel: false
    });

    expect(reporter.specStarted.calls.count()).toBe(6);
    expect(reporter.specDone.calls.count()).toBe(6);

    const baseSpecEvent = {
      passedExpectations: [],
      failedExpectations: [],
      deprecationWarnings: [],
      pendingReason: '',
      duration: null,
      properties: null,
      debugLogs: null,
      id: jasmine.any(String),
      filename: jasmine.any(String)
    };

    expect(reporter.specStarted.calls.argsFor(0)[0]).toEqual({
      ...baseSpecEvent,
      description: 'a top level spec',
      fullName: 'a top level spec',
      parentSuiteId: null
    });
    expect(reporter.specDone.calls.argsFor(0)[0]).toEqual({
      ...baseSpecEvent,
      description: 'a top level spec',
      fullName: 'a top level spec',
      status: 'passed',
      parentSuiteId: null,
      duration: jasmine.any(Number)
    });
    expect(reporter.specStarted.calls.argsFor(1)[0]).toEqual({
      ...baseSpecEvent,
      description: 'with a spec',
      fullName: 'A Suite with a spec',
      parentSuiteId: suiteFullNameToId['A Suite']
    });
    expect(reporter.specDone.calls.argsFor(1)[0]).toEqual({
      ...baseSpecEvent,
      description: 'with a spec',
      fullName: 'A Suite with a spec',
      status: 'passed',
      parentSuiteId: suiteFullNameToId['A Suite'],
      passedExpectations: [
        { matcherName: 'toBe', message: 'Passed.', stack: '', passed: true }
      ],
      duration: jasmine.any(Number)
    });

    expect(reporter.specStarted.calls.argsFor(2)[0]).toEqual({
      ...baseSpecEvent,
      description: ""with an x'ed spec"",
      fullName: ""A Suite with a nested suite with an x'ed spec"",
      parentSuiteId: suiteFullNameToId['A Suite with a nested suite'],
      pendingReason: 'Temporarily disabled with xit'
    });
    expect(reporter.specDone.calls.argsFor(2)[0]).toEqual({
      ...baseSpecEvent,
      description: ""with an x'ed spec"",
      fullName: ""A Suite with a nested suite with an x'ed spec"",
      status: 'pending',
      parentSuiteId: suiteFullNameToId['A Suite with a nested suite'],
      pendingReason: 'Temporarily disabled with xit',
      duration: jasmine.any(Number)
    });

    expect(reporter.specStarted.calls.argsFor(3)[0]).toEqual({
      ...baseSpecEvent,
      description: 'with a spec',
      fullName: 'A Suite with a nested suite with a spec',
      parentSuiteId: suiteFullNameToId['A Suite with a nested suite']
    });
    expect(reporter.specDone.calls.argsFor(3)[0]).toEqual({
      ...baseSpecEvent,
      description: 'with a spec',
      fullName: 'A Suite with a nested suite with a spec',
      status: 'failed',
      parentSuiteId: suiteFullNameToId['A Suite with a nested suite'],
      failedExpectations: [
        jasmine.objectContaining({
          matcherName: 'toBe',
          message: 'Expected true to be false.'
        })
      ],
      duration: jasmine.any(Number)
    });

    expect(reporter.specStarted.calls.argsFor(4)[0]).toEqual({
      ...baseSpecEvent,
      description: 'is pending',
      fullName: 'A Suite with only non-executable specs is pending',
      parentSuiteId: suiteFullNameToId['A Suite with only non-executable specs']
    });
    expect(reporter.specDone.calls.argsFor(4)[0]).toEqual({
      ...baseSpecEvent,
      description: 'is pending',
      status: 'pending',
      fullName: 'A Suite with only non-executable specs is pending',
      parentSuiteId:
        suiteFullNameToId['A Suite with only non-executable specs'],
      duration: jasmine.any(Number)
    });

    expect(reporter.specStarted.calls.argsFor(5)[0]).toEqual({
      ...baseSpecEvent,
      description: 'is xed',
      fullName: 'A Suite with only non-executable specs is xed',
      parentSuiteId:
        suiteFullNameToId['A Suite with only non-executable specs'],
      pendingReason: 'Temporarily disabled with xit'
    });
    expect(reporter.specDone.calls.argsFor(5)[0]).toEqual({
      ...baseSpecEvent,
      description: 'is xed',
      status: 'pending',
      fullName: 'A Suite with only non-executable specs is xed',
      parentSuiteId:
        suiteFullNameToId['A Suite with only non-executable specs'],
      pendingReason: 'Temporarily disabled with xit',
      duration: jasmine.any(Number)
    });

    expect(reporter.suiteStarted.calls.count()).toBe(3);
    expect(reporter.suiteDone.calls.count()).toBe(3);

    const baseSuiteEvent = {
      id: jasmine.any(String),
      filename: jasmine.any(String),
      failedExpectations: [],
      deprecationWarnings: [],
      duration: null,
      properties: null
    };

    expect(reporter.suiteStarted.calls.argsFor(0)[0]).toEqual({
      ...baseSuiteEvent,
      description: 'A Suite',
      fullName: 'A Suite',
      parentSuiteId: null
    });
    expect(reporter.suiteDone.calls.argsFor(2)[0]).toEqual({
      ...baseSuiteEvent,
      description: 'A Suite',
      fullName: 'A Suite',
      status: 'passed',
      parentSuiteId: null,
      duration: jasmine.any(Number)
    });

    expect(reporter.suiteStarted.calls.argsFor(1)[0]).toEqual({
      ...baseSuiteEvent,
      description: 'with a nested suite',
      fullName: 'A Suite with a nested suite',
      parentSuiteId: suiteFullNameToId['A Suite']
    });
    expect(reporter.suiteDone.calls.argsFor(0)[0]).toEqual({
      ...baseSuiteEvent,
      description: 'with a nested suite',
      status: 'passed',
      fullName: 'A Suite with a nested suite',
      parentSuiteId: suiteFullNameToId['A Suite'],
      duration: jasmine.any(Number)
    });

    expect(reporter.suiteStarted.calls.argsFor(2)[0]).toEqual({
      ...baseSuiteEvent,
      description: 'with only non-executable specs',
      fullName: 'A Suite with only non-executable specs',
      parentSuiteId: suiteFullNameToId['A Suite']
    });
    expect(reporter.suiteDone.calls.argsFor(1)[0]).toEqual({
      ...baseSuiteEvent,
      description: 'with only non-executable specs',
      status: 'passed',
      fullName: 'A Suite with only non-executable specs',
      parentSuiteId: suiteFullNameToId['A Suite'],
      duration: jasmine.any(Number)
    });
  })",snuts
/spec/core/integration/EnvSpec.js,VerboseStatement,"{'startLine':1824,'endLine':1905}","it('reports focused specs and suites as expected', async function() {
    const reporter = jasmine.createSpyObj('fakeReporter', [
      'suiteStarted',
      'suiteDone',
      'specStarted',
      'specDone'
    ]);
    const suiteFullNameToId = {};
    reporter.suiteStarted.and.callFake(function(e) {
      suiteFullNameToId[e.fullName] = e.id;
    });

    env.fit('a focused top level spec', function() {});

    env.describe('a suite', function() {
      env.fdescribe('a focused suite', function() {
        env.fit('a focused spec', function() {});
      });
    });

    env.addReporter(reporter);
    await env.execute();

    expect(reporter.specStarted).toHaveBeenCalledTimes(2);
    expect(reporter.specDone).toHaveBeenCalledTimes(2);

    expect(reporter.specStarted).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused top level spec',
        parentSuiteId: null
      })
    );
    expect(reporter.specDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused top level spec',
        status: 'passed',
        parentSuiteId: null
      })
    );

    expect(reporter.specStarted).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused spec',
        parentSuiteId: suiteFullNameToId['a suite a focused suite']
      })
    );
    expect(reporter.specDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused spec',
        status: 'passed',
        parentSuiteId: suiteFullNameToId['a suite a focused suite']
      })
    );

    expect(reporter.suiteStarted).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a suite',
        parentSuiteId: null
      })
    );
    expect(reporter.suiteDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a suite',
        status: 'passed',
        parentSuiteId: null
      })
    );

    expect(reporter.suiteStarted).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused suite',
        parentSuiteId: suiteFullNameToId['a suite']
      })
    );
    expect(reporter.suiteDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        description: 'a focused suite',
        status: 'passed',
        parentSuiteId: suiteFullNameToId['a suite']
      })
    );
  })",snuts
/spec/core/integration/EnvSpec.js,VerboseStatement,"{'startLine':2510,'endLine':2613}","it(""should throw on suites/specs/befores/afters nested in methods other than 'describe'"", async function() {
    const reporter = jasmine.createSpyObj('reporter', [
      'suiteDone',
      'specDone'
    ]);

    env.addReporter(reporter);

    env.describe('suite', function() {
      env.it('describe', function() {
        env.describe('inner suite', function() {});
      });
      env.it('xdescribe', function() {
        env.xdescribe('inner suite', function() {});
      });
      env.it('fdescribe', function() {
        env.fdescribe('inner suite', function() {});
      });
    });

    env.describe('spec', function() {
      env.it('it', function() {
        env.it('inner spec', function() {});
      });
      env.it('xit', function() {
        env.xit('inner spec', function() {});
      });
      env.it('fit', function() {
        env.fit('inner spec', function() {});
      });
    });

    env.describe('beforeAll', function() {
      env.beforeAll(function() {
        env.beforeAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('beforeEach', function() {
      env.beforeEach(function() {
        env.beforeEach(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterAll', function() {
      env.afterAll(function() {
        env.afterAll(function() {});
      });
      env.it('spec', function() {});
    });

    env.describe('afterEach', function() {
      env.afterEach(function() {
        env.afterEach(function() {});
      });
      env.it('spec', function() {});
    });

    await env.execute();

    const msg = /\'.*\' should only be used in \'describe\' function/;

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite describe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite xdescribe',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'suite fdescribe',
      [msg]
    );

    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec it', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec xit', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable('spec fit', [
      msg
    ]);

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'beforeAll',
      [msg]
    );
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'beforeEach spec',
      [msg]
    );

    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('afterAll', [
      msg
    ]);
    expect(reporter.specDone).toHaveFailedExpectationsForRunnable(
      'afterEach spec',
      [msg]
    );
  })",snuts
/spec/core/integration/DeprecationSpec.js,NonFunctionalStatement,"{'startLine':21,'endLine':21}","it('reports a deprecation on the top suite', async function() {
    const reporter = jasmine.createSpyObj('reporter', ['jasmineDone']);
    env.addReporter(reporter);
    spyOn(console, 'error');

    env.beforeAll(function() {
      env.deprecated('the message');
    });
    env.it('a spec', function() {});

    await env.execute();

    expect(reporter.jasmineDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        deprecationWarnings: [
          jasmine.objectContaining({
            message: jasmine.stringMatching(/^the message/)
          })
        ]
      })
    );
    expect(console.error).toHaveBeenCalledWith(
      jasmine.stringMatching(/^DEPRECATION: the message/)
    );
  })",snuts
/spec/core/integration/DeprecationSpec.js,NonFunctionalStatement,"{'startLine':48,'endLine':48}","it('reports a deprecation on a descendent suite', async function() {
    const reporter = jasmine.createSpyObj('reporter', ['suiteDone']);
    env.addReporter(reporter);
    spyOn(console, 'error');

    env.describe('a suite', function() {
      env.beforeAll(function() {
        env.deprecated('the message');
      });
      env.it('a spec', function() {});
    });

    await env.execute();

    expect(reporter.suiteDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        deprecationWarnings: [
          jasmine.objectContaining({
            message: jasmine.stringMatching(/^the message/)
          })
        ]
      })
    );
    expect(console.error).toHaveBeenCalledWith(
      jasmine.stringMatching(/^DEPRECATION: the message \(in suite: a suite\)/)
    );
  })",snuts
/spec/core/integration/DeprecationSpec.js,NonFunctionalStatement,"{'startLine':298,'endLine':298}","it('handles deprecations that occur before execute() is called', async function() {
    const reporter = jasmine.createSpyObj('reporter', ['jasmineDone']);
    env.addReporter(reporter);
    spyOn(console, 'error');

    env.deprecated('the message');
    env.it('a spec', function() {});

    await env.execute();

    expect(reporter.jasmineDone).toHaveBeenCalledWith(
      jasmine.objectContaining({
        deprecationWarnings: [
          jasmine.objectContaining({
            message: jasmine.stringMatching(/^the message/)
          })
        ]
      })
    );
    expect(console.error).toHaveBeenCalledWith(
      jasmine.stringMatching(/^DEPRECATION: the message/)
    );
  })",snuts
/spec/core/integration/CustomObjectFormatterSpec.js,NonFunctionalStatement,"{'startLine':72,'endLine':72}","it('throws an exception if you try to add a custom object formatter outside a runable', function() {
    expect(function() {
      env.addCustomObjectFormatter(function() {});
    }).toThrowError(
      'Custom object formatters must be added in a before function or a spec'
    );
  })",snuts
/spec/core/integration/CustomMatchersSpec.js,SensitiveEquality,"{'startLine':248,'endLine':248}","it('provides custom equality testers to the matcher factory via matchersUtil', async function() {
    const matcherFactory = function(matchersUtil) {
        return {
          compare: function(actual, expected) {
            return { pass: matchersUtil.equals(actual[0], expected) };
          }
        };
      },
      customEqualityFn = jasmine
        .createSpy('customEqualityFn')
        .and.callFake(function(a, b) {
          return a.toString() === b;
        });

    env.it('spec with expectation', function() {
      env.addCustomEqualityTester(customEqualityFn);
      env.addMatchers({
        toBeArrayWithFirstElement: matcherFactory
      });

      env.expect([1, 2]).toBeArrayWithFirstElement('1');
    });

    const reporter = jasmine.createSpyObj('reporter', ['specDone']);
    env.addReporter(reporter);
    await env.execute();

    expect(reporter.specDone).toHaveBeenCalledTimes(1);
    const result = reporter.specDone.calls.argsFor(0)[0];
    expect(customEqualityFn).toHaveBeenCalledWith(1, '1');
    expect(result.failedExpectations).toEqual([]);
  })",snuts
/spec/core/integration/CustomMatchersSpec.js,ConditionalTestLogic,"{'startLine':79,'endLine':86}","it('passes the spec if the custom equality matcher passes for types nested inside asymmetric equality testers', async function() {
    env.it('spec using custom equality matcher', function() {
      const customEqualityFn = function(a, b) {
        // All ""foo*"" strings match each other.
        if (
          typeof a == 'string' &&
          typeof b == 'string' &&
          a.slice(0, 3) == 'foo' &&
          b.slice(0, 3) == 'foo'
        ) {
          return true;
        }
      };

      env.addCustomEqualityTester(customEqualityFn);
      env
        .expect({ foo: 'fooValue' })
        .toEqual(jasmineUnderTest.objectContaining({ foo: 'fooBar' }));
      env
        .expect(['fooValue', 'things'])
        .toEqual(jasmineUnderTest.arrayContaining(['fooBar']));
      env
        .expect(['fooValue'])
        .toEqual(jasmineUnderTest.arrayWithExactContents(['fooBar']));
    });

    const reporter = jasmine.createSpyObj('reporter', ['specDone']);
    env.addReporter(reporter);
    await env.execute();

    expect(reporter.specDone).toHaveBeenCalledTimes(1);
    const result = reporter.specDone.calls.argsFor(0)[0];
    expect(result.status).toEqual('passed');
  })",snuts
/spec/core/integration/CustomMatchersSpec.js,ConditionalTestLogic,"{'startLine':114,'endLine':116}","it('displays an appropriate failure message if a custom equality matcher fails', async function() {
    env.it('spec using custom equality matcher', function() {
      const customEqualityFn = function(a, b) {
        // ""foo"" is not equal to anything
        if (a === 'foo' || b === 'foo') {
          return false;
        }
      };

      env.addCustomEqualityTester(customEqualityFn);
      env.expect({ foo: 'foo' }).toEqual({ foo: 'foo' });
    });

    const reporter = jasmine.createSpyObj('reporter', ['specDone']);
    env.addReporter(reporter);
    await env.execute();

    expect(reporter.specDone).toHaveBeenCalledTimes(1);
    const result = reporter.specDone.calls.argsFor(0)[0];
    expect(result.status).toEqual('failed');
    expect(result.failedExpectations[0].message).toEqual(
      ""Expected $.foo = 'foo' to equal 'foo'.""
    );
  })",snuts
/spec/core/integration/CustomAsyncMatchersSpec.js,SensitiveEquality,"{'startLine':131,'endLine':131}","it('provides custom equality testers to the matcher factory via matchersUtil', async function() {
    const matcherFactory = function(matchersUtil) {
        return {
          compare: function(actual, expected) {
            return Promise.resolve({
              pass: matchersUtil.equals(actual[0], expected)
            });
          }
        };
      },
      customEqualityFn = jasmine
        .createSpy('customEqualityFn')
        .and.callFake(function(a, b) {
          return a.toString() === b;
        });

    env.it('spec with expectation', function() {
      env.addCustomEqualityTester(customEqualityFn);
      env.addAsyncMatchers({
        toBeArrayWithFirstElement: matcherFactory
      });

      return env.expectAsync([1, 2]).toBeArrayWithFirstElement('1');
    });

    const specExpectations = function(result) {
      expect(customEqualityFn).toHaveBeenCalledWith(1, '1');
      expect(result.failedExpectations).toEqual([]);
    };

    env.addReporter({ specDone: specExpectations });
    await env.execute();
  })",snuts
/spec/core/asymmetric_equality/TruthySpec.js,NonFunctionalStatement,"{'startLine':21,'endLine':21}","it('is true for a function', function() {
    const truthy = new jasmineUnderTest.Truthy();

    expect(truthy.asymmetricMatch(function() {})).toBe(true);
  })",snuts
/spec/core/asymmetric_equality/StringMatchingSpec.js,AnonymousTest,"{'startLine':22,'endLine':28}","it(""jasmineToString's itself"", function() {
    const matching = new jasmineUnderTest.StringMatching(/^foo/);

    expect(matching.jasmineToString()).toEqual(
      '<jasmine.stringMatching(/^foo/)>'
    );
  })",snuts
/spec/core/asymmetric_equality/StringContainingSpec.js,AnonymousTest,"{'startLine':20,'endLine':26}","it(""jasmineToString's itself"", function() {
    const matching = new jasmineUnderTest.StringContaining('foo');

    expect(matching.jasmineToString()).toEqual(
      '<jasmine.stringContaining(""foo"")>'
    );
  })",snuts
/spec/core/asymmetric_equality/SetContainingSpec.js,AnonymousTest,"{'startLine':55,'endLine':66}","it('matches recursively', function() {
    const actualSet = new Set(['foo', new Set([1, 'bar', 2]), 'other']);

    const containingSet = new Set([
      new jasmineUnderTest.SetContaining(new Set(['bar'])),
      'foo'
    ]);
    const containing = new jasmineUnderTest.SetContaining(containingSet);
    const matchersUtil = new jasmineUnderTest.MatchersUtil();

    expect(containing.asymmetricMatch(actualSet, matchersUtil)).toBe(true);
  })",snuts
/spec/core/asymmetric_equality/ObjectContainingSpec.js,AnonymousTest,"{'startLine':55,'endLine':64}","it(""jasmineToString's itself"", function() {
    const sample = {},
      matcher = new jasmineUnderTest.ObjectContaining(sample),
      pp = jasmine.createSpy('pp').and.returnValue('sample');

    expect(matcher.jasmineToString(pp)).toEqual(
      '<jasmine.objectContaining(sample)>'
    );
    expect(pp).toHaveBeenCalledWith(sample);
  })",snuts
/spec/core/asymmetric_equality/ObjectContainingSpec.js,AnonymousTest,"{'startLine':66,'endLine':75}","it('matches recursively', function() {
    const containing = new jasmineUnderTest.ObjectContaining({
      one: new jasmineUnderTest.ObjectContaining({ two: {} })
    });
    const matchersUtil = new jasmineUnderTest.MatchersUtil();

    expect(containing.asymmetricMatch({ one: { two: {} } }, matchersUtil)).toBe(
      true
    );
  })",snuts
/spec/core/asymmetric_equality/ObjectContainingSpec.js,ConditionalTestLogic,"{'startLine':125,'endLine':132}","it('uses custom equality testers', function() {
    const tester = function(a, b) {
      // All ""foo*"" strings match each other.
      if (
        typeof a == 'string' &&
        typeof b == 'string' &&
        a.slice(0, 3) == 'foo' &&
        b.slice(0, 3) == 'foo'
      ) {
        return true;
      }
    };
    const containing = new jasmineUnderTest.ObjectContaining({ foo: 'fooVal' });
    const matchersUtil = new jasmineUnderTest.MatchersUtil({
      customTesters: [tester]
    });

    expect(containing.asymmetricMatch({ foo: 'fooBar' }, matchersUtil)).toBe(
      true
    );
  })",snuts
/spec/core/asymmetric_equality/MapContainingSpec.js,AnonymousTest,"{'startLine':95,'endLine':110}","it('matches recursively', function() {
    const actualMap = new Map([
      ['foo', new Map([['foo1', 1], ['foo2', 2]])],
      [new Map([[1, 'bar1'], [2, 'bar2']]), 'bar'],
      ['other', 'any']
    ]);

    const containingMap = new Map([
      ['foo', new jasmineUnderTest.MapContaining(new Map([['foo1', 1]]))],
      [new jasmineUnderTest.MapContaining(new Map([[2, 'bar2']])), 'bar']
    ]);
    const containing = new jasmineUnderTest.MapContaining(containingMap);
    const matchersUtil = new jasmineUnderTest.MatchersUtil();

    expect(containing.asymmetricMatch(actualMap, matchersUtil)).toBe(true);
  })",snuts
/spec/core/asymmetric_equality/ArrayWithExactContentsSpec.js,AnonymousTest,"{'startLine':34,'endLine':43}","it('jasmineToStrings itself', function() {
    const sample = [],
      matcher = new jasmineUnderTest.ArrayWithExactContents(sample),
      pp = jasmine.createSpy('pp').and.returnValue('sample');

    expect(matcher.jasmineToString(pp)).toEqual(
      '<jasmine.arrayWithExactContents(sample)>'
    );
    expect(pp).toHaveBeenCalledWith(sample);
  })",snuts
/spec/core/asymmetric_equality/ArrayWithExactContentsSpec.js,ConditionalTestLogic,"{'startLine':48,'endLine':55}","it('uses custom equality testers', function() {
    const tester = function(a, b) {
      // All ""foo*"" strings match each other.
      if (
        typeof a == 'string' &&
        typeof b == 'string' &&
        a.slice(0, 3) == 'foo' &&
        b.slice(0, 3) == 'foo'
      ) {
        return true;
      }
    };
    const matcher = new jasmineUnderTest.ArrayWithExactContents(['fooVal']);
    const matchersUtil = new jasmineUnderTest.MatchersUtil({
      customTesters: [tester]
    });

    expect(matcher.asymmetricMatch(['fooBar'], matchersUtil)).toBe(true);
  })",snuts
/spec/core/asymmetric_equality/ArrayContainingSpec.js,AnonymousTest,"{'startLine':44,'endLine':53}","it('jasmineToStrings itself', function() {
    const sample = [],
      matcher = new jasmineUnderTest.ArrayContaining(sample),
      pp = jasmine.createSpy('pp').and.returnValue('sample');

    expect(matcher.jasmineToString(pp)).toEqual(
      '<jasmine.arrayContaining(sample)>'
    );
    expect(pp).toHaveBeenCalledWith(sample);
  })",snuts
/spec/core/asymmetric_equality/ArrayContainingSpec.js,ConditionalTestLogic,"{'startLine':58,'endLine':65}","it('uses custom equality testers', function() {
    const tester = function(a, b) {
      // All ""foo*"" strings match each other.
      if (
        typeof a == 'string' &&
        typeof b == 'string' &&
        a.slice(0, 3) == 'foo' &&
        b.slice(0, 3) == 'foo'
      ) {
        return true;
      }
    };
    const containing = new jasmineUnderTest.ArrayContaining(['fooVal']);
    const matchersUtil = new jasmineUnderTest.MatchersUtil({
      customTesters: [tester]
    });

    expect(containing.asymmetricMatch(['fooBar'], matchersUtil)).toBe(true);
  })",snuts
/spec/core/asymmetric_equality/AnythingSpec.js,AnonymousTest,"{'startLine':63,'endLine':67}","it(""jasmineToString's itself"", function() {
    const anything = new jasmineUnderTest.Anything();

    expect(anything.jasmineToString()).toEqual('<jasmine.anything>');
  })",snuts
/spec/core/asymmetric_equality/AnySpec.js,AnonymousTest,"{'startLine':69,'endLine':74}","it(""jasmineToString's itself"", function() {
    const any = new jasmineUnderTest.Any(Number);

    expect(any.jasmineToString()).toEqual('<jasmine.any(Number)>');
    expect(any.jasmineToString()).toEqual('<jasmine.any(Number)>');
  })",snuts
/spec/core/asymmetric_equality/AnySpec.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}","it('matches a function', function() {
    const any = new jasmineUnderTest.Any(Function);

    expect(any.asymmetricMatch(function() {})).toBe(true);
  })",snuts
/spec/core/asymmetric_equality/AnySpec.js,NonFunctionalStatement,"{'startLine':57,'endLine':57}","it('matches another constructed object', function() {
    const Thing = function() {},
      any = new jasmineUnderTest.Any(Thing);

    expect(any.asymmetricMatch(new Thing())).toBe(true);
  })",snuts
/spec/core/matchers/toThrowErrorSpec.js,IdenticalTestDescription,"{'startLine':305,'endLine':321}","it('fails if thrown is a type of Error and the expected is a different Error', function() {
      const matchersUtil = {
          equals: jasmine.createSpy('delegated-equal').and.returnValue(false),
          pp: jasmineUnderTest.makePrettyPrinter()
        },
        matcher = jasmineUnderTest.matchers.toThrowError(matchersUtil),
        fn = function() {
          throw new TypeError('foo');
        };

      const result = matcher.compare(fn, TypeError, /bar/);

      expect(result.pass).toBe(false);
      expect(result.message()).toEqual(
        ""Expected function to throw TypeError with a message matching /bar/, but it threw TypeError with message 'foo'.""
      );
    })",snuts
/spec/core/matchers/toThrowErrorSpec.js,ConditionalTestLogic,"{'startLine':84,'endLine':86}","it('passes if thrown is an instanceof Error regardless of global that contains its constructor', function() {
      if (isNotRunningInBrowser()) {
        pending('This test only runs in browsers.');
      }

      const matcher = jasmineUnderTest.matchers.toThrowError();
      iframe = document.body.appendChild(document.createElement('iframe'));
      iframe.src = 'about:blank';
      const iframeDocument = iframe.contentWindow.document;

      iframeDocument.body.appendChild(
        iframeDocument.createElement('script')
      ).textContent = ""function method() { throw new Error('foo'); }"";

      const result = matcher.compare(iframe.contentWindow.method);
      expect(result.pass).toBe(true);
      expect(result.message).toEqual(
        'Expected function not to throw an Error, but it threw Error.'
      );
    })",snuts
/spec/core/matchers/toHaveSpyInteractionsSpec.js,NonFunctionalStatement,"{'startLine':62,'endLine':62}","it('fails when only non-observed spy object interactions are interacted', function() {
    let matcher = jasmineUnderTest.matchers.toHaveSpyInteractions();
    let spyObj = jasmineUnderTest
      .getEnv()
      .createSpyObj('NewClass', ['spyA', 'spyB']);
    spyObj.otherMethod = function() {};

    spyObj.otherMethod();

    let result = matcher.compare(spyObj);
    expect(result.pass).toBe(false);
    expect(result.message).toContain(
      'Expected spy object spies to have been called'
    );
  })",snuts
/spec/core/matchers/toHaveSpyInteractionsSpec.js,NonFunctionalStatement,"{'startLine':106,'endLine':106}","it('throws an error if the spy object has no spies', function() {
    let matcher = jasmineUnderTest.matchers.toHaveSpyInteractions();
    const spyObj = jasmineUnderTest
      .getEnv()
      .createSpyObj('NewClass', ['notSpy']);
    // Removing spy since spy objects cannot be created without spies.
    spyObj.notSpy = function() {};

    expect(function() {
      matcher.compare(spyObj);
    }).toThrowError(
      Error,
      /Expected a spy object with spies, but object has no spies/
    );
  })",snuts
/spec/core/matchers/toHaveNoOtherSpyInteractionsSpec.js,NonFunctionalStatement,"{'startLine':77,'endLine':77}","it('passes when only non-observed spy object interactions are interacted', function() {
    let matcher = jasmineUnderTest.matchers.toHaveNoOtherSpyInteractions();
    let spyObj = jasmineUnderTest
      .getEnv()
      .createSpyObj('NewClass', ['spyA', 'spyB']);
    spyObj.otherMethod = function() {};

    spyObj.otherMethod();

    let result = matcher.compare(spyObj);
    expect(result.pass).toBeTrue();
    expect(result.message).toEqual(
      ""Expected a spy object to have other spy interactions but it didn't.""
    );
  })",snuts
/spec/core/matchers/toHaveNoOtherSpyInteractionsSpec.js,NonFunctionalStatement,"{'startLine':121,'endLine':121}","it('throws an error if the spy object has no spies', function() {
    let matcher = jasmineUnderTest.matchers.toHaveNoOtherSpyInteractions();
    const spyObj = jasmineUnderTest
      .getEnv()
      .createSpyObj('mySpyObj', ['notSpy']);
    // Removing spy since spy objects cannot be created without spies.
    spyObj.notSpy = function() {};

    expect(function() {
      matcher.compare(spyObj);
    }).toThrowError(
      Error,
      /Expected an object with spies, but object has no spies/
    );
  })",snuts
/spec/core/matchers/toHaveBeenCalledWithSpec.js,NonFunctionalStatement,"{'startLine':90,'endLine':90}","it('throws an exception when the actual is not a spy', function() {
    const matcher = jasmineUnderTest.matchers.toHaveBeenCalledWith({
        pp: jasmineUnderTest.makePrettyPrinter()
      }),
      fn = function() {};

    expect(function() {
      matcher.compare(fn);
    }).toThrowError(/Expected a spy, but got Function./);
  })",snuts
/spec/core/matchers/toHaveBeenCalledTimesSpec.js,NonFunctionalStatement,"{'startLine':52,'endLine':52}","it('throws an exception when the actual is not a spy', function() {
    const matcher = jasmineUnderTest.matchers.toHaveBeenCalledTimes({
        pp: jasmineUnderTest.makePrettyPrinter()
      }),
      fn = function() {};

    expect(function() {
      matcher.compare(fn);
    }).toThrowError(/Expected a spy, but got Function./);
  })",snuts
/spec/core/matchers/toHaveBeenCalledSpec.js,NonFunctionalStatement,"{'startLine':27,'endLine':27}","it('throws an exception when the actual is not a spy', function() {
    const matcher = jasmineUnderTest.matchers.toHaveBeenCalled({
        pp: jasmineUnderTest.makePrettyPrinter()
      }),
      fn = function() {};

    expect(function() {
      matcher.compare(fn);
    }).toThrowError(Error, /Expected a spy, but got Function./);
  })",snuts
/spec/core/matchers/toHaveBeenCalledOnceWithSpec.js,NonFunctionalStatement,"{'startLine':102,'endLine':102}","it('throws an exception when the actual is not a spy', function() {
    const pp = jasmineUnderTest.makePrettyPrinter(),
      util = new jasmineUnderTest.MatchersUtil({ pp: pp }),
      matcher = jasmineUnderTest.matchers.toHaveBeenCalledOnceWith(util),
      fn = function() {};

    expect(function() {
      matcher.compare(fn);
    }).toThrowError(/Expected a spy, but got Function./);
  })",snuts
/spec/core/matchers/toHaveBeenCalledBeforeSpec.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}","it('throws an exception when the actual is not a spy', function() {
    const matcher = jasmineUnderTest.matchers.toHaveBeenCalledBefore({
        pp: jasmineUnderTest.makePrettyPrinter()
      }),
      fn = function() {},
      spy = new jasmineUnderTest.Env().createSpy('a spy');

    expect(function() {
      matcher.compare(fn, spy);
    }).toThrowError(Error, /Expected a spy, but got Function./);
  })",snuts
/spec/core/matchers/toHaveBeenCalledBeforeSpec.js,NonFunctionalStatement,"{'startLine':19,'endLine':19}","it('throws an exception when the expected is not a spy', function() {
    const matcher = jasmineUnderTest.matchers.toHaveBeenCalledBefore({
        pp: jasmineUnderTest.makePrettyPrinter()
      }),
      spy = new jasmineUnderTest.Env().createSpy('a spy'),
      fn = function() {};

    expect(function() {
      matcher.compare(spy, fn);
    }).toThrowError(Error, /Expected a spy, but got Function./);
  })",snuts
/spec/core/matchers/toEqualSpec.js,AnonymousTest,"{'startLine':134,'endLine':140}","it('pretty-prints properties', function() {
    const actual = { x: { y: 'foo bar' } },
      expected = { x: {} },
      message = 'Expected $.x not to have properties\n' + ""    y: 'foo bar'"";

    expect(compareEquals(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,SensitiveEquality,"{'startLine':33,'endLine':33}","it('works with custom equality testers', function() {
    const tester = function(a, b) {
        return a.toString() === b.toString();
      },
      matchersUtil = new jasmineUnderTest.MatchersUtil({
        customTesters: [tester]
      }),
      matcher = jasmineUnderTest.matchers.toEqual(matchersUtil);

    const result = matcher.compare(1, '1');

    expect(result.pass).toBe(true);
  })",snuts
/spec/core/matchers/toEqualSpec.js,ConditionalTestLogic,"{'startLine':144,'endLine':146}","it('uses custom object formatters to pretty-print simple properties', function() {
    function formatter(x) {
      if (typeof x === 'number') {
        return '|' + x + '|';
      }
    }

    const actual = { x: { y: 1, z: 2, f: 4 } },
      expected = { x: { y: 1, z: 2, g: 3 } },
      pp = jasmineUnderTest.makePrettyPrinter([formatter]),
      matchersUtil = new jasmineUnderTest.MatchersUtil({ pp: pp }),
      matcher = jasmineUnderTest.matchers.toEqual(matchersUtil),
      message =
        'Expected $.x to have properties\n' +
        '    g: |3|\n' +
        'Expected $.x not to have properties\n' +
        '    f: |4|';

    expect(matcher.compare(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,ConditionalTestLogic,"{'startLine':165,'endLine':167}","it('uses custom object formatters to show simple values in diffs', function() {
    function formatter(x) {
      if (typeof x === 'number') {
        return '|' + x + '|';
      }
    }

    const actual = [{ foo: 4 }],
      expected = [{ foo: 5 }],
      prettyPrinter = jasmineUnderTest.makePrettyPrinter([formatter]),
      matchersUtil = new jasmineUnderTest.MatchersUtil({ pp: prettyPrinter }),
      matcher = jasmineUnderTest.matchers.toEqual(matchersUtil),
      message = 'Expected $[0].foo = |4| to equal |5|.';

    expect(matcher.compare(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,ConditionalTestLogic,"{'startLine':182,'endLine':184}","it('uses custom object formatters to show more complex objects diffs', function() {
    function formatter(x) {
      if (x.hasOwnProperty('a')) {
        return '[thing with a=' + x.a + ', b=' + x.b + ']';
      }
    }

    const actual = [
        {
          foo: { a: 1, b: 2 },
          bar: 'should not be pretty printed'
        }
      ],
      expected = [
        {
          foo: { a: 5, b: 2 },
          bar: ""shouldn't be pretty printed""
        }
      ],
      prettyPrinter = jasmineUnderTest.makePrettyPrinter([formatter]),
      matchersUtil = new jasmineUnderTest.MatchersUtil({ pp: prettyPrinter }),
      matcher = jasmineUnderTest.matchers.toEqual(matchersUtil),
      message =
        'Expected $[0].foo = [thing with a=1, b=2] to equal [thing with a=5, b=2].\n' +
        ""Expected $[0].bar = 'should not be pretty printed' to equal 'shouldn't be pretty printed'."";

    expect(matcher.compare(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,ConditionalTestLogic,"{'startLine':385,'endLine':387}","it('uses custom object formatters for the value but not the type when reporting objects with different constructors', function() {
    function Foo() {}
    function Bar() {}
    function formatter(x) {
      if (x instanceof Foo || x instanceof Bar) {
        return '|' + x + '|';
      }
    }

    const actual = { x: new Foo() },
      expected = { x: new Bar() },
      message = 'Expected $.x to be a kind of Bar, but was |[object Object]|.',
      pp = jasmineUnderTest.makePrettyPrinter([formatter]),
      matchersUtil = new jasmineUnderTest.MatchersUtil({ pp: pp }),
      matcher = jasmineUnderTest.matchers.toEqual(matchersUtil);

    expect(matcher.compare(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,ConditionalTestLogic,"{'startLine':935,'endLine':937}","it('uses custom object formatters when the actual array is longer', function() {
      function formatter(x) {
        if (typeof x === 'number') {
          return '|' + x + '|';
        }
      }

      const actual = [1, 1, 2, 3, 5],
        expected = [1, 1, 2, 3],
        pp = jasmineUnderTest.makePrettyPrinter([formatter]),
        matchersUtil = new jasmineUnderTest.MatchersUtil({ pp: pp }),
        matcher = jasmineUnderTest.matchers.toEqual(matchersUtil),
        message =
          'Expected $.length = |5| to equal |4|.\n' +
          'Unexpected $[4] = |5| in array.';

      expect(matcher.compare(actual, expected).message).toEqual(message);
    })",snuts
/spec/core/matchers/toEqualSpec.js,NonFunctionalStatement,"{'startLine':371,'endLine':371}","it('reports mismatches between objects with different constructors', function() {
    function Foo() {}
    function Bar() {}

    const actual = { x: new Foo() },
      expected = { x: new Bar() },
      message = 'Expected $.x to be a kind of Bar, but was Foo({  }).';

    expect(compareEquals(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,NonFunctionalStatement,"{'startLine':372,'endLine':372}","it('reports mismatches between objects with different constructors', function() {
    function Foo() {}
    function Bar() {}

    const actual = { x: new Foo() },
      expected = { x: new Bar() },
      message = 'Expected $.x to be a kind of Bar, but was Foo({  }).';

    expect(compareEquals(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,NonFunctionalStatement,"{'startLine':382,'endLine':382}","it('uses custom object formatters for the value but not the type when reporting objects with different constructors', function() {
    function Foo() {}
    function Bar() {}
    function formatter(x) {
      if (x instanceof Foo || x instanceof Bar) {
        return '|' + x + '|';
      }
    }

    const actual = { x: new Foo() },
      expected = { x: new Bar() },
      message = 'Expected $.x to be a kind of Bar, but was |[object Object]|.',
      pp = jasmineUnderTest.makePrettyPrinter([formatter]),
      matchersUtil = new jasmineUnderTest.MatchersUtil({ pp: pp }),
      matcher = jasmineUnderTest.matchers.toEqual(matchersUtil);

    expect(matcher.compare(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,NonFunctionalStatement,"{'startLine':383,'endLine':383}","it('uses custom object formatters for the value but not the type when reporting objects with different constructors', function() {
    function Foo() {}
    function Bar() {}
    function formatter(x) {
      if (x instanceof Foo || x instanceof Bar) {
        return '|' + x + '|';
      }
    }

    const actual = { x: new Foo() },
      expected = { x: new Bar() },
      message = 'Expected $.x to be a kind of Bar, but was |[object Object]|.',
      pp = jasmineUnderTest.makePrettyPrinter([formatter]),
      matchersUtil = new jasmineUnderTest.MatchersUtil({ pp: pp }),
      matcher = jasmineUnderTest.matchers.toEqual(matchersUtil);

    expect(matcher.compare(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,NonFunctionalStatement,"{'startLine':401,'endLine':401}","it('reports type mismatches at the root level', function() {
    function Foo() {}
    function Bar() {}

    const actual = new Foo(),
      expected = new Bar(),
      message = 'Expected object to be a kind of Bar, but was Foo({  }).';

    expect(compareEquals(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,NonFunctionalStatement,"{'startLine':402,'endLine':402}","it('reports type mismatches at the root level', function() {
    function Foo() {}
    function Bar() {}

    const actual = new Foo(),
      expected = new Bar(),
      message = 'Expected object to be a kind of Bar, but was Foo({  }).';

    expect(compareEquals(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,NonFunctionalStatement,"{'startLine':461,'endLine':461}","it('reports mismatches between Functions', function() {
    const actual = { x: function() {} };
    const expected = { x: function() {} };
    const message = ""Expected $.x = Function 'x' to equal Function 'x'."";

    expect(compareEquals(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,NonFunctionalStatement,"{'startLine':462,'endLine':462}","it('reports mismatches between Functions', function() {
    const actual = { x: function() {} };
    const expected = { x: function() {} };
    const message = ""Expected $.x = Function 'x' to equal Function 'x'."";

    expect(compareEquals(actual, expected).message).toEqual(message);
  })",snuts
/spec/core/matchers/toEqualSpec.js,NonFunctionalStatement,"{'startLine':1173,'endLine':1173}","it('Fails if Symbol compared to Function', function() {
      const sym = Symbol('foo');
      const f = function func() {};

      expect(sym).not.toEqual(f);
    })",snuts
/spec/core/matchers/toEqualSpec.js,SubOptimalAssert,"{'startLine':1155,'endLine':1155}","it('Fails if Symbol compared to Undefined', function() {
      const sym = Symbol('foo');

      expect(sym).not.toEqual(undefined);
    })",snuts
/spec/core/matchers/toEqualSpec.js,SubOptimalAssert,"{'startLine':1161,'endLine':1161}","it('Fails if Symbol compared to null', function() {
      const sym = Symbol('foo');

      expect(sym).not.toEqual(null);
    })",snuts
/spec/core/matchers/toContainSpec.js,SensitiveEquality,"{'startLine':15,'endLine':15}","it('works with custom equality testers', function() {
    const tester = function(a, b) {
        return a.toString() === b.toString();
      },
      matchersUtil = new jasmineUnderTest.MatchersUtil({
        customTesters: [tester]
      }),
      matcher = jasmineUnderTest.matchers.toContain(matchersUtil);

    const result = matcher.compare(['1', '2'], 2);
    expect(result.pass).toBe(true);
  })",snuts
/spec/core/matchers/toBeTruthySpec.js,NonFunctionalStatement,"{'startLine':21,'endLine':21}","it(""passes for 'truthy' values"", function() {
    const matcher = jasmineUnderTest.matchers.toBeTruthy();
    let result;

    result = matcher.compare(true);
    expect(result.pass).toBe(true);

    result = matcher.compare(1);
    expect(result.pass).toBe(true);

    result = matcher.compare('foo');
    expect(result.pass).toBe(true);

    result = matcher.compare({});
    expect(result.pass).toBe(true);

    result = matcher.compare([]);
    expect(result.pass).toBe(true);

    result = matcher.compare(function() {});
    expect(result.pass).toBe(true);
  })",snuts
/spec/core/matchers/toBeTruthySpec.js,VerboseStatement,"{'startLine':2,'endLine':23}","it(""passes for 'truthy' values"", function() {
    const matcher = jasmineUnderTest.matchers.toBeTruthy();
    let result;

    result = matcher.compare(true);
    expect(result.pass).toBe(true);

    result = matcher.compare(1);
    expect(result.pass).toBe(true);

    result = matcher.compare('foo');
    expect(result.pass).toBe(true);

    result = matcher.compare({});
    expect(result.pass).toBe(true);

    result = matcher.compare([]);
    expect(result.pass).toBe(true);

    result = matcher.compare(function() {});
    expect(result.pass).toBe(true);
  })",snuts
/spec/core/matchers/toBeTruthySpec.js,VerboseStatement,"{'startLine':25,'endLine':46}","it(""fails for 'falsy' values"", function() {
    const matcher = jasmineUnderTest.matchers.toBeTruthy();
    let result;

    result = matcher.compare(false);
    expect(result.pass).toBe(false);

    result = matcher.compare(0);
    expect(result.pass).toBe(false);

    result = matcher.compare('');
    expect(result.pass).toBe(false);

    result = matcher.compare(null);
    expect(result.pass).toBe(false);

    result = matcher.compare(undefined);
    expect(result.pass).toBe(false);

    result = matcher.compare(void 0);
    expect(result.pass).toBe(false);
  })",snuts
/spec/core/matchers/toBeInstanceOfSpec.js,NonFunctionalStatement,"{'startLine':95,'endLine':95}","it('passes for a function', function() {
      const fn = function() {};

      const matcher = jasmineUnderTest.matchers.toBeInstanceOf();
      const result = matcher.compare(fn, Function);
      expect(result).toEqual({
        pass: true,
        message:
          'Expected instance of Function not to be an instance of Function'
      });
    })",snuts
/spec/core/matchers/toBeInstanceOfSpec.js,NonFunctionalStatement,"{'startLine':122,'endLine':122}","describe('when expecting Object', function() {
    function Animal() {}

    it('passes for any object', function() {
      const matcher = jasmineUnderTest.matchers.toBeInstanceOf();
      const result = matcher.compare({ foo: 'bar' }, Object);
      expect(result).toEqual({
        pass: true,
        message: 'Expected instance of Object not to be an instance of Object'
      });
    });

    it('passes for an Error object', function() {
      const matcher = jasmineUnderTest.matchers.toBeInstanceOf();
      const result = matcher.compare(new Error('example'), Object);
      expect(result).toEqual({
        pass: true,
        message: 'Expected instance of Error not to be an instance of Object'
      });
    });

    it('passes for a user-defined class', function() {
      const matcher = jasmineUnderTest.matchers.toBeInstanceOf();
      const result = matcher.compare(new Animal(), Object);
      expect(result).toEqual({
        pass: true,
        message: 'Expected instance of Animal not to be an instance of Object'
      });
    });

    it('fails for a non-object', function() {
      const matcher = jasmineUnderTest.matchers.toBeInstanceOf();
      const result = matcher.compare('foo', Object);
      expect(result).toEqual({
        pass: false,
        message: 'Expected instance of String to be an instance of Object'
      });
    });

    it('passes for objects with no constructor', function() {
      const object = Object.create(null);

      const matcher = jasmineUnderTest.matchers.toBeInstanceOf({
        pp: jasmineUnderTest.makePrettyPrinter()
      });
      const result = matcher.compare(object, Object);
      expect(result).toEqual({
        pass: true,
        message:
          'Expected instance of null({  }) not to be an instance of Object'
      });
    });
  })",snuts
/spec/core/matchers/toBeInstanceOfSpec.js,NonFunctionalStatement,"{'startLine':177,'endLine':177}","describe('when expecting a user-defined class', function() {
    // Base class
    function Animal() {}

    // Subclasses, defined using syntax that is as old as possible
    function Dog() {
      Animal.call(this);
    }
    Dog.prototype = new Animal();
    Dog.prototype.constructor = Dog;

    function Cat() {
      Animal.call(this);
    }
    Cat.prototype = new Animal();
    Cat.prototype.constructor = Cat;

    it('passes for instances of that class', function() {
      const matcher = jasmineUnderTest.matchers.toBeInstanceOf();
      const result = matcher.compare(new Animal(), Animal);
      expect(result).toEqual({
        pass: true,
        message: 'Expected instance of Animal not to be an instance of Animal'
      });
    });

    it('passes for instances of a subclass', function() {
      const matcher = jasmineUnderTest.matchers.toBeInstanceOf();
      const result = matcher.compare(new Cat(), Animal);
      expect(result).toEqual({
        pass: true,
        message: 'Expected instance of Cat not to be an instance of Animal'
      });
    });

    it('does not pass for sibling classes', function() {
      const matcher = jasmineUnderTest.matchers.toBeInstanceOf();
      const result = matcher.compare(new Dog(), Cat);
      expect(result).toEqual({
        pass: false,
        message: 'Expected instance of Dog to be an instance of Cat'
      });
    });
  })",snuts
/spec/core/matchers/toBeFalsySpec.js,NonFunctionalStatement,"{'startLine':44,'endLine':44}","it(""fails for 'truthy' values"", function() {
    const matcher = jasmineUnderTest.matchers.toBeFalsy();
    let result;

    result = matcher.compare(true);
    expect(result.pass).toBe(false);

    result = matcher.compare(1);
    expect(result.pass).toBe(false);

    result = matcher.compare('foo');
    expect(result.pass).toBe(false);

    result = matcher.compare({});
    expect(result.pass).toBe(false);

    result = matcher.compare([]);
    expect(result.pass).toBe(false);

    result = matcher.compare(function() {});
    expect(result.pass).toBe(false);
  })",snuts
/spec/core/matchers/toBeFalsySpec.js,VerboseStatement,"{'startLine':2,'endLine':23}","it(""passes for 'falsy' values"", function() {
    const matcher = jasmineUnderTest.matchers.toBeFalsy();
    let result;

    result = matcher.compare(false);
    expect(result.pass).toBe(true);

    result = matcher.compare(0);
    expect(result.pass).toBe(true);

    result = matcher.compare('');
    expect(result.pass).toBe(true);

    result = matcher.compare(null);
    expect(result.pass).toBe(true);

    result = matcher.compare(undefined);
    expect(result.pass).toBe(true);

    result = matcher.compare(void 0);
    expect(result.pass).toBe(true);
  })",snuts
/spec/core/matchers/toBeFalsySpec.js,VerboseStatement,"{'startLine':25,'endLine':46}","it(""fails for 'truthy' values"", function() {
    const matcher = jasmineUnderTest.matchers.toBeFalsy();
    let result;

    result = matcher.compare(true);
    expect(result.pass).toBe(false);

    result = matcher.compare(1);
    expect(result.pass).toBe(false);

    result = matcher.compare('foo');
    expect(result.pass).toBe(false);

    result = matcher.compare({});
    expect(result.pass).toBe(false);

    result = matcher.compare([]);
    expect(result.pass).toBe(false);

    result = matcher.compare(function() {});
    expect(result.pass).toBe(false);
  })",snuts
/spec/core/matchers/toBeCloseToSpec.js,VerboseStatement,"{'startLine':27,'endLine':48}","it('accepts an optional precision argument', function() {
    const matcher = jasmineUnderTest.matchers.toBeCloseTo();
    let result;

    result = matcher.compare(0, 0.1, 0);
    expect(result.pass).toBe(true);

    result = matcher.compare(0, 0.5, 0);
    expect(result.pass).toBe(true);

    result = matcher.compare(0, 0.0001, 3);
    expect(result.pass).toBe(true);

    result = matcher.compare(0, 0.0005, 3);
    expect(result.pass).toBe(true);

    result = matcher.compare(0, 0.00001, 4);
    expect(result.pass).toBe(true);

    result = matcher.compare(0, 0.00005, 4);
    expect(result.pass).toBe(true);
  })",snuts
/spec/core/matchers/toBeCloseToSpec.js,VerboseStatement,"{'startLine':72,'endLine':98}","it('rounds expected values', function() {
    const matcher = jasmineUnderTest.matchers.toBeCloseTo();
    let result;

    result = matcher.compare(1.23, 1.229);
    expect(result.pass).toBe(true);

    result = matcher.compare(1.23, 1.226);
    expect(result.pass).toBe(true);

    result = matcher.compare(1.23, 1.225);
    expect(result.pass).toBe(true);

    result = matcher.compare(1.23, 1.235);
    expect(result.pass).toBe(true);

    // 1.2249999 will be rounded to 1.225
    result = matcher.compare(1.23, 1.2249999);
    expect(result.pass).toBe(true);

    // 1.2249999 will be rounded to 1.224
    result = matcher.compare(1.23, 1.2244999);
    expect(result.pass).toBe(false);

    result = matcher.compare(1.23, 1.234);
    expect(result.pass).toBe(true);
  })",snuts
/spec/core/matchers/nothingSpec.js,AnonymousTest,"{'startLine':2,'endLine':7}","it('should pass', function() {
    const matcher = jasmineUnderTest.matchers.nothing(),
      result = matcher.compare();

    expect(result.pass).toBe(true);
  })",snuts
/spec/core/matchers/matchersUtilSpec.js,IdenticalTestDescription,"{'startLine':455,'endLine':461}","it('passes for two empty Objects', function() {
        const matchersUtil = new jasmineUnderTest.MatchersUtil({
          customTesters: [tester],
          pp: function() {}
        });
        expect(matchersUtil.equals({}, {})).toBe(true);
      })",snuts
/spec/core/matchers/matchersUtilSpec.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}","it('exposes the injected pretty-printer as .pp', function() {
    const pp = function() {},
      matchersUtil = new jasmineUnderTest.MatchersUtil({ pp: pp });

    expect(matchersUtil.pp).toBe(pp);
  })",snuts
/spec/core/matchers/matchersUtilSpec.js,NonFunctionalStatement,"{'startLine':166,'endLine':166}","it('fails for objects with different constructors', function() {
      const matchersUtil = new jasmineUnderTest.MatchersUtil();
      function One() {}
      function Two() {}

      expect(matchersUtil.equals(new One(), new Two())).toBe(false);
    })",snuts
/spec/core/matchers/matchersUtilSpec.js,NonFunctionalStatement,"{'startLine':167,'endLine':167}","it('fails for objects with different constructors', function() {
      const matchersUtil = new jasmineUnderTest.MatchersUtil();
      function One() {}
      function Two() {}

      expect(matchersUtil.equals(new One(), new Two())).toBe(false);
    })",snuts
/spec/core/matchers/matchersUtilSpec.js,NonFunctionalStatement,"{'startLine':253,'endLine':253}","it('passes for equivalent Promises (GitHub issue #1314)', function() {
      const p1 = new Promise(function() {}),
        p2 = new Promise(function() {}),
        matchersUtil = new jasmineUnderTest.MatchersUtil();

      expect(matchersUtil.equals(p1, p1)).toBe(true);
      expect(matchersUtil.equals(p1, p2)).toBe(false);
    })",snuts
/spec/core/matchers/matchersUtilSpec.js,NonFunctionalStatement,"{'startLine':254,'endLine':254}","it('passes for equivalent Promises (GitHub issue #1314)', function() {
      const p1 = new Promise(function() {}),
        p2 = new Promise(function() {}),
        matchersUtil = new jasmineUnderTest.MatchersUtil();

      expect(matchersUtil.equals(p1, p1)).toBe(true);
      expect(matchersUtil.equals(p1, p2)).toBe(false);
    })",snuts
/spec/core/matchers/matchersUtilSpec.js,NonFunctionalStatement,"{'startLine':439,'endLine':439}","it('passes when a custom equality matcher returns true', function() {
      const tester = function() {
          return true;
        },
        matchersUtil = new jasmineUnderTest.MatchersUtil({
          customTesters: [tester],
          pp: function() {}
        });

      expect(matchersUtil.equals(1, 2)).toBe(true);
    })",snuts
/spec/core/matchers/matchersUtilSpec.js,NonFunctionalStatement,"{'startLine':458,'endLine':458}","it('passes for two empty Objects', function() {
        const matchersUtil = new jasmineUnderTest.MatchersUtil({
          customTesters: [tester],
          pp: function() {}
        });
        expect(matchersUtil.equals({}, {})).toBe(true);
      })",snuts
/spec/core/matchers/matchersUtilSpec.js,NonFunctionalStatement,"{'startLine':470,'endLine':470}","it('fails for equivalents when a custom equality matcher returns false', function() {
      const tester = function() {
          return false;
        },
        matchersUtil = new jasmineUnderTest.MatchersUtil({
          customTesters: [tester],
          pp: function() {}
        });

      expect(matchersUtil.equals(1, 1)).toBe(false);
    })",snuts
/spec/core/matchers/matchersUtilSpec.js,NonFunctionalStatement,"{'startLine':487,'endLine':487}","it('passes for an asymmetric equality tester that returns true when a custom equality tester return false', function() {
      const asymmetricTester = {
          asymmetricMatch: function() {
            return true;
          }
        },
        symmetricTester = function() {
          return false;
        },
        matchersUtil = new jasmineUnderTest.MatchersUtil({
          customTesters: [symmetricTester()],
          pp: function() {}
        });

      expect(matchersUtil.equals(asymmetricTester, true)).toBe(true);
      expect(matchersUtil.equals(true, asymmetricTester)).toBe(true);
    })",snuts
/spec/core/matchers/matchersUtilSpec.js,NonFunctionalStatement,"{'startLine':1024,'endLine':1024}","it('uses custom equality testers if actual is an Array', function() {
      const customTester = function() {
          return true;
        },
        matchersUtil = new jasmineUnderTest.MatchersUtil({
          customTesters: [customTester],
          pp: function() {}
        });

      expect(matchersUtil.contains([1, 2], 3)).toBe(true);
    })",snuts
/spec/core/matchers/matchersUtilSpec.js,VerboseStatement,"{'startLine':293,'endLine':313}","it('fails for DOM nodes with different attributes or child nodes', function() {
        const matchersUtil = new jasmineUnderTest.MatchersUtil();
        const a = document.createElement('div');
        a.setAttribute('test-attr', 'attr-value');
        a.appendChild(document.createTextNode('test'));

        const b = document.createElement('div');
        b.setAttribute('test-attr', 'attr-value2');
        b.appendChild(document.createTextNode('test'));

        expect(matchersUtil.equals(a, b)).toBe(false);

        b.setAttribute('test-attr', 'attr-value');
        expect(matchersUtil.equals(a, b)).toBe(true);

        b.appendChild(document.createTextNode('2'));
        expect(matchersUtil.equals(a, b)).toBe(false);

        a.appendChild(document.createTextNode('2'));
        expect(matchersUtil.equals(a, b)).toBe(true);
      })",snuts
/spec/core/matchers/matchersUtilSpec.js,VerboseStatement,"{'startLine':553,'endLine':576}","it('passes when comparing identical sets with different insertion order and complex elements 1', function() {
      const matchersUtil = new jasmineUnderTest.MatchersUtil();
      const setA1 = new Set();
      setA1.add(['a', 3]);
      setA1.add([6, 1]);
      const setA2 = new Set();
      setA1.add(['y', 3]);
      setA1.add([6, 1]);
      const setA = new Set();
      setA.add(setA1);
      setA.add(setA2);

      const setB1 = new Set();
      setB1.add([6, 1]);
      setB1.add(['a', 3]);
      const setB2 = new Set();
      setB1.add([6, 1]);
      setB1.add(['y', 3]);
      const setB = new Set();
      setB.add(setB1);
      setB.add(setB2);

      expect(matchersUtil.equals(setA, setB)).toBe(true);
    })",snuts
/spec/core/matchers/MismatchTreeSpec.js,NonFunctionalStatement,"{'startLine':141,'endLine':141}","describe('MismatchTree', function() {
  describe('#add', function() {
    describe('When the path is empty', function() {
      it('flags the root node as mismatched', function() {
        const tree = new jasmineUnderTest.MismatchTree();
        tree.add(new jasmineUnderTest.ObjectPath([]));
        expect(tree.isMismatch).toBe(true);
      });
    });

    describe('When the path is not empty', function() {
      it('flags the node as mismatched', function() {
        const tree = new jasmineUnderTest.MismatchTree();

        tree.add(new jasmineUnderTest.ObjectPath(['a', 'b']));

        expect(tree.child('a').child('b').isMismatch).toBe(true);
      });

      it('does not flag ancestors as mismatched', function() {
        const tree = new jasmineUnderTest.MismatchTree();

        tree.add(new jasmineUnderTest.ObjectPath(['a', 'b']));

        expect(tree.isMismatch).toBe(false);
        expect(tree.child('a').isMismatch).toBe(false);
      });
    });

    it('stores the formatter on only the target node', function() {
      const tree = new jasmineUnderTest.MismatchTree();

      tree.add(new jasmineUnderTest.ObjectPath(['a', 'b']), formatter);

      expect(tree.formatter).toBeFalsy();
      expect(tree.child('a').formatter).toBeFalsy();
      expect(tree.child('a').child('b').formatter).toBe(formatter);
    });

    it('stores the path to the node', function() {
      const tree = new jasmineUnderTest.MismatchTree();

      tree.add(new jasmineUnderTest.ObjectPath(['a', 'b']), formatter);

      expect(tree.child('a').child('b').path.components).toEqual(['a', 'b']);
    });
  });

  describe('#traverse', function() {
    it('calls the callback for all nodes that are or contain mismatches', function() {
      const tree = new jasmineUnderTest.MismatchTree();
      tree.add(new jasmineUnderTest.ObjectPath(['a', 'b']), formatter);
      tree.add(new jasmineUnderTest.ObjectPath(['c']));
      const visit = jasmine.createSpy('visit').and.returnValue(true);

      tree.traverse(visit);

      expect(visit).toHaveBeenCalledWith(
        new jasmineUnderTest.ObjectPath([]),
        false,
        undefined
      );
      expect(visit).toHaveBeenCalledWith(
        new jasmineUnderTest.ObjectPath(['a']),
        false,
        undefined
      );
      expect(visit).toHaveBeenCalledWith(
        new jasmineUnderTest.ObjectPath(['a', 'b']),
        true,
        formatter
      );
      expect(visit).toHaveBeenCalledWith(
        new jasmineUnderTest.ObjectPath(['c']),
        true,
        undefined
      );
    });

    it('does not call the callback if there are no mismatches', function() {
      const tree = new jasmineUnderTest.MismatchTree();
      const visit = jasmine.createSpy('visit');

      tree.traverse(visit);

      expect(visit).not.toHaveBeenCalled();
    });

    it('visits parents before children', function() {
      const tree = new jasmineUnderTest.MismatchTree();
      tree.add(new jasmineUnderTest.ObjectPath(['a', 'b']));
      const visited = [];

      tree.traverse(function(path) {
        visited.push(path);
        return true;
      });

      expect(visited).toEqual([
        new jasmineUnderTest.ObjectPath([]),
        new jasmineUnderTest.ObjectPath(['a']),
        new jasmineUnderTest.ObjectPath(['a', 'b'])
      ]);
    });

    it('visits children in the order they were recorded', function() {
      const tree = new jasmineUnderTest.MismatchTree();
      tree.add(new jasmineUnderTest.ObjectPath(['length']));
      tree.add(new jasmineUnderTest.ObjectPath([1]));
      const visited = [];

      tree.traverse(function(path) {
        visited.push(path);
        return true;
      });

      expect(visited).toEqual([
        new jasmineUnderTest.ObjectPath([]),
        new jasmineUnderTest.ObjectPath(['length']),
        new jasmineUnderTest.ObjectPath([1])
      ]);
    });

    it('does not visit children if the callback returns falsy', function() {
      const tree = new jasmineUnderTest.MismatchTree();
      tree.add(new jasmineUnderTest.ObjectPath(['a', 'b']));
      const visited = [];

      tree.traverse(function(path) {
        visited.push(path);
        return path.depth() === 0;
      });

      expect(visited).toEqual([
        new jasmineUnderTest.ObjectPath([]),
        new jasmineUnderTest.ObjectPath(['a'])
      ]);
    });
  });

  function formatter() {}
})",snuts
/spec/core/matchers/DiffBuilderSpec.js,ConditionalTestLogic,"{'startLine':111,'endLine':113}","it('uses custom object formatters on leaf nodes', function() {
    const formatter = function(x) {
      if (typeof x === 'number') {
        return '[number:' + x + ']';
      }
    };
    const prettyPrinter = jasmineUnderTest.makePrettyPrinter([formatter]);
    const diffBuilder = new jasmineUnderTest.DiffBuilder({
      prettyPrinter: prettyPrinter
    });

    diffBuilder.setRoots(5, 4);
    diffBuilder.recordMismatch();

    expect(diffBuilder.getMessage()).toEqual(
      'Expected [number:5] to equal [number:4].'
    );
  })",snuts
/spec/core/matchers/DiffBuilderSpec.js,ConditionalTestLogic,"{'startLine':130,'endLine':132}","it('uses custom object formatters on non leaf nodes', function() {
    const formatter = function(x) {
      if (x.hasOwnProperty('a')) {
        return '[thing with a=' + x.a + ', b=' + JSON.stringify(x.b) + ']';
      }
    };
    const prettyPrinter = jasmineUnderTest.makePrettyPrinter([formatter]);
    const diffBuilder = new jasmineUnderTest.DiffBuilder({
      prettyPrinter: prettyPrinter
    });
    const expectedMsg =
      'Expected $[0].foo = [thing with a=1, b={""x"":42}] to equal [thing with a=1, b={""x"":43}].\n' +
      ""Expected $[0].bar = 'yes' to equal 'no'."";

    diffBuilder.setRoots(
      [{ foo: { a: 1, b: { x: 42 } }, bar: 'yes' }],
      [{ foo: { a: 1, b: { x: 43 } }, bar: 'no' }]
    );

    diffBuilder.withPath(0, function() {
      diffBuilder.withPath('foo', function() {
        diffBuilder.withPath('b', function() {
          diffBuilder.withPath('x', function() {
            diffBuilder.recordMismatch();
          });
        });
      });

      diffBuilder.withPath('bar', function() {
        diffBuilder.recordMismatch();
      });
    });

    expect(diffBuilder.getMessage()).toEqual(expectedMsg);
  })",snuts
/spec/core/matchers/DiffBuilderSpec.js,ConditionalTestLogic,"{'startLine':166,'endLine':168}","it('handles cases where only the expected has a custom object formatter', function() {
    const formatter = function(x) {
      if (typeof x === 'number') {
        return '[number:' + x + ']';
      }
    };
    const prettyPrinter = jasmineUnderTest.makePrettyPrinter([formatter]);
    const diffBuilder = new jasmineUnderTest.DiffBuilder({
      prettyPrinter: prettyPrinter
    });

    diffBuilder.setRoots('five', 4);
    diffBuilder.recordMismatch();

    expect(diffBuilder.getMessage()).toEqual(
      ""Expected 'five' to equal [number:4].""
    );
  })",snuts
/spec/core/matchers/DiffBuilderSpec.js,ConditionalTestLogic,"{'startLine':185,'endLine':187}","it('handles cases where only the actual has a custom object formatter', function() {
    const formatter = function(x) {
      if (typeof x === 'number') {
        return '[number:' + x + ']';
      }
    };
    const prettyPrinter = jasmineUnderTest.makePrettyPrinter([formatter]);
    const diffBuilder = new jasmineUnderTest.DiffBuilder({
      prettyPrinter: prettyPrinter
    });

    diffBuilder.setRoots(5, 'four');
    diffBuilder.recordMismatch();

    expect(diffBuilder.getMessage()).toEqual(
      ""Expected [number:5] to equal 'four'.""
    );
  })",snuts
/spec/core/matchers/DiffBuilderSpec.js,ConditionalTestLogic,"{'startLine':204,'endLine':206}","it('handles complex cases where only one side has a custom object formatter', function() {
    const formatter = function(x) {
      if (typeof x === 'number') {
        return '[number:' + x + ']';
      }
    };
    const prettyPrinter = jasmineUnderTest.makePrettyPrinter([formatter]);
    const diffBuilder = new jasmineUnderTest.DiffBuilder({
      prettyPrinter: prettyPrinter
    });

    diffBuilder.setRoots(5, { foo: 'bar', fnord: { graults: ['wombat'] } });
    diffBuilder.recordMismatch();

    expect(diffBuilder.getMessage()).toEqual(
      ""Expected [number:5] to equal Object({ foo: 'bar', fnord: Object({ graults: [ 'wombat' ] }) }).""
    );
  })",snuts
/spec/core/matchers/DiffBuilderSpec.js,NonFunctionalStatement,"{'startLine':74,'endLine':74}","it('uses the injected pretty-printer', function() {
    const prettyPrinter = function(val) {
        return '|' + val + '|';
      },
      diffBuilder = new jasmineUnderTest.DiffBuilder({
        prettyPrinter: prettyPrinter
      });
    prettyPrinter.customFormat_ = function() {};

    diffBuilder.setRoots({ foo: 'actual' }, { foo: 'expected' });
    diffBuilder.withPath('foo', function() {
      diffBuilder.recordMismatch();
    });

    expect(diffBuilder.getMessage()).toEqual(
      'Expected $.foo = |actual| to equal |expected|.'
    );
  })",snuts
/spec/core/matchers/DiffBuilderSpec.js,NonFunctionalStatement,"{'startLine':88,'endLine':88}","it('passes the injected pretty-printer to the diff formatter', function() {
    const diffFormatter = jasmine.createSpy('diffFormatter'),
      prettyPrinter = function() {},
      diffBuilder = new jasmineUnderTest.DiffBuilder({
        prettyPrinter: prettyPrinter
      });
    prettyPrinter.customFormat_ = function() {};

    diffBuilder.setRoots({ x: 'bar' }, { x: 'foo' });
    diffBuilder.withPath('x', function() {
      diffBuilder.recordMismatch(diffFormatter);
    });

    diffBuilder.getMessage();

    expect(diffFormatter).toHaveBeenCalledWith(
      'bar',
      'foo',
      jasmine.anything(),
      prettyPrinter
    );
  })",snuts
/spec/core/matchers/DiffBuilderSpec.js,NonFunctionalStatement,"{'startLine':92,'endLine':92}","it('passes the injected pretty-printer to the diff formatter', function() {
    const diffFormatter = jasmine.createSpy('diffFormatter'),
      prettyPrinter = function() {},
      diffBuilder = new jasmineUnderTest.DiffBuilder({
        prettyPrinter: prettyPrinter
      });
    prettyPrinter.customFormat_ = function() {};

    diffBuilder.setRoots({ x: 'bar' }, { x: 'foo' });
    diffBuilder.withPath('x', function() {
      diffBuilder.recordMismatch(diffFormatter);
    });

    diffBuilder.getMessage();

    expect(diffFormatter).toHaveBeenCalledWith(
      'bar',
      'foo',
      jasmine.anything(),
      prettyPrinter
    );
  })",snuts
/spec/core/matchers/async/toBePendingSpec.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}","it('passes if the actual promise is pending', function() {
    const matchersUtil = new jasmineUnderTest.MatchersUtil(),
      matcher = jasmineUnderTest.asyncMatchers.toBePending(matchersUtil),
      actual = new Promise(function() {});

    return matcher.compare(actual).then(function(result) {
      expect(result).toEqual(jasmine.objectContaining({ pass: true }));
    });
  })",snuts
/spec/performance/performance_test.js,Conditional Test Logic,"{'line': 2, 'column': 2, 'index': 39}","describe('performance', function() {
  for (let i = 0; i < 10000; i++) {
    it('should pass', function() {
      expect(true).toBe(true);
    });
    it('should fail', function() {
      expect(true).toBe(false);
    });
  }
})",steel
/spec/performance/performance_test.js,Redundant Assertion,"{'column': 6, 'line': 4}","it('should pass', function() {
      expect(true).toBe(true);
    })",steel
/spec/performance/performance_test.js,Redundant Assertion,"{'column': 6, 'line': 7}","it('should fail', function() {
      expect(true).toBe(false);
    })",steel
/spec/performance/large_object_test.js,Conditional Test Logic,"{'line': 9, 'column': 4, 'index': 186}","describe('Printing a big object', function() {
  function rand(upper) {
    return Math.round(upper * Math.random());
  }

  function generateObject(level) {
    const object = {};

    for (let i = 0; i < 50; i++) {
      const decide = rand(2);
      switch (decide) {
        case 0:
          object['cycle' + i] = object;
          break;
        case 1:
          object['number' + i] = rand(100);
          break;
        case 2:
          if (level < 3) {
            object['nesting' + i] = generateObject(level + 1);
          }
          break;
      }
    }

    return object;
  }

  it('takes a reasonable amount of time', function() {
    const bigObject = generateObject(0);
    expect(jasmineUnderTest.pp(bigObject)).toMatch(/cycle/);
  });
})",steel
/spec/performance/large_object_test.js,Conditional Test Logic,"{'line': 11, 'column': 6, 'index': 253}","describe('Printing a big object', function() {
  function rand(upper) {
    return Math.round(upper * Math.random());
  }

  function generateObject(level) {
    const object = {};

    for (let i = 0; i < 50; i++) {
      const decide = rand(2);
      switch (decide) {
        case 0:
          object['cycle' + i] = object;
          break;
        case 1:
          object['number' + i] = rand(100);
          break;
        case 2:
          if (level < 3) {
            object['nesting' + i] = generateObject(level + 1);
          }
          break;
      }
    }

    return object;
  }

  it('takes a reasonable amount of time', function() {
    const bigObject = generateObject(0);
    expect(jasmineUnderTest.pp(bigObject)).toMatch(/cycle/);
  });
})",steel
/spec/performance/large_object_test.js,Conditional Test Logic,"{'line': 19, 'column': 10, 'index': 447}","describe('Printing a big object', function() {
  function rand(upper) {
    return Math.round(upper * Math.random());
  }

  function generateObject(level) {
    const object = {};

    for (let i = 0; i < 50; i++) {
      const decide = rand(2);
      switch (decide) {
        case 0:
          object['cycle' + i] = object;
          break;
        case 1:
          object['number' + i] = rand(100);
          break;
        case 2:
          if (level < 3) {
            object['nesting' + i] = generateObject(level + 1);
          }
          break;
      }
    }

    return object;
  }

  it('takes a reasonable amount of time', function() {
    const bigObject = generateObject(0);
    expect(jasmineUnderTest.pp(bigObject)).toMatch(/cycle/);
  });
})",steel
/spec/core/SpecSpec.js,Duplicate Assert,"{'line': 368, 'column': 6, 'index': 10954}","it('adds the messages to the result', function() {
      const timer = jasmine.createSpyObj('timer', ['start', 'elapsed']);
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} },
        timer: timer
      });
      const t1 = 123;
      const t2 = 456;

      expect(spec.result.debugLogs).toBeNull();
      timer.elapsed.and.returnValue(t1);
      spec.debugLog('msg 1');
      expect(spec.result.debugLogs).toEqual([
        { message: 'msg 1', timestamp: t1 }
      ]);
      timer.elapsed.and.returnValue(t2);
      spec.debugLog('msg 2');
      expect(spec.result.debugLogs).toEqual([
        { message: 'msg 1', timestamp: t1 },
        { message: 'msg 2', timestamp: t2 }
      ]);
    })",steel
/spec/core/SpecSpec.js,Duplicate Assert,"{'line': 371, 'column': 6, 'index': 11073}","it('adds the messages to the result', function() {
      const timer = jasmine.createSpyObj('timer', ['start', 'elapsed']);
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} },
        timer: timer
      });
      const t1 = 123;
      const t2 = 456;

      expect(spec.result.debugLogs).toBeNull();
      timer.elapsed.and.returnValue(t1);
      spec.debugLog('msg 1');
      expect(spec.result.debugLogs).toEqual([
        { message: 'msg 1', timestamp: t1 }
      ]);
      timer.elapsed.and.returnValue(t2);
      spec.debugLog('msg 2');
      expect(spec.result.debugLogs).toEqual([
        { message: 'msg 1', timestamp: t1 },
        { message: 'msg 2', timestamp: t2 }
      ]);
    })",steel
/spec/core/SpecSpec.js,Duplicate Assert,"{'line': 376, 'column': 6, 'index': 11244}","it('adds the messages to the result', function() {
      const timer = jasmine.createSpyObj('timer', ['start', 'elapsed']);
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} },
        timer: timer
      });
      const t1 = 123;
      const t2 = 456;

      expect(spec.result.debugLogs).toBeNull();
      timer.elapsed.and.returnValue(t1);
      spec.debugLog('msg 1');
      expect(spec.result.debugLogs).toEqual([
        { message: 'msg 1', timestamp: t1 }
      ]);
      timer.elapsed.and.returnValue(t2);
      spec.debugLog('msg 2');
      expect(spec.result.debugLogs).toEqual([
        { message: 'msg 1', timestamp: t1 },
        { message: 'msg 2', timestamp: t2 }
      ]);
    })",steel
/spec/core/SpecSpec.js,Magic Number,"{'line': 76, 'column': 45, 'index': 2549}","it('get the property value', function() {
      const spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: () => {} }
      });

      spec.setSpecProperty('a', 4);
      expect(spec.getSpecProperty('a')).toBe(4);
    })",steel
/spec/core/SpecSpec.js,Magic Number,"{'line': 272, 'column': 58, 'index': 8397}","it('does not forward non-late handleException calls to onLateError', function() {
    const onLateError = jasmine.createSpy('onLateError');
    const spec = new jasmineUnderTest.Spec({
      onLateError,
      queueableFn: { fn: function() {} }
    });
    const error = new Error('oops');

    spec.handleException(error);

    expect(onLateError).not.toHaveBeenCalled();
    expect(spec.result.failedExpectations.length).toEqual(1);
  })",steel
/spec/core/SpecSpec.js,Unknown Test,"{'column': 2, 'line': 286}","it('does not throw an ExpectationFailed error when handling an error', function() {
    const resultCallback = jasmine.createSpy('resultCallback'),
      spec = new jasmineUnderTest.Spec({
        queueableFn: { fn: function() {} },
        resultCallback: resultCallback,
        throwOnExpectationFailure: true
      });

    spec.handleException('failing exception');
  })",steel
/spec/core/integration/SpecRunningSpec.js,Conditional Test Logic,"{'line': 1391, 'column': 10, 'index': 36574}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Conditional Test Logic,"{'line': 1397, 'column': 12, 'index': 36750}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Conditional Test Logic,"{'line': 1405, 'column': 12, 'index': 36997}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1511}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 60, 'column': 4, 'index': 1539}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1567}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 1595}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1651}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 67, 'column': 4, 'index': 1679}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 1707}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 69, 'column': 4, 'index': 1735}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 565, 'column': 12, 'index': 13877}","it('should recover gracefully when there are errors in describe functions', async function() {
    const specs = [],
      reporter = jasmine.createSpyObj(['specDone', 'suiteDone']);

    reporter.specDone.and.callFake(function(result) {
      specs.push(result.fullName);
    });

    expect(function() {
      env.describe('outer1', function() {
        env.describe('inner1', function() {
          env.it('should thingy', function() {
            this.expect(true).toEqual(true);
          });

          throw new Error('inner error');
        });

        env.describe('inner2', function() {
          env.it('should other thingy', function() {
            this.expect(true).toEqual(true);
          });
        });

        throw new Error('outer error');
      });
    }).not.toThrow();

    env.describe('outer2', function() {
      env.it('should xxx', function() {
        this.expect(true).toEqual(true);
      });
    });

    env.addReporter(reporter);
    await env.execute();

    expect(specs).toEqual([
      'outer1 inner1 should thingy',
      'outer1 inner2 should other thingy',
      'outer2 should xxx'
    ]);
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'outer1 inner1',
      [/inner error/]
    );
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('outer1', [
      /outer error/
    ]);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 573, 'column': 12, 'index': 14089}","it('should recover gracefully when there are errors in describe functions', async function() {
    const specs = [],
      reporter = jasmine.createSpyObj(['specDone', 'suiteDone']);

    reporter.specDone.and.callFake(function(result) {
      specs.push(result.fullName);
    });

    expect(function() {
      env.describe('outer1', function() {
        env.describe('inner1', function() {
          env.it('should thingy', function() {
            this.expect(true).toEqual(true);
          });

          throw new Error('inner error');
        });

        env.describe('inner2', function() {
          env.it('should other thingy', function() {
            this.expect(true).toEqual(true);
          });
        });

        throw new Error('outer error');
      });
    }).not.toThrow();

    env.describe('outer2', function() {
      env.it('should xxx', function() {
        this.expect(true).toEqual(true);
      });
    });

    env.addReporter(reporter);
    await env.execute();

    expect(specs).toEqual([
      'outer1 inner1 should thingy',
      'outer1 inner2 should other thingy',
      'outer2 should xxx'
    ]);
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'outer1 inner1',
      [/inner error/]
    );
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('outer1', [
      /outer error/
    ]);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 583, 'column': 8, 'index': 14310}","it('should recover gracefully when there are errors in describe functions', async function() {
    const specs = [],
      reporter = jasmine.createSpyObj(['specDone', 'suiteDone']);

    reporter.specDone.and.callFake(function(result) {
      specs.push(result.fullName);
    });

    expect(function() {
      env.describe('outer1', function() {
        env.describe('inner1', function() {
          env.it('should thingy', function() {
            this.expect(true).toEqual(true);
          });

          throw new Error('inner error');
        });

        env.describe('inner2', function() {
          env.it('should other thingy', function() {
            this.expect(true).toEqual(true);
          });
        });

        throw new Error('outer error');
      });
    }).not.toThrow();

    env.describe('outer2', function() {
      env.it('should xxx', function() {
        this.expect(true).toEqual(true);
      });
    });

    env.addReporter(reporter);
    await env.execute();

    expect(specs).toEqual([
      'outer1 inner1 should thingy',
      'outer1 inner2 should other thingy',
      'outer2 should xxx'
    ]);
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'outer1 inner1',
      [/inner error/]
    );
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('outer1', [
      /outer error/
    ]);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 595, 'column': 4, 'index': 14565}","it('should recover gracefully when there are errors in describe functions', async function() {
    const specs = [],
      reporter = jasmine.createSpyObj(['specDone', 'suiteDone']);

    reporter.specDone.and.callFake(function(result) {
      specs.push(result.fullName);
    });

    expect(function() {
      env.describe('outer1', function() {
        env.describe('inner1', function() {
          env.it('should thingy', function() {
            this.expect(true).toEqual(true);
          });

          throw new Error('inner error');
        });

        env.describe('inner2', function() {
          env.it('should other thingy', function() {
            this.expect(true).toEqual(true);
          });
        });

        throw new Error('outer error');
      });
    }).not.toThrow();

    env.describe('outer2', function() {
      env.it('should xxx', function() {
        this.expect(true).toEqual(true);
      });
    });

    env.addReporter(reporter);
    await env.execute();

    expect(specs).toEqual([
      'outer1 inner1 should thingy',
      'outer1 inner2 should other thingy',
      'outer2 should xxx'
    ]);
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'outer1 inner1',
      [/inner error/]
    );
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('outer1', [
      /outer error/
    ]);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 599, 'column': 4, 'index': 14685}","it('should recover gracefully when there are errors in describe functions', async function() {
    const specs = [],
      reporter = jasmine.createSpyObj(['specDone', 'suiteDone']);

    reporter.specDone.and.callFake(function(result) {
      specs.push(result.fullName);
    });

    expect(function() {
      env.describe('outer1', function() {
        env.describe('inner1', function() {
          env.it('should thingy', function() {
            this.expect(true).toEqual(true);
          });

          throw new Error('inner error');
        });

        env.describe('inner2', function() {
          env.it('should other thingy', function() {
            this.expect(true).toEqual(true);
          });
        });

        throw new Error('outer error');
      });
    }).not.toThrow();

    env.describe('outer2', function() {
      env.it('should xxx', function() {
        this.expect(true).toEqual(true);
      });
    });

    env.addReporter(reporter);
    await env.execute();

    expect(specs).toEqual([
      'outer1 inner1 should thingy',
      'outer1 inner2 should other thingy',
      'outer2 should xxx'
    ]);
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'outer1 inner1',
      [/inner error/]
    );
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('outer1', [
      /outer error/
    ]);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1111, 'column': 6, 'index': 28135}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.beforeAll(function() {
        throw new Error('nope');
      });

      env.beforeEach(outerBeforeEach);
      env.it('a spec', outerIt);
      env.describe('a nested suite', function() {
        env.beforeAll(nestedBeforeAll);
        env.beforeEach(nestedBeforeEach);
        env.it('a nested spec', nestedIt);
        env.afterEach(nestedAfterEach);
      });
      env.afterEach(outerAfterEach);

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1116, 'column': 6, 'index': 28276}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.beforeAll(function() {
        throw new Error('nope');
      });

      env.beforeEach(outerBeforeEach);
      env.it('a spec', outerIt);
      env.describe('a nested suite', function() {
        env.beforeAll(nestedBeforeAll);
        env.beforeEach(nestedBeforeEach);
        env.it('a nested spec', nestedIt);
        env.afterEach(nestedAfterEach);
      });
      env.afterEach(outerAfterEach);

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1132, 'column': 6, 'index': 28767}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.beforeAll(function() {
        throw new Error('nope');
      });

      env.beforeEach(outerBeforeEach);
      env.it('a spec', outerIt);
      env.describe('a nested suite', function() {
        env.beforeAll(nestedBeforeAll);
        env.beforeEach(nestedBeforeEach);
        env.it('a nested spec', nestedIt);
        env.afterEach(nestedAfterEach);
      });
      env.afterEach(outerAfterEach);

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1137, 'column': 6, 'index': 28930}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.beforeAll(function() {
        throw new Error('nope');
      });

      env.beforeEach(outerBeforeEach);
      env.it('a spec', outerIt);
      env.describe('a nested suite', function() {
        env.beforeAll(nestedBeforeAll);
        env.beforeEach(nestedBeforeEach);
        env.it('a nested spec', nestedIt);
        env.afterEach(nestedAfterEach);
      });
      env.afterEach(outerAfterEach);

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1215, 'column': 6, 'index': 31625}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.describe('a suite', function() {
        env.beforeAll(function() {
          throw new Error('nope');
        });

        env.beforeEach(outerBeforeEach);
        env.it('a spec', outerIt);
        env.describe('a nested suite', function() {
          env.beforeAll(nestedBeforeAll);
          env.beforeEach(nestedBeforeEach);
          env.it('a nested spec', nestedIt);
          env.afterEach(nestedAfterEach);
        });
        env.afterEach(outerAfterEach);
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1220, 'column': 6, 'index': 31774}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.describe('a suite', function() {
        env.beforeAll(function() {
          throw new Error('nope');
        });

        env.beforeEach(outerBeforeEach);
        env.it('a spec', outerIt);
        env.describe('a nested suite', function() {
          env.beforeAll(nestedBeforeAll);
          env.beforeEach(nestedBeforeEach);
          env.it('a nested spec', nestedIt);
          env.afterEach(nestedAfterEach);
        });
        env.afterEach(outerAfterEach);
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1236, 'column': 6, 'index': 32273}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.describe('a suite', function() {
        env.beforeAll(function() {
          throw new Error('nope');
        });

        env.beforeEach(outerBeforeEach);
        env.it('a spec', outerIt);
        env.describe('a nested suite', function() {
          env.beforeAll(nestedBeforeAll);
          env.beforeEach(nestedBeforeEach);
          env.it('a nested spec', nestedIt);
          env.afterEach(nestedAfterEach);
        });
        env.afterEach(outerAfterEach);
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1241, 'column': 6, 'index': 32444}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.describe('a suite', function() {
        env.beforeAll(function() {
          throw new Error('nope');
        });

        env.beforeEach(outerBeforeEach);
        env.it('a spec', outerIt);
        env.describe('a nested suite', function() {
          env.beforeAll(nestedBeforeAll);
          env.beforeEach(nestedBeforeEach);
          env.it('a nested spec', nestedIt);
          env.afterEach(nestedAfterEach);
        });
        env.afterEach(outerAfterEach);
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1366, 'column': 6, 'index': 35856}","it('should be able to run multiple times', async function() {
      const actions = [];

      env.describe('Suite', function() {
        env.it('spec1', function() {
          actions.push('spec1');
        });
        env.describe('inner suite', function() {
          env.it('spec2', function() {
            actions.push('spec2');
          });
        });
      });

      await env.execute();
      expect(actions).toEqual(['spec1', 'spec2']);

      await env.execute();
      expect(actions).toEqual(['spec1', 'spec2', 'spec1', 'spec2']);
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1369, 'column': 6, 'index': 35935}","it('should be able to run multiple times', async function() {
      const actions = [];

      env.describe('Suite', function() {
        env.it('spec1', function() {
          actions.push('spec1');
        });
        env.describe('inner suite', function() {
          env.it('spec2', function() {
            actions.push('spec2');
          });
        });
      });

      await env.execute();
      expect(actions).toEqual(['spec1', 'spec2']);

      await env.execute();
      expect(actions).toEqual(['spec1', 'spec2', 'spec1', 'spec2']);
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1426, 'column': 6, 'index': 37556}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1435, 'column': 6, 'index': 37780}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1435, 'column': 6, 'index': 37780}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1445, 'column': 6, 'index': 38011}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1454, 'column': 6, 'index': 38234}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1454, 'column': 6, 'index': 38234}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1491, 'column': 6, 'index': 39241}","it('should execute before and after hooks per run', async function() {
      let timeline = [];
      const timelineFn = function(hookName) {
        return function() {
          timeline.push(hookName);
        };
      };
      const expectedTimeLine = [
        'beforeAll',
        'beforeEach',
        'spec1',
        'afterEach',
        'beforeEach',
        'spec2',
        'afterEach',
        'afterAll'
      ];

      env.describe('suite0', function() {
        env.beforeAll(timelineFn('beforeAll'));
        env.beforeEach(timelineFn('beforeEach'));
        env.afterEach(timelineFn('afterEach'));
        env.afterAll(timelineFn('afterAll'));
        env.it('spec1', timelineFn('spec1'));
        env.it('spec2', timelineFn('spec2'));
      });
      await env.execute();
      expect(timeline).toEqual(expectedTimeLine);

      timeline = [];
      await env.execute();
      expect(timeline).toEqual(expectedTimeLine);
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1491, 'column': 6, 'index': 39241}","it('should execute before and after hooks per run', async function() {
      let timeline = [];
      const timelineFn = function(hookName) {
        return function() {
          timeline.push(hookName);
        };
      };
      const expectedTimeLine = [
        'beforeAll',
        'beforeEach',
        'spec1',
        'afterEach',
        'beforeEach',
        'spec2',
        'afterEach',
        'afterAll'
      ];

      env.describe('suite0', function() {
        env.beforeAll(timelineFn('beforeAll'));
        env.beforeEach(timelineFn('beforeEach'));
        env.afterEach(timelineFn('afterEach'));
        env.afterAll(timelineFn('afterAll'));
        env.it('spec1', timelineFn('spec1'));
        env.it('spec2', timelineFn('spec2'));
      });
      await env.execute();
      expect(timeline).toEqual(expectedTimeLine);

      timeline = [];
      await env.execute();
      expect(timeline).toEqual(expectedTimeLine);
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1495, 'column': 6, 'index': 39340}","it('should execute before and after hooks per run', async function() {
      let timeline = [];
      const timelineFn = function(hookName) {
        return function() {
          timeline.push(hookName);
        };
      };
      const expectedTimeLine = [
        'beforeAll',
        'beforeEach',
        'spec1',
        'afterEach',
        'beforeEach',
        'spec2',
        'afterEach',
        'afterAll'
      ];

      env.describe('suite0', function() {
        env.beforeAll(timelineFn('beforeAll'));
        env.beforeEach(timelineFn('beforeEach'));
        env.afterEach(timelineFn('afterEach'));
        env.afterAll(timelineFn('afterAll'));
        env.it('spec1', timelineFn('spec1'));
        env.it('spec2', timelineFn('spec2'));
      });
      await env.execute();
      expect(timeline).toEqual(expectedTimeLine);

      timeline = [];
      await env.execute();
      expect(timeline).toEqual(expectedTimeLine);
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1495, 'column': 6, 'index': 39340}","it('should execute before and after hooks per run', async function() {
      let timeline = [];
      const timelineFn = function(hookName) {
        return function() {
          timeline.push(hookName);
        };
      };
      const expectedTimeLine = [
        'beforeAll',
        'beforeEach',
        'spec1',
        'afterEach',
        'beforeEach',
        'spec2',
        'afterEach',
        'afterAll'
      ];

      env.describe('suite0', function() {
        env.beforeAll(timelineFn('beforeAll'));
        env.beforeEach(timelineFn('beforeEach'));
        env.afterEach(timelineFn('afterEach'));
        env.afterAll(timelineFn('afterAll'));
        env.it('spec1', timelineFn('spec1'));
        env.it('spec2', timelineFn('spec2'));
      });
      await env.execute();
      expect(timeline).toEqual(expectedTimeLine);

      timeline = [];
      await env.execute();
      expect(timeline).toEqual(expectedTimeLine);
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1521, 'column': 6, 'index': 40024}","it('should be able to filter out different tests in subsequent runs', async function() {
      const specResults = {};
      let focussedSpec = 'spec1';

      env.configure({
        specFilter: function(spec) {
          return spec.description === focussedSpec;
        }
      });

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {});
        env.it('spec2', function() {});
        env.it('spec3', function() {});
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'excluded',
        spec3: 'excluded'
      });

      focussedSpec = 'spec2';
      await env.execute();
      expect(specResults).toEqual({
        spec1: 'excluded',
        spec2: 'passed',
        spec3: 'excluded'
      });

      focussedSpec = 'spec3';
      await env.execute();
      expect(specResults).toEqual({
        spec1: 'excluded',
        spec2: 'excluded',
        spec3: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1529, 'column': 6, 'index': 40206}","it('should be able to filter out different tests in subsequent runs', async function() {
      const specResults = {};
      let focussedSpec = 'spec1';

      env.configure({
        specFilter: function(spec) {
          return spec.description === focussedSpec;
        }
      });

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {});
        env.it('spec2', function() {});
        env.it('spec3', function() {});
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'excluded',
        spec3: 'excluded'
      });

      focussedSpec = 'spec2';
      await env.execute();
      expect(specResults).toEqual({
        spec1: 'excluded',
        spec2: 'passed',
        spec3: 'excluded'
      });

      focussedSpec = 'spec3';
      await env.execute();
      expect(specResults).toEqual({
        spec1: 'excluded',
        spec2: 'excluded',
        spec3: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Duplicate Assert,"{'line': 1537, 'column': 6, 'index': 40388}","it('should be able to filter out different tests in subsequent runs', async function() {
      const specResults = {};
      let focussedSpec = 'spec1';

      env.configure({
        specFilter: function(spec) {
          return spec.description === focussedSpec;
        }
      });

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {});
        env.it('spec2', function() {});
        env.it('spec3', function() {});
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'excluded',
        spec3: 'excluded'
      });

      focussedSpec = 'spec2';
      await env.execute();
      expect(specResults).toEqual({
        spec1: 'excluded',
        spec2: 'passed',
        spec3: 'excluded'
      });

      focussedSpec = 'spec3';
      await env.execute();
      expect(specResults).toEqual({
        spec1: 'excluded',
        spec2: 'excluded',
        spec3: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Exception Handling,"{'line': 568, 'column': 10, 'index': 13935}","it('should recover gracefully when there are errors in describe functions', async function() {
    const specs = [],
      reporter = jasmine.createSpyObj(['specDone', 'suiteDone']);

    reporter.specDone.and.callFake(function(result) {
      specs.push(result.fullName);
    });

    expect(function() {
      env.describe('outer1', function() {
        env.describe('inner1', function() {
          env.it('should thingy', function() {
            this.expect(true).toEqual(true);
          });

          throw new Error('inner error');
        });

        env.describe('inner2', function() {
          env.it('should other thingy', function() {
            this.expect(true).toEqual(true);
          });
        });

        throw new Error('outer error');
      });
    }).not.toThrow();

    env.describe('outer2', function() {
      env.it('should xxx', function() {
        this.expect(true).toEqual(true);
      });
    });

    env.addReporter(reporter);
    await env.execute();

    expect(specs).toEqual([
      'outer1 inner1 should thingy',
      'outer1 inner2 should other thingy',
      'outer2 should xxx'
    ]);
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'outer1 inner1',
      [/inner error/]
    );
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('outer1', [
      /outer error/
    ]);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Exception Handling,"{'line': 577, 'column': 8, 'index': 14157}","it('should recover gracefully when there are errors in describe functions', async function() {
    const specs = [],
      reporter = jasmine.createSpyObj(['specDone', 'suiteDone']);

    reporter.specDone.and.callFake(function(result) {
      specs.push(result.fullName);
    });

    expect(function() {
      env.describe('outer1', function() {
        env.describe('inner1', function() {
          env.it('should thingy', function() {
            this.expect(true).toEqual(true);
          });

          throw new Error('inner error');
        });

        env.describe('inner2', function() {
          env.it('should other thingy', function() {
            this.expect(true).toEqual(true);
          });
        });

        throw new Error('outer error');
      });
    }).not.toThrow();

    env.describe('outer2', function() {
      env.it('should xxx', function() {
        this.expect(true).toEqual(true);
      });
    });

    env.addReporter(reporter);
    await env.execute();

    expect(specs).toEqual([
      'outer1 inner1 should thingy',
      'outer1 inner2 should other thingy',
      'outer2 should xxx'
    ]);
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable(
      'outer1 inner1',
      [/inner error/]
    );
    expect(reporter.suiteDone).toHaveFailedExpectationsForRunnable('outer1', [
      /outer error/
    ]);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Exception Handling,"{'line': 787, 'column': 10, 'index': 19321}","it('skips to cleanup functions after a thrown error', async function() {
      const actions = [];

      env.describe('Something', function() {
        env.beforeEach(function() {
          actions.push('outer beforeEach');
          throw new Error('error');
        });

        env.afterEach(function() {
          actions.push('outer afterEach');
        });

        env.describe('Inner', function() {
          env.beforeEach(function() {
            actions.push('inner beforeEach');
          });

          env.afterEach(function() {
            actions.push('inner afterEach');
          });

          env.it('does it', function() {
            actions.push('inner it');
          });
        });
      });

      await env.execute();

      expect(actions).toEqual(['outer beforeEach', 'outer afterEach']);
    })",steel
/spec/core/integration/SpecRunningSpec.js,Exception Handling,"{'line': 931, 'column': 10, 'index': 22936}","it('runs all reporter callbacks even if one fails', async function() {
      const laterReporter = jasmine.createSpyObj('laterReporter', ['specDone']);

      env.it('a spec', function() {});
      env.addReporter({
        specDone: function() {
          throw new Error('nope');
        }
      });
      env.addReporter(laterReporter);

      await env.execute();

      expect(laterReporter.specDone).toHaveBeenCalled();
    })",steel
/spec/core/integration/SpecRunningSpec.js,Exception Handling,"{'line': 947, 'column': 10, 'index': 23462}","it('skips cleanup functions that are defined in child suites when a beforeEach errors', async function() {
      const parentAfterEachFn = jasmine.createSpy('parentAfterEachFn');
      const childAfterEachFn = jasmine.createSpy('childAfterEachFn');

      env.describe('parent suite', function() {
        env.beforeEach(function() {
          throw new Error('nope');
        });

        env.afterEach(parentAfterEachFn);

        env.describe('child suite', function() {
          env.it('a spec', function() {});
          env.afterEach(childAfterEachFn);
        });
      });

      await env.execute();

      expect(parentAfterEachFn).toHaveBeenCalled();
      expect(childAfterEachFn).not.toHaveBeenCalled();
    })",steel
/spec/core/integration/SpecRunningSpec.js,Exception Handling,"{'line': 1064, 'column': 8, 'index': 26670}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.beforeAll(function() {
        throw new Error('nope');
      });

      env.beforeEach(outerBeforeEach);
      env.it('a spec', outerIt);
      env.describe('a nested suite', function() {
        env.beforeAll(nestedBeforeAll);
        env.beforeEach(nestedBeforeEach);
        env.it('a nested spec', nestedIt);
        env.afterEach(nestedAfterEach);
      });
      env.afterEach(outerAfterEach);

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",steel
/spec/core/integration/SpecRunningSpec.js,Exception Handling,"{'line': 1167, 'column': 10, 'index': 30114}","it('skips and reports contained specs', async function() {
      const outerBeforeEach = jasmine.createSpy('outerBeforeEach');
      const nestedBeforeEach = jasmine.createSpy('nestedBeforeEach');
      const outerAfterEach = jasmine.createSpy('outerAfterEach');
      const nestedAfterEach = jasmine.createSpy('nestedAfterEach');
      const outerIt = jasmine.createSpy('outerIt');
      const nestedIt = jasmine.createSpy('nestedIt');
      const nestedBeforeAll = jasmine.createSpy('nestedBeforeAll');

      env.describe('a suite', function() {
        env.beforeAll(function() {
          throw new Error('nope');
        });

        env.beforeEach(outerBeforeEach);
        env.it('a spec', outerIt);
        env.describe('a nested suite', function() {
          env.beforeAll(nestedBeforeAll);
          env.beforeEach(nestedBeforeEach);
          env.it('a nested spec', nestedIt);
          env.afterEach(nestedAfterEach);
        });
        env.afterEach(outerAfterEach);
      });

      const reporter = jasmine.createSpyObj('reporter', [
        'suiteStarted',
        'suiteDone',
        'specStarted',
        'specDone'
      ]);
      env.addReporter(reporter);

      await env.execute();

      expect(outerBeforeEach).not.toHaveBeenCalled();
      expect(outerIt).not.toHaveBeenCalled();
      expect(nestedBeforeAll).not.toHaveBeenCalled();
      expect(nestedBeforeEach).not.toHaveBeenCalled();
      expect(nestedIt).not.toHaveBeenCalled();
      expect(nestedAfterEach).not.toHaveBeenCalled();
      expect(outerAfterEach).not.toHaveBeenCalled();

      expect(reporter.suiteStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite'
        })
      );

      // The child suite should be reported as passed, for consistency with
      // suites that contain failing specs but no suite-level errors.
      expect(reporter.suiteDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite',
          status: 'passed',
          failedExpectations: []
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );

      expect(reporter.specStarted).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec'
        })
      );
      expect(reporter.specDone).toHaveBeenCalledWith(
        jasmine.objectContaining({
          fullName: 'a suite a nested suite a nested spec',
          status: 'failed',
          failedExpectations: [
            jasmine.objectContaining({
              passed: false,
              message:
                'Not run because a beforeAll function failed. The ' +
                'beforeAll failure will be reported on the suite that ' +
                'caused it.'
            })
          ]
        })
      );
    })",steel
/spec/core/integration/SpecRunningSpec.js,Exception Handling,"{'line': 1265, 'column': 10, 'index': 33362}","it('runs afterAll functions in the current suite and outer scopes', async function() {
      const outerAfterAll = jasmine.createSpy('outerAfterAll');
      const nestedAfterAll = jasmine.createSpy('nestedAfterAll');
      const secondNestedAfterAll = jasmine.createSpy('secondNestedAfterAll');

      env.describe('a nested suite', function() {
        env.beforeAll(function() {
          throw new Error('nope');
        });

        env.describe('more nesting', function() {
          env.it('a nested spec', function() {});
          env.afterAll(secondNestedAfterAll);
        });

        env.afterAll(nestedAfterAll);
      });
      env.afterAll(outerAfterAll);

      await env.execute();

      expect(secondNestedAfterAll).not.toHaveBeenCalled();
      expect(nestedAfterAll).toHaveBeenCalled();
      expect(outerAfterAll).toHaveBeenCalled();
    })",steel
/spec/core/integration/SpecRunningSpec.js,Exception Handling,"{'line': 1406, 'column': 14, 'index': 37033}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Exception Handling,"{'line': 1412, 'column': 12, 'index': 37200}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 59, 'column': 24, 'index': 1531}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 60, 'column': 24, 'index': 1559}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 61, 'column': 24, 'index': 1587}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 62, 'column': 25, 'index': 1616}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 66, 'column': 24, 'index': 1671}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 67, 'column': 24, 'index': 1699}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 68, 'column': 24, 'index': 1727}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 69, 'column': 25, 'index': 1756}","it('nested suites', async function() {
    let foo = 0;
    let bar = 0;
    let baz = 0;
    let quux = 0;
    env.describe('suite', function() {
      env.describe('nested', function() {
        env.it('should run nested suites', function() {
          foo++;
        });
        env.it('should run nested suites', function() {
          bar++;
        });
      });

      env.describe('nested 2', function() {
        env.it('should run suites following nested suites', function() {
          baz++;
        });
      });

      env.it('should run tests following nested suites', function() {
        quux++;
      });
    });

    expect(foo).toEqual(0);
    expect(bar).toEqual(0);
    expect(baz).toEqual(0);
    expect(quux).toEqual(0);

    await env.execute();

    expect(foo).toEqual(1);
    expect(bar).toEqual(1);
    expect(baz).toEqual(1);
    expect(quux).toEqual(1);
  })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 978, 'column': 29, 'index': 24323}","it('skips to cleanup functions after an expectation failure', async function() {
      const actions = [];

      env.describe('Something', function() {
        env.beforeEach(function() {
          actions.push('outer beforeEach');
          env.expect(1).toBe(2);
        });

        env.afterEach(function() {
          actions.push('outer afterEach');
        });

        env.describe('Inner', function() {
          env.beforeEach(function() {
            actions.push('inner beforeEach');
          });

          env.afterEach(function() {
            actions.push('inner afterEach');
          });

          env.it('does it', function() {
            actions.push('inner it');
          });
        });
      });

      await env.execute();

      expect(actions).toEqual(['outer beforeEach', 'outer afterEach']);
    })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 1019, 'column': 29, 'index': 25373}","it('does not skip anything after an expectation failure', async function() {
      const actions = [];

      env.describe('Something', function() {
        env.beforeEach(function() {
          actions.push('outer beforeEach');
          env.expect(1).toBe(2);
        });

        env.afterEach(function() {
          actions.push('outer afterEach');
        });

        env.describe('Inner', function() {
          env.beforeEach(function() {
            actions.push('inner beforeEach');
          });

          env.afterEach(function() {
            actions.push('inner afterEach');
          });

          env.it('does it', function() {
            actions.push('inner it');
          });
        });
      });

      await env.execute();

      expect(actions).toEqual([
        'outer beforeEach',
        'inner beforeEach',
        'inner it',
        'inner afterEach',
        'outer afterEach'
      ]);
    })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 1292, 'column': 29, 'index': 34138}","it('does not run further specs when one fails', async function() {
      const actions = [];

      env.describe('wrapper', function() {
        env.it('fails', function() {
          actions.push('fails');
          env.expect(1).toBe(2);
        });
      });

      env.describe('holder', function() {
        env.it('does not run', function() {
          actions.push('does not run');
        });
      });

      env.configure({ random: false });
      env.configure({ stopOnSpecFailure: true });

      await env.execute();

      expect(actions).toEqual(['fails']);
    })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 1317, 'column': 31, 'index': 34765}","it('runs afterAll functions', async function() {
      const actions = [];

      env.describe('outer suite', function() {
        env.describe('inner suite', function() {
          env.it('fails', function() {
            actions.push('fails');
            env.expect(1).toBe(2);
          });

          env.afterAll(function() {
            actions.push('inner afterAll');
          });
        });

        env.afterAll(function() {
          actions.push('outer afterAll');
        });
      });

      env.afterAll(function() {
        actions.push('top afterAll');
      });

      env.configure({ stopOnSpecFailure: true });
      await env.execute();

      expect(actions).toEqual([
        'fails',
        'inner afterAll',
        'outer afterAll',
        'top afterAll'
      ]);
    })",steel
/spec/core/integration/SpecRunningSpec.js,Magic Number,"{'line': 1392, 'column': 31, 'index': 36627}","it('should reset results between runs', async function() {
      const specResults = {};
      const suiteResults = {};
      let firstExecution = true;

      env.addReporter({
        specDone: function(spec) {
          specResults[spec.description] = spec.status;
        },
        suiteDone: function(suite) {
          suiteResults[suite.description] = suite.status;
        },
        jasmineDone: function() {
          firstExecution = false;
        }
      });

      env.describe('suite0', function() {
        env.it('spec1', function() {
          if (firstExecution) {
            env.expect(1).toBe(2);
          }
        });
        env.describe('suite1', function() {
          env.it('spec2', function() {
            if (firstExecution) {
              env.pending();
            }
          });
          env.xit('spec3', function() {}); // Always pending
        });
        env.describe('suite2', function() {
          env.it('spec4', function() {
            if (firstExecution) {
              throw new Error('spec 3 fails');
            }
          });
        });
        env.describe('suite3', function() {
          env.beforeEach(function() {
            throw new Error('suite 3 fails');
          });
          env.it('spec5', function() {});
        });
        env.xdescribe('suite4', function() {
          // Always pending
          env.it('spec6', function() {});
        });
        env.describe('suite5', function() {
          env.it('spec7');
        });
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'failed',
        spec2: 'pending',
        spec3: 'pending',
        spec4: 'failed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });

      await env.execute();
      expect(specResults).toEqual({
        spec1: 'passed',
        spec2: 'passed',
        spec3: 'pending',
        spec4: 'passed',
        spec5: 'failed',
        spec6: 'pending',
        spec7: 'pending'
      });
      expect(suiteResults).toEqual({
        suite0: 'passed',
        suite1: 'passed',
        suite2: 'passed',
        suite3: 'passed',
        suite4: 'pending',
        suite5: 'passed'
      });
    })",steel
