file,type,line,method,source
/packages/jsdoc/test/fixtures/specialnames.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/packages/jsdoc/test/fixtures/specialnames.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/specialnames.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/packages/jsdoc/test/fixtures/specialchars.js,NonFunctionalStatement,"{'startLine':12,'endLine':12}",Unknown,snuts
/packages/jsdoc-util/test/specs/index.js,AnonymousTest,"{'startLine':27,'endLine':29}","it('is lib/cast', () => {
      expect(util.cast).toEqual(cast);
    })",snuts
/packages/jsdoc-util/test/specs/index.js,AnonymousTest,"{'startLine':33,'endLine':35}","it('is lib/log', () => {
      expect(util.getLogFunctions).toEqual(log);
    })",snuts
/packages/jsdoc-task-runner/test/specs/index.js,AnonymousTest,"{'startLine':26,'endLine':28}","it('is lib/task', () => {
      expect(taskRunner.Task).toEqual(Task);
    })",snuts
/packages/jsdoc-task-runner/test/specs/index.js,AnonymousTest,"{'startLine':32,'endLine':34}","it('is lib/task-runner', () => {
      expect(taskRunner.TaskRunner).toEqual(TaskRunner);
    })",snuts
/packages/jsdoc-tag/test/specs/index.js,AnonymousTest,"{'startLine':31,'endLine':33}","it('is lib/definitions', () => {
      expect(tag.definitions).toEqual(definitions);
    })",snuts
/packages/jsdoc-tag/test/specs/index.js,AnonymousTest,"{'startLine':37,'endLine':39}","it('is lib/dictionary.Dictionary', () => {
      expect(tag.Dictionary).toEqual(Dictionary);
    })",snuts
/packages/jsdoc-tag/test/specs/index.js,AnonymousTest,"{'startLine':43,'endLine':45}","it('is lib/inline', () => {
      expect(tag.inline).toEqual(inline);
    })",snuts
/packages/jsdoc-tag/test/specs/index.js,AnonymousTest,"{'startLine':49,'endLine':51}","it('is lib/tag.Tag', () => {
      expect(tag.Tag).toEqual(Tag);
    })",snuts
/packages/jsdoc-tag/test/specs/index.js,AnonymousTest,"{'startLine':55,'endLine':57}","it('is lib/type', () => {
      expect(tag.type).toEqual(type);
    })",snuts
/packages/jsdoc-tag/test/specs/index.js,AnonymousTest,"{'startLine':61,'endLine':63}","it('is lib/validator.validate', () => {
      expect(tag.validate).toEqual(validate);
    })",snuts
/packages/jsdoc-name/test/specs/index.js,AnonymousTest,"{'startLine':21,'endLine':29}","it('is lib/name', () => {
    const indexKeys = Object.keys(index).sort();
    const nameKeys = Object.keys(name).sort();

    expect(indexKeys).toEqual(nameKeys);
    for (const indexKey of indexKeys) {
      expect(index[indexKey]).toBe(name[indexKey]);
    }
  })",snuts
/packages/jsdoc-plugins/test/specs/source-tag.js,GeneralFixture,"{'startLine':28,'endLine':28}","beforeEach(async () => {
    parser = jsdoc.createParser();
    await plugins.installPlugins([pluginPath], parser, jsdoc.env);
    docSet = jsdoc.getDocSetFromFile(pluginPath, parser);
  })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':58,'endLine':58}","it('does not add unique longnames to constructors', () => {
      const soup = docSet.getByLongname('Soup');
      const soup1 = docSet.getByLongname('Soup()');
      const soup2 = docSet.getByLongname('Soup(spiciness)');

      expect(soup.length).toBe(2);
      expect(soup1.length).toBe(0);
      expect(soup2.length).toBe(0);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':59,'endLine':59}","it('does not add unique longnames to constructors', () => {
      const soup = docSet.getByLongname('Soup');
      const soup1 = docSet.getByLongname('Soup()');
      const soup2 = docSet.getByLongname('Soup(spiciness)');

      expect(soup.length).toBe(2);
      expect(soup1.length).toBe(0);
      expect(soup2.length).toBe(0);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':60,'endLine':60}","it('does not add unique longnames to constructors', () => {
      const soup = docSet.getByLongname('Soup');
      const soup1 = docSet.getByLongname('Soup()');
      const soup2 = docSet.getByLongname('Soup(spiciness)');

      expect(soup.length).toBe(2);
      expect(soup1.length).toBe(0);
      expect(soup2.length).toBe(0);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':68,'endLine':68}","it('adds unique longnames to methods', () => {
      const slurp = docSet.getByLongname('Soup#slurp');
      const slurp1 = docSet.getByLongname('Soup#slurp()');
      const slurp2 = docSet.getByLongname('Soup#slurp(dBA)');

      expect(slurp.length).toBe(0);
      expect(slurp1.length).toBe(1);
      expect(slurp2.length).toBe(1);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':69,'endLine':69}","it('adds unique longnames to methods', () => {
      const slurp = docSet.getByLongname('Soup#slurp');
      const slurp1 = docSet.getByLongname('Soup#slurp()');
      const slurp2 = docSet.getByLongname('Soup#slurp(dBA)');

      expect(slurp.length).toBe(0);
      expect(slurp1.length).toBe(1);
      expect(slurp2.length).toBe(1);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':70,'endLine':70}","it('adds unique longnames to methods', () => {
      const slurp = docSet.getByLongname('Soup#slurp');
      const slurp1 = docSet.getByLongname('Soup#slurp()');
      const slurp2 = docSet.getByLongname('Soup#slurp(dBA)');

      expect(slurp.length).toBe(0);
      expect(slurp1.length).toBe(1);
      expect(slurp2.length).toBe(1);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':85,'endLine':85}","it('does not add to or change existing variations that are unique', () => {
      const salt1 = docSet.getByLongname('Soup#salt');
      const salt2 = docSet.getByLongname('Soup#salt(mg)');

      expect(salt1.length).toBe(1);
      expect(salt2.length).toBe(1);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':86,'endLine':86}","it('does not add to or change existing variations that are unique', () => {
      const salt1 = docSet.getByLongname('Soup#salt');
      const salt2 = docSet.getByLongname('Soup#salt(mg)');

      expect(salt1.length).toBe(1);
      expect(salt2.length).toBe(1);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':94,'endLine':94}","it('does not duplicate the names of existing numeric variations', () => {
      const heat1 = docSet.getByLongname('Soup#heat(1)');
      const heat2 = docSet.getByLongname('Soup#heat(2)');
      const heat3 = docSet.getByLongname('Soup#heat(3)');

      expect(heat1.length).toBe(1);
      expect(heat2.length).toBe(1);
      expect(heat3.length).toBe(1);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':95,'endLine':95}","it('does not duplicate the names of existing numeric variations', () => {
      const heat1 = docSet.getByLongname('Soup#heat(1)');
      const heat2 = docSet.getByLongname('Soup#heat(2)');
      const heat3 = docSet.getByLongname('Soup#heat(3)');

      expect(heat1.length).toBe(1);
      expect(heat2.length).toBe(1);
      expect(heat3.length).toBe(1);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':96,'endLine':96}","it('does not duplicate the names of existing numeric variations', () => {
      const heat1 = docSet.getByLongname('Soup#heat(1)');
      const heat2 = docSet.getByLongname('Soup#heat(2)');
      const heat3 = docSet.getByLongname('Soup#heat(3)');

      expect(heat1.length).toBe(1);
      expect(heat2.length).toBe(1);
      expect(heat3.length).toBe(1);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':103,'endLine':103}","it('replaces identical variations with new, unique variations', () => {
      const discard1 = docSet.getByLongname('Soup#discard()');
      const discard2 = docSet.getByLongname('Soup#discard(container)');

      expect(discard1.length).toBe(1);
      expect(discard2.length).toBe(1);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':104,'endLine':104}","it('replaces identical variations with new, unique variations', () => {
      const discard1 = docSet.getByLongname('Soup#discard()');
      const discard2 = docSet.getByLongname('Soup#discard(container)');

      expect(discard1.length).toBe(1);
      expect(discard2.length).toBe(1);
    })",snuts
/packages/jsdoc-plugins/test/specs/overload-helper.js,SubOptimalAssert,"{'startLine':118,'endLine':118}","xit('does not retain parse results between parser runs', () => {
      parser.clear();
      docSet = jsdoc.getDocSetFromFile(
        path.resolve(__dirname, '../fixtures/overload-helper.js'),
        parser
      );
      const heat = docSet.getByLongname('Soup#heat(4)');

      expect(heat.length).toBe(0);
    })",snuts
/packages/jsdoc-plugins/test/specs/comment-convert.js,SubOptimalAssert,"{'startLine':37,'endLine':37}","it('converts ///-style comments into jsdoc comments', () => {
    const doclet = docSet.getByLongname(
      'module:@jsdoc/plugins/comment-convert.handlers.beforeParse'
    );

    expect(doclet.length).toBe(1);
  })",snuts
/packages/jsdoc-plugins/test/fixtures/underscore.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/packages/jsdoc-plugins/test/fixtures/underscore.js,NonFunctionalStatement,"{'startLine':7,'endLine':7}",Unknown,snuts
/packages/jsdoc-plugins/test/fixtures/overload-helper.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/packages/jsdoc-plugins/test/fixtures/overload-helper.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/packages/jsdoc-plugins/test/fixtures/overload-helper.js,NonFunctionalStatement,"{'startLine':26,'endLine':26}",Unknown,snuts
/packages/jsdoc-plugins/test/fixtures/overload-helper.js,NonFunctionalStatement,"{'startLine':40,'endLine':40}",Unknown,snuts
/packages/jsdoc-plugins/test/fixtures/overload-helper.js,NonFunctionalStatement,"{'startLine':50,'endLine':50}",Unknown,snuts
/packages/jsdoc-plugins/test/fixtures/markdown.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/packages/jsdoc-plugins/test/fixtures/markdown.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/packages/jsdoc-plugins/test/fixtures/markdown.js,NonFunctionalStatement,"{'startLine':31,'endLine':31}",Unknown,snuts
/packages/jsdoc-core/test/specs/index.js,AnonymousTest,"{'startLine':25,'endLine':27}","it('is lib/api', () => {
      expect(core.Api).toEqual(Api);
    })",snuts
/packages/jsdoc-core/test/specs/index.js,AnonymousTest,"{'startLine':31,'endLine':33}","it('is lib/config', () => {
      expect(core.config).toEqual(config);
    })",snuts
/packages/jsdoc-core/test/specs/index.js,AnonymousTest,"{'startLine':37,'endLine':39}","it('is lib/env', () => {
      expect(core.Env).toEqual(Env);
    })",snuts
/packages/jsdoc-core/test/specs/index.js,AnonymousTest,"{'startLine':43,'endLine':45}","it('is lib/plugins', () => {
      expect(core.plugins).toEqual(plugins);
    })",snuts
/packages/jsdoc-parse/test/specs/index.js,AnonymousTest,"{'startLine':27,'endLine':29}","it('is lib/parser.createParser', () => {
      expect(parse.createParser).toEqual(createParser);
    })",snuts
/packages/jsdoc-parse/test/specs/index.js,AnonymousTest,"{'startLine':33,'endLine':35}","it('is lib/handlers', () => {
      expect(parse.handlers).toEqual(handlers);
    })",snuts
/packages/jsdoc-parse/test/specs/index.js,AnonymousTest,"{'startLine':39,'endLine':41}","it('is lib/parser.Parser', () => {
      expect(parse.Parser).toEqual(Parser);
    })",snuts
/packages/jsdoc-parse/test/specs/index.js,AnonymousTest,"{'startLine':45,'endLine':47}","it('is lib/visitor.Visitor', () => {
      expect(parse.Visitor).toEqual(Visitor);
    })",snuts
/packages/jsdoc-cli/test/specs/index.js,AnonymousTest,"{'startLine':21,'endLine':23}","it('is lib/engine', () => {
    expect(Engine).toEqual(engine);
  })",snuts
/packages/jsdoc-ast/test/specs/index.js,AnonymousTest,"{'startLine':24,'endLine':28}","it('is lib/ast-builder.AstBuilder', async () => {
      const { AstBuilder } = await import('../../lib/ast-builder.js');

      expect(ast.AstBuilder).toEqual(AstBuilder);
    })",snuts
/packages/jsdoc-ast/test/specs/index.js,AnonymousTest,"{'startLine':32,'endLine':36}","it('is lib/ast-node', async () => {
      const astNode = await import('../../lib/ast-node.js');

      expect(ast.astNode).toEqual(astNode);
    })",snuts
/packages/jsdoc-ast/test/specs/index.js,AnonymousTest,"{'startLine':40,'endLine':44}","it('is lib/syntax.Syntax', async () => {
      const { Syntax } = await import('../../lib/syntax.js');

      expect(ast.Syntax).toEqual(Syntax);
    })",snuts
/packages/jsdoc-ast/test/specs/index.js,AnonymousTest,"{'startLine':48,'endLine':52}","it('is lib/walker.Walker', async () => {
      const { Walker } = await import('../../lib/walker.js');

      expect(ast.Walker).toEqual(Walker);
    })",snuts
/packages/jsdoc-doclet/test/specs/index.js,AnonymousTest,"{'startLine':31,'endLine':33}","it('is lib/augment', () => {
      expect(doclet.augment).toEqual(augment);
    })",snuts
/packages/jsdoc-doclet/test/specs/index.js,AnonymousTest,"{'startLine':37,'endLine':39}","it('is lib/doclet.Doclet', () => {
      expect(doclet.Doclet).toEqual(Doclet);
    })",snuts
/packages/jsdoc-doclet/test/specs/index.js,AnonymousTest,"{'startLine':43,'endLine':45}","it('is lib/doclet.DocletStore', () => {
      expect(doclet.DocletStore).toEqual(DocletStore);
    })",snuts
/packages/jsdoc-doclet/test/specs/index.js,AnonymousTest,"{'startLine':49,'endLine':51}","it('is lib/package.Package', () => {
      expect(doclet.Package).toEqual(Package);
    })",snuts
/packages/jsdoc-doclet/test/specs/index.js,AnonymousTest,"{'startLine':55,'endLine':57}","it('is lib/borrow.resolveBorrows', () => {
      expect(doclet.resolveBorrows).toEqual(resolveBorrows);
    })",snuts
/packages/jsdoc-doclet/test/specs/index.js,AnonymousTest,"{'startLine':61,'endLine':63}","it('is lib/schema', () => {
      expect(doclet.schema).toEqual(schema);
    })",snuts
/packages/jsdoc/test/specs/validate.js,ConditionalTestLogic,"{'startLine':42,'endLine':47}","it('finds no validation errors in the JSDoc parse results', () => {
    jsdoc.getParseResults().forEach((doclets) => {
      const isValid = validate(doclets.doclets);

      // Hack to get the filename/errors in the test results.
      if (!isValid) {
        expect(doclets.filename).toBe('');
        expect(validate.errors).toBeEmptyArray();
      } else {
        expect(validate.errors).toBeNull();
      }
    });
  })",snuts
/packages/jsdoc/test/fixtures/yieldstag.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/yieldstag.js,NonFunctionalStatement,"{'startLine':15,'endLine':15}",Unknown,snuts
/packages/jsdoc/test/fixtures/yieldstag.js,NonFunctionalStatement,"{'startLine':22,'endLine':22}",Unknown,snuts
/packages/jsdoc/test/fixtures/versiontag.js,NonFunctionalStatement,"{'startLine':4,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/variationtag.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/packages/jsdoc/test/fixtures/variationtag.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/variationtag.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}",Unknown,snuts
/packages/jsdoc/test/fixtures/variationtag.js,NonFunctionalStatement,"{'startLine':21,'endLine':21}",Unknown,snuts
/packages/jsdoc/test/fixtures/var.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/utf8.js,NonFunctionalStatement,"{'startLine':5,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/unrestrictedtag.js,NonFunctionalStatement,"{'startLine':7,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/typetagwithnewline.js,NonFunctionalStatement,"{'startLine':2,'endLine':2}",Unknown,snuts
/packages/jsdoc/test/fixtures/typetaginline.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/packages/jsdoc/test/fixtures/typetaginline.js,NonFunctionalStatement,"{'startLine':12,'endLine':12}",Unknown,snuts
/packages/jsdoc/test/fixtures/typetaginline.js,NonFunctionalStatement,"{'startLine':19,'endLine':19}",Unknown,snuts
/packages/jsdoc/test/fixtures/typetaginline.js,NonFunctionalStatement,"{'startLine':26,'endLine':26}",Unknown,snuts
/packages/jsdoc/test/fixtures/typetaginline.js,NonFunctionalStatement,"{'startLine':35,'endLine':35}",Unknown,snuts
/packages/jsdoc/test/fixtures/typedeftag.js,NonFunctionalStatement,"{'startLine':10,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/todotag.js,NonFunctionalStatement,"{'startLine':5,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/this4.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/packages/jsdoc/test/fixtures/this4.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/templatetag.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/suppresstag.js,NonFunctionalStatement,"{'startLine':7,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/summarytag.js,NonFunctionalStatement,"{'startLine':2,'endLine':3}",Unknown,snuts
/packages/jsdoc/test/fixtures/structtag.js,NonFunctionalStatement,"{'startLine':7,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/sincetag.js,NonFunctionalStatement,"{'startLine':4,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/seetag.js,NonFunctionalStatement,"{'startLine':4,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/seetag.js,NonFunctionalStatement,"{'startLine':10,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/returnstag.js,NonFunctionalStatement,"{'startLine':4,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/returnstag.js,NonFunctionalStatement,"{'startLine':10,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/returnstag.js,NonFunctionalStatement,"{'startLine':16,'endLine':17}",Unknown,snuts
/packages/jsdoc/test/fixtures/returnstag.js,NonFunctionalStatement,"{'startLine':22,'endLine':23}",Unknown,snuts
/packages/jsdoc/test/fixtures/restparams2.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/restparams.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/restparams.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}",Unknown,snuts
/packages/jsdoc/test/fixtures/restparams.js,NonFunctionalStatement,"{'startLine':23,'endLine':23}",Unknown,snuts
/packages/jsdoc/test/fixtures/requirestag.js,NonFunctionalStatement,"{'startLine':4,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/requirestag.js,NonFunctionalStatement,"{'startLine':11,'endLine':12}",Unknown,snuts
/packages/jsdoc/test/fixtures/requirestag.js,NonFunctionalStatement,"{'startLine':19,'endLine':20}",Unknown,snuts
/packages/jsdoc/test/fixtures/publictag.js,NonFunctionalStatement,"{'startLine':7,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/protectedtag2.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/projecttag.js,NonFunctionalStatement,"{'startLine':8,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/polymertag.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtagsametype.js,NonFunctionalStatement,"{'startLine':15,'endLine':15}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtaginvalidtype.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtaginvalidtype.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtag2.js,NonFunctionalStatement,"{'startLine':7,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtag.js,NonFunctionalStatement,"{'startLine':4,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtag.js,NonFunctionalStatement,"{'startLine':10,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtag.js,NonFunctionalStatement,"{'startLine':16,'endLine':17}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtag.js,NonFunctionalStatement,"{'startLine':22,'endLine':23}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtag.js,NonFunctionalStatement,"{'startLine':28,'endLine':29}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtag.js,NonFunctionalStatement,"{'startLine':34,'endLine':35}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtag.js,NonFunctionalStatement,"{'startLine':40,'endLine':41}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtag.js,NonFunctionalStatement,"{'startLine':46,'endLine':47}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtag.js,NonFunctionalStatement,"{'startLine':50,'endLine':50}",Unknown,snuts
/packages/jsdoc/test/fixtures/paramtag.js,NonFunctionalStatement,"{'startLine':55,'endLine':55}",Unknown,snuts
/packages/jsdoc/test/fixtures/packagetag.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag2.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag2.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag2.js,NonFunctionalStatement,"{'startLine':15,'endLine':15}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag2.js,NonFunctionalStatement,"{'startLine':24,'endLine':24}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag2.js,NonFunctionalStatement,"{'startLine':31,'endLine':31}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag2.js,NonFunctionalStatement,"{'startLine':34,'endLine':34}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag2.js,NonFunctionalStatement,"{'startLine':41,'endLine':41}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag2.js,NonFunctionalStatement,"{'startLine':44,'endLine':44}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag.js,NonFunctionalStatement,"{'startLine':25,'endLine':25}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag.js,NonFunctionalStatement,"{'startLine':32,'endLine':32}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag.js,NonFunctionalStatement,"{'startLine':35,'endLine':35}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag.js,NonFunctionalStatement,"{'startLine':42,'endLine':42}",Unknown,snuts
/packages/jsdoc/test/fixtures/overridetag.js,NonFunctionalStatement,"{'startLine':45,'endLine':45}",Unknown,snuts
/packages/jsdoc/test/fixtures/objectpropertykeys.js,NonFunctionalStatement,"{'startLine':20,'endLine':20}",Unknown,snuts
/packages/jsdoc/test/fixtures/objectlit3.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/objectlit3.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/nosideeffectstag.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/noaliastag.js,NonFunctionalStatement,"{'startLine':2,'endLine':2}",Unknown,snuts
/packages/jsdoc/test/fixtures/nametag.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/namespacetag.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduletag8.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduletag8.js,NonFunctionalStatement,"{'startLine':13,'endLine':13}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduletag7.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduletag3.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduletag2.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduletag2.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduletag11.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduletag11.js,NonFunctionalStatement,"{'startLine':12,'endLine':12}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduletag10.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduleisfunction.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduleinner.js,NonFunctionalStatement,"{'startLine':7,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduleinner.js,NonFunctionalStatement,"{'startLine':13,'endLine':14}",Unknown,snuts
/packages/jsdoc/test/fixtures/moduleinner.js,NonFunctionalStatement,"{'startLine':27,'endLine':28}",Unknown,snuts
/packages/jsdoc/test/fixtures/modifiestag.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/mixintag2.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/mixintag2.js,NonFunctionalStatement,"{'startLine':30,'endLine':30}",Unknown,snuts
/packages/jsdoc/test/fixtures/mixintag2.js,NonFunctionalStatement,"{'startLine':38,'endLine':38}",Unknown,snuts
/packages/jsdoc/test/fixtures/mixintag2.js,NonFunctionalStatement,"{'startLine':41,'endLine':41}",Unknown,snuts
/packages/jsdoc/test/fixtures/mixintag2.js,NonFunctionalStatement,"{'startLine':49,'endLine':49}",Unknown,snuts
/packages/jsdoc/test/fixtures/mixintag.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/mixintag.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/mixintag.js,NonFunctionalStatement,"{'startLine':18,'endLine':19}",Unknown,snuts
/packages/jsdoc/test/fixtures/methoddefinition.js,NonFunctionalStatement,"{'startLine':3,'endLine':4}",Unknown,snuts
/packages/jsdoc/test/fixtures/methoddefinition.js,NonFunctionalStatement,"{'startLine':7,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/memberoftag5.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/memberoftag5.js,NonFunctionalStatement,"{'startLine':13,'endLine':13}",Unknown,snuts
/packages/jsdoc/test/fixtures/memberoftag4.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/memberoftag4.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}",Unknown,snuts
/packages/jsdoc/test/fixtures/memberoftag3.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/memberoftag2.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/listenstag.js,NonFunctionalStatement,"{'startLine':13,'endLine':14}",Unknown,snuts
/packages/jsdoc/test/fixtures/listenstag.js,NonFunctionalStatement,"{'startLine':19,'endLine':20}",Unknown,snuts
/packages/jsdoc/test/fixtures/linktag.js,NonFunctionalStatement,"{'startLine':8,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/linktag.js,NonFunctionalStatement,"{'startLine':14,'endLine':15}",Unknown,snuts
/packages/jsdoc/test/fixtures/letkeyword.js,NonFunctionalStatement,"{'startLine':13,'endLine':13}",Unknown,snuts
/packages/jsdoc/test/fixtures/lendsglobal.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/lendsglobal.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/lends5.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/interfacetag3.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements2.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements2.js,NonFunctionalStatement,"{'startLine':14,'endLine':14}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements2.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements.js,NonFunctionalStatement,"{'startLine':24,'endLine':24}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements.js,NonFunctionalStatement,"{'startLine':29,'endLine':29}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements.js,NonFunctionalStatement,"{'startLine':35,'endLine':35}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements.js,NonFunctionalStatement,"{'startLine':50,'endLine':50}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements.js,NonFunctionalStatement,"{'startLine':51,'endLine':51}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements.js,NonFunctionalStatement,"{'startLine':56,'endLine':56}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements.js,NonFunctionalStatement,"{'startLine':58,'endLine':58}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements.js,NonFunctionalStatement,"{'startLine':64,'endLine':64}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements.js,NonFunctionalStatement,"{'startLine':66,'endLine':66}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements.js,NonFunctionalStatement,"{'startLine':67,'endLine':67}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-implements.js,NonFunctionalStatement,"{'startLine':73,'endLine':73}",Unknown,snuts
/packages/jsdoc/test/fixtures/interface-assignment.js,NonFunctionalStatement,"{'startLine':14,'endLine':14}",Unknown,snuts
/packages/jsdoc/test/fixtures/instanceproperty.js,NonFunctionalStatement,"{'startLine':2,'endLine':2}",Unknown,snuts
/packages/jsdoc/test/fixtures/inner.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/inlineparamcomment2.js,NonFunctionalStatement,"{'startLine':2,'endLine':2}",Unknown,snuts
/packages/jsdoc/test/fixtures/inlineparamcomment.js,NonFunctionalStatement,"{'startLine':2,'endLine':2}",Unknown,snuts
/packages/jsdoc/test/fixtures/inlinecomment.js,NonFunctionalStatement,"{'startLine':1,'endLine':1}",Unknown,snuts
/packages/jsdoc/test/fixtures/inlinecomment.js,NonFunctionalStatement,"{'startLine':2,'endLine':2}",Unknown,snuts
/packages/jsdoc/test/fixtures/inheritdoctag.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/inheritdoctag.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/inheritdoctag.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}",Unknown,snuts
/packages/jsdoc/test/fixtures/inheritdoctag.js,NonFunctionalStatement,"{'startLine':25,'endLine':25}",Unknown,snuts
/packages/jsdoc/test/fixtures/inheritdoctag.js,NonFunctionalStatement,"{'startLine':32,'endLine':32}",Unknown,snuts
/packages/jsdoc/test/fixtures/inheritdoctag.js,NonFunctionalStatement,"{'startLine':35,'endLine':35}",Unknown,snuts
/packages/jsdoc/test/fixtures/inheritdoctag.js,NonFunctionalStatement,"{'startLine':42,'endLine':42}",Unknown,snuts
/packages/jsdoc/test/fixtures/inheritdoctag.js,NonFunctionalStatement,"{'startLine':45,'endLine':45}",Unknown,snuts
/packages/jsdoc/test/fixtures/implicitcasttag.js,NonFunctionalStatement,"{'startLine':1,'endLine':1}",Unknown,snuts
/packages/jsdoc/test/fixtures/ignoretag2.js,NonFunctionalStatement,"{'startLine':4,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/ignoretag.js,NonFunctionalStatement,"{'startLine':4,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/hideconstructortag.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/hideconstructortag.js,NonFunctionalStatement,"{'startLine':20,'endLine':20}",Unknown,snuts
/packages/jsdoc/test/fixtures/hideconstructortag.js,NonFunctionalStatement,"{'startLine':62,'endLine':62}",Unknown,snuts
/packages/jsdoc/test/fixtures/getset.js,NonFunctionalStatement,"{'startLine':6,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/functiontag.js,NonFunctionalStatement,"{'startLine':2,'endLine':3}",Unknown,snuts
/packages/jsdoc/test/fixtures/functiontag.js,NonFunctionalStatement,"{'startLine':6,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/file.js,NonFunctionalStatement,"{'startLine':6,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/exporttag.js,NonFunctionalStatement,"{'startLine':7,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/exporttag.js,NonFunctionalStatement,"{'startLine':14,'endLine':14}",Unknown,snuts
/packages/jsdoc/test/fixtures/exportstag7.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}",Unknown,snuts
/packages/jsdoc/test/fixtures/exportstag5.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/packages/jsdoc/test/fixtures/exportstag5.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/exportstag4.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/exportstag4.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/exportdefaultclass.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/exceptiontag.js,NonFunctionalStatement,"{'startLine':4,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/exceptiontag.js,NonFunctionalStatement,"{'startLine':11,'endLine':13}",Unknown,snuts
/packages/jsdoc/test/fixtures/exceptiontag.js,NonFunctionalStatement,"{'startLine':18,'endLine':20}",Unknown,snuts
/packages/jsdoc/test/fixtures/exceptiontag.js,NonFunctionalStatement,"{'startLine':27,'endLine':27}",Unknown,snuts
/packages/jsdoc/test/fixtures/eventfirestag.js,NonFunctionalStatement,"{'startLine':4,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/emptycomments.js,NonFunctionalStatement,"{'startLine':2,'endLine':2}",Unknown,snuts
/packages/jsdoc/test/fixtures/emptycomments.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/emptycomments.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/emptycomments.js,NonFunctionalStatement,"{'startLine':13,'endLine':13}",Unknown,snuts
/packages/jsdoc/test/fixtures/emptycomments.js,NonFunctionalStatement,"{'startLine':18,'endLine':18}",Unknown,snuts
/packages/jsdoc/test/fixtures/emptycomments.js,NonFunctionalStatement,"{'startLine':27,'endLine':27}",Unknown,snuts
/packages/jsdoc/test/fixtures/doclet.js,NonFunctionalStatement,"{'startLine':9,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/doclet.js,NonFunctionalStatement,"{'startLine':21,'endLine':23}",Unknown,snuts
/packages/jsdoc/test/fixtures/dicttag.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/deprecatedtag.js,NonFunctionalStatement,"{'startLine':3,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/deprecatedtag.js,NonFunctionalStatement,"{'startLine':9,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/defaultparams2.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/defaultparams.js,NonFunctionalStatement,"{'startLine':14,'endLine':14}",Unknown,snuts
/packages/jsdoc/test/fixtures/defaultparams.js,NonFunctionalStatement,"{'startLine':21,'endLine':21}",Unknown,snuts
/packages/jsdoc/test/fixtures/defaultparams.js,NonFunctionalStatement,"{'startLine':30,'endLine':30}",Unknown,snuts
/packages/jsdoc/test/fixtures/defaultparams.js,NonFunctionalStatement,"{'startLine':37,'endLine':37}",Unknown,snuts
/packages/jsdoc/test/fixtures/defaultparams.js,NonFunctionalStatement,"{'startLine':44,'endLine':44}",Unknown,snuts
/packages/jsdoc/test/fixtures/defaultparams.js,NonFunctionalStatement,"{'startLine':50,'endLine':50}",Unknown,snuts
/packages/jsdoc/test/fixtures/defaultparams.js,NonFunctionalStatement,"{'startLine':57,'endLine':57}",Unknown,snuts
/packages/jsdoc/test/fixtures/defaultparams.js,NonFunctionalStatement,"{'startLine':64,'endLine':64}",Unknown,snuts
/packages/jsdoc/test/fixtures/defaultparams.js,NonFunctionalStatement,"{'startLine':71,'endLine':71}",Unknown,snuts
/packages/jsdoc/test/fixtures/copyrighttag.js,NonFunctionalStatement,"{'startLine':4,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/constructstag5.js,NonFunctionalStatement,"{'startLine':8,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/constructstag5.js,NonFunctionalStatement,"{'startLine':11,'endLine':12}",Unknown,snuts
/packages/jsdoc/test/fixtures/constructstag2.js,NonFunctionalStatement,"{'startLine':6,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/constructstag2.js,NonFunctionalStatement,"{'startLine':13,'endLine':14}",Unknown,snuts
/packages/jsdoc/test/fixtures/constructstag.js,NonFunctionalStatement,"{'startLine':10,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/constructstag.js,NonFunctionalStatement,"{'startLine':17,'endLine':18}",Unknown,snuts
/packages/jsdoc/test/fixtures/constructortag.js,NonFunctionalStatement,"{'startLine':8,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/constructortag.js,NonFunctionalStatement,"{'startLine':14,'endLine':15}",Unknown,snuts
/packages/jsdoc/test/fixtures/classwithoutname.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/classtag2.js,NonFunctionalStatement,"{'startLine':12,'endLine':12}",Unknown,snuts
/packages/jsdoc/test/fixtures/classtag2.js,NonFunctionalStatement,"{'startLine':15,'endLine':15}",Unknown,snuts
/packages/jsdoc/test/fixtures/classtag2.js,NonFunctionalStatement,"{'startLine':27,'endLine':27}",Unknown,snuts
/packages/jsdoc/test/fixtures/classtag2.js,NonFunctionalStatement,"{'startLine':30,'endLine':30}",Unknown,snuts
/packages/jsdoc/test/fixtures/classtag2.js,NonFunctionalStatement,"{'startLine':49,'endLine':49}",Unknown,snuts
/packages/jsdoc/test/fixtures/classtag2.js,NonFunctionalStatement,"{'startLine':55,'endLine':55}",Unknown,snuts
/packages/jsdoc/test/fixtures/classtag.js,NonFunctionalStatement,"{'startLine':5,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/classdesctag.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/classdesctag.js,NonFunctionalStatement,"{'startLine':21,'endLine':21}",Unknown,snuts
/packages/jsdoc/test/fixtures/callbacktag.js,NonFunctionalStatement,"{'startLine':4,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/callbacktag.js,NonFunctionalStatement,"{'startLine':10,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/borrowstag3.js,NonFunctionalStatement,"{'startLine':7,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/borrowstag3.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/borrowstag2.js,NonFunctionalStatement,"{'startLine':19,'endLine':20}",Unknown,snuts
/packages/jsdoc/test/fixtures/borrowstag.js,NonFunctionalStatement,"{'startLine':12,'endLine':13}",Unknown,snuts
/packages/jsdoc/test/fixtures/authortag.js,NonFunctionalStatement,"{'startLine':4,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/authortag.js,NonFunctionalStatement,"{'startLine':9,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag6.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag6.js,NonFunctionalStatement,"{'startLine':7,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag6.js,NonFunctionalStatement,"{'startLine':13,'endLine':13}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag6.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag5.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag5.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag5.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag5.js,NonFunctionalStatement,"{'startLine':15,'endLine':15}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag5.js,NonFunctionalStatement,"{'startLine':19,'endLine':19}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag5.js,NonFunctionalStatement,"{'startLine':22,'endLine':22}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag5.js,NonFunctionalStatement,"{'startLine':30,'endLine':30}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag4.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag3.js,NonFunctionalStatement,"{'startLine':3,'endLine':4}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag3.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag3.js,NonFunctionalStatement,"{'startLine':9,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag3.js,NonFunctionalStatement,"{'startLine':12,'endLine':12}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag3.js,NonFunctionalStatement,"{'startLine':17,'endLine':18}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag2.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag.js,NonFunctionalStatement,"{'startLine':18,'endLine':18}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag.js,NonFunctionalStatement,"{'startLine':23,'endLine':23}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag.js,NonFunctionalStatement,"{'startLine':28,'endLine':28}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag.js,NonFunctionalStatement,"{'startLine':42,'endLine':42}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentstag.js,NonFunctionalStatement,"{'startLine':56,'endLine':56}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentall2.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentall2.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentall2.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentall2.js,NonFunctionalStatement,"{'startLine':24,'endLine':24}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentall2.js,NonFunctionalStatement,"{'startLine':27,'endLine':27}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentall.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentall.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentall.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentall.js,NonFunctionalStatement,"{'startLine':20,'endLine':20}",Unknown,snuts
/packages/jsdoc/test/fixtures/augmentall.js,NonFunctionalStatement,"{'startLine':27,'endLine':27}",Unknown,snuts
/packages/jsdoc/test/fixtures/asyncfunction.js,NonFunctionalStatement,"{'startLine':36,'endLine':36}",Unknown,snuts
/packages/jsdoc/test/fixtures/asyncfunction.js,NonFunctionalStatement,"{'startLine':42,'endLine':42}",Unknown,snuts
/packages/jsdoc/test/fixtures/anonymousclassparam.js,NonFunctionalStatement,"{'startLine':3,'endLine':4}",Unknown,snuts
/packages/jsdoc/test/fixtures/anonymousclassparam.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/anonymousclass.js,NonFunctionalStatement,"{'startLine':15,'endLine':15}",Unknown,snuts
/packages/jsdoc/test/fixtures/anonymousclass.js,NonFunctionalStatement,"{'startLine':18,'endLine':18}",Unknown,snuts
/packages/jsdoc/test/fixtures/aliasresolve2.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}",Unknown,snuts
/packages/jsdoc/test/fixtures/aliasresolve.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}",Unknown,snuts
/packages/jsdoc/test/fixtures/aliasglobal2.js,NonFunctionalStatement,"{'startLine':13,'endLine':14}",Unknown,snuts
/packages/jsdoc/test/fixtures/aliasglobal.js,NonFunctionalStatement,"{'startLine':4,'endLine':5}",Unknown,snuts
/packages/jsdoc/test/fixtures/aliasfores6export2.js,NonFunctionalStatement,"{'startLine':19,'endLine':19}",Unknown,snuts
/packages/jsdoc/test/fixtures/aliasfores6export2.js,NonFunctionalStatement,"{'startLine':26,'endLine':26}",Unknown,snuts
/packages/jsdoc/test/fixtures/aliasfores6export2.js,NonFunctionalStatement,"{'startLine':31,'endLine':31}",Unknown,snuts
/packages/jsdoc/test/fixtures/aliasfores6export.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/packages/jsdoc/test/fixtures/aliasexports.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/packages/jsdoc/test/fixtures/alias6.js,NonFunctionalStatement,"{'startLine':7,'endLine':7}",Unknown,snuts
/packages/jsdoc/test/fixtures/alias5.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/packages/jsdoc/test/fixtures/alias5.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/packages/jsdoc/test/fixtures/alias5.js,NonFunctionalStatement,"{'startLine':26,'endLine':26}",Unknown,snuts
/packages/jsdoc/test/fixtures/alias4.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/packages/jsdoc-task-runner/test/specs/lib/task.js,SubOptimalAssert,"{'startLine':28,'endLine':28}","it('inherits from emittery', () => {
    expect(new Task() instanceof Emittery).toBeTrue();
  })",snuts
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,AnonymousTest,"{'startLine':242,'endLine':249}","it('returns `this`', () => {
      const result = runner.addTasks({
        foo,
        bar,
      });

      expect(result).toBe(runner);
    })",snuts
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,AnonymousTest,"{'startLine':376,'endLine':383}","it('returns `this`', () => {
      let result;

      runner.addTask(foo);
      result = runner.removeTask(foo);

      expect(result).toBe(runner);
    })",snuts
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,AnonymousTest,"{'startLine':472,'endLine':476}","it('returns `this`', () => {
      runner.addTask(foo);

      expect(runner.removeTask(foo)).toBe(runner);
    })",snuts
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,IdenticalTestDescription,"{'startLine':306,'endLine':314}","it('fails if the task runner is already running', () => {
      function removeWhileRunning() {
        runner.addTasks([foo, bar]);
        runner.run();
        runner.removeTask(foo);
      }

      expect(removeWhileRunning).toThrowErrorOfType(STATE_ERROR);
    })",snuts
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,IdenticalTestDescription,"{'startLine':376,'endLine':383}","it('returns `this`', () => {
      let result;

      runner.addTask(foo);
      result = runner.removeTask(foo);

      expect(result).toBe(runner);
    })",snuts
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,IdenticalTestDescription,"{'startLine':387,'endLine':395}","it('accepts an object whose values are tasks', () => {
      function removeTasks() {
        runner.removeTasks({ foo });
      }

      runner.addTask(foo);

      expect(removeTasks).not.toThrow();
    })",snuts
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,IdenticalTestDescription,"{'startLine':397,'endLine':405}","it('fails with an object whose values are not tasks', () => {
      function removeTasks() {
        runner.removeTasks({ foo: 7 });
      }

      runner.addTask(foo);

      expect(removeTasks).toThrowErrorOfType(ARGUMENT_ERROR);
    })",snuts
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,IdenticalTestDescription,"{'startLine':407,'endLine':415}","it('accepts an array of tasks', () => {
      function removeTasks() {
        runner.removeTasks([foo]);
      }

      runner.addTask(foo);

      expect(removeTasks).not.toThrow();
    })",snuts
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,IdenticalTestDescription,"{'startLine':435,'endLine':441}","it('fails with non-object, non-array input', () => {
      function removeTasks() {
        runner.removeTasks(7);
      }

      expect(removeTasks).toThrowErrorOfType(ARGUMENT_ERROR);
    })",snuts
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,IdenticalTestDescription,"{'startLine':472,'endLine':476}","it('returns `this`', () => {
      runner.addTask(foo);

      expect(runner.removeTask(foo)).toBe(runner);
    })",snuts
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,IdenticalTestDescription,"{'startLine':548,'endLine':561}","it('fails if the task runner is already running', async () => {
      let error;

      runner.addTask(taskA);
      runner.run();

      try {
        await runner.run();
      } catch (e) {
        error = e;
      }

      expect(rethrower(error)).toThrowErrorOfType(STATE_ERROR);
    })",snuts
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,SubOptimalAssert,"{'startLine':76,'endLine':76}","it('inherits from emittery', () => {
    expect(runner instanceof Emittery).toBeTrue();
  })",snuts
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,AnonymousTest,"{'startLine':32,'endLine':34}","it('should exist', () => {
    expect(helper).toBeObject();
  })",snuts
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,GeneralFixture,"{'startLine':1320,'endLine':1320}","beforeEach(() => {
      conf = _.cloneDeep(config.templates);
    })",snuts
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,IdenticalTestDescription,"{'startLine':269,'endLine':277}","it('should not consider the same name with different letter case to be unique', () => {
      const camel = 'myJavaScriptIdentifier';
      const pascal = 'MyJavaScriptIdentifier';
      const filename = 'mercutio.html';
      const id1 = helper.getUniqueId(filename, camel);
      const id2 = helper.getUniqueId(filename, pascal);

      expect(id1.toLowerCase()).not.toBe(id2.toLowerCase());
    })",snuts
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,IdenticalTestDescription,"{'startLine':897,'endLine':902}","it('returns an empty array if the doclet has no specified type', () => {
      const doc = new Doclet('/** @function myFunction */', {}, jsdoc.env);
      const params = helper.getSignatureParams(doc);

      expect(params).toBeEmptyArray();
    })",snuts
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,IdenticalTestDescription,"{'startLine':1026,'endLine':1043}","it('uses the cssClass parameter for links if it is provided', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc, 'myCssClass');

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"" class=""myCssClass"">MyClass</a>');
      expect(returns).toContain('number');
    })",snuts
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,SubOptimalAssert,"{'startLine':723,'endLine':723}","describe('getAttribs', () => {
    let doc;
    let attribs;

    it('should return an array', () => {
      doc = new Doclet('/** ljklajsdf */', {}, jsdoc.env);
      attribs = helper.getAttribs(doc);

      expect(attribs).toBeEmptyArray();
    });

    // tests is an object of test[doclet src] = <result expected in attribs|false>
    // if false, we expect attribs to either not contain anything in whatNotToContain,
    // or be empty (if whatNotToContain was not provided).
    function doTests(tests, whatNotToContain) {
      for (const src in tests) {
        if (Object.hasOwn(tests, src)) {
          doc = new Doclet(`/** ${src} */`, {}, jsdoc.env);
          attribs = helper.getAttribs(doc);

          if (tests[src]) {
            expect(attribs).toContain(tests[src]);
          } else if (Array.isArray(whatNotToContain)) {
            for (let i = 0; i < whatNotToContain.length; ++i) {
              expect(attribs).not.toContain(whatNotToContain[i]);
            }
          } else {
            expect(attribs.length).toBe(0);
          }
        }
      }
    }

    it('should detect if a doclet is virtual', () => {
      const tests = {
        'My constant. \n @virtual': 'abstract',
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's access is not public"", () => {
      const tests = {
        '@private': 'private',
        '@access private': 'private',
        '@protected': 'protected',
        '@access protected': 'protected',
        '@public': false,
        '@access public': false,
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's scope is inner or static AND it is a function or member or constant"", () => {
      const tests = {
        // by default these are members
        '@inner': 'inner',
        '@instance': false,
        '@global': false,
        '@static': 'static',
        '@name Asdf.fdsa': 'static',
        '@name Outer~inner': 'inner',
        '@name Fdsa#asdf': false,
        '@name <global>.log': false,
        // some tests with functions and constants
        '@const Asdf#FOO': false,
        '@const Asdf\n@inner': 'inner',
        '@function Asdf#myFunction': false,
        '@function Fdsa.MyFunction': 'static',
        '@function Fdsa': false,
        // these are not functions or members or constants, they should not have their scope recorded.
        '@namespace Fdsa\n@inner': false,
        '@class asdf': false,
      };

      doTests(tests, ['inner', 'static', 'global', 'instance']);
    });

    it(""should detect if a doclet is readonly (and its kind is 'member')"", () => {
      const tests = {
        'asdf\n @readonly': 'readonly',
        asdf: false,
        '@name Fdsa#foo\n@readonly': 'readonly',
        // kind is not 'member'.
        '@const asdf\n@readonly': 'constant',
        '@function asdf\n@readonly': false,
        '@function Asdf#bar\n@readonly': false,
      };

      doTests(tests, 'readonly');
    });

    it('should detect if the doclet is a for constant', () => {
      const tests = {
        'Enum. @enum\n@constant': 'constant',
        '@function Foo#BAR\n@const': 'constant',
        '@const Asdf': 'constant',
      };

      doTests(tests, 'constant');
    });

    it('should detect if a doclet is async', () => {
      const tests = { '@async': 'async' };

      doTests(tests, 'async');
    });

    it('should detect if a doclet is a generator function', () => {
      const tests = { '@generator': 'generator' };

      doTests(tests, 'generator');
    });

    it('should detect multiple attributes', () => {
      const fdsaFoo = new Doclet(
        '/** @const module:fdsa~FOO\n@readonly\n@private */',
        {},
        jsdoc.env
      );

      attribs = helper.getAttribs(fdsaFoo);

      expect(attribs).toContain('private');
      // expect(attribs).toContain('readonly'); // kind is 'constant' not 'member'.
      expect(attribs).toContain('constant');
      expect(attribs).toContain('inner');
    });

    it('should return an empty array for null values', () => {
      let emptyAttribs;

      function getAttribs() {
        return helper.getAttribs();
      }

      expect(getAttribs).not.toThrow();

      emptyAttribs = getAttribs();

      expect(emptyAttribs).toBeEmptyArray();
    });
  })",snuts
/packages/jsdoc-salty/test/specs/lib/salty.js,AnonymousTest,"{'startLine':88,'endLine':90}","it('returns true', () => {
        expect(db.sort('a')).toBeTrue();
      })",snuts
/packages/jsdoc-tag/test/specs/lib/type.js,VerboseStatement,"{'startLine':204,'endLine':230}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",snuts
/packages/jsdoc-tag/test/specs/lib/type.js,VerboseStatement,"{'startLine':233,'endLine':261}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",snuts
/packages/jsdoc-tag/test/specs/lib/inline.js,IdenticalTestDescription,"{'startLine':92,'endLine':94}","it('allows any inline tag by default', () => {
      expect(isInlineTag('{@anyoldtag will do}')).toBeTrue();
    })",snuts
/packages/jsdoc-tag/test/specs/lib/inline.js,IdenticalTestDescription,"{'startLine':96,'endLine':98}","it('identifies things that are not inline tags when a tag name is not provided', () => {
      expect(isInlineTag('mytag hooray')).toBeFalse();
    })",snuts
/packages/jsdoc-tag/test/specs/lib/inline.js,IdenticalTestDescription,"{'startLine':100,'endLine':102}","it('allows regexp characters in the tag name', () => {
      expect(isInlineTag('{@mytags hooray}', 'mytag\\S')).toBeTrue();
    })",snuts
/packages/jsdoc-tag/test/specs/lib/inline.js,IdenticalTestDescription,"{'startLine':104,'endLine':111}","it('returns false (rather than throwing) with invalid input', () => {
      function badInput() {
        return isInlineTag();
      }

      expect(badInput).not.toThrow();
      expect(badInput()).toBeFalse();
    })",snuts
/packages/jsdoc-tag/test/specs/lib/inline.js,SubOptimalAssert,"{'startLine':233,'endLine':233}","it('processes all occurrences of a tag', () => {
      function replacer(string, { completeTag }) {
        return string.replace(completeTag, 'stuff');
      }

      const result = inline.replaceInlineTag(
        'some {@foo text} with multiple {@foo tags}, {@foo like} {@foo this}',
        'foo',
        replacer
      );

      expect(result.tags.length).toBe(4);

      expect(result.tags[0]).toBeObject();
      expect(result.tags[0].tag).toBe('foo');
      expect(result.tags[0].text).toBe('text');

      expect(result.tags[1]).toBeObject();
      expect(result.tags[1].tag).toBe('foo');
      expect(result.tags[1].text).toBe('tags');

      expect(result.tags[2]).toBeObject();
      expect(result.tags[2].tag).toBe('foo');
      expect(result.tags[2].text).toBe('like');

      expect(result.tags[3]).toBeObject();
      expect(result.tags[3].tag).toBe('foo');
      expect(result.tags[3].text).toBe('this');

      expect(result.newString).toBe('some stuff with multiple stuff, stuff stuff');
    })",snuts
/packages/jsdoc-tag/test/specs/lib/inline.js,VerboseStatement,"{'startLine':222,'endLine':252}","it('processes all occurrences of a tag', () => {
      function replacer(string, { completeTag }) {
        return string.replace(completeTag, 'stuff');
      }

      const result = inline.replaceInlineTag(
        'some {@foo text} with multiple {@foo tags}, {@foo like} {@foo this}',
        'foo',
        replacer
      );

      expect(result.tags.length).toBe(4);

      expect(result.tags[0]).toBeObject();
      expect(result.tags[0].tag).toBe('foo');
      expect(result.tags[0].text).toBe('text');

      expect(result.tags[1]).toBeObject();
      expect(result.tags[1].tag).toBe('foo');
      expect(result.tags[1].text).toBe('tags');

      expect(result.tags[2]).toBeObject();
      expect(result.tags[2].tag).toBe('foo');
      expect(result.tags[2].text).toBe('like');

      expect(result.tags[3]).toBeObject();
      expect(result.tags[3].tag).toBe('foo');
      expect(result.tags[3].text).toBe('this');

      expect(result.newString).toBe('some stuff with multiple stuff, stuff stuff');
    })",snuts
/packages/jsdoc-tag/test/specs/lib/dictionary.js,AnonymousTest,"{'startLine':67,'endLine':76}","it('adds synonyms', () => {
      const tagDef = {
        mustHaveValue: true,
        synonyms: ['bar'],
      };

      testDictionary.defineTag('foo', tagDef);

      expect(testDictionary.normalize('bar')).toBe('foo');
    })",snuts
/packages/jsdoc-tag/test/specs/lib/dictionary.js,AnonymousTest,"{'startLine':210,'endLine':216}","it('calls `lookUp`', () => {
      const lookUpSpy = spyOn(testDictionary, 'lookUp');

      testDictionary.lookup('foo');

      expect(lookUpSpy).toHaveBeenCalled();
    })",snuts
/packages/jsdoc-tag/test/specs/lib/dictionary.js,AnonymousTest,"{'startLine':238,'endLine':244}","it('calls `normalize`', () => {
      const normalizeSpy = spyOn(testDictionary, 'normalize');

      testDictionary.normalise('foo');

      expect(normalizeSpy).toHaveBeenCalled();
    })",snuts
/packages/jsdoc-name/test/specs/lib/name.js,AnonymousTest,"{'startLine':20,'endLine':22}","it('exists', () => {
    expect(name).toBeObject();
  })",snuts
/packages/jsdoc-name/test/specs/lib/name.js,AnonymousTest,"{'startLine':456,'endLine':462}","it('handles variations', () => {
      const parts = name.toParts('anim.fadein(2)');

      expect(parts.variation).toEqual('2');
      expect(parts.name).toEqual('fadein');
      expect(parts.longname).toEqual('anim.fadein(2)');
    })",snuts
/packages/jsdoc-name/test/specs/lib/name.js,IdenticalTestDescription,"{'startLine':231,'endLine':233}","it('has a GLOBAL property', () => {
        expect(SCOPE.NAMES.GLOBAL).toBeString();
      })",snuts
/packages/jsdoc-name/test/specs/lib/name.js,IdenticalTestDescription,"{'startLine':249,'endLine':251}","it('has an INNER property', () => {
        expect(SCOPE.PUNC.INNER).toBeString();
      })",snuts
/packages/jsdoc-name/test/specs/lib/name.js,IdenticalTestDescription,"{'startLine':253,'endLine':255}","it('has an INSTANCE property', () => {
        expect(SCOPE.PUNC.INSTANCE).toBeString();
      })",snuts
/packages/jsdoc-name/test/specs/lib/name.js,IdenticalTestDescription,"{'startLine':257,'endLine':259}","it('has a STATIC property', () => {
        expect(SCOPE.PUNC.STATIC).toBeString();
      })",snuts
/packages/jsdoc-name/test/specs/lib/name.js,SubOptimalAssert,"{'startLine':215,'endLine':215}","it('has the same number of properties as SCOPE_TO_PUNC', () => {
      expect(Object.keys(name.PUNC_TO_SCOPE).length).toBe(Object.keys(name.SCOPE_TO_PUNC).length);
    })",snuts
/packages/jsdoc-core/test/specs/lib/plugins.js,ConditionalTestLogic,"{'startLine':90,'endLine':92}","it('adds tags to the dictionary', async () => {
      const doclets = [];
      let pluginPath = path.resolve(__dirname, '../../fixtures/plugin-test-tags.js');

      await plugins.installPlugins([pluginPath], parser, jsdoc.env);
      parser.on('newDoclet', (e) => {
        if (e.doclet.longname === 'test') {
          doclets.push(e.doclet);
        }
      });
      jsdoc.getDocSetFromFile(
        path.resolve(__dirname, '../../fixtures/plugin-source-file.js'),
        parser
      );

      expect(doclets.length).toBe(1);
      expect(doclets[0].foo).toBeTrue();
    })",snuts
/packages/jsdoc-core/test/specs/lib/plugins.js,SubOptimalAssert,"{'startLine':80,'endLine':80}","it('adds AST node visitors to the parser', async () => {
      let pluginPath = path.resolve(__dirname, '../../fixtures/plugin-test-ast-visitor.js');
      const { nodes, init } = await import(pluginPath);

      init();

      await plugins.installPlugins([pluginPath], parser, jsdoc.env);
      jsdoc.getDocSetFromFile(
        path.resolve(__dirname, '../../fixtures/plugin-source-file.js'),
        parser
      );

      expect(nodes.length).toBe(1);
      expect(nodes[0].init.value).toBe('bar');
    })",snuts
/packages/jsdoc-core/test/specs/lib/plugins.js,SubOptimalAssert,"{'startLine':99,'endLine':99}","it('adds tags to the dictionary', async () => {
      const doclets = [];
      let pluginPath = path.resolve(__dirname, '../../fixtures/plugin-test-tags.js');

      await plugins.installPlugins([pluginPath], parser, jsdoc.env);
      parser.on('newDoclet', (e) => {
        if (e.doclet.longname === 'test') {
          doclets.push(e.doclet);
        }
      });
      jsdoc.getDocSetFromFile(
        path.resolve(__dirname, '../../fixtures/plugin-source-file.js'),
        parser
      );

      expect(doclets.length).toBe(1);
      expect(doclets[0].foo).toBeTrue();
    })",snuts
/packages/jsdoc-core/test/specs/lib/config.js,IdenticalTestDescription,"{'startLine':132,'endLine':134}","it('is an object', () => {
      expect(defaultConfig).toBeObject();
    })",snuts
/packages/jsdoc-core/test/specs/lib/config.js,IdenticalTestDescription,"{'startLine':155,'endLine':157}","it('is an object', () => {
        expect(defaultConfig.tags).toBeObject();
      })",snuts
/packages/jsdoc-core/test/specs/lib/config.js,IdenticalTestDescription,"{'startLine':173,'endLine':175}","it('is an object', () => {
        expect(defaultConfig.templates).toBeObject();
      })",snuts
/packages/jsdoc-core/test/specs/lib/config.js,IdenticalTestDescription,"{'startLine':178,'endLine':180}","it('is a boolean', () => {
          expect(defaultConfig.templates.cleverLinks).toBeBoolean();
        })",snuts
/packages/jsdoc-core/test/specs/lib/config.js,IdenticalTestDescription,"{'startLine':184,'endLine':186}","it('is a boolean', () => {
          expect(defaultConfig.templates.monospaceLinks).toBeBoolean();
        })",snuts
/packages/jsdoc-parse/test/specs/lib/parser.js,ConditionalTestLogic,"{'startLine':175,'endLine':177}","it('calls AST node visitors', () => {
        let args;
        const sourceCode = ['javascript:/** foo */var foo;'];
        const visitor = {
          visitNode(node, e) {
            if (e && e.code && !args) {
              args = Array.prototype.slice.call(arguments);
            }
          },
        };

        attachTo(parser);
        parser.addAstNodeVisitor(visitor);
        parser.parse(sourceCode);

        expect(args).toBeArrayOfSize(4);

        // args[0]: AST node
        expect(args[0].type).toBe(Syntax.VariableDeclarator);

        // args[1]: JSDoc event
        expect(args[1]).toBeObject();
        expect(args[1].code).toBeObject();
        expect(args[1].code.name).toBe('foo');

        // args[2]: parser
        expect(args[2]).toBeObject();
        expect(args[2] instanceof jsdocParser.Parser).toBeTrue();

        // args[3]: current source name
        expect(String(args[3])).toBe('[[string0]]');
      })",snuts
/packages/jsdoc-parse/test/specs/lib/parser.js,ConditionalTestLogic,"{'startLine':208,'endLine':210}","it('reflects changes made by AST node visitors', () => {
        let doclet;
        const sourceCode = ['javascript:/** foo */var foo;'];
        const visitor = {
          visitNode(node, e) {
            if (e && e.code && e.code.name === 'foo') {
              e.code.name = 'bar';
            }
          },
        };

        attachTo(parser);
        parser.addAstNodeVisitor(visitor);
        parser.parse(sourceCode);

        doclet = parser.results()[0];

        expect(doclet).toBeObject();
        expect(doclet.name).toBe('bar');
      })",snuts
/packages/jsdoc-parse/test/specs/lib/parser.js,NonFunctionalStatement,"{'startLine':375,'endLine':375}","describe('addAstNodeVisitor', () => {
      /* eslint-disable no-empty-function */
      function visitorA() {}
      function visitorB() {}
      /* eslint-enable no-empty-function */

      let visitors;

      it('works with a single node visitor', () => {
        parser.addAstNodeVisitor(visitorA);

        visitors = parser.getAstNodeVisitors();

        expect(visitors).toEqual([visitorA]);
      });

      it('works with multiple node visitors', () => {
        parser.addAstNodeVisitor(visitorA);
        parser.addAstNodeVisitor(visitorB);

        visitors = parser.getAstNodeVisitors();

        expect(visitors).toEqual([visitorA, visitorB]);
      });
    })",snuts
/packages/jsdoc-parse/test/specs/lib/parser.js,NonFunctionalStatement,"{'startLine':376,'endLine':376}","describe('addAstNodeVisitor', () => {
      /* eslint-disable no-empty-function */
      function visitorA() {}
      function visitorB() {}
      /* eslint-enable no-empty-function */

      let visitors;

      it('works with a single node visitor', () => {
        parser.addAstNodeVisitor(visitorA);

        visitors = parser.getAstNodeVisitors();

        expect(visitors).toEqual([visitorA]);
      });

      it('works with multiple node visitors', () => {
        parser.addAstNodeVisitor(visitorA);
        parser.addAstNodeVisitor(visitorB);

        visitors = parser.getAstNodeVisitors();

        expect(visitors).toEqual([visitorA, visitorB]);
      });
    })",snuts
/packages/jsdoc-parse/test/specs/lib/parser.js,SubOptimalAssert,"{'startLine':91,'endLine':91}","it('contains an appropriate visitor by default', () => {
        expect(parser.visitor instanceof Visitor).toBeTrue();
      })",snuts
/packages/jsdoc-parse/test/specs/lib/parser.js,SubOptimalAssert,"{'startLine':97,'endLine':97}","it('contains an appropriate walker by default', () => {
        expect(parser.walker instanceof Walker).toBeTrue();
      })",snuts
/packages/jsdoc-parse/test/specs/lib/parser.js,SubOptimalAssert,"{'startLine':197,'endLine':197}","it('calls AST node visitors', () => {
        let args;
        const sourceCode = ['javascript:/** foo */var foo;'];
        const visitor = {
          visitNode(node, e) {
            if (e && e.code && !args) {
              args = Array.prototype.slice.call(arguments);
            }
          },
        };

        attachTo(parser);
        parser.addAstNodeVisitor(visitor);
        parser.parse(sourceCode);

        expect(args).toBeArrayOfSize(4);

        // args[0]: AST node
        expect(args[0].type).toBe(Syntax.VariableDeclarator);

        // args[1]: JSDoc event
        expect(args[1]).toBeObject();
        expect(args[1].code).toBeObject();
        expect(args[1].code.name).toBe('foo');

        // args[2]: parser
        expect(args[2]).toBeObject();
        expect(args[2] instanceof jsdocParser.Parser).toBeTrue();

        // args[3]: current source name
        expect(String(args[3])).toBe('[[string0]]');
      })",snuts
/packages/jsdoc-parse/test/specs/lib/parser.js,VerboseStatement,"{'startLine':170,'endLine':201}","it('calls AST node visitors', () => {
        let args;
        const sourceCode = ['javascript:/** foo */var foo;'];
        const visitor = {
          visitNode(node, e) {
            if (e && e.code && !args) {
              args = Array.prototype.slice.call(arguments);
            }
          },
        };

        attachTo(parser);
        parser.addAstNodeVisitor(visitor);
        parser.parse(sourceCode);

        expect(args).toBeArrayOfSize(4);

        // args[0]: AST node
        expect(args[0].type).toBe(Syntax.VariableDeclarator);

        // args[1]: JSDoc event
        expect(args[1]).toBeObject();
        expect(args[1].code).toBeObject();
        expect(args[1].code.name).toBe('foo');

        // args[2]: parser
        expect(args[2]).toBeObject();
        expect(args[2] instanceof jsdocParser.Parser).toBeTrue();

        // args[3]: current source name
        expect(String(args[3])).toBe('[[string0]]');
      })",snuts
/packages/jsdoc-cli/test/specs/lib/engine.js,AnonymousTest,"{'startLine':30,'endLine':32}","it('exists', () => {
    expect(Engine).toBeFunction();
  })",snuts
/packages/jsdoc-cli/test/specs/lib/engine.js,AnonymousTest,"{'startLine':471,'endLine':473}","it('is lib/logger.LEVELS', () => {
      expect(Engine.LOG_LEVELS).toBe(LEVELS);
    })",snuts
/packages/jsdoc-cli/test/specs/lib/engine.js,IdenticalTestDescription,"{'startLine':389,'endLine':391}","it('works with no input', () => {
      expect(() => instance.help()).not.toThrow();
    })",snuts
/packages/jsdoc-cli/test/specs/lib/engine.js,IdenticalTestDescription,"{'startLine':581,'endLine':586}","it('returns a promise that resolves to 0', async () => {
      const instance = new Engine({ version: '1.2.3' });
      const returnValue = await instance.printVersion();

      expect(returnValue).toBe(0);
    })",snuts
/packages/jsdoc-cli/test/specs/lib/engine.js,SubOptimalAssert,"{'startLine':238,'endLine':238}","it('only dumps visible doclets by default', async () => {
      docletStore = await api.parseSourceFiles([sourceFile]);
      instance.dumpParseResults(docletStore);
      reparsedDoclets = JSON.parse(jsonDoclets);

      expect(reparsedDoclets.length).toBe(1);
      expect(reparsedDoclets[0].kind).toBe('class');
      expect(reparsedDoclets[0].name).toBe('NiceClass');
    })",snuts
/packages/jsdoc-cli/test/specs/lib/engine.js,SubOptimalAssert,"{'startLine':249,'endLine':249}","it('dumps all doclets when the `debug` option is set', async () => {
      env.opts.debug = true;
      docletStore = await api.parseSourceFiles([sourceFile]);
      instance.dumpParseResults(docletStore);
      reparsedDoclets = JSON.parse(jsonDoclets).filter((d) => d.kind === 'class');

      expect(reparsedDoclets.length).toBe(2);
      expect(reparsedDoclets[0].name).toBe('NiceClass');
      expect(reparsedDoclets[1].name).toBe('NotSoNiceClass');
    })",snuts
/packages/jsdoc-cli/test/specs/lib/engine.js,SubOptimalAssert,"{'startLine':260,'endLine':260}","it('dumps all doclets when the `verbose` option is set', async () => {
      env.opts.verbose = true;
      docletStore = await api.parseSourceFiles([sourceFile]);
      instance.dumpParseResults(docletStore);
      reparsedDoclets = JSON.parse(jsonDoclets).filter((d) => d.kind === 'class');

      expect(reparsedDoclets.length).toBe(2);
      expect(reparsedDoclets[0].name).toBe('NiceClass');
      expect(reparsedDoclets[1].name).toBe('NotSoNiceClass');
    })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':89,'endLine':91}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'bugs')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':93,'endLine':95}","it('contains the value from the package file', () => {
        checkPackageProperty('bugs', { url: 'http://example.com/bugs' });
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':99,'endLine':101}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'contributors')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':103,'endLine':110}","it('contains the value from the package file', () => {
        checkPackageProperty('contributors', [
          {
            name: 'Jane Smith',
            email: 'jsmith@example.com',
          },
        ]);
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':114,'endLine':116}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'dependencies')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':118,'endLine':120}","it('contains the value from the package file', () => {
        checkPackageProperty('dependencies', { bar: '~1.1.0' });
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':124,'endLine':126}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'description')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':128,'endLine':130}","it('contains the value from the package file', () => {
        checkPackageProperty('description', 'My package.');
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':134,'endLine':136}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'devDependencies')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':138,'endLine':140}","it('contains the value from the package file', () => {
        checkPackageProperty('devDependencies', { baz: '~3.4.5' });
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':144,'endLine':146}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'engines')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':148,'endLine':150}","it('contains the value from the package file', () => {
        checkPackageProperty('engines', { node: '>=0.10.3' });
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':166,'endLine':168}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'homepage')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':170,'endLine':172}","it('contains the value from the package file', () => {
        checkPackageProperty('homepage', 'http://example.com/');
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':176,'endLine':178}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'keywords')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':180,'endLine':182}","it('contains the value from the package file', () => {
        checkPackageProperty('keywords', ['foo', 'bar']);
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':186,'endLine':188}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'licenses')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':190,'endLine':197}","it('contains the value from the package file', () => {
        checkPackageProperty('licenses', [
          {
            type: 'My Open-Source License',
            url: 'http://example.com/oss',
          },
        ]);
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':236,'endLine':238}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'main')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':240,'endLine':242}","it('contains the value from the package file', () => {
        checkPackageProperty('main', 'foo');
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':246,'endLine':248}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'name')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':250,'endLine':252}","it('contains the value from the package file', () => {
        checkPackageProperty('name', 'foo');
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':256,'endLine':258}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'repository')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':260,'endLine':265}","it('contains the value from the package file', () => {
        checkPackageProperty('repository', {
          type: 'git',
          url: 'git@example.org:foo/bar/baz.git',
        });
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':269,'endLine':271}","it('does not exist by default', () => {
        expect(Object.hasOwn(emptyPackage, 'version')).toBeFalse();
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/package.js,IdenticalTestDescription,"{'startLine':273,'endLine':275}","it('contains the value from the package file', () => {
        checkPackageProperty('version', '0.1.2');
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet.js,AnonymousTest,"{'startLine':28,'endLine':30}","it('exists', () => {
    expect(doclet).toBeObject();
  })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet.js,ConditionalTestLogic,"{'startLine':253,'endLine':255}","it('overrides most properties of the secondary doclet', () => {
        let descriptors;
        const primaryDoclet = new Doclet(
          '/** New and improved!\n@version 2.0.0 */',
          null,
          jsdoc.env
        );
        const secondaryDoclet = new Doclet('/** Hello!\n@version 1.0.0 */', null, jsdoc.env);
        const newDoclet = Doclet.combineDoclets(primaryDoclet, secondaryDoclet);

        descriptors = Object.getOwnPropertyDescriptors(newDoclet);
        Object.keys(descriptors).forEach((property) => {
          if (!descriptors[property].enumerable) {
            return;
          }

          expect(newDoclet[property]).toEqual(primaryDoclet[property]);
        });
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet.js,ConditionalTestLogic,"{'startLine':409,'endLine':411}","it('always returns `true` based on `doclet.access` when `access` config includes `all`', () => {
          const fakeEnv = makeEnv(['all']);
          const doclets = ACCESS_VALUES.map((value) => {
            let newDoclet;
            const tags = ['@function', '@name foo'];

            if (value) {
              tags.push('@' + value);
            }
            newDoclet = makeDoclet(tags, fakeEnv);
            // Just to be sure.
            if (!value) {
              newDoclet.access = undefined;
            }

            return newDoclet;
          });

          doclets.forEach((d) => {
            expect(d.isVisible()).toBeTrue();
          });
        })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet.js,ConditionalTestLogic,"{'startLine':414,'endLine':416}","it('always returns `true` based on `doclet.access` when `access` config includes `all`', () => {
          const fakeEnv = makeEnv(['all']);
          const doclets = ACCESS_VALUES.map((value) => {
            let newDoclet;
            const tags = ['@function', '@name foo'];

            if (value) {
              tags.push('@' + value);
            }
            newDoclet = makeDoclet(tags, fakeEnv);
            // Just to be sure.
            if (!value) {
              newDoclet.access = undefined;
            }

            return newDoclet;
          });

          doclets.forEach((d) => {
            expect(d.isVisible()).toBeTrue();
          });
        })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet.js,ConditionalTestLogic,"{'startLine':554,'endLine':560}","it('sends events to the event bus when watchable properties change', () => {
          const propValues = {
            access: 'private',
            augments: ['Foo'],
            borrowed: true,
            ignore: true,
            implements: ['Foo'],
            kind: 'class',
            listens: ['event:foo'],
            longname: 'foo',
            memberof: 'foo',
            mixes: ['foo'],
            scope: 'static',
            undocumented: true,
          };
          const keys = Object.keys(propValues);

          // Make sure this test covers all watchable properties.
          expect(keys).toEqual(doclet.WATCHABLE_PROPS);

          keys.forEach((key) => {
            const newDoclet = new Doclet('/** Huzzah, a doclet! */', null, jsdoc.env);

            events = [];

            // Generates first event.
            newDoclet[key] = propValues[key];
            // Generates second event.
            newDoclet[key] = undefined;

            expect(events.length).toBe(2);

            expect(events[0]).toBeObject();
            expect(events[0].doclet).toBe(newDoclet);
            expect(events[0].property).toBe(key);
            if (key === 'kind') {
              expect(events[0].oldValue).toBe('member');
            } else if (key === 'longname') {
              expect(events[0].oldValue).toBeEmptyString();
            } else {
              expect(events[0].oldValue).toBeUndefined();
            }
            expect(events[0].newValue).toEqual(propValues[key]);

            expect(events[1]).toBeObject();
            expect(events[1].doclet).toBe(newDoclet);
            expect(events[1].property).toBe(key);
            expect(events[1].oldValue).toEqual(propValues[key]);
            expect(events[1].newValue).toBeUndefined();
          });
        })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet.js,ConditionalTestLogic,"{'startLine':556,'endLine':560}","it('sends events to the event bus when watchable properties change', () => {
          const propValues = {
            access: 'private',
            augments: ['Foo'],
            borrowed: true,
            ignore: true,
            implements: ['Foo'],
            kind: 'class',
            listens: ['event:foo'],
            longname: 'foo',
            memberof: 'foo',
            mixes: ['foo'],
            scope: 'static',
            undocumented: true,
          };
          const keys = Object.keys(propValues);

          // Make sure this test covers all watchable properties.
          expect(keys).toEqual(doclet.WATCHABLE_PROPS);

          keys.forEach((key) => {
            const newDoclet = new Doclet('/** Huzzah, a doclet! */', null, jsdoc.env);

            events = [];

            // Generates first event.
            newDoclet[key] = propValues[key];
            // Generates second event.
            newDoclet[key] = undefined;

            expect(events.length).toBe(2);

            expect(events[0]).toBeObject();
            expect(events[0].doclet).toBe(newDoclet);
            expect(events[0].property).toBe(key);
            if (key === 'kind') {
              expect(events[0].oldValue).toBe('member');
            } else if (key === 'longname') {
              expect(events[0].oldValue).toBeEmptyString();
            } else {
              expect(events[0].oldValue).toBeUndefined();
            }
            expect(events[0].newValue).toEqual(propValues[key]);

            expect(events[1]).toBeObject();
            expect(events[1].doclet).toBe(newDoclet);
            expect(events[1].property).toBe(key);
            expect(events[1].oldValue).toEqual(propValues[key]);
            expect(events[1].newValue).toBeUndefined();
          });
        })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet.js,SubOptimalAssert,"{'startLine':549,'endLine':549}","it('sends events to the event bus when watchable properties change', () => {
          const propValues = {
            access: 'private',
            augments: ['Foo'],
            borrowed: true,
            ignore: true,
            implements: ['Foo'],
            kind: 'class',
            listens: ['event:foo'],
            longname: 'foo',
            memberof: 'foo',
            mixes: ['foo'],
            scope: 'static',
            undocumented: true,
          };
          const keys = Object.keys(propValues);

          // Make sure this test covers all watchable properties.
          expect(keys).toEqual(doclet.WATCHABLE_PROPS);

          keys.forEach((key) => {
            const newDoclet = new Doclet('/** Huzzah, a doclet! */', null, jsdoc.env);

            events = [];

            // Generates first event.
            newDoclet[key] = propValues[key];
            // Generates second event.
            newDoclet[key] = undefined;

            expect(events.length).toBe(2);

            expect(events[0]).toBeObject();
            expect(events[0].doclet).toBe(newDoclet);
            expect(events[0].property).toBe(key);
            if (key === 'kind') {
              expect(events[0].oldValue).toBe('member');
            } else if (key === 'longname') {
              expect(events[0].oldValue).toBeEmptyString();
            } else {
              expect(events[0].oldValue).toBeUndefined();
            }
            expect(events[0].newValue).toEqual(propValues[key]);

            expect(events[1]).toBeObject();
            expect(events[1].doclet).toBe(newDoclet);
            expect(events[1].property).toBe(key);
            expect(events[1].oldValue).toEqual(propValues[key]);
            expect(events[1].newValue).toBeUndefined();
          });
        })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,AnonymousTest,"{'startLine':39,'endLine':41}","it('exists', () => {
    expect(docletStore).toBeObject();
  })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,OvercommentedTest,"{'startLine':1048,'endLine':1070}","it('starts listening for events if necessary', () => {
        const foo = makeDoclet(['@class', '@name Foo']);
        const bar = makeDoclet(['@class', '@name Bar']);

        expect(store.doclets).toHave(foo);
        expect(store.doclets).toHave(bar);

        // Stop listening for events.
        store.stopListening();
        // Change the doclet for `Foo` so that it's not visible.
        foo.undocumented = true;
        // Start listening for events.
        store.startListening();
        // Change the doclet for `Bar` so that it's not visible.
        bar.undocumented = true;

        // The doclet store didn't observe the change to `Foo`, but it did observe the change to
        // `Bar`. Therefore, `Foo` should be treated as if it's still visible, and `Bar` shouldn't.
        expect(store.doclets).toHave(foo);
        expect(store.unusedDoclets).not.toHave(foo);
        expect(store.doclets).not.toHave(bar);
        expect(store.unusedDoclets).toHave(bar);
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,IdenticalTestDescription,"{'startLine':422,'endLine':428}","it('contains both visible and hidden doclets', () => {
        const fooDoclet = makeDoclet(['@function', '@name foo']);
        const barDoclet = makeDoclet(['@function', '@name bar', '@ignore']);

        expect(store.allDocletsByLongname.get('foo')).toHave(fooDoclet);
        expect(store.allDocletsByLongname.get('bar')).toHave(barDoclet);
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,IdenticalTestDescription,"{'startLine':430,'endLine':449}","it('does not contain anonymous doclets that were added directly', () => {
        const anonymousDoclet = makeDoclet(['@function', `@name ${ANONYMOUS_LONGNAME}`], {
          _emitEvent: false,
          code: {
            node: {
              nodeId: 'a',
            },
          },
        });

        anonymousDoclet.longname = ANONYMOUS_LONGNAME;
        store.add(anonymousDoclet);

        makeDoclet(['@function', '@name foo']);

        // Confirm that the anonymous doclet wasn't just ignored.
        expect(store.docletsByNodeId.get('a')).toHave(anonymousDoclet);

        expect(store.allDocletsByLongname).not.toHave(ANONYMOUS_LONGNAME);
      })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,IdenticalTestDescription,"{'startLine':996,'endLine':1006}","it('marks the doclet as unused when added', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);

          doclet.undocumented = true;

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);
        })",snuts
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,IdenticalTestDescription,"{'startLine':1008,'endLine':1018}","it('marks the doclet as visible when removed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@undocumented']);

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);

          doclet.undocumented = undefined;

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);
        })",snuts
/packages/jsdoc-doclet/test/specs/lib/augment.js,AnonymousTest,"{'startLine':21,'endLine':23}","it('should exist', () => {
    expect(augment).toBeObject();
  })",snuts
/packages/jsdoc-ast/test/specs/lib/ast-node.js,AnonymousTest,"{'startLine':66,'endLine':68}","it('should exist', () => {
    expect(astNode).toBeObject();
  })",snuts
/packages/jsdoc-ast/test/specs/lib/ast-node.js,IdenticalTestDescription,"{'startLine':435,'endLine':437}","it('should return false for undefined values', () => {
      expect(astNode.isAssignment()).toBeFalse();
    })",snuts
/packages/jsdoc-ast/test/specs/lib/ast-node.js,IdenticalTestDescription,"{'startLine':439,'endLine':441}","it('should return false if the parameter is not an object', () => {
      expect(astNode.isAssignment('foo')).toBeFalse();
    })",snuts
/packages/jsdoc-ast/test/specs/lib/ast-node.js,IdenticalTestDescription,"{'startLine':479,'endLine':481}","it('should return false for undefined values', () => {
      expect(astNode.isScope()).toBeFalse();
    })",snuts
/packages/jsdoc-ast/test/specs/lib/ast-node.js,IdenticalTestDescription,"{'startLine':483,'endLine':485}","it('should return false if the parameter is not an object', () => {
      expect(astNode.isScope('foo')).toBeFalse();
    })",snuts
/packages/jsdoc-ast/test/specs/lib/ast-node.js,SubOptimalAssert,"{'startLine':116,'endLine':116}","it('returns `null` for undefined input', () => {
      expect(astNode.addNodeProperties()).toBe(null);
    })",snuts
/packages/jsdoc/test/specs/documentation/var.js,IdenticalTestDescription,"{'startLine':57,'endLine':59}","it('should have the correct name', () => {
      expect(results.name).toBe('results');
    })",snuts
/packages/jsdoc/test/specs/documentation/typetaginline.js,SubOptimalAssert,"{'startLine':22,'endLine':22}","describe('@type tag inline with function parameters', () => {
  const docSet = jsdoc.getDocSetFromFile('test/fixtures/typetaginline.js');
  let info;

  function checkParams({ params }, paramInfo) {
    expect(params).toBeDefined();
    expect(params.length).toBe(paramInfo.length);

    params.forEach(({ name, type, description }, i) => {
      expect(name).toBe(paramInfo[i].name);
      expect(type.names[0]).toBe(paramInfo[i].typeName);
      if (paramInfo[i].description !== undefined) {
        expect(description).toBe(paramInfo[i].description);
      }
    });
  }

  beforeEach(() => {
    info = [];
  });

  it('When a function parameter has an inline @type tag, the parameter type is documented', () => {
    const dispense = docSet.getByLongname('dispense')[0];

    info[0] = {
      name: 'candy',
      typeName: 'string',
    };

    checkParams(dispense, info);
  });

  it(
    'When a function parameter has a standard JSDoc comment and an inline @type tag, the docs ' +
      'reflect the standard JSDoc comment',
    () => {
      const Dispenser = docSet.getByLongname('Dispenser')[0];

      info[0] = {
        name: 'candyId',
        typeName: 'number',
        description: ""The candy's identifier."",
      };

      checkParams(Dispenser, info);
    }
  );

  it(
    'When a function accepts multiple parameters, and only the first parameter is documented ' +
      'with an inline @type tag, the function parameters are documented in the correct order',
    () => {
      const restock = docSet.getByLongname('restock')[0];

      info[0] = {
        name: 'dispenser',
        typeName: 'Dispenser',
      };
      info[1] = {
        name: 'item',
        typeName: 'string',
      };

      checkParams(restock, info);
    }
  );

  it(
    'When a function accepts multiple parameters, and only the last parameter is documented ' +
      'with an inline @type tag, the function parameters are documented in the correct order',
    () => {
      const clean = docSet.getByLongname('clean')[0];

      info[0] = {
        name: 'dispenser',
        typeName: 'Dispenser',
      };
      info[1] = {
        name: 'cleaner',
        typeName: 'string',
      };

      checkParams(clean, info);
    }
  );

  it(
    'When a function accepts multiple parameters, and a parameter in the middle is documented ' +
      'with an inline @type tag, the function parameters are documented in the correct order',
    () => {
      const paint = docSet.getByLongname('paint')[0];

      info[0] = {
        name: 'dispenser',
        typeName: 'Dispenser',
      };
      info[1] = {
        name: 'color',
        typeName: 'Color',
      };
      info[2] = {
        name: 'shade',
        typeName: 'number',
      };
      info[3] = {
        name: 'brand',
        typeName: 'string',
      };

      checkParams(paint, info);
    }
  );
})",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':41,'endLine':43}","it('should have a longname like Constructor#member', () => {
        expect(found2).toBeArrayOfSize(1);
      })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':45,'endLine':47}","it('should have a correct short name', () => {
        expect(found2[0].name).toBe('isSinging');
      })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':49,'endLine':51}","it('should have a correct memberof', () => {
        expect(found2[0].memberof).toBe('Singer');
      })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':53,'endLine':55}","it('should default to an ""instance"" scope', () => {
        expect(found2[0].scope).toBe('instance');
      })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':67,'endLine':69}","it('should have a correct short name', () => {
      expect(found[0].name).toBe('rendered');
    })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':71,'endLine':73}","it('should have a correct memberof', () => {
      expect(found[0].memberof).toBe('TemplateBuilder#Template');
    })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':75,'endLine':77}","it('should default to an ""instance"" scope', () => {
      expect(found[0].scope).toBe('instance');
    })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':88,'endLine':90}","it('should have a correct short name', () => {
      expect(found[0].name).toBe('position');
    })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':92,'endLine':94}","it('should have a correct memberof', () => {
      expect(found[0].memberof).toBeUndefined();
    })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':101,'endLine':103}","it('should have a longname like Constructor#member', () => {
      expect(found).toBeArrayOfSize(1);
    })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':118,'endLine':120}","it('should have a longname like Constructor#member', () => {
      expect(found).toBeArrayOfSize(1);
    })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':122,'endLine':124}","it('should have the correct name', () => {
      expect(found[0].name).toBe('view');
    })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':126,'endLine':128}","it('should have the correct memberof', () => {
      expect(found[0].memberof).toBe('module:template.Template');
    })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':150,'endLine':152}","it('should have a correct short name', () => {
      expect(found[0].name).toBe('heading');
    })",snuts
/packages/jsdoc/test/specs/documentation/this.js,IdenticalTestDescription,"{'startLine':154,'endLine':156}","it('should have a correct memberof', () => {
      expect(found[0].memberof).toBe('Page#parts.body');
    })",snuts
/packages/jsdoc/test/specs/documentation/quotename.js,IdenticalTestDescription,"{'startLine':31,'endLine':34}","it('should have correct name and memberof', () => {
      expect(found1.name).toBe('username');
      expect(found1.memberof).toBe('contacts.""say-\\""hello\\""@example.com""');
    })",snuts
/packages/jsdoc/test/specs/documentation/objectlit.js,IdenticalTestDescription,"{'startLine':42,'endLine':44}","it('should have a doclet with the correct longname', () => {
      expect(found).toBeArrayOfSize(1);
    })",snuts
/packages/jsdoc/test/specs/documentation/objectlit.js,IdenticalTestDescription,"{'startLine':46,'endLine':48}","it('should have a doclet with the correct name', () => {
      expect(found[0].name).toBe('x');
    })",snuts
/packages/jsdoc/test/specs/documentation/objectlit.js,IdenticalTestDescription,"{'startLine':50,'endLine':52}","it('should have the correct memberof', () => {
      expect(found[0].memberof).toBe('position.axis');
    })",snuts
/packages/jsdoc/test/specs/documentation/objectlit.js,IdenticalTestDescription,"{'startLine':54,'endLine':56}","it('should have a static scope', () => {
      expect(found[0].scope).toBe('static');
    })",snuts
/packages/jsdoc/test/specs/documentation/objectlit.js,IdenticalTestDescription,"{'startLine':70,'endLine':74}","it('should have a doclet with the correct name', () => {
      const found = loadDocSet();

      expect(found[0].name).toBe('before');
    })",snuts
/packages/jsdoc/test/specs/documentation/moduleisconstructor.js,IdenticalTestDescription,"{'startLine':70,'endLine':73}","it('should include one doclet whose kind is ""module""', () => {
      expect(modules).toBeArrayOfSize(1);
      expect(modules[0].kind).toBe('module');
    })",snuts
/packages/jsdoc/test/specs/documentation/moduleisconstructor.js,IdenticalTestDescription,"{'startLine':81,'endLine':83}","it('should include a ""description"" property that contains the constructor description', () => {
        expect(classes[0].description).toEqual('Create a new configuration.');
      })",snuts
/packages/jsdoc/test/specs/documentation/moduleisconstructor.js,IdenticalTestDescription,"{'startLine':85,'endLine':87}","it('should include a ""classdesc"" property', () => {
        expect(classes[0].classdesc).toEqual('Describe the class here.');
      })",snuts
/packages/jsdoc/test/specs/documentation/moduleisconstructor.js,IdenticalTestDescription,"{'startLine':91,'endLine':93}","it('should include a ""description"" property that contains the module description', () => {
        expect(modules[0].description).toEqual('Describe the module here.');
      })",snuts
/packages/jsdoc/test/specs/documentation/moduleisconstructor.js,IdenticalTestDescription,"{'startLine':97,'endLine':99}","it('should use the correct longname for instance properties', () => {
        expect(id.description).toBe('Document me.');
      })",snuts
/packages/jsdoc/test/specs/documentation/moduleisconstructor.js,IdenticalTestDescription,"{'startLine':101,'endLine':103}","it('should use the correct longname for instance methods', () => {
        expect(getId.description).toBe('Get the configuration ID.');
      })",snuts
/packages/jsdoc/test/specs/documentation/moduleclasses.js,IdenticalTestDescription,"{'startLine':39,'endLine':42}","it('should merge the constructor doclet with the class doclet', () => {
      expect(baz.description).toBe('Construct a Baz.');
      expect(baz.classdesc).toBe('Baz class.');
    })",snuts
/packages/jsdoc/test/specs/documentation/moduleclasses.js,IdenticalTestDescription,"{'startLine':44,'endLine':46}","it('should correctly mark the scope of instance properties', () => {
      expect(bazBaz.scope).toBe('instance');
    })",snuts
/packages/jsdoc/test/specs/documentation/lends.js,IdenticalTestDescription,"{'startLine':45,'endLine':47}","it('The member should be documented as a member of the lendee', () => {
        expect(person).toBeArrayOfSize(1);
      })",snuts
/packages/jsdoc/test/specs/documentation/lends.js,IdenticalTestDescription,"{'startLine':49,'endLine':51}","it('The this member should be documented as a member of the lendee', () => {
        expect(name).toBeArrayOfSize(1);
      })",snuts
/packages/jsdoc/test/specs/documentation/lends.js,IdenticalTestDescription,"{'startLine':59,'endLine':61}","it('The member should be documented as a member of the lendee', () => {
        expect(init).toBeArrayOfSize(1);
      })",snuts
/packages/jsdoc/test/specs/documentation/lends.js,IdenticalTestDescription,"{'startLine':63,'endLine':65}","it('The this member should be documented as a member of the lendee', () => {
        expect(name).toBeArrayOfSize(1);
      })",snuts
/packages/jsdoc/test/specs/documentation/lends.js,IdenticalTestDescription,"{'startLine':89,'endLine':93}","it('The class constructor should be documented with the name of the lendee', () => {
        expect(person).toBeObject();
        expect(person.name).toBe('Person');
        expect(person.kind).toBe('class');
      })",snuts
/packages/jsdoc/test/specs/documentation/lends.js,IdenticalTestDescription,"{'startLine':95,'endLine':97}","it(""A class' instance method should be documented as a member of the lendee"", () => {
        expect(say).toBeObject();
      })",snuts
/packages/jsdoc/test/specs/documentation/getset.js,IdenticalTestDescription,"{'startLine':51,'endLine':53}","it('should have a doclet with the correct longname', () => {
      expect(location).toBeArrayOfSize(2);
    })",snuts
/packages/jsdoc/test/specs/documentation/getset.js,IdenticalTestDescription,"{'startLine':55,'endLine':58}","it('should have a doclet with the correct name', () => {
      expect(location[0].name).toBe('location');
      expect(location[1].name).toBe('location');
    })",snuts
/packages/jsdoc/test/specs/documentation/getset.js,IdenticalTestDescription,"{'startLine':60,'endLine':63}","it('should have a doclet with the correct kind', () => {
      expect(location[0].kind).toBe('member');
      expect(location[1].kind).toBe('member');
    })",snuts
/packages/jsdoc/test/specs/documentation/getset.js,IdenticalTestDescription,"{'startLine':65,'endLine':68}","it('should have a doclet with the correct memberof', () => {
      expect(location[0].memberof).toBe('Employee');
      expect(location[1].memberof).toBe('Employee');
    })",snuts
/packages/jsdoc/test/specs/documentation/classwithoutname.js,SubOptimalAssert,"{'startLine':23,'endLine':23}","it('When the doclet for a class has an empty name, it should also have an empty longname', () => {
    expect(docSet).toBeArray();
    expect(docSet.length).toBe(1);
    expect(docSet[0].description).toBe('Create an instance of MyClass.');
    expect(docSet[0].longname).toBe('');
  })",snuts
/packages/jsdoc/test/specs/documentation/aliasfores6export.js,IdenticalTestDescription,"{'startLine':41,'endLine':47}","it('uses the alias for the class to create longnames for its methods', () => {
      const empty = docSet.getByLongname('module:fruits.Basket#empty')[0];

      expect(empty).toBeObject();
      expect(empty.memberof).toBe('module:fruits.Basket');
      expect(empty.name).toBe('empty');
    })",snuts
/packages/jsdoc/test/specs/documentation/aliasfores6export.js,IdenticalTestDescription,"{'startLine':49,'endLine':55}","it('uses the alias for the class to create longnames for its other members', () => {
      const material = docSet.getByLongname('module:fruits.Basket#material')[0];

      expect(material).toBeObject();
      expect(material.memberof).toBe('module:fruits.Basket');
      expect(material.name).toBe('material');
    })",snuts
/packages/jsdoc/test/specs/documentation/alias.js,SubOptimalAssert,"{'startLine':55,'endLine':55}","it('When a symbol is a function expression that has an alias, the symbol should get the correct longname', () => {
    const docSet = jsdoc.getDocSetFromFile('test/fixtures/alias4.js');
    const jacketClass = docSet
      .getByLongname('module:jacket')
      .filter(({ kind }) => kind === 'class');

    expect(jacketClass.length).toBe(1);
    expect(jacketClass[0].longname).toBe('module:jacket');
  })",snuts
/packages/jsdoc/test/specs/tags/typedeftag.js,IdenticalTestDescription,"{'startLine':81,'endLine':86}","it('When a comment has a @typedef tag, the doclet has a kind property set to ""typedef"".', () => {
      const docSet = jsdoc.getDocSetFromFile('test/fixtures/typedeftag2.js');
      const numberlike = docSet.getByLongname('calc.NumberLike')[0];

      expect(numberlike.kind).toBe('typedef');
    })",snuts
/packages/jsdoc/test/specs/tags/typedeftag.js,IdenticalTestDescription,"{'startLine':88,'endLine':96}","it('When a comment has a @typedef tag with a type, the doclet has a type property set to that type.', () => {
      const docSet = jsdoc.getDocSetFromFile('test/fixtures/typedeftag2.js');
      const numberlike = docSet.getByLongname('calc.NumberLike')[0];

      expect(numberlike.type).toBeObject();
      expect(numberlike.type.names).toBeArrayOfSize(2);
      expect(numberlike.type.names[0]).toBe('string');
      expect(numberlike.type.names[1]).toBe('number');
    })",snuts
/packages/jsdoc/test/specs/tags/thistag.js,IdenticalTestDescription,"{'startLine':56,'endLine':64}","it('should change the memberof for symbols like `this.foo`', () => {
      const docSet = jsdoc.getDocSetFromFile('test/fixtures/thistag2.js');
      const fooName = docSet.getByLongname('Foo#name')[0];

      expect(fooName).toBeObject();
      expect(fooName.name).toBe('name');
      expect(fooName.memberof).toBe('Foo');
      expect(fooName.scope).toBe('instance');
    })",snuts
/packages/jsdoc/test/specs/tags/publictag.js,IdenticalTestDescription,"{'startLine':39,'endLine':44}","it(""should set the doclet's `access` property to `public`"", () => {
      const docSet = jsdoc.getDocSetFromFile('test/fixtures/publictag2.js');
      const bar = docSet.getByLongname('bar')[0];

      expect(bar.access).toBe('public');
    })",snuts
/packages/jsdoc/test/specs/tags/overridetag.js,IdenticalTestDescription,"{'startLine':89,'endLine':94}","it('should cause the symbol to be documented', () => {
        const open = docSet.getByLongname('Socket#open').filter(ignored);

        expect(open).toBeArrayOfSize(1);
        expect(open[0].description).toBe('Open the connection.');
      })",snuts
/packages/jsdoc/test/specs/tags/overridetag.js,IdenticalTestDescription,"{'startLine':96,'endLine':101}","it('should use any other tags that are defined', () => {
        const close = docSet.getByLongname('Socket#close').filter(ignored)[0];

        expect(close.description).toBe('Close the socket.');
        expect(close.params).toBeArrayOfSize(1);
      })",snuts
/packages/jsdoc/test/specs/tags/moduletag.js,IdenticalTestDescription,"{'startLine':170,'endLine':176}","it('should not crash JSDoc', () => {
        function getDocSet() {
          jsdoc.getDocSetFromFile('test/fixtures/moduletag10.js');
        }

        expect(getDocSet).not.toThrow();
      })",snuts
/packages/jsdoc/test/specs/tags/exportstag.js,IdenticalTestDescription,"{'startLine':88,'endLine':90}","it('When a function symbol has an @exports tag, the module doclet does not have a scope.', () => {
      expect(html.scope).toBeUndefined();
    })",snuts
/packages/jsdoc/test/specs/tags/exportstag.js,IdenticalTestDescription,"{'startLine':109,'endLine':111}","it('When a function symbol has an @exports tag, the module doclet does not have a scope.', () => {
      expect(module.scope).toBeUndefined();
    })",snuts
/packages/jsdoc/test/specs/tags/augmentstag.js,VerboseStatement,"{'startLine':99,'endLine':115}","it('(Grand)children correctly identify the original source of inherited members', () => {
    const fooProp1 = docSet.getByLongname('Foo#prop1')[0];
    const barProp1 = docSet.getByLongname('Bar#prop1')[0];
    const barProp3 = docSet.getByLongname('Bar#prop3')[0];
    const bazProp2 = docSet.getByLongname('Baz#prop2')[0];
    const bazProp3 = docSet.getByLongname('Baz#prop3')[0];
    const bazMethod1 = docSet.getByLongname('Baz#method1')[0];
    const bazMethod2 = docSet.getByLongname('Baz#method2')[0];

    expect(fooProp1.inherits).toBeUndefined();
    expect(barProp3.inherits).toBeUndefined();
    expect(barProp1.inherits).toBe('Foo#prop1');
    expect(bazProp2.inherits).toBe('Foo#prop2');
    expect(bazProp3.inherits).toBe('Bar#prop3');
    expect(bazMethod1.inherits).toBe('Foo#method1');
    expect(bazMethod2.inherits).toBe('Bar#method2');
  })",snuts
/packages/jsdoc/test/fixtures/modules/data/mod-3.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}",Unknown,snuts
/packages/jsdoc/test/fixtures/modules/data/mod-2.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/packages/jsdoc/test/fixtures/modules/data/mod-1.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/packages/jsdoc-util/test/specs/lib/cast.js,Magic Number,"{'line': 25, 'column': 25, 'index': 845}","it('does not modify values that are not strings, objects, or arrays', () => {
    expect(cast(8)).toBe(8);
  })",steel
/packages/jsdoc-util/test/specs/lib/cast.js,Magic Number,"{'line': 46, 'column': 31, 'index': 1410}","it('casts positive number-ish strings to numbers', () => {
    expect(cast('17.35')).toBe(17.35);
  })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Conditional Test Logic,"{'line': 546, 'column': 4, 'index': 17064}","describe('@jsdoc/template-legacy/lib/templateHelper', () => {
  const { config, options } = jsdoc.env;

  helper.registerLink('test', 'path/to/test.html');

  it('should exist', () => {
    expect(helper).toBeObject();
  });

  it(""should export a 'globalName' property"", () => {
    expect(helper.globalName).toBeString();
  });

  it(""should export a 'fileExtension' property"", () => {
    expect(helper.fileExtension).toBeString();
  });

  it(""should export a 'SCOPE_TO_PUNC' property"", () => {
    expect(helper.SCOPE_TO_PUNC).toBeObject();
  });

  it(""should export a 'getUniqueFilename' function"", () => {
    expect(helper.getUniqueFilename).toBeFunction();
  });

  it(""should export a 'getUniqueId' function"", () => {
    expect(helper.getUniqueId).toBeFunction();
  });

  it(""should export a 'longnameToUrl' property"", () => {
    expect(helper.longnameToUrl).toBeObject();
  });

  it(""should export a 'linkto' function"", () => {
    expect(helper.linkto).toBeFunction();
  });

  it(""should export an 'htmlsafe' function"", () => {
    expect(helper.htmlsafe).toBeFunction();
  });

  it(""should export a 'find' function"", () => {
    expect(helper.find).toBeFunction();
  });

  it(""should export a 'getMembers' function"", () => {
    expect(helper.getMembers).toBeFunction();
  });

  it(""should export a 'getAttribs' function"", () => {
    expect(helper.getAttribs).toBeFunction();
  });

  it(""should export a 'getSignatureTypes' function"", () => {
    expect(helper.getSignatureTypes).toBeFunction();
  });

  it(""should export a 'getSignatureParams' function"", () => {
    expect(helper.getSignatureParams).toBeFunction();
  });

  it(""should export a 'getSignatureReturns' function"", () => {
    expect(helper.getSignatureReturns).toBeFunction();
  });

  it(""should export a 'getAncestors' function"", () => {
    expect(helper.getAncestors).toBeFunction();
  });

  it(""should export a 'getAncestorLinks' function"", () => {
    expect(helper.getAncestorLinks).toBeFunction();
  });

  it(""should export a 'addEventListeners' function"", () => {
    expect(helper.addEventListeners).toBeFunction();
  });

  it(""should export a 'prune' function"", () => {
    expect(helper.prune).toBeFunction();
  });

  it(""should export a 'registerLink' function"", () => {
    expect(helper.registerLink).toBeFunction();
  });

  it(""should export a 'resolveLinks' function"", () => {
    expect(helper.resolveLinks).toBeFunction();
  });

  it(""should export a 'resolveAuthorLinks' function"", () => {
    expect(helper.resolveAuthorLinks).toBeFunction();
  });

  it(""should export a 'createLink' function"", () => {
    expect(helper.createLink).toBeFunction();
  });

  it('should export a ""longnamesToTree"" function', () => {
    expect(helper.longnamesToTree).toBeFunction();
  });

  describe('globalName', () => {
    it(""should equal 'global'"", () => {
      expect(helper.globalName).toBe('global');
    });
  });

  describe('fileExtension', () => {
    it(""should equal '.html'"", () => {
      expect(helper.fileExtension).toBe('.html');
    });
  });

  describe('SCOPE_TO_PUNC', () => {
    it(""should map 'static' to '.', 'inner', to '~', 'instance' to '#'"", () => {
      expect(helper.SCOPE_TO_PUNC).toEqual({
        static: '.',
        inner: '~',
        instance: '#',
      });
    });
  });

  describe('getUniqueFilename', () => {
    afterEach(() => {
      jsdoc.restoreTagDictionary();
    });

    // TODO: needs more tests for unusual values and things that get special treatment (such as
    // inner members)
    it('should convert a simple string into the string plus the default extension', () => {
      const filename = helper.getUniqueFilename('BackusNaur', jsdoc.env);

      expect(filename).toBe('BackusNaur.html');
    });

    it('should replace slashes with underscores', () => {
      const filename = helper.getUniqueFilename('tick/tock', jsdoc.env);

      expect(filename).toBe('tick_tock.html');
    });

    it('should replace other problematic characters with underscores', () => {
      const filename = helper.getUniqueFilename('a very strange \\/?*:|\'""<> filename', jsdoc.env);

      expect(filename).toBe('a very strange __________ filename.html');
    });

    it('should not allow a filename to start with an underscore', () => {
      expect(helper.getUniqueFilename('', jsdoc.env)).toBe('-_.html');
    });

    it('should not return the same filename twice', () => {
      const name = 'polymorphic';
      const filename1 = helper.getUniqueFilename(name, jsdoc.env);
      const filename2 = helper.getUniqueFilename(name, jsdoc.env);

      expect(filename1).not.toBe(filename2);
    });

    it('should not consider the same name with different letter case to be unique', () => {
      const camel = 'myJavaScriptIdentifier';
      const pascal = 'MyJavaScriptIdentifier';
      const filename1 = helper.getUniqueFilename(camel, jsdoc.env);
      const filename2 = helper.getUniqueFilename(pascal, jsdoc.env);

      expect(filename1.toLowerCase()).not.toBe(filename2.toLowerCase());
    });

    it('should remove variations from the longname before generating the filename', () => {
      const filename = helper.getUniqueFilename('MyClass(foo, bar)', jsdoc.env);

      expect(filename).toBe('MyClass.html');
    });

    it('should generate the correct filename for built-in namespaces', () => {
      const filenameEvent = helper.getUniqueFilename('event:userDidSomething', jsdoc.env);
      const filenameExternal = helper.getUniqueFilename('external:NotInThisPackage', jsdoc.env);
      const filenameModule = helper.getUniqueFilename('module:some/sort/of/module', jsdoc.env);
      const filenamePackage = helper.getUniqueFilename(
        'package:node-solve-all-your-problems',
        jsdoc.env
      );

      expect(filenameEvent).toBe('event-userDidSomething.html');
      expect(filenameExternal).toBe('external-NotInThisPackage.html');
      expect(filenameModule).toBe('module-some_sort_of_module.html');
      expect(filenamePackage).toBe('package-node-solve-all-your-problems.html');
    });

    it('should generate the correct filename for user-specified namespaces', () => {
      const env = new Env();
      const dict = new Dictionary();
      let filename;

      dict.defineTag('anaphylaxis', {
        isNamespace: true,
      });
      env.tags = dict;

      filename = helper.getUniqueFilename('anaphylaxis:peanut', env);

      expect(filename).toBe('anaphylaxis-peanut.html');
    });
  });

  describe('getUniqueId', () => {
    it('should return the provided string in normal cases', () => {
      const id = helper.getUniqueId('futon.html', 'backrest');

      expect(id).toBe('backrest');
    });

    it('should return an empty string if no base ID is provided', () => {
      const id = helper.getUniqueId('futon.html', '');

      expect(id).toBe('');
    });

    it('should remove whitespace characters', () => {
      const id = helper.getUniqueId('futon.html', 'a very long identifier');

      expect(id).toBe('averylongidentifier');
    });

    it('should not return the same ID twice for a given file', () => {
      const filename = 'futon.html';
      const name = 'polymorphic';
      const id1 = helper.getUniqueId(filename, name);
      const id2 = helper.getUniqueId(filename, name);

      expect(id1).not.toBe(id2);
    });

    it('should allow duplicate IDs if they are in different files', () => {
      const name = 'magnificence';
      const id1 = helper.getUniqueId('supersensational.html', name);
      const id2 = helper.getUniqueId('razzledazzle.html', name);

      expect(id1).toBe(id2);
    });

    it('should not consider the same name with different letter case to be unique', () => {
      const camel = 'myJavaScriptIdentifier';
      const pascal = 'MyJavaScriptIdentifier';
      const filename = 'mercutio.html';
      const id1 = helper.getUniqueId(filename, camel);
      const id2 = helper.getUniqueId(filename, pascal);

      expect(id1.toLowerCase()).not.toBe(id2.toLowerCase());
    });
  });

  describe('longnameToUrl', () => {
    afterEach(() => {
      delete helper.longnameToUrl.foo2;
      delete helper.longnameToUrl.MySymbol;
    });

    it('is an object', () => {
      expect(typeof helper.longnameToUrl).toBe('object');
    });

    it('has an entry added into it by calling registerLink', () => {
      helper.registerLink('MySymbol', 'asdf.html');

      expect(helper.longnameToUrl.MySymbol).toBeDefined();
      expect(helper.longnameToUrl.MySymbol).toBe('asdf.html');
    });

    it('adding an entry to it allows me to link with linkto', () => {
      helper.longnameToUrl.foo2 = 'bar.html';

      expect(helper.linkto('foo2')).toBe('<a href=""bar.html"">foo2</a>');
    });
  });

  describe('linkto', () => {
    beforeEach(() => {
      helper.longnameToUrl.linktoTest = 'test.html';
      helper.longnameToUrl.LinktoFakeClass = 'fakeclass.html';
      helper.longnameToUrl['Foo#bar(baz)'] = 'foo-bar-baz.html';
    });

    afterEach(() => {
      delete helper.longnameToUrl.linktoTest;
      delete helper.longnameToUrl.LinktoFakeClass;
      delete helper.longnameToUrl['Foo#bar(baz)'];
    });

    it('returns the longname if only the longname is specified and has no URL', () => {
      const link = helper.linkto('example');

      expect(link).toBe('example');
    });

    it('returns the link text if only the link text is specified', () => {
      const link = helper.linkto(null, 'link text');

      expect(link).toBe('link text');
    });

    it(
      'returns the link text if the longname does not have a URL, and both the longname and ' +
        'link text are specified',
      () => {
        const link = helper.linkto('example', 'link text');

        expect(link).toBe('link text');
      }
    );

    it('uses the longname as the link text if no link text is provided', () => {
      const link = helper.linkto('linktoTest');

      expect(link).toBe('<a href=""test.html"">linktoTest</a>');
    });

    it('uses the link text if it is specified', () => {
      const link = helper.linkto('linktoTest', 'link text');

      expect(link).toBe('<a href=""test.html"">link text</a>');
    });

    it('includes a ""class"" attribute in the link if a class is specified', () => {
      const link = helper.linkto('linktoTest', 'link text', 'myclass');

      expect(link).toBe('<a href=""test.html"" class=""myclass"">link text</a>');
    });

    it('is careful with longnames that are reserved words in JS', () => {
      // we don't have a registered link for 'constructor' so it should return the text 'link text'.
      const link = helper.linkto('constructor', 'link text');

      expect(link).toBe('link text');
    });

    it('works correctly with type applications if only the longname is specified', () => {
      const link = helper.linkto('Array.<LinktoFakeClass>');

      expect(link).toBe('Array&lt;<a href=""fakeclass.html"">LinktoFakeClass</a>&gt;');
    });

    it('works correctly with type applications if a class is not specified', () => {
      const link = helper.linkto('Array.<LinktoFakeClass>', 'link text');

      expect(link).toBe('Array&lt;<a href=""fakeclass.html"">LinktoFakeClass</a>&gt;');
    });

    it('works correctly with type applications if a class is specified', () => {
      const link = helper.linkto('Array.<LinktoFakeClass>', 'link text', 'myclass');

      expect(link).toBe(
        'Array&lt;<a href=""fakeclass.html"" class=""myclass"">LinktoFakeClass</a>&gt;'
      );
    });

    it('works correctly with type applications that include a type union', () => {
      const link = helper.linkto('Array.<(linktoTest|LinktoFakeClass)>', 'link text');

      expect(link).toBe(
        'Array&lt;(<a href=""test.html"">linktoTest</a>|' +
          '<a href=""fakeclass.html"">LinktoFakeClass</a>)&gt;'
      );
    });

    it('works correctly with type unions that are not enclosed in parentheses', () => {
      const link = helper.linkto('linktoTest|LinktoFakeClass', 'link text');

      expect(link).toBe(
        '(<a href=""test.html"">linktoTest</a>|<a href=""fakeclass.html"">LinktoFakeClass</a>)'
      );
    });

    it('does not try to parse a longname starting with <anonymous> as a type application', () => {
      const emitter = jsdoc.env.emitter;
      const events = [];

      function storeEvent(e) {
        events.push(e);
      }

      emitter.on('logger:error', storeEvent);
      helper.linkto('<anonymous>~foo');

      expect(events).toBeEmptyArray();

      emitter.off('logger:error', storeEvent);
    });

    it('does not treat a longname with a variation as a type application', () => {
      const link = helper.linkto('Foo#bar(baz)', 'link text');

      expect(link).toBe('<a href=""foo-bar-baz.html"">link text</a>');
    });

    it('returns a link when a URL is specified', () => {
      const link = helper.linkto('http://example.com');

      expect(link).toBe('<a href=""http://example.com"">http://example.com</a>');
    });

    it('returns a link if a URL wrapped in angle brackets is specified', () => {
      const link = helper.linkto('<http://example.com>');

      expect(link).toBe('<a href=""http://example.com"">http://example.com</a>');
    });

    it('returns a link with link text if a URL and link text are specified', () => {
      const link = helper.linkto('http://example.com', 'text');

      expect(link).toBe('<a href=""http://example.com"">text</a>');
    });

    it('returns a link with a fragment ID if a URL and fragment ID are specified', () => {
      const link = helper.linkto('LinktoFakeClass', null, null, 'fragment');

      expect(link).toBe('<a href=""fakeclass.html#fragment"">LinktoFakeClass</a>');
    });

    it('returns the original text if an HTML <a> tag is specified', () => {
      const text = '<a href=""http://example.com"">text</a>';
      const link = helper.linkto(text);

      expect(link).toBe(text);
    });

    it('returns the original text if an inline {@link} tag is specified', () => {
      let link;
      const text = '{@link Foo}';

      function getLink() {
        link = helper.linkto(text);
      }

      // make sure we're not trying to parse the inline link as a type expression
      expect(getLink).not.toThrow();
      // linkto doesn't process {@link} tags
      expect(link).toBe(text);
    });
  });

  describe('htmlsafe', () => {
    it('should convert all occurences of < to &lt;', () => {
      const inp = '<h1>Potentially dangerous.</h1>';
      const out = helper.htmlsafe(inp);

      expect(out).toBe('&lt;h1>Potentially dangerous.&lt;/h1>');
    });

    it('should convert all occurrences of & to &amp;', () => {
      const input = 'foo && bar & baz;';

      expect(helper.htmlsafe(input)).toBe('foo &amp;&amp; bar &amp; baz;');
    });

    it('should not double-convert ampersands', () => {
      const input = '<h1>Foo & Friends</h1>';

      expect(helper.htmlsafe(input)).toBe('&lt;h1>Foo &amp; Friends&lt;/h1>');
    });

    it('should convert non-strings to strings', () => {
      function htmlsafe() {
        return helper.htmlsafe(false);
      }

      expect(htmlsafe).not.toThrow();
      expect(htmlsafe()).toBe('false');
    });
  });

  describe('find', () => {
    const array = [
      // match
      {
        number: 2,
        A: true,
      },
      // match
      {
        number: 1,
        A: true,
        D: 'hello',
        Q: false,
      },
      // match
      {
        number: 3,
        A: 'maybe',
        squiggle: '?',
      },
      // no match (number not in spec)
      {
        number: 4,
        A: true,
      },
      // no match (missing top-level property)
      {
        A: true,
      },
    ];
    const matches = array.slice(0, 3);
    const spec = {
      number: [1, 2, 3],
      A: [true, 'maybe'],
    };

    it('should find the requested items', () => {
      expect(helper.find(taffy(array), spec)).toEqual(matches);
    });
  });

  // Make sure arrays a and b are the same length, and that each object in
  // array b has all the properties of the corresponding object in array a
  // used for getMembers and prune tests.
  function compareObjectArrays(a, b) {
    expect(a.length).toEqual(b.length);

    for (let i = 0, l = a.length; i < l; i++) {
      for (const prop in a[i]) {
        if (Object.hasOwn(a[i], prop)) {
          expect(b[i][prop]).toBeDefined();
          expect(a[i][prop]).toEqual(b[i][prop]);
        }
      }
    }
  }
  describe('getMembers', () => {
    // instead parse a file from fixtures and verify it?
    const classes = [
      // global
      {
        kind: 'class',
      },
      // not global
      {
        kind: 'class',
        memberof: 'SomeNamespace',
      },
    ];
    const externals = [
      {
        kind: 'external',
        name: 'foo',
      },
    ];
    const events = [
      {
        kind: 'event',
      },
    ];
    const mixins = [
      {
        kind: 'mixin',
      },
    ];
    const modules = [
      {
        kind: 'module',
      },
    ];
    const namespaces = [
      {
        kind: 'namespace',
      },
    ];
    const miscGlobal = [
      {
        kind: 'function',
      },
      {
        kind: 'member',
      },
      {
        kind: 'constant',
      },
      {
        kind: 'typedef',
      },
    ];
    const miscNonGlobal = [
      {
        kind: 'constant',
        memberof: 'module:one/two',
      },
      {
        kind: 'function',
        name: 'module:foo',
        longname: 'module:foo',
      },
      {
        kind: 'member',
        name: 'module:bar',
        longname: 'module:bar',
      },
    ];
    const misc = miscGlobal.concat(miscNonGlobal);
    const array = [
      ...classes,
      ...externals,
      ...events,
      ...mixins,
      ...modules,
      ...namespaces,
      ...misc,
    ];
    const data = taffy(array);
    const members = helper.getMembers(data);

    // check the output object has properties as expected.
    it(""should have a 'classes' property"", () => {
      expect(members.classes).toBeArray();
    });

    it(""should have a 'externals' property"", () => {
      expect(members.externals).toBeArray();
    });

    it(""should have a 'events' property"", () => {
      expect(members.events).toBeArray();
    });

    it(""should have a 'globals' property"", () => {
      expect(members.globals).toBeArray();
    });

    it(""should have a 'mixins' property"", () => {
      expect(members.mixins).toBeArray();
    });

    it(""should have a 'modules' property"", () => {
      expect(members.modules).toBeArray();
    });

    it(""should have a 'namespaces' property"", () => {
      expect(members.namespaces).toBeArray();
    });

    // check that things were found properly.
    it('classes are detected', () => {
      compareObjectArrays(classes, members.classes);
    });

    it('externals are detected', () => {
      compareObjectArrays(externals, members.externals);
    });

    it('events are detected', () => {
      compareObjectArrays(events, members.events);
    });

    it('mixins are detected', () => {
      compareObjectArrays(mixins, members.mixins);
    });

    it('modules are detected', () => {
      compareObjectArrays(modules, members.modules);
    });

    it('namespaces are detected', () => {
      compareObjectArrays(namespaces, members.namespaces);
    });

    it('globals are detected', () => {
      compareObjectArrays(miscGlobal, members.globals);
    });
  });

  describe('getAttribs', () => {
    let doc;
    let attribs;

    it('should return an array', () => {
      doc = new Doclet('/** ljklajsdf */', {}, jsdoc.env);
      attribs = helper.getAttribs(doc);

      expect(attribs).toBeEmptyArray();
    });

    // tests is an object of test[doclet src] = <result expected in attribs|false>
    // if false, we expect attribs to either not contain anything in whatNotToContain,
    // or be empty (if whatNotToContain was not provided).
    function doTests(tests, whatNotToContain) {
      for (const src in tests) {
        if (Object.hasOwn(tests, src)) {
          doc = new Doclet(`/** ${src} */`, {}, jsdoc.env);
          attribs = helper.getAttribs(doc);

          if (tests[src]) {
            expect(attribs).toContain(tests[src]);
          } else if (Array.isArray(whatNotToContain)) {
            for (let i = 0; i < whatNotToContain.length; ++i) {
              expect(attribs).not.toContain(whatNotToContain[i]);
            }
          } else {
            expect(attribs.length).toBe(0);
          }
        }
      }
    }

    it('should detect if a doclet is virtual', () => {
      const tests = {
        'My constant. \n @virtual': 'abstract',
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's access is not public"", () => {
      const tests = {
        '@private': 'private',
        '@access private': 'private',
        '@protected': 'protected',
        '@access protected': 'protected',
        '@public': false,
        '@access public': false,
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's scope is inner or static AND it is a function or member or constant"", () => {
      const tests = {
        // by default these are members
        '@inner': 'inner',
        '@instance': false,
        '@global': false,
        '@static': 'static',
        '@name Asdf.fdsa': 'static',
        '@name Outer~inner': 'inner',
        '@name Fdsa#asdf': false,
        '@name <global>.log': false,
        // some tests with functions and constants
        '@const Asdf#FOO': false,
        '@const Asdf\n@inner': 'inner',
        '@function Asdf#myFunction': false,
        '@function Fdsa.MyFunction': 'static',
        '@function Fdsa': false,
        // these are not functions or members or constants, they should not have their scope recorded.
        '@namespace Fdsa\n@inner': false,
        '@class asdf': false,
      };

      doTests(tests, ['inner', 'static', 'global', 'instance']);
    });

    it(""should detect if a doclet is readonly (and its kind is 'member')"", () => {
      const tests = {
        'asdf\n @readonly': 'readonly',
        asdf: false,
        '@name Fdsa#foo\n@readonly': 'readonly',
        // kind is not 'member'.
        '@const asdf\n@readonly': 'constant',
        '@function asdf\n@readonly': false,
        '@function Asdf#bar\n@readonly': false,
      };

      doTests(tests, 'readonly');
    });

    it('should detect if the doclet is a for constant', () => {
      const tests = {
        'Enum. @enum\n@constant': 'constant',
        '@function Foo#BAR\n@const': 'constant',
        '@const Asdf': 'constant',
      };

      doTests(tests, 'constant');
    });

    it('should detect if a doclet is async', () => {
      const tests = { '@async': 'async' };

      doTests(tests, 'async');
    });

    it('should detect if a doclet is a generator function', () => {
      const tests = { '@generator': 'generator' };

      doTests(tests, 'generator');
    });

    it('should detect multiple attributes', () => {
      const fdsaFoo = new Doclet(
        '/** @const module:fdsa~FOO\n@readonly\n@private */',
        {},
        jsdoc.env
      );

      attribs = helper.getAttribs(fdsaFoo);

      expect(attribs).toContain('private');
      // expect(attribs).toContain('readonly'); // kind is 'constant' not 'member'.
      expect(attribs).toContain('constant');
      expect(attribs).toContain('inner');
    });

    it('should return an empty array for null values', () => {
      let emptyAttribs;

      function getAttribs() {
        return helper.getAttribs();
      }

      expect(getAttribs).not.toThrow();

      emptyAttribs = getAttribs();

      expect(emptyAttribs).toBeEmptyArray();
    });
  });

  describe('getSignatureTypes', () => {
    afterEach(() => {
      delete helper.longnameToUrl.MyClass;
    });

    // returns links to allowed types for a doclet.
    it('returns an empty array if the doclet has no specified type', () => {
      const doc = new Doclet('/** @const ASDF */', {}, jsdoc.env);
      const types = helper.getSignatureTypes(doc);

      expect(types).toBeEmptyArray();
    });

    it(""returns a string array of the doclet's types"", () => {
      const doc = new Doclet('/** @const {number|Array.<boolean>} ASDF */', {}, jsdoc.env);
      const types = helper.getSignatureTypes(doc);

      expect(types).toBeArrayOfSize(2);
      expect(types).toContain('number');
      expect(types).toContain('Array&lt;boolean&gt;');
    });

    it('creates links for types if relevant', () => {
      let doc;
      let types;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet('/** @const {MyClass} ASDF */', {}, jsdoc.env);
      types = helper.getSignatureTypes(doc);

      expect(types).toBeArrayOfSize(1);
      expect(types).toContain('<a href=""MyClass.html"">MyClass</a>');
    });

    it('uses the cssClass parameter for links if it is provided', () => {
      let doc;
      let types;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet('/** @const {MyClass} ASDF */', {}, jsdoc.env);
      types = helper.getSignatureTypes(doc, 'myCSSClass');

      expect(types).toBeArrayOfSize(1);
      expect(types).toContain('<a href=""MyClass.html"" class=""myCSSClass"">MyClass</a>');
    });
  });

  describe('getSignatureParams', () => {
    // retrieves parameter names.
    // if css class is provided, optional parameters are wrapped in a <span> with that class.
    it('returns an empty array if the doclet has no specified type', () => {
      const doc = new Doclet('/** @function myFunction */', {}, jsdoc.env);
      const params = helper.getSignatureParams(doc);

      expect(params).toBeEmptyArray();
    });

    it(""returns a string array of the doclet's parameter names"", () => {
      const doc = new Doclet(
        '/** @function myFunction\n @param {string} foo - asdf. */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc);

      expect(params).toBeArrayOfSize(1);
      expect(params).toContain('foo');
    });

    it('wraps optional parameters in <span class=..> if optClass is provided', () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc, 'cssClass');

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('<span class=""cssClass"">bar</span>');
      expect(params).toContain('<span class=""cssClass"">baz</span>');
    });

    it(""doesn't wrap optional parameters in <span class=..> if optClass is not provided"", () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc);

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('bar');
      expect(params).toContain('baz');
    });
  });

  describe('getSignatureReturns', () => {
    afterEach(() => {
      delete helper.longnameToUrl.MyClass;
    });

    it('returns a value with correctly escaped HTML', () => {
      const mockDoclet = {
        returns: [
          {
            type: {
              names: ['Array.<string>'],
            },
          },
        ],
      };
      const html = helper.getSignatureReturns(mockDoclet);

      expect(html).not.toContain('Array<string>');
      expect(html).toContain('Array&lt;string&gt;');
    });

    it('returns an empty array if the doclet has no returns', () => {
      const doc = new Doclet('/** @function myFunction */', {}, jsdoc.env);
      const returns = helper.getSignatureReturns(doc);

      expect(returns).toBeEmptyArray();
    });

    it('returns an empty array if the doclet has @returns but with no type', () => {
      const doc = new Doclet(
        '/** @function myFunction\n@returns an interesting result.*/',
        {},
        jsdoc.env
      );
      const returns = helper.getSignatureReturns(doc);

      expect(returns).toBeEmptyArray();
    });

    it('uses the value of the `yields` property', () => {
      const doc = new Doclet('/** @yields {string} A string. */', {}, jsdoc.env);
      const html = helper.getSignatureReturns(doc);

      expect(html).toContain('string');
    });

    it('prefers `yields` over `returns`', () => {
      const doc = new Doclet('/** @yields {string}\n@returns {number} */', {}, jsdoc.env);
      const html = helper.getSignatureReturns(doc);

      expect(html).toContain('string');
      expect(html).not.toContain('number');
    });

    it('creates links for return types if relevant', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc);

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"">MyClass</a>');
      expect(returns).toContain('number');
    });

    it('uses the cssClass parameter for links if it is provided', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc, 'myCssClass');

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"" class=""myCssClass"">MyClass</a>');
      expect(returns).toContain('number');
    });
  });

  // TODO: getAncestors tests

  describe('getAncestorLinks', () => {
    // make a hierarchy.
    const lackeys = new Doclet(
      '/** @member lackeys\n@memberof module:mafia/gangs.Sharks~Henchman\n@instance*/',
      {},
      jsdoc.env
    );
    const henchman = new Doclet(
      '/** @class Henchman\n@memberof module:mafia/gangs.Sharks\n@inner */',
      {},
      jsdoc.env
    );
    const gang = new Doclet('/** @namespace module:mafia/gangs.Sharks */', {}, jsdoc.env);
    const mafia = new Doclet('/** @module mafia/gangs */', {}, jsdoc.env);
    const data = taffy([lackeys, henchman, gang, mafia]);

    afterEach(() => {
      delete helper.longnameToUrl['module:mafia/gangs'];
      delete helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'];
    });

    // register some links
    it('returns an empty array if there are no ancestors', () => {
      const links = helper.getAncestorLinks(data, mafia);

      expect(links).toBeEmptyArray();
    });

    it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    });

    it('adds links if they exist', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"">mafia/gangs</a>');
    });

    it('adds cssClass to any link', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys, 'myClass');

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"" class=""myClass"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"" class=""myClass"">mafia/gangs</a>');
    });
  });

  describe('addEventListeners', () => {
    const docSet = jsdoc.getDocSetFromFile('test/fixtures/listenstag.js');
    const doclets = taffy(_.cloneDeep(docSet.doclets));
    const ev = helper.find(doclets, { longname: 'module:myModule.event:MyEvent' })[0];
    const ev2 = helper.find(doclets, { longname: 'module:myModule~Events.event:Event2' })[0];
    const ev3 = helper.find(doclets, { longname: 'module:myModule#event:Event3' })[0];

    helper.addEventListeners(doclets);

    it(""adds a 'listeners' array to events with the longnames of the listeners"", () => {
      expect(ev.listeners).toBeArrayOfSize(2);
      expect(ev.listeners).toContain('module:myModule~MyHandler');
      expect(ev.listeners).toContain('module:myModule~AnotherHandler');

      expect(ev2.listeners).toBeArrayOfSize(1);
      expect(ev2.listeners).toContain('module:myModule~MyHandler');
    });

    it('does not add listeners for events with no listeners', () => {
      expect(ev3.listeners).toBeUndefined();
    });

    it('does not make spurious doclets if something @listens to a non-existent symbol', () => {
      expect(helper.find(doclets, { longname: 'event:fakeEvent' })).toBeEmptyArray();
    });
  });

  describe('prune', () => {
    const access = options.access;
    const priv = Boolean(options.private);

    afterEach(() => {
      options.access = access;
      options.private = priv;
    });

    const array = [
      // keep
      { undocumented: false },
      // keep
      { ignore: false },
      // keep
      { memberof: 'SomeClass' },
      // prune
      { undocumented: true },
      // prune
      { ignore: true },
      // prune
      { memberof: '<anonymous>' },
    ];
    const keep = [
      // keep
      { undocumented: false },
      // keep
      { ignore: false },
      // keep
      { memberof: 'SomeClass' },
    ];
    const arrayPrivate = [
      // prune (unless options.private is truthy)
      { access: 'private' },
    ];
    const arrayMixed = [
      { access: 'package' },
      { access: 'public' },
      { asdf: true },
      { access: 'protected' },
      { access: 'private' },
    ];

    it('should prune the correct members', () => {
      const pruned = helper.prune(taffy(array), jsdoc.env)().get();

      compareObjectArrays(keep, pruned);
    });

    it('should prune private members if options.private is falsy', () => {
      let pruned;

      options.private = false;
      pruned = helper.prune(taffy(arrayPrivate), jsdoc.env)().get();

      compareObjectArrays([], pruned);
    });

    it('should only keep package-private members if options.access only contains ""package""', () => {
      let pruned;
      const keepPackage = [{ access: 'package' }];

      options.access = 'package';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPackage, pruned);
    });

    it('should only keep public members if options.access only contains ""public""', () => {
      let pruned;
      const keepPublic = [{ access: 'public' }];

      options.access = 'public';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPublic, pruned);
    });

    it('should only keep undefined members if options.access only contains ""undefined""', () => {
      let pruned;
      const keepUndefined = [{ asdf: true }];

      options.access = 'undefined';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepUndefined, pruned);
    });

    it('should only keep protected members if options.access only contains ""protected""', () => {
      let pruned;
      const keepProtected = [{ access: 'protected' }];

      options.access = 'protected';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepProtected, pruned);
    });

    it('should only keep private members if options.access only contains ""private""', () => {
      let pruned;
      const keepPrivate = [{ access: 'private' }];

      options.access = 'private';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPrivate, pruned);
    });

    it('should keep public and protected members if options.access contains ""public"" and ""protected""', () => {
      let pruned;
      const keepPublicProtected = [
        {
          access: 'public',
        },
        {
          access: 'protected',
        },
      ];

      options.access = ['public', 'protected'];
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPublicProtected, pruned);
    });

    it('should keep everything if options.access contains ""all""', () => {
      let pruned;

      options.access = 'all';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(arrayMixed, pruned);
    });

    it('should not prune private members if options.private is truthy', () => {
      let pruned;

      options.private = true;
      pruned = helper.prune(taffy(arrayPrivate), jsdoc.env)().get();

      compareObjectArrays(arrayPrivate, pruned);
    });
  });

  describe('registerLink', () => {
    afterEach(() => {
      delete helper.longnameToUrl.MySymbol;
    });

    it('adds an entry to exports.longnameToUrl', () => {
      helper.longnameToUrl.MySymbol = 'asdf.html';

      expect(helper.longnameToUrl.MySymbol).toBe('asdf.html');
    });

    it('allows linkto to work', () => {
      helper.registerLink('MySymbol', 'asdf.html');

      expect(helper.linkto('MySymbol')).toBe('<a href=""asdf.html"">MySymbol</a>');
    });
  });

  describe('resolveLinks', () => {
    let conf;

    beforeEach(() => {
      conf = _.cloneDeep(config.templates);
    });

    afterEach(() => {
      config.templates = conf;
      delete helper.longnameToUrl['my.long.namespace'];
    });

    it('should translate {@link test} into a HTML link.', () => {
      const input = 'This is a {@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test</a>.');
    });

    it('should translate {@link unknown} into a simple text.', () => {
      const input = 'This is a {@link unknown}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a unknown.');
    });

    it('should translate {@link test} into a HTML links multiple times.', () => {
      const input = 'This is a {@link test} and {@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe(
        'This is a <a href=""path/to/test.html"">test</a> and <a href=""path/to/test.html"">test</a>.'
      );
    });

    it('should translate [hello there]{@link test} into a HTML link with the custom content.', () => {
      const input = 'This is a [hello there]{@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">hello there</a>.');
    });

    it('should translate [dummy text] and [hello there]{@link test} into an HTML link with the custom content.', () => {
      const input = 'This is [dummy text] and [hello there]{@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is [dummy text] and <a href=""path/to/test.html"">hello there</a>.');
    });

    it('should translate [dummy text] and [more] and [hello there]{@link test} into an HTML link with the custom content.', () => {
      const input = 'This is [dummy text] and [more] and [hello there]{@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe(
        'This is [dummy text] and [more] and <a href=""path/to/test.html"">hello there</a>.'
      );
    });

    it('should ignore [hello there].', () => {
      const input = 'This is a [hello there].';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe(input);
    });

    it('should translate http links in the tag', () => {
      const input = 'Link to {@link http://github.com}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""http://github.com"">http://github.com</a>');
    });

    it('should translate ftp links in the tag', () => {
      const input = 'Link to {@link ftp://foo.bar}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""ftp://foo.bar"">ftp://foo.bar</a>');
    });

    it('should allow pipe to be used as delimiter between href and text (external link)', () => {
      const input = 'Link to {@link http://github.com|Github}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""http://github.com"">Github</a>');
    });

    it('should allow pipe to be used as delimiter between href and text (symbol link)', () => {
      const input = 'Link to {@link test|Test}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">Test</a>');
    });

    it('should not add spaces to the href or text when there are spaces around the pipe', () => {
      const input = 'Link to {@link test | Test}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">Test</a>');
    });

    it('should allow first space to be used as delimiter between href and text (external link)', () => {
      const input = 'Link to {@link http://github.com Github}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""http://github.com"">Github</a>');
    });

    it('should allow first space to be used as delimiter between href and text (symbol link)', () => {
      const input = 'Link to {@link test My Caption}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">My Caption</a>');
    });

    it('if pipe and space are present in link tag, use pipe as the delimiter', () => {
      const input = 'Link to {@link test|My Caption}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">My Caption</a>');
    });

    it('Test of {@linkcode } which should be in monospace', () => {
      const input = 'Link to {@linkcode test}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    it('Test of {@linkplain } which should be in normal font', () => {
      const input = 'Link to {@linkplain test}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">test</a>');
    });

    it('should be careful with linking to links whose names are reserved JS keywords', () => {
      const input = 'Link to {@link constructor}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to constructor');
    });

    it('should allow linebreaks between link tag and content', () => {
      const input = 'This is a {@link\ntest}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test</a>.');
    });

    it('should allow linebreaks to separate url from link text', () => {
      const input = 'This is a {@link\ntest\ntest}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test</a>.');
    });

    it('should normalize additional newlines to spaces', () => {
      const input = 'This is a {@link\ntest\ntest\n\ntest}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test test</a>.');
    });

    it('should allow tabs between link tag and content', () => {
      const input = 'This is a {@link\ttest}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test</a>.');
    });

    // conf.monospaceLinks. check that
    // a) it works
    it('if conf.monospaceLinks is true, all {@link} should be monospace', () => {
      const input = 'Link to {@link test}';
      let output;

      config.templates.monospaceLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    // b) linkcode and linkplain are still respected
    it('if conf.monospaceLinks is true, all {@linkcode} should still be monospace', () => {
      const input = 'Link to {@linkcode test}';
      let output;

      config.templates.monospaceLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    it('if conf.monospaceLinks is true, all {@linkplain} should still be plain', () => {
      const input = 'Link to {@linkplain test}';
      let output;

      config.templates.monospaceLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">test</a>');
    });

    // conf.cleverLinks. check that
    // a) it works
    it('if conf.cleverLinks is true, {@link symbol} should be in monospace', () => {
      const input = 'Link to {@link test}';
      let output;

      config.templates.cleverLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    it('if conf.cleverLinks is true, {@link URL} should be in plain text', () => {
      const input = 'Link to {@link http://github.com}';
      let output;

      config.templates.cleverLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""http://github.com"">http://github.com</a>');
    });

    // b) linkcode and linkplain are still respected
    it('if conf.cleverLinks is true, all {@linkcode} should still be clever', () => {
      const input = 'Link to {@linkcode test}';
      let output;

      config.templates.cleverLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    it('if conf.cleverLinks is true, all {@linkplain} should still be plain', () => {
      const input = 'Link to {@linkplain test}';
      let output;

      config.templates.cleverLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">test</a>');
    });

    // c) if monospaceLinks is additionally `true` it is ignored in favour
    //    of cleverLinks
    it('if conf.cleverLinks is true and so is conf.monospaceLinks, cleverLinks overrides', () => {
      const input = 'Link to {@link test} and {@link http://github.com}';
      let output;

      config.templates.cleverLinks = true;
      config.templates.monospaceLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe(
        'Link to <a href=""path/to/test.html""><code>test</code></a> and ' +
          '<a href=""http://github.com"">http://github.com</a>'
      );
    });

    it('if conf.useShortNamesInLinks is true, it uses the short name in links', () => {
      const input = 'Link to {@link my.long.namespace}';
      let output;

      config.templates.useShortNamesInLinks = true;
      helper.registerLink('my.long.namespace', 'asdf.html');
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""asdf.html"">namespace</a>');
    });
  });

  describe('createLink', () => {
    it('should create a url for a simple global.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'foo',
        name: 'foo',
        scope: 'global',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toBe('global.html#foo');
    });

    it('should create a url for a namespace.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'namespace',
        longname: 'foo',
        name: 'foo',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toBe('foo.html');
    });

    it('should create a url for a member of a namespace.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'ns.foo',
        name: 'foo',
        memberof: 'ns',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toBe('ns.html#foo');
    });

    const nestedNamespaceDoclet = {
      env: jsdoc.env,
      kind: 'function',
      longname: 'ns1.ns2.foo',
      name: 'foo',
      memberof: 'ns1.ns2',
    };
    let nestedNamespaceUrl;

    it('should create a url for a member of a nested namespace.', () => {
      nestedNamespaceUrl = helper.createLink(nestedNamespaceDoclet, jsdoc.env);

      expect(nestedNamespaceUrl).toBe('ns1.ns2.html#foo');
    });

    it('should return the same value when called twice with the same doclet.', () => {
      const newUrl = helper.createLink(nestedNamespaceDoclet, jsdoc.env);

      expect(newUrl).toBe(nestedNamespaceUrl);
    });

    it('should create a url for a name with invalid characters.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'ns1.""!"".""*foo""',
        name: '""*foo""',
        memberof: 'ns1.""!""',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toEqual('ns1._!_.html#%22*foo%22');
    });

    it('should create a url for a function that is the only symbol exported by a module.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'module:bar',
        name: 'module:bar',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toEqual('module-bar.html');
    });

    it('should create a url for a doclet with the wrong kind (caused by incorrect JSDoc tags', () => {
      const moduleDoclet = {
        env: jsdoc.env,
        kind: 'module',
        longname: 'module:baz',
        name: 'module:baz',
      };
      const badDoclet = {
        env: jsdoc.env,
        kind: 'member',
        longname: 'module:baz',
        name: 'module:baz',
      };
      const moduleDocletUrl = helper.createLink(moduleDoclet, jsdoc.env);
      const badDocletUrl = helper.createLink(badDoclet, jsdoc.env);

      expect(moduleDocletUrl).toBe('module-baz.html');
      expect(badDocletUrl).toBe('module-baz.html');
    });

    it('should create a url for a function that is a member of a doclet with the wrong kind', () => {
      const badModuleDoclet = {
        env: jsdoc.env,
        kind: 'member',
        longname: 'module:qux',
        name: 'module:qux',
      };
      const memberDoclet = {
        env: jsdoc.env,
        kind: 'function',
        name: 'frozzle',
        memberof: 'module:qux',
        scope: 'instance',
        longname: 'module:qux#frozzle',
      };
      const badModuleDocletUrl = helper.createLink(badModuleDoclet, jsdoc.env);
      const memberDocletUrl = helper.createLink(memberDoclet, jsdoc.env);

      expect(badModuleDocletUrl).toBe('module-qux.html');
      expect(memberDocletUrl).toBe('module-qux.html#frozzle');
    });

    it('should include the scope punctuation in the fragment ID for static members', () => {
      const functionDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'Milk.pasteurize',
        name: 'pasteurize',
        memberof: 'Milk',
        scope: 'static',
      };
      const docletUrl = helper.createLink(functionDoclet, jsdoc.env);

      expect(docletUrl).toBe('Milk.html#.pasteurize');
    });

    it('should include the scope punctuation in the fragment ID for inner members', () => {
      const functionDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'Milk~removeSticksAndLeaves',
        name: 'removeSticksAndLeaves',
        memberof: 'Milk',
        scope: 'inner',
      };
      const docletUrl = helper.createLink(functionDoclet, jsdoc.env);

      expect(docletUrl).toBe('Milk.html#~removeSticksAndLeaves');
    });

    it('should omit the scope punctuation from the fragment ID for instance members', () => {
      const propertyDoclet = {
        env: jsdoc.env,
        kind: 'member',
        longname: 'Milk#calcium',
        name: 'calcium',
        memberof: 'Milk',
        scope: 'instance',
      };
      const docletUrl = helper.createLink(propertyDoclet, jsdoc.env);

      expect(docletUrl).toBe('Milk.html#calcium');
    });

    it('should include the variation, if present, in the fragment ID', () => {
      const variationDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'Milk#fat(percent)',
        name: 'fat',
        memberof: 'Milk',
        scope: 'instance',
        variation: '(percent)',
      };
      const docletUrl = helper.createLink(variationDoclet, jsdoc.env);

      expect(docletUrl).toBe('Milk.html#fat(percent)');
    });
  });

  describe('resolveAuthorLinks', () => {
    it('should not crash JSDoc if no text is specified', () => {
      function resolve() {
        helper.resolveAuthorLinks();
      }

      expect(resolve).not.toThrow();
    });

    // convert Jane Doe <jdoe@example.org> to a mailto link.
    it('should convert email addresses in angle brackets *after* a name to mailto links', () => {
      const str = ' John Doe  <asdf.fdsa-2@gmail.com> ';
      const out = helper.resolveAuthorLinks(str);

      expect(out).toBe('<a href=""mailto:asdf.fdsa-2@gmail.com"">John Doe</a>');
    });

    it('should HTML-safe author names', () => {
      const str = ' John<Doe  <asdf.fdsa-2@gmail.com> ';
      const out = helper.resolveAuthorLinks(str);

      expect(out).toBe(`<a href=""mailto:asdf.fdsa-2@gmail.com"">${helper.htmlsafe('John<Doe')}</a>`);
    });

    it('should simply return the input string, HTML-safe, if no email is detected', () => {
      const str = 'John Doe <dummy>';
      const out = helper.resolveAuthorLinks(str);

      expect(out).toBe(helper.htmlsafe(str));
    });
  });

  // TODO: longnamesToTree tests
})",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Conditional Test Logic,"{'line': 547, 'column': 6, 'index': 17114}","describe('@jsdoc/template-legacy/lib/templateHelper', () => {
  const { config, options } = jsdoc.env;

  helper.registerLink('test', 'path/to/test.html');

  it('should exist', () => {
    expect(helper).toBeObject();
  });

  it(""should export a 'globalName' property"", () => {
    expect(helper.globalName).toBeString();
  });

  it(""should export a 'fileExtension' property"", () => {
    expect(helper.fileExtension).toBeString();
  });

  it(""should export a 'SCOPE_TO_PUNC' property"", () => {
    expect(helper.SCOPE_TO_PUNC).toBeObject();
  });

  it(""should export a 'getUniqueFilename' function"", () => {
    expect(helper.getUniqueFilename).toBeFunction();
  });

  it(""should export a 'getUniqueId' function"", () => {
    expect(helper.getUniqueId).toBeFunction();
  });

  it(""should export a 'longnameToUrl' property"", () => {
    expect(helper.longnameToUrl).toBeObject();
  });

  it(""should export a 'linkto' function"", () => {
    expect(helper.linkto).toBeFunction();
  });

  it(""should export an 'htmlsafe' function"", () => {
    expect(helper.htmlsafe).toBeFunction();
  });

  it(""should export a 'find' function"", () => {
    expect(helper.find).toBeFunction();
  });

  it(""should export a 'getMembers' function"", () => {
    expect(helper.getMembers).toBeFunction();
  });

  it(""should export a 'getAttribs' function"", () => {
    expect(helper.getAttribs).toBeFunction();
  });

  it(""should export a 'getSignatureTypes' function"", () => {
    expect(helper.getSignatureTypes).toBeFunction();
  });

  it(""should export a 'getSignatureParams' function"", () => {
    expect(helper.getSignatureParams).toBeFunction();
  });

  it(""should export a 'getSignatureReturns' function"", () => {
    expect(helper.getSignatureReturns).toBeFunction();
  });

  it(""should export a 'getAncestors' function"", () => {
    expect(helper.getAncestors).toBeFunction();
  });

  it(""should export a 'getAncestorLinks' function"", () => {
    expect(helper.getAncestorLinks).toBeFunction();
  });

  it(""should export a 'addEventListeners' function"", () => {
    expect(helper.addEventListeners).toBeFunction();
  });

  it(""should export a 'prune' function"", () => {
    expect(helper.prune).toBeFunction();
  });

  it(""should export a 'registerLink' function"", () => {
    expect(helper.registerLink).toBeFunction();
  });

  it(""should export a 'resolveLinks' function"", () => {
    expect(helper.resolveLinks).toBeFunction();
  });

  it(""should export a 'resolveAuthorLinks' function"", () => {
    expect(helper.resolveAuthorLinks).toBeFunction();
  });

  it(""should export a 'createLink' function"", () => {
    expect(helper.createLink).toBeFunction();
  });

  it('should export a ""longnamesToTree"" function', () => {
    expect(helper.longnamesToTree).toBeFunction();
  });

  describe('globalName', () => {
    it(""should equal 'global'"", () => {
      expect(helper.globalName).toBe('global');
    });
  });

  describe('fileExtension', () => {
    it(""should equal '.html'"", () => {
      expect(helper.fileExtension).toBe('.html');
    });
  });

  describe('SCOPE_TO_PUNC', () => {
    it(""should map 'static' to '.', 'inner', to '~', 'instance' to '#'"", () => {
      expect(helper.SCOPE_TO_PUNC).toEqual({
        static: '.',
        inner: '~',
        instance: '#',
      });
    });
  });

  describe('getUniqueFilename', () => {
    afterEach(() => {
      jsdoc.restoreTagDictionary();
    });

    // TODO: needs more tests for unusual values and things that get special treatment (such as
    // inner members)
    it('should convert a simple string into the string plus the default extension', () => {
      const filename = helper.getUniqueFilename('BackusNaur', jsdoc.env);

      expect(filename).toBe('BackusNaur.html');
    });

    it('should replace slashes with underscores', () => {
      const filename = helper.getUniqueFilename('tick/tock', jsdoc.env);

      expect(filename).toBe('tick_tock.html');
    });

    it('should replace other problematic characters with underscores', () => {
      const filename = helper.getUniqueFilename('a very strange \\/?*:|\'""<> filename', jsdoc.env);

      expect(filename).toBe('a very strange __________ filename.html');
    });

    it('should not allow a filename to start with an underscore', () => {
      expect(helper.getUniqueFilename('', jsdoc.env)).toBe('-_.html');
    });

    it('should not return the same filename twice', () => {
      const name = 'polymorphic';
      const filename1 = helper.getUniqueFilename(name, jsdoc.env);
      const filename2 = helper.getUniqueFilename(name, jsdoc.env);

      expect(filename1).not.toBe(filename2);
    });

    it('should not consider the same name with different letter case to be unique', () => {
      const camel = 'myJavaScriptIdentifier';
      const pascal = 'MyJavaScriptIdentifier';
      const filename1 = helper.getUniqueFilename(camel, jsdoc.env);
      const filename2 = helper.getUniqueFilename(pascal, jsdoc.env);

      expect(filename1.toLowerCase()).not.toBe(filename2.toLowerCase());
    });

    it('should remove variations from the longname before generating the filename', () => {
      const filename = helper.getUniqueFilename('MyClass(foo, bar)', jsdoc.env);

      expect(filename).toBe('MyClass.html');
    });

    it('should generate the correct filename for built-in namespaces', () => {
      const filenameEvent = helper.getUniqueFilename('event:userDidSomething', jsdoc.env);
      const filenameExternal = helper.getUniqueFilename('external:NotInThisPackage', jsdoc.env);
      const filenameModule = helper.getUniqueFilename('module:some/sort/of/module', jsdoc.env);
      const filenamePackage = helper.getUniqueFilename(
        'package:node-solve-all-your-problems',
        jsdoc.env
      );

      expect(filenameEvent).toBe('event-userDidSomething.html');
      expect(filenameExternal).toBe('external-NotInThisPackage.html');
      expect(filenameModule).toBe('module-some_sort_of_module.html');
      expect(filenamePackage).toBe('package-node-solve-all-your-problems.html');
    });

    it('should generate the correct filename for user-specified namespaces', () => {
      const env = new Env();
      const dict = new Dictionary();
      let filename;

      dict.defineTag('anaphylaxis', {
        isNamespace: true,
      });
      env.tags = dict;

      filename = helper.getUniqueFilename('anaphylaxis:peanut', env);

      expect(filename).toBe('anaphylaxis-peanut.html');
    });
  });

  describe('getUniqueId', () => {
    it('should return the provided string in normal cases', () => {
      const id = helper.getUniqueId('futon.html', 'backrest');

      expect(id).toBe('backrest');
    });

    it('should return an empty string if no base ID is provided', () => {
      const id = helper.getUniqueId('futon.html', '');

      expect(id).toBe('');
    });

    it('should remove whitespace characters', () => {
      const id = helper.getUniqueId('futon.html', 'a very long identifier');

      expect(id).toBe('averylongidentifier');
    });

    it('should not return the same ID twice for a given file', () => {
      const filename = 'futon.html';
      const name = 'polymorphic';
      const id1 = helper.getUniqueId(filename, name);
      const id2 = helper.getUniqueId(filename, name);

      expect(id1).not.toBe(id2);
    });

    it('should allow duplicate IDs if they are in different files', () => {
      const name = 'magnificence';
      const id1 = helper.getUniqueId('supersensational.html', name);
      const id2 = helper.getUniqueId('razzledazzle.html', name);

      expect(id1).toBe(id2);
    });

    it('should not consider the same name with different letter case to be unique', () => {
      const camel = 'myJavaScriptIdentifier';
      const pascal = 'MyJavaScriptIdentifier';
      const filename = 'mercutio.html';
      const id1 = helper.getUniqueId(filename, camel);
      const id2 = helper.getUniqueId(filename, pascal);

      expect(id1.toLowerCase()).not.toBe(id2.toLowerCase());
    });
  });

  describe('longnameToUrl', () => {
    afterEach(() => {
      delete helper.longnameToUrl.foo2;
      delete helper.longnameToUrl.MySymbol;
    });

    it('is an object', () => {
      expect(typeof helper.longnameToUrl).toBe('object');
    });

    it('has an entry added into it by calling registerLink', () => {
      helper.registerLink('MySymbol', 'asdf.html');

      expect(helper.longnameToUrl.MySymbol).toBeDefined();
      expect(helper.longnameToUrl.MySymbol).toBe('asdf.html');
    });

    it('adding an entry to it allows me to link with linkto', () => {
      helper.longnameToUrl.foo2 = 'bar.html';

      expect(helper.linkto('foo2')).toBe('<a href=""bar.html"">foo2</a>');
    });
  });

  describe('linkto', () => {
    beforeEach(() => {
      helper.longnameToUrl.linktoTest = 'test.html';
      helper.longnameToUrl.LinktoFakeClass = 'fakeclass.html';
      helper.longnameToUrl['Foo#bar(baz)'] = 'foo-bar-baz.html';
    });

    afterEach(() => {
      delete helper.longnameToUrl.linktoTest;
      delete helper.longnameToUrl.LinktoFakeClass;
      delete helper.longnameToUrl['Foo#bar(baz)'];
    });

    it('returns the longname if only the longname is specified and has no URL', () => {
      const link = helper.linkto('example');

      expect(link).toBe('example');
    });

    it('returns the link text if only the link text is specified', () => {
      const link = helper.linkto(null, 'link text');

      expect(link).toBe('link text');
    });

    it(
      'returns the link text if the longname does not have a URL, and both the longname and ' +
        'link text are specified',
      () => {
        const link = helper.linkto('example', 'link text');

        expect(link).toBe('link text');
      }
    );

    it('uses the longname as the link text if no link text is provided', () => {
      const link = helper.linkto('linktoTest');

      expect(link).toBe('<a href=""test.html"">linktoTest</a>');
    });

    it('uses the link text if it is specified', () => {
      const link = helper.linkto('linktoTest', 'link text');

      expect(link).toBe('<a href=""test.html"">link text</a>');
    });

    it('includes a ""class"" attribute in the link if a class is specified', () => {
      const link = helper.linkto('linktoTest', 'link text', 'myclass');

      expect(link).toBe('<a href=""test.html"" class=""myclass"">link text</a>');
    });

    it('is careful with longnames that are reserved words in JS', () => {
      // we don't have a registered link for 'constructor' so it should return the text 'link text'.
      const link = helper.linkto('constructor', 'link text');

      expect(link).toBe('link text');
    });

    it('works correctly with type applications if only the longname is specified', () => {
      const link = helper.linkto('Array.<LinktoFakeClass>');

      expect(link).toBe('Array&lt;<a href=""fakeclass.html"">LinktoFakeClass</a>&gt;');
    });

    it('works correctly with type applications if a class is not specified', () => {
      const link = helper.linkto('Array.<LinktoFakeClass>', 'link text');

      expect(link).toBe('Array&lt;<a href=""fakeclass.html"">LinktoFakeClass</a>&gt;');
    });

    it('works correctly with type applications if a class is specified', () => {
      const link = helper.linkto('Array.<LinktoFakeClass>', 'link text', 'myclass');

      expect(link).toBe(
        'Array&lt;<a href=""fakeclass.html"" class=""myclass"">LinktoFakeClass</a>&gt;'
      );
    });

    it('works correctly with type applications that include a type union', () => {
      const link = helper.linkto('Array.<(linktoTest|LinktoFakeClass)>', 'link text');

      expect(link).toBe(
        'Array&lt;(<a href=""test.html"">linktoTest</a>|' +
          '<a href=""fakeclass.html"">LinktoFakeClass</a>)&gt;'
      );
    });

    it('works correctly with type unions that are not enclosed in parentheses', () => {
      const link = helper.linkto('linktoTest|LinktoFakeClass', 'link text');

      expect(link).toBe(
        '(<a href=""test.html"">linktoTest</a>|<a href=""fakeclass.html"">LinktoFakeClass</a>)'
      );
    });

    it('does not try to parse a longname starting with <anonymous> as a type application', () => {
      const emitter = jsdoc.env.emitter;
      const events = [];

      function storeEvent(e) {
        events.push(e);
      }

      emitter.on('logger:error', storeEvent);
      helper.linkto('<anonymous>~foo');

      expect(events).toBeEmptyArray();

      emitter.off('logger:error', storeEvent);
    });

    it('does not treat a longname with a variation as a type application', () => {
      const link = helper.linkto('Foo#bar(baz)', 'link text');

      expect(link).toBe('<a href=""foo-bar-baz.html"">link text</a>');
    });

    it('returns a link when a URL is specified', () => {
      const link = helper.linkto('http://example.com');

      expect(link).toBe('<a href=""http://example.com"">http://example.com</a>');
    });

    it('returns a link if a URL wrapped in angle brackets is specified', () => {
      const link = helper.linkto('<http://example.com>');

      expect(link).toBe('<a href=""http://example.com"">http://example.com</a>');
    });

    it('returns a link with link text if a URL and link text are specified', () => {
      const link = helper.linkto('http://example.com', 'text');

      expect(link).toBe('<a href=""http://example.com"">text</a>');
    });

    it('returns a link with a fragment ID if a URL and fragment ID are specified', () => {
      const link = helper.linkto('LinktoFakeClass', null, null, 'fragment');

      expect(link).toBe('<a href=""fakeclass.html#fragment"">LinktoFakeClass</a>');
    });

    it('returns the original text if an HTML <a> tag is specified', () => {
      const text = '<a href=""http://example.com"">text</a>';
      const link = helper.linkto(text);

      expect(link).toBe(text);
    });

    it('returns the original text if an inline {@link} tag is specified', () => {
      let link;
      const text = '{@link Foo}';

      function getLink() {
        link = helper.linkto(text);
      }

      // make sure we're not trying to parse the inline link as a type expression
      expect(getLink).not.toThrow();
      // linkto doesn't process {@link} tags
      expect(link).toBe(text);
    });
  });

  describe('htmlsafe', () => {
    it('should convert all occurences of < to &lt;', () => {
      const inp = '<h1>Potentially dangerous.</h1>';
      const out = helper.htmlsafe(inp);

      expect(out).toBe('&lt;h1>Potentially dangerous.&lt;/h1>');
    });

    it('should convert all occurrences of & to &amp;', () => {
      const input = 'foo && bar & baz;';

      expect(helper.htmlsafe(input)).toBe('foo &amp;&amp; bar &amp; baz;');
    });

    it('should not double-convert ampersands', () => {
      const input = '<h1>Foo & Friends</h1>';

      expect(helper.htmlsafe(input)).toBe('&lt;h1>Foo &amp; Friends&lt;/h1>');
    });

    it('should convert non-strings to strings', () => {
      function htmlsafe() {
        return helper.htmlsafe(false);
      }

      expect(htmlsafe).not.toThrow();
      expect(htmlsafe()).toBe('false');
    });
  });

  describe('find', () => {
    const array = [
      // match
      {
        number: 2,
        A: true,
      },
      // match
      {
        number: 1,
        A: true,
        D: 'hello',
        Q: false,
      },
      // match
      {
        number: 3,
        A: 'maybe',
        squiggle: '?',
      },
      // no match (number not in spec)
      {
        number: 4,
        A: true,
      },
      // no match (missing top-level property)
      {
        A: true,
      },
    ];
    const matches = array.slice(0, 3);
    const spec = {
      number: [1, 2, 3],
      A: [true, 'maybe'],
    };

    it('should find the requested items', () => {
      expect(helper.find(taffy(array), spec)).toEqual(matches);
    });
  });

  // Make sure arrays a and b are the same length, and that each object in
  // array b has all the properties of the corresponding object in array a
  // used for getMembers and prune tests.
  function compareObjectArrays(a, b) {
    expect(a.length).toEqual(b.length);

    for (let i = 0, l = a.length; i < l; i++) {
      for (const prop in a[i]) {
        if (Object.hasOwn(a[i], prop)) {
          expect(b[i][prop]).toBeDefined();
          expect(a[i][prop]).toEqual(b[i][prop]);
        }
      }
    }
  }
  describe('getMembers', () => {
    // instead parse a file from fixtures and verify it?
    const classes = [
      // global
      {
        kind: 'class',
      },
      // not global
      {
        kind: 'class',
        memberof: 'SomeNamespace',
      },
    ];
    const externals = [
      {
        kind: 'external',
        name: 'foo',
      },
    ];
    const events = [
      {
        kind: 'event',
      },
    ];
    const mixins = [
      {
        kind: 'mixin',
      },
    ];
    const modules = [
      {
        kind: 'module',
      },
    ];
    const namespaces = [
      {
        kind: 'namespace',
      },
    ];
    const miscGlobal = [
      {
        kind: 'function',
      },
      {
        kind: 'member',
      },
      {
        kind: 'constant',
      },
      {
        kind: 'typedef',
      },
    ];
    const miscNonGlobal = [
      {
        kind: 'constant',
        memberof: 'module:one/two',
      },
      {
        kind: 'function',
        name: 'module:foo',
        longname: 'module:foo',
      },
      {
        kind: 'member',
        name: 'module:bar',
        longname: 'module:bar',
      },
    ];
    const misc = miscGlobal.concat(miscNonGlobal);
    const array = [
      ...classes,
      ...externals,
      ...events,
      ...mixins,
      ...modules,
      ...namespaces,
      ...misc,
    ];
    const data = taffy(array);
    const members = helper.getMembers(data);

    // check the output object has properties as expected.
    it(""should have a 'classes' property"", () => {
      expect(members.classes).toBeArray();
    });

    it(""should have a 'externals' property"", () => {
      expect(members.externals).toBeArray();
    });

    it(""should have a 'events' property"", () => {
      expect(members.events).toBeArray();
    });

    it(""should have a 'globals' property"", () => {
      expect(members.globals).toBeArray();
    });

    it(""should have a 'mixins' property"", () => {
      expect(members.mixins).toBeArray();
    });

    it(""should have a 'modules' property"", () => {
      expect(members.modules).toBeArray();
    });

    it(""should have a 'namespaces' property"", () => {
      expect(members.namespaces).toBeArray();
    });

    // check that things were found properly.
    it('classes are detected', () => {
      compareObjectArrays(classes, members.classes);
    });

    it('externals are detected', () => {
      compareObjectArrays(externals, members.externals);
    });

    it('events are detected', () => {
      compareObjectArrays(events, members.events);
    });

    it('mixins are detected', () => {
      compareObjectArrays(mixins, members.mixins);
    });

    it('modules are detected', () => {
      compareObjectArrays(modules, members.modules);
    });

    it('namespaces are detected', () => {
      compareObjectArrays(namespaces, members.namespaces);
    });

    it('globals are detected', () => {
      compareObjectArrays(miscGlobal, members.globals);
    });
  });

  describe('getAttribs', () => {
    let doc;
    let attribs;

    it('should return an array', () => {
      doc = new Doclet('/** ljklajsdf */', {}, jsdoc.env);
      attribs = helper.getAttribs(doc);

      expect(attribs).toBeEmptyArray();
    });

    // tests is an object of test[doclet src] = <result expected in attribs|false>
    // if false, we expect attribs to either not contain anything in whatNotToContain,
    // or be empty (if whatNotToContain was not provided).
    function doTests(tests, whatNotToContain) {
      for (const src in tests) {
        if (Object.hasOwn(tests, src)) {
          doc = new Doclet(`/** ${src} */`, {}, jsdoc.env);
          attribs = helper.getAttribs(doc);

          if (tests[src]) {
            expect(attribs).toContain(tests[src]);
          } else if (Array.isArray(whatNotToContain)) {
            for (let i = 0; i < whatNotToContain.length; ++i) {
              expect(attribs).not.toContain(whatNotToContain[i]);
            }
          } else {
            expect(attribs.length).toBe(0);
          }
        }
      }
    }

    it('should detect if a doclet is virtual', () => {
      const tests = {
        'My constant. \n @virtual': 'abstract',
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's access is not public"", () => {
      const tests = {
        '@private': 'private',
        '@access private': 'private',
        '@protected': 'protected',
        '@access protected': 'protected',
        '@public': false,
        '@access public': false,
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's scope is inner or static AND it is a function or member or constant"", () => {
      const tests = {
        // by default these are members
        '@inner': 'inner',
        '@instance': false,
        '@global': false,
        '@static': 'static',
        '@name Asdf.fdsa': 'static',
        '@name Outer~inner': 'inner',
        '@name Fdsa#asdf': false,
        '@name <global>.log': false,
        // some tests with functions and constants
        '@const Asdf#FOO': false,
        '@const Asdf\n@inner': 'inner',
        '@function Asdf#myFunction': false,
        '@function Fdsa.MyFunction': 'static',
        '@function Fdsa': false,
        // these are not functions or members or constants, they should not have their scope recorded.
        '@namespace Fdsa\n@inner': false,
        '@class asdf': false,
      };

      doTests(tests, ['inner', 'static', 'global', 'instance']);
    });

    it(""should detect if a doclet is readonly (and its kind is 'member')"", () => {
      const tests = {
        'asdf\n @readonly': 'readonly',
        asdf: false,
        '@name Fdsa#foo\n@readonly': 'readonly',
        // kind is not 'member'.
        '@const asdf\n@readonly': 'constant',
        '@function asdf\n@readonly': false,
        '@function Asdf#bar\n@readonly': false,
      };

      doTests(tests, 'readonly');
    });

    it('should detect if the doclet is a for constant', () => {
      const tests = {
        'Enum. @enum\n@constant': 'constant',
        '@function Foo#BAR\n@const': 'constant',
        '@const Asdf': 'constant',
      };

      doTests(tests, 'constant');
    });

    it('should detect if a doclet is async', () => {
      const tests = { '@async': 'async' };

      doTests(tests, 'async');
    });

    it('should detect if a doclet is a generator function', () => {
      const tests = { '@generator': 'generator' };

      doTests(tests, 'generator');
    });

    it('should detect multiple attributes', () => {
      const fdsaFoo = new Doclet(
        '/** @const module:fdsa~FOO\n@readonly\n@private */',
        {},
        jsdoc.env
      );

      attribs = helper.getAttribs(fdsaFoo);

      expect(attribs).toContain('private');
      // expect(attribs).toContain('readonly'); // kind is 'constant' not 'member'.
      expect(attribs).toContain('constant');
      expect(attribs).toContain('inner');
    });

    it('should return an empty array for null values', () => {
      let emptyAttribs;

      function getAttribs() {
        return helper.getAttribs();
      }

      expect(getAttribs).not.toThrow();

      emptyAttribs = getAttribs();

      expect(emptyAttribs).toBeEmptyArray();
    });
  });

  describe('getSignatureTypes', () => {
    afterEach(() => {
      delete helper.longnameToUrl.MyClass;
    });

    // returns links to allowed types for a doclet.
    it('returns an empty array if the doclet has no specified type', () => {
      const doc = new Doclet('/** @const ASDF */', {}, jsdoc.env);
      const types = helper.getSignatureTypes(doc);

      expect(types).toBeEmptyArray();
    });

    it(""returns a string array of the doclet's types"", () => {
      const doc = new Doclet('/** @const {number|Array.<boolean>} ASDF */', {}, jsdoc.env);
      const types = helper.getSignatureTypes(doc);

      expect(types).toBeArrayOfSize(2);
      expect(types).toContain('number');
      expect(types).toContain('Array&lt;boolean&gt;');
    });

    it('creates links for types if relevant', () => {
      let doc;
      let types;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet('/** @const {MyClass} ASDF */', {}, jsdoc.env);
      types = helper.getSignatureTypes(doc);

      expect(types).toBeArrayOfSize(1);
      expect(types).toContain('<a href=""MyClass.html"">MyClass</a>');
    });

    it('uses the cssClass parameter for links if it is provided', () => {
      let doc;
      let types;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet('/** @const {MyClass} ASDF */', {}, jsdoc.env);
      types = helper.getSignatureTypes(doc, 'myCSSClass');

      expect(types).toBeArrayOfSize(1);
      expect(types).toContain('<a href=""MyClass.html"" class=""myCSSClass"">MyClass</a>');
    });
  });

  describe('getSignatureParams', () => {
    // retrieves parameter names.
    // if css class is provided, optional parameters are wrapped in a <span> with that class.
    it('returns an empty array if the doclet has no specified type', () => {
      const doc = new Doclet('/** @function myFunction */', {}, jsdoc.env);
      const params = helper.getSignatureParams(doc);

      expect(params).toBeEmptyArray();
    });

    it(""returns a string array of the doclet's parameter names"", () => {
      const doc = new Doclet(
        '/** @function myFunction\n @param {string} foo - asdf. */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc);

      expect(params).toBeArrayOfSize(1);
      expect(params).toContain('foo');
    });

    it('wraps optional parameters in <span class=..> if optClass is provided', () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc, 'cssClass');

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('<span class=""cssClass"">bar</span>');
      expect(params).toContain('<span class=""cssClass"">baz</span>');
    });

    it(""doesn't wrap optional parameters in <span class=..> if optClass is not provided"", () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc);

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('bar');
      expect(params).toContain('baz');
    });
  });

  describe('getSignatureReturns', () => {
    afterEach(() => {
      delete helper.longnameToUrl.MyClass;
    });

    it('returns a value with correctly escaped HTML', () => {
      const mockDoclet = {
        returns: [
          {
            type: {
              names: ['Array.<string>'],
            },
          },
        ],
      };
      const html = helper.getSignatureReturns(mockDoclet);

      expect(html).not.toContain('Array<string>');
      expect(html).toContain('Array&lt;string&gt;');
    });

    it('returns an empty array if the doclet has no returns', () => {
      const doc = new Doclet('/** @function myFunction */', {}, jsdoc.env);
      const returns = helper.getSignatureReturns(doc);

      expect(returns).toBeEmptyArray();
    });

    it('returns an empty array if the doclet has @returns but with no type', () => {
      const doc = new Doclet(
        '/** @function myFunction\n@returns an interesting result.*/',
        {},
        jsdoc.env
      );
      const returns = helper.getSignatureReturns(doc);

      expect(returns).toBeEmptyArray();
    });

    it('uses the value of the `yields` property', () => {
      const doc = new Doclet('/** @yields {string} A string. */', {}, jsdoc.env);
      const html = helper.getSignatureReturns(doc);

      expect(html).toContain('string');
    });

    it('prefers `yields` over `returns`', () => {
      const doc = new Doclet('/** @yields {string}\n@returns {number} */', {}, jsdoc.env);
      const html = helper.getSignatureReturns(doc);

      expect(html).toContain('string');
      expect(html).not.toContain('number');
    });

    it('creates links for return types if relevant', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc);

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"">MyClass</a>');
      expect(returns).toContain('number');
    });

    it('uses the cssClass parameter for links if it is provided', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc, 'myCssClass');

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"" class=""myCssClass"">MyClass</a>');
      expect(returns).toContain('number');
    });
  });

  // TODO: getAncestors tests

  describe('getAncestorLinks', () => {
    // make a hierarchy.
    const lackeys = new Doclet(
      '/** @member lackeys\n@memberof module:mafia/gangs.Sharks~Henchman\n@instance*/',
      {},
      jsdoc.env
    );
    const henchman = new Doclet(
      '/** @class Henchman\n@memberof module:mafia/gangs.Sharks\n@inner */',
      {},
      jsdoc.env
    );
    const gang = new Doclet('/** @namespace module:mafia/gangs.Sharks */', {}, jsdoc.env);
    const mafia = new Doclet('/** @module mafia/gangs */', {}, jsdoc.env);
    const data = taffy([lackeys, henchman, gang, mafia]);

    afterEach(() => {
      delete helper.longnameToUrl['module:mafia/gangs'];
      delete helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'];
    });

    // register some links
    it('returns an empty array if there are no ancestors', () => {
      const links = helper.getAncestorLinks(data, mafia);

      expect(links).toBeEmptyArray();
    });

    it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    });

    it('adds links if they exist', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"">mafia/gangs</a>');
    });

    it('adds cssClass to any link', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys, 'myClass');

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"" class=""myClass"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"" class=""myClass"">mafia/gangs</a>');
    });
  });

  describe('addEventListeners', () => {
    const docSet = jsdoc.getDocSetFromFile('test/fixtures/listenstag.js');
    const doclets = taffy(_.cloneDeep(docSet.doclets));
    const ev = helper.find(doclets, { longname: 'module:myModule.event:MyEvent' })[0];
    const ev2 = helper.find(doclets, { longname: 'module:myModule~Events.event:Event2' })[0];
    const ev3 = helper.find(doclets, { longname: 'module:myModule#event:Event3' })[0];

    helper.addEventListeners(doclets);

    it(""adds a 'listeners' array to events with the longnames of the listeners"", () => {
      expect(ev.listeners).toBeArrayOfSize(2);
      expect(ev.listeners).toContain('module:myModule~MyHandler');
      expect(ev.listeners).toContain('module:myModule~AnotherHandler');

      expect(ev2.listeners).toBeArrayOfSize(1);
      expect(ev2.listeners).toContain('module:myModule~MyHandler');
    });

    it('does not add listeners for events with no listeners', () => {
      expect(ev3.listeners).toBeUndefined();
    });

    it('does not make spurious doclets if something @listens to a non-existent symbol', () => {
      expect(helper.find(doclets, { longname: 'event:fakeEvent' })).toBeEmptyArray();
    });
  });

  describe('prune', () => {
    const access = options.access;
    const priv = Boolean(options.private);

    afterEach(() => {
      options.access = access;
      options.private = priv;
    });

    const array = [
      // keep
      { undocumented: false },
      // keep
      { ignore: false },
      // keep
      { memberof: 'SomeClass' },
      // prune
      { undocumented: true },
      // prune
      { ignore: true },
      // prune
      { memberof: '<anonymous>' },
    ];
    const keep = [
      // keep
      { undocumented: false },
      // keep
      { ignore: false },
      // keep
      { memberof: 'SomeClass' },
    ];
    const arrayPrivate = [
      // prune (unless options.private is truthy)
      { access: 'private' },
    ];
    const arrayMixed = [
      { access: 'package' },
      { access: 'public' },
      { asdf: true },
      { access: 'protected' },
      { access: 'private' },
    ];

    it('should prune the correct members', () => {
      const pruned = helper.prune(taffy(array), jsdoc.env)().get();

      compareObjectArrays(keep, pruned);
    });

    it('should prune private members if options.private is falsy', () => {
      let pruned;

      options.private = false;
      pruned = helper.prune(taffy(arrayPrivate), jsdoc.env)().get();

      compareObjectArrays([], pruned);
    });

    it('should only keep package-private members if options.access only contains ""package""', () => {
      let pruned;
      const keepPackage = [{ access: 'package' }];

      options.access = 'package';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPackage, pruned);
    });

    it('should only keep public members if options.access only contains ""public""', () => {
      let pruned;
      const keepPublic = [{ access: 'public' }];

      options.access = 'public';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPublic, pruned);
    });

    it('should only keep undefined members if options.access only contains ""undefined""', () => {
      let pruned;
      const keepUndefined = [{ asdf: true }];

      options.access = 'undefined';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepUndefined, pruned);
    });

    it('should only keep protected members if options.access only contains ""protected""', () => {
      let pruned;
      const keepProtected = [{ access: 'protected' }];

      options.access = 'protected';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepProtected, pruned);
    });

    it('should only keep private members if options.access only contains ""private""', () => {
      let pruned;
      const keepPrivate = [{ access: 'private' }];

      options.access = 'private';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPrivate, pruned);
    });

    it('should keep public and protected members if options.access contains ""public"" and ""protected""', () => {
      let pruned;
      const keepPublicProtected = [
        {
          access: 'public',
        },
        {
          access: 'protected',
        },
      ];

      options.access = ['public', 'protected'];
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPublicProtected, pruned);
    });

    it('should keep everything if options.access contains ""all""', () => {
      let pruned;

      options.access = 'all';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(arrayMixed, pruned);
    });

    it('should not prune private members if options.private is truthy', () => {
      let pruned;

      options.private = true;
      pruned = helper.prune(taffy(arrayPrivate), jsdoc.env)().get();

      compareObjectArrays(arrayPrivate, pruned);
    });
  });

  describe('registerLink', () => {
    afterEach(() => {
      delete helper.longnameToUrl.MySymbol;
    });

    it('adds an entry to exports.longnameToUrl', () => {
      helper.longnameToUrl.MySymbol = 'asdf.html';

      expect(helper.longnameToUrl.MySymbol).toBe('asdf.html');
    });

    it('allows linkto to work', () => {
      helper.registerLink('MySymbol', 'asdf.html');

      expect(helper.linkto('MySymbol')).toBe('<a href=""asdf.html"">MySymbol</a>');
    });
  });

  describe('resolveLinks', () => {
    let conf;

    beforeEach(() => {
      conf = _.cloneDeep(config.templates);
    });

    afterEach(() => {
      config.templates = conf;
      delete helper.longnameToUrl['my.long.namespace'];
    });

    it('should translate {@link test} into a HTML link.', () => {
      const input = 'This is a {@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test</a>.');
    });

    it('should translate {@link unknown} into a simple text.', () => {
      const input = 'This is a {@link unknown}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a unknown.');
    });

    it('should translate {@link test} into a HTML links multiple times.', () => {
      const input = 'This is a {@link test} and {@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe(
        'This is a <a href=""path/to/test.html"">test</a> and <a href=""path/to/test.html"">test</a>.'
      );
    });

    it('should translate [hello there]{@link test} into a HTML link with the custom content.', () => {
      const input = 'This is a [hello there]{@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">hello there</a>.');
    });

    it('should translate [dummy text] and [hello there]{@link test} into an HTML link with the custom content.', () => {
      const input = 'This is [dummy text] and [hello there]{@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is [dummy text] and <a href=""path/to/test.html"">hello there</a>.');
    });

    it('should translate [dummy text] and [more] and [hello there]{@link test} into an HTML link with the custom content.', () => {
      const input = 'This is [dummy text] and [more] and [hello there]{@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe(
        'This is [dummy text] and [more] and <a href=""path/to/test.html"">hello there</a>.'
      );
    });

    it('should ignore [hello there].', () => {
      const input = 'This is a [hello there].';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe(input);
    });

    it('should translate http links in the tag', () => {
      const input = 'Link to {@link http://github.com}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""http://github.com"">http://github.com</a>');
    });

    it('should translate ftp links in the tag', () => {
      const input = 'Link to {@link ftp://foo.bar}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""ftp://foo.bar"">ftp://foo.bar</a>');
    });

    it('should allow pipe to be used as delimiter between href and text (external link)', () => {
      const input = 'Link to {@link http://github.com|Github}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""http://github.com"">Github</a>');
    });

    it('should allow pipe to be used as delimiter between href and text (symbol link)', () => {
      const input = 'Link to {@link test|Test}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">Test</a>');
    });

    it('should not add spaces to the href or text when there are spaces around the pipe', () => {
      const input = 'Link to {@link test | Test}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">Test</a>');
    });

    it('should allow first space to be used as delimiter between href and text (external link)', () => {
      const input = 'Link to {@link http://github.com Github}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""http://github.com"">Github</a>');
    });

    it('should allow first space to be used as delimiter between href and text (symbol link)', () => {
      const input = 'Link to {@link test My Caption}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">My Caption</a>');
    });

    it('if pipe and space are present in link tag, use pipe as the delimiter', () => {
      const input = 'Link to {@link test|My Caption}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">My Caption</a>');
    });

    it('Test of {@linkcode } which should be in monospace', () => {
      const input = 'Link to {@linkcode test}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    it('Test of {@linkplain } which should be in normal font', () => {
      const input = 'Link to {@linkplain test}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">test</a>');
    });

    it('should be careful with linking to links whose names are reserved JS keywords', () => {
      const input = 'Link to {@link constructor}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to constructor');
    });

    it('should allow linebreaks between link tag and content', () => {
      const input = 'This is a {@link\ntest}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test</a>.');
    });

    it('should allow linebreaks to separate url from link text', () => {
      const input = 'This is a {@link\ntest\ntest}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test</a>.');
    });

    it('should normalize additional newlines to spaces', () => {
      const input = 'This is a {@link\ntest\ntest\n\ntest}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test test</a>.');
    });

    it('should allow tabs between link tag and content', () => {
      const input = 'This is a {@link\ttest}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test</a>.');
    });

    // conf.monospaceLinks. check that
    // a) it works
    it('if conf.monospaceLinks is true, all {@link} should be monospace', () => {
      const input = 'Link to {@link test}';
      let output;

      config.templates.monospaceLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    // b) linkcode and linkplain are still respected
    it('if conf.monospaceLinks is true, all {@linkcode} should still be monospace', () => {
      const input = 'Link to {@linkcode test}';
      let output;

      config.templates.monospaceLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    it('if conf.monospaceLinks is true, all {@linkplain} should still be plain', () => {
      const input = 'Link to {@linkplain test}';
      let output;

      config.templates.monospaceLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">test</a>');
    });

    // conf.cleverLinks. check that
    // a) it works
    it('if conf.cleverLinks is true, {@link symbol} should be in monospace', () => {
      const input = 'Link to {@link test}';
      let output;

      config.templates.cleverLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    it('if conf.cleverLinks is true, {@link URL} should be in plain text', () => {
      const input = 'Link to {@link http://github.com}';
      let output;

      config.templates.cleverLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""http://github.com"">http://github.com</a>');
    });

    // b) linkcode and linkplain are still respected
    it('if conf.cleverLinks is true, all {@linkcode} should still be clever', () => {
      const input = 'Link to {@linkcode test}';
      let output;

      config.templates.cleverLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    it('if conf.cleverLinks is true, all {@linkplain} should still be plain', () => {
      const input = 'Link to {@linkplain test}';
      let output;

      config.templates.cleverLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">test</a>');
    });

    // c) if monospaceLinks is additionally `true` it is ignored in favour
    //    of cleverLinks
    it('if conf.cleverLinks is true and so is conf.monospaceLinks, cleverLinks overrides', () => {
      const input = 'Link to {@link test} and {@link http://github.com}';
      let output;

      config.templates.cleverLinks = true;
      config.templates.monospaceLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe(
        'Link to <a href=""path/to/test.html""><code>test</code></a> and ' +
          '<a href=""http://github.com"">http://github.com</a>'
      );
    });

    it('if conf.useShortNamesInLinks is true, it uses the short name in links', () => {
      const input = 'Link to {@link my.long.namespace}';
      let output;

      config.templates.useShortNamesInLinks = true;
      helper.registerLink('my.long.namespace', 'asdf.html');
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""asdf.html"">namespace</a>');
    });
  });

  describe('createLink', () => {
    it('should create a url for a simple global.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'foo',
        name: 'foo',
        scope: 'global',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toBe('global.html#foo');
    });

    it('should create a url for a namespace.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'namespace',
        longname: 'foo',
        name: 'foo',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toBe('foo.html');
    });

    it('should create a url for a member of a namespace.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'ns.foo',
        name: 'foo',
        memberof: 'ns',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toBe('ns.html#foo');
    });

    const nestedNamespaceDoclet = {
      env: jsdoc.env,
      kind: 'function',
      longname: 'ns1.ns2.foo',
      name: 'foo',
      memberof: 'ns1.ns2',
    };
    let nestedNamespaceUrl;

    it('should create a url for a member of a nested namespace.', () => {
      nestedNamespaceUrl = helper.createLink(nestedNamespaceDoclet, jsdoc.env);

      expect(nestedNamespaceUrl).toBe('ns1.ns2.html#foo');
    });

    it('should return the same value when called twice with the same doclet.', () => {
      const newUrl = helper.createLink(nestedNamespaceDoclet, jsdoc.env);

      expect(newUrl).toBe(nestedNamespaceUrl);
    });

    it('should create a url for a name with invalid characters.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'ns1.""!"".""*foo""',
        name: '""*foo""',
        memberof: 'ns1.""!""',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toEqual('ns1._!_.html#%22*foo%22');
    });

    it('should create a url for a function that is the only symbol exported by a module.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'module:bar',
        name: 'module:bar',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toEqual('module-bar.html');
    });

    it('should create a url for a doclet with the wrong kind (caused by incorrect JSDoc tags', () => {
      const moduleDoclet = {
        env: jsdoc.env,
        kind: 'module',
        longname: 'module:baz',
        name: 'module:baz',
      };
      const badDoclet = {
        env: jsdoc.env,
        kind: 'member',
        longname: 'module:baz',
        name: 'module:baz',
      };
      const moduleDocletUrl = helper.createLink(moduleDoclet, jsdoc.env);
      const badDocletUrl = helper.createLink(badDoclet, jsdoc.env);

      expect(moduleDocletUrl).toBe('module-baz.html');
      expect(badDocletUrl).toBe('module-baz.html');
    });

    it('should create a url for a function that is a member of a doclet with the wrong kind', () => {
      const badModuleDoclet = {
        env: jsdoc.env,
        kind: 'member',
        longname: 'module:qux',
        name: 'module:qux',
      };
      const memberDoclet = {
        env: jsdoc.env,
        kind: 'function',
        name: 'frozzle',
        memberof: 'module:qux',
        scope: 'instance',
        longname: 'module:qux#frozzle',
      };
      const badModuleDocletUrl = helper.createLink(badModuleDoclet, jsdoc.env);
      const memberDocletUrl = helper.createLink(memberDoclet, jsdoc.env);

      expect(badModuleDocletUrl).toBe('module-qux.html');
      expect(memberDocletUrl).toBe('module-qux.html#frozzle');
    });

    it('should include the scope punctuation in the fragment ID for static members', () => {
      const functionDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'Milk.pasteurize',
        name: 'pasteurize',
        memberof: 'Milk',
        scope: 'static',
      };
      const docletUrl = helper.createLink(functionDoclet, jsdoc.env);

      expect(docletUrl).toBe('Milk.html#.pasteurize');
    });

    it('should include the scope punctuation in the fragment ID for inner members', () => {
      const functionDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'Milk~removeSticksAndLeaves',
        name: 'removeSticksAndLeaves',
        memberof: 'Milk',
        scope: 'inner',
      };
      const docletUrl = helper.createLink(functionDoclet, jsdoc.env);

      expect(docletUrl).toBe('Milk.html#~removeSticksAndLeaves');
    });

    it('should omit the scope punctuation from the fragment ID for instance members', () => {
      const propertyDoclet = {
        env: jsdoc.env,
        kind: 'member',
        longname: 'Milk#calcium',
        name: 'calcium',
        memberof: 'Milk',
        scope: 'instance',
      };
      const docletUrl = helper.createLink(propertyDoclet, jsdoc.env);

      expect(docletUrl).toBe('Milk.html#calcium');
    });

    it('should include the variation, if present, in the fragment ID', () => {
      const variationDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'Milk#fat(percent)',
        name: 'fat',
        memberof: 'Milk',
        scope: 'instance',
        variation: '(percent)',
      };
      const docletUrl = helper.createLink(variationDoclet, jsdoc.env);

      expect(docletUrl).toBe('Milk.html#fat(percent)');
    });
  });

  describe('resolveAuthorLinks', () => {
    it('should not crash JSDoc if no text is specified', () => {
      function resolve() {
        helper.resolveAuthorLinks();
      }

      expect(resolve).not.toThrow();
    });

    // convert Jane Doe <jdoe@example.org> to a mailto link.
    it('should convert email addresses in angle brackets *after* a name to mailto links', () => {
      const str = ' John Doe  <asdf.fdsa-2@gmail.com> ';
      const out = helper.resolveAuthorLinks(str);

      expect(out).toBe('<a href=""mailto:asdf.fdsa-2@gmail.com"">John Doe</a>');
    });

    it('should HTML-safe author names', () => {
      const str = ' John<Doe  <asdf.fdsa-2@gmail.com> ';
      const out = helper.resolveAuthorLinks(str);

      expect(out).toBe(`<a href=""mailto:asdf.fdsa-2@gmail.com"">${helper.htmlsafe('John<Doe')}</a>`);
    });

    it('should simply return the input string, HTML-safe, if no email is detected', () => {
      const str = 'John Doe <dummy>';
      const out = helper.resolveAuthorLinks(str);

      expect(out).toBe(helper.htmlsafe(str));
    });
  });

  // TODO: longnamesToTree tests
})",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Conditional Test Logic,"{'line': 548, 'column': 8, 'index': 17149}","describe('@jsdoc/template-legacy/lib/templateHelper', () => {
  const { config, options } = jsdoc.env;

  helper.registerLink('test', 'path/to/test.html');

  it('should exist', () => {
    expect(helper).toBeObject();
  });

  it(""should export a 'globalName' property"", () => {
    expect(helper.globalName).toBeString();
  });

  it(""should export a 'fileExtension' property"", () => {
    expect(helper.fileExtension).toBeString();
  });

  it(""should export a 'SCOPE_TO_PUNC' property"", () => {
    expect(helper.SCOPE_TO_PUNC).toBeObject();
  });

  it(""should export a 'getUniqueFilename' function"", () => {
    expect(helper.getUniqueFilename).toBeFunction();
  });

  it(""should export a 'getUniqueId' function"", () => {
    expect(helper.getUniqueId).toBeFunction();
  });

  it(""should export a 'longnameToUrl' property"", () => {
    expect(helper.longnameToUrl).toBeObject();
  });

  it(""should export a 'linkto' function"", () => {
    expect(helper.linkto).toBeFunction();
  });

  it(""should export an 'htmlsafe' function"", () => {
    expect(helper.htmlsafe).toBeFunction();
  });

  it(""should export a 'find' function"", () => {
    expect(helper.find).toBeFunction();
  });

  it(""should export a 'getMembers' function"", () => {
    expect(helper.getMembers).toBeFunction();
  });

  it(""should export a 'getAttribs' function"", () => {
    expect(helper.getAttribs).toBeFunction();
  });

  it(""should export a 'getSignatureTypes' function"", () => {
    expect(helper.getSignatureTypes).toBeFunction();
  });

  it(""should export a 'getSignatureParams' function"", () => {
    expect(helper.getSignatureParams).toBeFunction();
  });

  it(""should export a 'getSignatureReturns' function"", () => {
    expect(helper.getSignatureReturns).toBeFunction();
  });

  it(""should export a 'getAncestors' function"", () => {
    expect(helper.getAncestors).toBeFunction();
  });

  it(""should export a 'getAncestorLinks' function"", () => {
    expect(helper.getAncestorLinks).toBeFunction();
  });

  it(""should export a 'addEventListeners' function"", () => {
    expect(helper.addEventListeners).toBeFunction();
  });

  it(""should export a 'prune' function"", () => {
    expect(helper.prune).toBeFunction();
  });

  it(""should export a 'registerLink' function"", () => {
    expect(helper.registerLink).toBeFunction();
  });

  it(""should export a 'resolveLinks' function"", () => {
    expect(helper.resolveLinks).toBeFunction();
  });

  it(""should export a 'resolveAuthorLinks' function"", () => {
    expect(helper.resolveAuthorLinks).toBeFunction();
  });

  it(""should export a 'createLink' function"", () => {
    expect(helper.createLink).toBeFunction();
  });

  it('should export a ""longnamesToTree"" function', () => {
    expect(helper.longnamesToTree).toBeFunction();
  });

  describe('globalName', () => {
    it(""should equal 'global'"", () => {
      expect(helper.globalName).toBe('global');
    });
  });

  describe('fileExtension', () => {
    it(""should equal '.html'"", () => {
      expect(helper.fileExtension).toBe('.html');
    });
  });

  describe('SCOPE_TO_PUNC', () => {
    it(""should map 'static' to '.', 'inner', to '~', 'instance' to '#'"", () => {
      expect(helper.SCOPE_TO_PUNC).toEqual({
        static: '.',
        inner: '~',
        instance: '#',
      });
    });
  });

  describe('getUniqueFilename', () => {
    afterEach(() => {
      jsdoc.restoreTagDictionary();
    });

    // TODO: needs more tests for unusual values and things that get special treatment (such as
    // inner members)
    it('should convert a simple string into the string plus the default extension', () => {
      const filename = helper.getUniqueFilename('BackusNaur', jsdoc.env);

      expect(filename).toBe('BackusNaur.html');
    });

    it('should replace slashes with underscores', () => {
      const filename = helper.getUniqueFilename('tick/tock', jsdoc.env);

      expect(filename).toBe('tick_tock.html');
    });

    it('should replace other problematic characters with underscores', () => {
      const filename = helper.getUniqueFilename('a very strange \\/?*:|\'""<> filename', jsdoc.env);

      expect(filename).toBe('a very strange __________ filename.html');
    });

    it('should not allow a filename to start with an underscore', () => {
      expect(helper.getUniqueFilename('', jsdoc.env)).toBe('-_.html');
    });

    it('should not return the same filename twice', () => {
      const name = 'polymorphic';
      const filename1 = helper.getUniqueFilename(name, jsdoc.env);
      const filename2 = helper.getUniqueFilename(name, jsdoc.env);

      expect(filename1).not.toBe(filename2);
    });

    it('should not consider the same name with different letter case to be unique', () => {
      const camel = 'myJavaScriptIdentifier';
      const pascal = 'MyJavaScriptIdentifier';
      const filename1 = helper.getUniqueFilename(camel, jsdoc.env);
      const filename2 = helper.getUniqueFilename(pascal, jsdoc.env);

      expect(filename1.toLowerCase()).not.toBe(filename2.toLowerCase());
    });

    it('should remove variations from the longname before generating the filename', () => {
      const filename = helper.getUniqueFilename('MyClass(foo, bar)', jsdoc.env);

      expect(filename).toBe('MyClass.html');
    });

    it('should generate the correct filename for built-in namespaces', () => {
      const filenameEvent = helper.getUniqueFilename('event:userDidSomething', jsdoc.env);
      const filenameExternal = helper.getUniqueFilename('external:NotInThisPackage', jsdoc.env);
      const filenameModule = helper.getUniqueFilename('module:some/sort/of/module', jsdoc.env);
      const filenamePackage = helper.getUniqueFilename(
        'package:node-solve-all-your-problems',
        jsdoc.env
      );

      expect(filenameEvent).toBe('event-userDidSomething.html');
      expect(filenameExternal).toBe('external-NotInThisPackage.html');
      expect(filenameModule).toBe('module-some_sort_of_module.html');
      expect(filenamePackage).toBe('package-node-solve-all-your-problems.html');
    });

    it('should generate the correct filename for user-specified namespaces', () => {
      const env = new Env();
      const dict = new Dictionary();
      let filename;

      dict.defineTag('anaphylaxis', {
        isNamespace: true,
      });
      env.tags = dict;

      filename = helper.getUniqueFilename('anaphylaxis:peanut', env);

      expect(filename).toBe('anaphylaxis-peanut.html');
    });
  });

  describe('getUniqueId', () => {
    it('should return the provided string in normal cases', () => {
      const id = helper.getUniqueId('futon.html', 'backrest');

      expect(id).toBe('backrest');
    });

    it('should return an empty string if no base ID is provided', () => {
      const id = helper.getUniqueId('futon.html', '');

      expect(id).toBe('');
    });

    it('should remove whitespace characters', () => {
      const id = helper.getUniqueId('futon.html', 'a very long identifier');

      expect(id).toBe('averylongidentifier');
    });

    it('should not return the same ID twice for a given file', () => {
      const filename = 'futon.html';
      const name = 'polymorphic';
      const id1 = helper.getUniqueId(filename, name);
      const id2 = helper.getUniqueId(filename, name);

      expect(id1).not.toBe(id2);
    });

    it('should allow duplicate IDs if they are in different files', () => {
      const name = 'magnificence';
      const id1 = helper.getUniqueId('supersensational.html', name);
      const id2 = helper.getUniqueId('razzledazzle.html', name);

      expect(id1).toBe(id2);
    });

    it('should not consider the same name with different letter case to be unique', () => {
      const camel = 'myJavaScriptIdentifier';
      const pascal = 'MyJavaScriptIdentifier';
      const filename = 'mercutio.html';
      const id1 = helper.getUniqueId(filename, camel);
      const id2 = helper.getUniqueId(filename, pascal);

      expect(id1.toLowerCase()).not.toBe(id2.toLowerCase());
    });
  });

  describe('longnameToUrl', () => {
    afterEach(() => {
      delete helper.longnameToUrl.foo2;
      delete helper.longnameToUrl.MySymbol;
    });

    it('is an object', () => {
      expect(typeof helper.longnameToUrl).toBe('object');
    });

    it('has an entry added into it by calling registerLink', () => {
      helper.registerLink('MySymbol', 'asdf.html');

      expect(helper.longnameToUrl.MySymbol).toBeDefined();
      expect(helper.longnameToUrl.MySymbol).toBe('asdf.html');
    });

    it('adding an entry to it allows me to link with linkto', () => {
      helper.longnameToUrl.foo2 = 'bar.html';

      expect(helper.linkto('foo2')).toBe('<a href=""bar.html"">foo2</a>');
    });
  });

  describe('linkto', () => {
    beforeEach(() => {
      helper.longnameToUrl.linktoTest = 'test.html';
      helper.longnameToUrl.LinktoFakeClass = 'fakeclass.html';
      helper.longnameToUrl['Foo#bar(baz)'] = 'foo-bar-baz.html';
    });

    afterEach(() => {
      delete helper.longnameToUrl.linktoTest;
      delete helper.longnameToUrl.LinktoFakeClass;
      delete helper.longnameToUrl['Foo#bar(baz)'];
    });

    it('returns the longname if only the longname is specified and has no URL', () => {
      const link = helper.linkto('example');

      expect(link).toBe('example');
    });

    it('returns the link text if only the link text is specified', () => {
      const link = helper.linkto(null, 'link text');

      expect(link).toBe('link text');
    });

    it(
      'returns the link text if the longname does not have a URL, and both the longname and ' +
        'link text are specified',
      () => {
        const link = helper.linkto('example', 'link text');

        expect(link).toBe('link text');
      }
    );

    it('uses the longname as the link text if no link text is provided', () => {
      const link = helper.linkto('linktoTest');

      expect(link).toBe('<a href=""test.html"">linktoTest</a>');
    });

    it('uses the link text if it is specified', () => {
      const link = helper.linkto('linktoTest', 'link text');

      expect(link).toBe('<a href=""test.html"">link text</a>');
    });

    it('includes a ""class"" attribute in the link if a class is specified', () => {
      const link = helper.linkto('linktoTest', 'link text', 'myclass');

      expect(link).toBe('<a href=""test.html"" class=""myclass"">link text</a>');
    });

    it('is careful with longnames that are reserved words in JS', () => {
      // we don't have a registered link for 'constructor' so it should return the text 'link text'.
      const link = helper.linkto('constructor', 'link text');

      expect(link).toBe('link text');
    });

    it('works correctly with type applications if only the longname is specified', () => {
      const link = helper.linkto('Array.<LinktoFakeClass>');

      expect(link).toBe('Array&lt;<a href=""fakeclass.html"">LinktoFakeClass</a>&gt;');
    });

    it('works correctly with type applications if a class is not specified', () => {
      const link = helper.linkto('Array.<LinktoFakeClass>', 'link text');

      expect(link).toBe('Array&lt;<a href=""fakeclass.html"">LinktoFakeClass</a>&gt;');
    });

    it('works correctly with type applications if a class is specified', () => {
      const link = helper.linkto('Array.<LinktoFakeClass>', 'link text', 'myclass');

      expect(link).toBe(
        'Array&lt;<a href=""fakeclass.html"" class=""myclass"">LinktoFakeClass</a>&gt;'
      );
    });

    it('works correctly with type applications that include a type union', () => {
      const link = helper.linkto('Array.<(linktoTest|LinktoFakeClass)>', 'link text');

      expect(link).toBe(
        'Array&lt;(<a href=""test.html"">linktoTest</a>|' +
          '<a href=""fakeclass.html"">LinktoFakeClass</a>)&gt;'
      );
    });

    it('works correctly with type unions that are not enclosed in parentheses', () => {
      const link = helper.linkto('linktoTest|LinktoFakeClass', 'link text');

      expect(link).toBe(
        '(<a href=""test.html"">linktoTest</a>|<a href=""fakeclass.html"">LinktoFakeClass</a>)'
      );
    });

    it('does not try to parse a longname starting with <anonymous> as a type application', () => {
      const emitter = jsdoc.env.emitter;
      const events = [];

      function storeEvent(e) {
        events.push(e);
      }

      emitter.on('logger:error', storeEvent);
      helper.linkto('<anonymous>~foo');

      expect(events).toBeEmptyArray();

      emitter.off('logger:error', storeEvent);
    });

    it('does not treat a longname with a variation as a type application', () => {
      const link = helper.linkto('Foo#bar(baz)', 'link text');

      expect(link).toBe('<a href=""foo-bar-baz.html"">link text</a>');
    });

    it('returns a link when a URL is specified', () => {
      const link = helper.linkto('http://example.com');

      expect(link).toBe('<a href=""http://example.com"">http://example.com</a>');
    });

    it('returns a link if a URL wrapped in angle brackets is specified', () => {
      const link = helper.linkto('<http://example.com>');

      expect(link).toBe('<a href=""http://example.com"">http://example.com</a>');
    });

    it('returns a link with link text if a URL and link text are specified', () => {
      const link = helper.linkto('http://example.com', 'text');

      expect(link).toBe('<a href=""http://example.com"">text</a>');
    });

    it('returns a link with a fragment ID if a URL and fragment ID are specified', () => {
      const link = helper.linkto('LinktoFakeClass', null, null, 'fragment');

      expect(link).toBe('<a href=""fakeclass.html#fragment"">LinktoFakeClass</a>');
    });

    it('returns the original text if an HTML <a> tag is specified', () => {
      const text = '<a href=""http://example.com"">text</a>';
      const link = helper.linkto(text);

      expect(link).toBe(text);
    });

    it('returns the original text if an inline {@link} tag is specified', () => {
      let link;
      const text = '{@link Foo}';

      function getLink() {
        link = helper.linkto(text);
      }

      // make sure we're not trying to parse the inline link as a type expression
      expect(getLink).not.toThrow();
      // linkto doesn't process {@link} tags
      expect(link).toBe(text);
    });
  });

  describe('htmlsafe', () => {
    it('should convert all occurences of < to &lt;', () => {
      const inp = '<h1>Potentially dangerous.</h1>';
      const out = helper.htmlsafe(inp);

      expect(out).toBe('&lt;h1>Potentially dangerous.&lt;/h1>');
    });

    it('should convert all occurrences of & to &amp;', () => {
      const input = 'foo && bar & baz;';

      expect(helper.htmlsafe(input)).toBe('foo &amp;&amp; bar &amp; baz;');
    });

    it('should not double-convert ampersands', () => {
      const input = '<h1>Foo & Friends</h1>';

      expect(helper.htmlsafe(input)).toBe('&lt;h1>Foo &amp; Friends&lt;/h1>');
    });

    it('should convert non-strings to strings', () => {
      function htmlsafe() {
        return helper.htmlsafe(false);
      }

      expect(htmlsafe).not.toThrow();
      expect(htmlsafe()).toBe('false');
    });
  });

  describe('find', () => {
    const array = [
      // match
      {
        number: 2,
        A: true,
      },
      // match
      {
        number: 1,
        A: true,
        D: 'hello',
        Q: false,
      },
      // match
      {
        number: 3,
        A: 'maybe',
        squiggle: '?',
      },
      // no match (number not in spec)
      {
        number: 4,
        A: true,
      },
      // no match (missing top-level property)
      {
        A: true,
      },
    ];
    const matches = array.slice(0, 3);
    const spec = {
      number: [1, 2, 3],
      A: [true, 'maybe'],
    };

    it('should find the requested items', () => {
      expect(helper.find(taffy(array), spec)).toEqual(matches);
    });
  });

  // Make sure arrays a and b are the same length, and that each object in
  // array b has all the properties of the corresponding object in array a
  // used for getMembers and prune tests.
  function compareObjectArrays(a, b) {
    expect(a.length).toEqual(b.length);

    for (let i = 0, l = a.length; i < l; i++) {
      for (const prop in a[i]) {
        if (Object.hasOwn(a[i], prop)) {
          expect(b[i][prop]).toBeDefined();
          expect(a[i][prop]).toEqual(b[i][prop]);
        }
      }
    }
  }
  describe('getMembers', () => {
    // instead parse a file from fixtures and verify it?
    const classes = [
      // global
      {
        kind: 'class',
      },
      // not global
      {
        kind: 'class',
        memberof: 'SomeNamespace',
      },
    ];
    const externals = [
      {
        kind: 'external',
        name: 'foo',
      },
    ];
    const events = [
      {
        kind: 'event',
      },
    ];
    const mixins = [
      {
        kind: 'mixin',
      },
    ];
    const modules = [
      {
        kind: 'module',
      },
    ];
    const namespaces = [
      {
        kind: 'namespace',
      },
    ];
    const miscGlobal = [
      {
        kind: 'function',
      },
      {
        kind: 'member',
      },
      {
        kind: 'constant',
      },
      {
        kind: 'typedef',
      },
    ];
    const miscNonGlobal = [
      {
        kind: 'constant',
        memberof: 'module:one/two',
      },
      {
        kind: 'function',
        name: 'module:foo',
        longname: 'module:foo',
      },
      {
        kind: 'member',
        name: 'module:bar',
        longname: 'module:bar',
      },
    ];
    const misc = miscGlobal.concat(miscNonGlobal);
    const array = [
      ...classes,
      ...externals,
      ...events,
      ...mixins,
      ...modules,
      ...namespaces,
      ...misc,
    ];
    const data = taffy(array);
    const members = helper.getMembers(data);

    // check the output object has properties as expected.
    it(""should have a 'classes' property"", () => {
      expect(members.classes).toBeArray();
    });

    it(""should have a 'externals' property"", () => {
      expect(members.externals).toBeArray();
    });

    it(""should have a 'events' property"", () => {
      expect(members.events).toBeArray();
    });

    it(""should have a 'globals' property"", () => {
      expect(members.globals).toBeArray();
    });

    it(""should have a 'mixins' property"", () => {
      expect(members.mixins).toBeArray();
    });

    it(""should have a 'modules' property"", () => {
      expect(members.modules).toBeArray();
    });

    it(""should have a 'namespaces' property"", () => {
      expect(members.namespaces).toBeArray();
    });

    // check that things were found properly.
    it('classes are detected', () => {
      compareObjectArrays(classes, members.classes);
    });

    it('externals are detected', () => {
      compareObjectArrays(externals, members.externals);
    });

    it('events are detected', () => {
      compareObjectArrays(events, members.events);
    });

    it('mixins are detected', () => {
      compareObjectArrays(mixins, members.mixins);
    });

    it('modules are detected', () => {
      compareObjectArrays(modules, members.modules);
    });

    it('namespaces are detected', () => {
      compareObjectArrays(namespaces, members.namespaces);
    });

    it('globals are detected', () => {
      compareObjectArrays(miscGlobal, members.globals);
    });
  });

  describe('getAttribs', () => {
    let doc;
    let attribs;

    it('should return an array', () => {
      doc = new Doclet('/** ljklajsdf */', {}, jsdoc.env);
      attribs = helper.getAttribs(doc);

      expect(attribs).toBeEmptyArray();
    });

    // tests is an object of test[doclet src] = <result expected in attribs|false>
    // if false, we expect attribs to either not contain anything in whatNotToContain,
    // or be empty (if whatNotToContain was not provided).
    function doTests(tests, whatNotToContain) {
      for (const src in tests) {
        if (Object.hasOwn(tests, src)) {
          doc = new Doclet(`/** ${src} */`, {}, jsdoc.env);
          attribs = helper.getAttribs(doc);

          if (tests[src]) {
            expect(attribs).toContain(tests[src]);
          } else if (Array.isArray(whatNotToContain)) {
            for (let i = 0; i < whatNotToContain.length; ++i) {
              expect(attribs).not.toContain(whatNotToContain[i]);
            }
          } else {
            expect(attribs.length).toBe(0);
          }
        }
      }
    }

    it('should detect if a doclet is virtual', () => {
      const tests = {
        'My constant. \n @virtual': 'abstract',
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's access is not public"", () => {
      const tests = {
        '@private': 'private',
        '@access private': 'private',
        '@protected': 'protected',
        '@access protected': 'protected',
        '@public': false,
        '@access public': false,
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's scope is inner or static AND it is a function or member or constant"", () => {
      const tests = {
        // by default these are members
        '@inner': 'inner',
        '@instance': false,
        '@global': false,
        '@static': 'static',
        '@name Asdf.fdsa': 'static',
        '@name Outer~inner': 'inner',
        '@name Fdsa#asdf': false,
        '@name <global>.log': false,
        // some tests with functions and constants
        '@const Asdf#FOO': false,
        '@const Asdf\n@inner': 'inner',
        '@function Asdf#myFunction': false,
        '@function Fdsa.MyFunction': 'static',
        '@function Fdsa': false,
        // these are not functions or members or constants, they should not have their scope recorded.
        '@namespace Fdsa\n@inner': false,
        '@class asdf': false,
      };

      doTests(tests, ['inner', 'static', 'global', 'instance']);
    });

    it(""should detect if a doclet is readonly (and its kind is 'member')"", () => {
      const tests = {
        'asdf\n @readonly': 'readonly',
        asdf: false,
        '@name Fdsa#foo\n@readonly': 'readonly',
        // kind is not 'member'.
        '@const asdf\n@readonly': 'constant',
        '@function asdf\n@readonly': false,
        '@function Asdf#bar\n@readonly': false,
      };

      doTests(tests, 'readonly');
    });

    it('should detect if the doclet is a for constant', () => {
      const tests = {
        'Enum. @enum\n@constant': 'constant',
        '@function Foo#BAR\n@const': 'constant',
        '@const Asdf': 'constant',
      };

      doTests(tests, 'constant');
    });

    it('should detect if a doclet is async', () => {
      const tests = { '@async': 'async' };

      doTests(tests, 'async');
    });

    it('should detect if a doclet is a generator function', () => {
      const tests = { '@generator': 'generator' };

      doTests(tests, 'generator');
    });

    it('should detect multiple attributes', () => {
      const fdsaFoo = new Doclet(
        '/** @const module:fdsa~FOO\n@readonly\n@private */',
        {},
        jsdoc.env
      );

      attribs = helper.getAttribs(fdsaFoo);

      expect(attribs).toContain('private');
      // expect(attribs).toContain('readonly'); // kind is 'constant' not 'member'.
      expect(attribs).toContain('constant');
      expect(attribs).toContain('inner');
    });

    it('should return an empty array for null values', () => {
      let emptyAttribs;

      function getAttribs() {
        return helper.getAttribs();
      }

      expect(getAttribs).not.toThrow();

      emptyAttribs = getAttribs();

      expect(emptyAttribs).toBeEmptyArray();
    });
  });

  describe('getSignatureTypes', () => {
    afterEach(() => {
      delete helper.longnameToUrl.MyClass;
    });

    // returns links to allowed types for a doclet.
    it('returns an empty array if the doclet has no specified type', () => {
      const doc = new Doclet('/** @const ASDF */', {}, jsdoc.env);
      const types = helper.getSignatureTypes(doc);

      expect(types).toBeEmptyArray();
    });

    it(""returns a string array of the doclet's types"", () => {
      const doc = new Doclet('/** @const {number|Array.<boolean>} ASDF */', {}, jsdoc.env);
      const types = helper.getSignatureTypes(doc);

      expect(types).toBeArrayOfSize(2);
      expect(types).toContain('number');
      expect(types).toContain('Array&lt;boolean&gt;');
    });

    it('creates links for types if relevant', () => {
      let doc;
      let types;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet('/** @const {MyClass} ASDF */', {}, jsdoc.env);
      types = helper.getSignatureTypes(doc);

      expect(types).toBeArrayOfSize(1);
      expect(types).toContain('<a href=""MyClass.html"">MyClass</a>');
    });

    it('uses the cssClass parameter for links if it is provided', () => {
      let doc;
      let types;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet('/** @const {MyClass} ASDF */', {}, jsdoc.env);
      types = helper.getSignatureTypes(doc, 'myCSSClass');

      expect(types).toBeArrayOfSize(1);
      expect(types).toContain('<a href=""MyClass.html"" class=""myCSSClass"">MyClass</a>');
    });
  });

  describe('getSignatureParams', () => {
    // retrieves parameter names.
    // if css class is provided, optional parameters are wrapped in a <span> with that class.
    it('returns an empty array if the doclet has no specified type', () => {
      const doc = new Doclet('/** @function myFunction */', {}, jsdoc.env);
      const params = helper.getSignatureParams(doc);

      expect(params).toBeEmptyArray();
    });

    it(""returns a string array of the doclet's parameter names"", () => {
      const doc = new Doclet(
        '/** @function myFunction\n @param {string} foo - asdf. */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc);

      expect(params).toBeArrayOfSize(1);
      expect(params).toContain('foo');
    });

    it('wraps optional parameters in <span class=..> if optClass is provided', () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc, 'cssClass');

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('<span class=""cssClass"">bar</span>');
      expect(params).toContain('<span class=""cssClass"">baz</span>');
    });

    it(""doesn't wrap optional parameters in <span class=..> if optClass is not provided"", () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc);

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('bar');
      expect(params).toContain('baz');
    });
  });

  describe('getSignatureReturns', () => {
    afterEach(() => {
      delete helper.longnameToUrl.MyClass;
    });

    it('returns a value with correctly escaped HTML', () => {
      const mockDoclet = {
        returns: [
          {
            type: {
              names: ['Array.<string>'],
            },
          },
        ],
      };
      const html = helper.getSignatureReturns(mockDoclet);

      expect(html).not.toContain('Array<string>');
      expect(html).toContain('Array&lt;string&gt;');
    });

    it('returns an empty array if the doclet has no returns', () => {
      const doc = new Doclet('/** @function myFunction */', {}, jsdoc.env);
      const returns = helper.getSignatureReturns(doc);

      expect(returns).toBeEmptyArray();
    });

    it('returns an empty array if the doclet has @returns but with no type', () => {
      const doc = new Doclet(
        '/** @function myFunction\n@returns an interesting result.*/',
        {},
        jsdoc.env
      );
      const returns = helper.getSignatureReturns(doc);

      expect(returns).toBeEmptyArray();
    });

    it('uses the value of the `yields` property', () => {
      const doc = new Doclet('/** @yields {string} A string. */', {}, jsdoc.env);
      const html = helper.getSignatureReturns(doc);

      expect(html).toContain('string');
    });

    it('prefers `yields` over `returns`', () => {
      const doc = new Doclet('/** @yields {string}\n@returns {number} */', {}, jsdoc.env);
      const html = helper.getSignatureReturns(doc);

      expect(html).toContain('string');
      expect(html).not.toContain('number');
    });

    it('creates links for return types if relevant', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc);

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"">MyClass</a>');
      expect(returns).toContain('number');
    });

    it('uses the cssClass parameter for links if it is provided', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc, 'myCssClass');

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"" class=""myCssClass"">MyClass</a>');
      expect(returns).toContain('number');
    });
  });

  // TODO: getAncestors tests

  describe('getAncestorLinks', () => {
    // make a hierarchy.
    const lackeys = new Doclet(
      '/** @member lackeys\n@memberof module:mafia/gangs.Sharks~Henchman\n@instance*/',
      {},
      jsdoc.env
    );
    const henchman = new Doclet(
      '/** @class Henchman\n@memberof module:mafia/gangs.Sharks\n@inner */',
      {},
      jsdoc.env
    );
    const gang = new Doclet('/** @namespace module:mafia/gangs.Sharks */', {}, jsdoc.env);
    const mafia = new Doclet('/** @module mafia/gangs */', {}, jsdoc.env);
    const data = taffy([lackeys, henchman, gang, mafia]);

    afterEach(() => {
      delete helper.longnameToUrl['module:mafia/gangs'];
      delete helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'];
    });

    // register some links
    it('returns an empty array if there are no ancestors', () => {
      const links = helper.getAncestorLinks(data, mafia);

      expect(links).toBeEmptyArray();
    });

    it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    });

    it('adds links if they exist', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"">mafia/gangs</a>');
    });

    it('adds cssClass to any link', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys, 'myClass');

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"" class=""myClass"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"" class=""myClass"">mafia/gangs</a>');
    });
  });

  describe('addEventListeners', () => {
    const docSet = jsdoc.getDocSetFromFile('test/fixtures/listenstag.js');
    const doclets = taffy(_.cloneDeep(docSet.doclets));
    const ev = helper.find(doclets, { longname: 'module:myModule.event:MyEvent' })[0];
    const ev2 = helper.find(doclets, { longname: 'module:myModule~Events.event:Event2' })[0];
    const ev3 = helper.find(doclets, { longname: 'module:myModule#event:Event3' })[0];

    helper.addEventListeners(doclets);

    it(""adds a 'listeners' array to events with the longnames of the listeners"", () => {
      expect(ev.listeners).toBeArrayOfSize(2);
      expect(ev.listeners).toContain('module:myModule~MyHandler');
      expect(ev.listeners).toContain('module:myModule~AnotherHandler');

      expect(ev2.listeners).toBeArrayOfSize(1);
      expect(ev2.listeners).toContain('module:myModule~MyHandler');
    });

    it('does not add listeners for events with no listeners', () => {
      expect(ev3.listeners).toBeUndefined();
    });

    it('does not make spurious doclets if something @listens to a non-existent symbol', () => {
      expect(helper.find(doclets, { longname: 'event:fakeEvent' })).toBeEmptyArray();
    });
  });

  describe('prune', () => {
    const access = options.access;
    const priv = Boolean(options.private);

    afterEach(() => {
      options.access = access;
      options.private = priv;
    });

    const array = [
      // keep
      { undocumented: false },
      // keep
      { ignore: false },
      // keep
      { memberof: 'SomeClass' },
      // prune
      { undocumented: true },
      // prune
      { ignore: true },
      // prune
      { memberof: '<anonymous>' },
    ];
    const keep = [
      // keep
      { undocumented: false },
      // keep
      { ignore: false },
      // keep
      { memberof: 'SomeClass' },
    ];
    const arrayPrivate = [
      // prune (unless options.private is truthy)
      { access: 'private' },
    ];
    const arrayMixed = [
      { access: 'package' },
      { access: 'public' },
      { asdf: true },
      { access: 'protected' },
      { access: 'private' },
    ];

    it('should prune the correct members', () => {
      const pruned = helper.prune(taffy(array), jsdoc.env)().get();

      compareObjectArrays(keep, pruned);
    });

    it('should prune private members if options.private is falsy', () => {
      let pruned;

      options.private = false;
      pruned = helper.prune(taffy(arrayPrivate), jsdoc.env)().get();

      compareObjectArrays([], pruned);
    });

    it('should only keep package-private members if options.access only contains ""package""', () => {
      let pruned;
      const keepPackage = [{ access: 'package' }];

      options.access = 'package';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPackage, pruned);
    });

    it('should only keep public members if options.access only contains ""public""', () => {
      let pruned;
      const keepPublic = [{ access: 'public' }];

      options.access = 'public';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPublic, pruned);
    });

    it('should only keep undefined members if options.access only contains ""undefined""', () => {
      let pruned;
      const keepUndefined = [{ asdf: true }];

      options.access = 'undefined';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepUndefined, pruned);
    });

    it('should only keep protected members if options.access only contains ""protected""', () => {
      let pruned;
      const keepProtected = [{ access: 'protected' }];

      options.access = 'protected';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepProtected, pruned);
    });

    it('should only keep private members if options.access only contains ""private""', () => {
      let pruned;
      const keepPrivate = [{ access: 'private' }];

      options.access = 'private';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPrivate, pruned);
    });

    it('should keep public and protected members if options.access contains ""public"" and ""protected""', () => {
      let pruned;
      const keepPublicProtected = [
        {
          access: 'public',
        },
        {
          access: 'protected',
        },
      ];

      options.access = ['public', 'protected'];
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPublicProtected, pruned);
    });

    it('should keep everything if options.access contains ""all""', () => {
      let pruned;

      options.access = 'all';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(arrayMixed, pruned);
    });

    it('should not prune private members if options.private is truthy', () => {
      let pruned;

      options.private = true;
      pruned = helper.prune(taffy(arrayPrivate), jsdoc.env)().get();

      compareObjectArrays(arrayPrivate, pruned);
    });
  });

  describe('registerLink', () => {
    afterEach(() => {
      delete helper.longnameToUrl.MySymbol;
    });

    it('adds an entry to exports.longnameToUrl', () => {
      helper.longnameToUrl.MySymbol = 'asdf.html';

      expect(helper.longnameToUrl.MySymbol).toBe('asdf.html');
    });

    it('allows linkto to work', () => {
      helper.registerLink('MySymbol', 'asdf.html');

      expect(helper.linkto('MySymbol')).toBe('<a href=""asdf.html"">MySymbol</a>');
    });
  });

  describe('resolveLinks', () => {
    let conf;

    beforeEach(() => {
      conf = _.cloneDeep(config.templates);
    });

    afterEach(() => {
      config.templates = conf;
      delete helper.longnameToUrl['my.long.namespace'];
    });

    it('should translate {@link test} into a HTML link.', () => {
      const input = 'This is a {@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test</a>.');
    });

    it('should translate {@link unknown} into a simple text.', () => {
      const input = 'This is a {@link unknown}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a unknown.');
    });

    it('should translate {@link test} into a HTML links multiple times.', () => {
      const input = 'This is a {@link test} and {@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe(
        'This is a <a href=""path/to/test.html"">test</a> and <a href=""path/to/test.html"">test</a>.'
      );
    });

    it('should translate [hello there]{@link test} into a HTML link with the custom content.', () => {
      const input = 'This is a [hello there]{@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">hello there</a>.');
    });

    it('should translate [dummy text] and [hello there]{@link test} into an HTML link with the custom content.', () => {
      const input = 'This is [dummy text] and [hello there]{@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is [dummy text] and <a href=""path/to/test.html"">hello there</a>.');
    });

    it('should translate [dummy text] and [more] and [hello there]{@link test} into an HTML link with the custom content.', () => {
      const input = 'This is [dummy text] and [more] and [hello there]{@link test}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe(
        'This is [dummy text] and [more] and <a href=""path/to/test.html"">hello there</a>.'
      );
    });

    it('should ignore [hello there].', () => {
      const input = 'This is a [hello there].';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe(input);
    });

    it('should translate http links in the tag', () => {
      const input = 'Link to {@link http://github.com}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""http://github.com"">http://github.com</a>');
    });

    it('should translate ftp links in the tag', () => {
      const input = 'Link to {@link ftp://foo.bar}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""ftp://foo.bar"">ftp://foo.bar</a>');
    });

    it('should allow pipe to be used as delimiter between href and text (external link)', () => {
      const input = 'Link to {@link http://github.com|Github}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""http://github.com"">Github</a>');
    });

    it('should allow pipe to be used as delimiter between href and text (symbol link)', () => {
      const input = 'Link to {@link test|Test}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">Test</a>');
    });

    it('should not add spaces to the href or text when there are spaces around the pipe', () => {
      const input = 'Link to {@link test | Test}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">Test</a>');
    });

    it('should allow first space to be used as delimiter between href and text (external link)', () => {
      const input = 'Link to {@link http://github.com Github}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""http://github.com"">Github</a>');
    });

    it('should allow first space to be used as delimiter between href and text (symbol link)', () => {
      const input = 'Link to {@link test My Caption}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">My Caption</a>');
    });

    it('if pipe and space are present in link tag, use pipe as the delimiter', () => {
      const input = 'Link to {@link test|My Caption}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">My Caption</a>');
    });

    it('Test of {@linkcode } which should be in monospace', () => {
      const input = 'Link to {@linkcode test}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    it('Test of {@linkplain } which should be in normal font', () => {
      const input = 'Link to {@linkplain test}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">test</a>');
    });

    it('should be careful with linking to links whose names are reserved JS keywords', () => {
      const input = 'Link to {@link constructor}';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to constructor');
    });

    it('should allow linebreaks between link tag and content', () => {
      const input = 'This is a {@link\ntest}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test</a>.');
    });

    it('should allow linebreaks to separate url from link text', () => {
      const input = 'This is a {@link\ntest\ntest}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test</a>.');
    });

    it('should normalize additional newlines to spaces', () => {
      const input = 'This is a {@link\ntest\ntest\n\ntest}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test test</a>.');
    });

    it('should allow tabs between link tag and content', () => {
      const input = 'This is a {@link\ttest}.';
      const output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('This is a <a href=""path/to/test.html"">test</a>.');
    });

    // conf.monospaceLinks. check that
    // a) it works
    it('if conf.monospaceLinks is true, all {@link} should be monospace', () => {
      const input = 'Link to {@link test}';
      let output;

      config.templates.monospaceLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    // b) linkcode and linkplain are still respected
    it('if conf.monospaceLinks is true, all {@linkcode} should still be monospace', () => {
      const input = 'Link to {@linkcode test}';
      let output;

      config.templates.monospaceLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    it('if conf.monospaceLinks is true, all {@linkplain} should still be plain', () => {
      const input = 'Link to {@linkplain test}';
      let output;

      config.templates.monospaceLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">test</a>');
    });

    // conf.cleverLinks. check that
    // a) it works
    it('if conf.cleverLinks is true, {@link symbol} should be in monospace', () => {
      const input = 'Link to {@link test}';
      let output;

      config.templates.cleverLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    it('if conf.cleverLinks is true, {@link URL} should be in plain text', () => {
      const input = 'Link to {@link http://github.com}';
      let output;

      config.templates.cleverLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""http://github.com"">http://github.com</a>');
    });

    // b) linkcode and linkplain are still respected
    it('if conf.cleverLinks is true, all {@linkcode} should still be clever', () => {
      const input = 'Link to {@linkcode test}';
      let output;

      config.templates.cleverLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html""><code>test</code></a>');
    });

    it('if conf.cleverLinks is true, all {@linkplain} should still be plain', () => {
      const input = 'Link to {@linkplain test}';
      let output;

      config.templates.cleverLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""path/to/test.html"">test</a>');
    });

    // c) if monospaceLinks is additionally `true` it is ignored in favour
    //    of cleverLinks
    it('if conf.cleverLinks is true and so is conf.monospaceLinks, cleverLinks overrides', () => {
      const input = 'Link to {@link test} and {@link http://github.com}';
      let output;

      config.templates.cleverLinks = true;
      config.templates.monospaceLinks = true;
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe(
        'Link to <a href=""path/to/test.html""><code>test</code></a> and ' +
          '<a href=""http://github.com"">http://github.com</a>'
      );
    });

    it('if conf.useShortNamesInLinks is true, it uses the short name in links', () => {
      const input = 'Link to {@link my.long.namespace}';
      let output;

      config.templates.useShortNamesInLinks = true;
      helper.registerLink('my.long.namespace', 'asdf.html');
      output = helper.resolveLinks(input, jsdoc.env);

      expect(output).toBe('Link to <a href=""asdf.html"">namespace</a>');
    });
  });

  describe('createLink', () => {
    it('should create a url for a simple global.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'foo',
        name: 'foo',
        scope: 'global',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toBe('global.html#foo');
    });

    it('should create a url for a namespace.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'namespace',
        longname: 'foo',
        name: 'foo',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toBe('foo.html');
    });

    it('should create a url for a member of a namespace.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'ns.foo',
        name: 'foo',
        memberof: 'ns',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toBe('ns.html#foo');
    });

    const nestedNamespaceDoclet = {
      env: jsdoc.env,
      kind: 'function',
      longname: 'ns1.ns2.foo',
      name: 'foo',
      memberof: 'ns1.ns2',
    };
    let nestedNamespaceUrl;

    it('should create a url for a member of a nested namespace.', () => {
      nestedNamespaceUrl = helper.createLink(nestedNamespaceDoclet, jsdoc.env);

      expect(nestedNamespaceUrl).toBe('ns1.ns2.html#foo');
    });

    it('should return the same value when called twice with the same doclet.', () => {
      const newUrl = helper.createLink(nestedNamespaceDoclet, jsdoc.env);

      expect(newUrl).toBe(nestedNamespaceUrl);
    });

    it('should create a url for a name with invalid characters.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'ns1.""!"".""*foo""',
        name: '""*foo""',
        memberof: 'ns1.""!""',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toEqual('ns1._!_.html#%22*foo%22');
    });

    it('should create a url for a function that is the only symbol exported by a module.', () => {
      const mockDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'module:bar',
        name: 'module:bar',
      };
      const url = helper.createLink(mockDoclet, jsdoc.env);

      expect(url).toEqual('module-bar.html');
    });

    it('should create a url for a doclet with the wrong kind (caused by incorrect JSDoc tags', () => {
      const moduleDoclet = {
        env: jsdoc.env,
        kind: 'module',
        longname: 'module:baz',
        name: 'module:baz',
      };
      const badDoclet = {
        env: jsdoc.env,
        kind: 'member',
        longname: 'module:baz',
        name: 'module:baz',
      };
      const moduleDocletUrl = helper.createLink(moduleDoclet, jsdoc.env);
      const badDocletUrl = helper.createLink(badDoclet, jsdoc.env);

      expect(moduleDocletUrl).toBe('module-baz.html');
      expect(badDocletUrl).toBe('module-baz.html');
    });

    it('should create a url for a function that is a member of a doclet with the wrong kind', () => {
      const badModuleDoclet = {
        env: jsdoc.env,
        kind: 'member',
        longname: 'module:qux',
        name: 'module:qux',
      };
      const memberDoclet = {
        env: jsdoc.env,
        kind: 'function',
        name: 'frozzle',
        memberof: 'module:qux',
        scope: 'instance',
        longname: 'module:qux#frozzle',
      };
      const badModuleDocletUrl = helper.createLink(badModuleDoclet, jsdoc.env);
      const memberDocletUrl = helper.createLink(memberDoclet, jsdoc.env);

      expect(badModuleDocletUrl).toBe('module-qux.html');
      expect(memberDocletUrl).toBe('module-qux.html#frozzle');
    });

    it('should include the scope punctuation in the fragment ID for static members', () => {
      const functionDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'Milk.pasteurize',
        name: 'pasteurize',
        memberof: 'Milk',
        scope: 'static',
      };
      const docletUrl = helper.createLink(functionDoclet, jsdoc.env);

      expect(docletUrl).toBe('Milk.html#.pasteurize');
    });

    it('should include the scope punctuation in the fragment ID for inner members', () => {
      const functionDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'Milk~removeSticksAndLeaves',
        name: 'removeSticksAndLeaves',
        memberof: 'Milk',
        scope: 'inner',
      };
      const docletUrl = helper.createLink(functionDoclet, jsdoc.env);

      expect(docletUrl).toBe('Milk.html#~removeSticksAndLeaves');
    });

    it('should omit the scope punctuation from the fragment ID for instance members', () => {
      const propertyDoclet = {
        env: jsdoc.env,
        kind: 'member',
        longname: 'Milk#calcium',
        name: 'calcium',
        memberof: 'Milk',
        scope: 'instance',
      };
      const docletUrl = helper.createLink(propertyDoclet, jsdoc.env);

      expect(docletUrl).toBe('Milk.html#calcium');
    });

    it('should include the variation, if present, in the fragment ID', () => {
      const variationDoclet = {
        env: jsdoc.env,
        kind: 'function',
        longname: 'Milk#fat(percent)',
        name: 'fat',
        memberof: 'Milk',
        scope: 'instance',
        variation: '(percent)',
      };
      const docletUrl = helper.createLink(variationDoclet, jsdoc.env);

      expect(docletUrl).toBe('Milk.html#fat(percent)');
    });
  });

  describe('resolveAuthorLinks', () => {
    it('should not crash JSDoc if no text is specified', () => {
      function resolve() {
        helper.resolveAuthorLinks();
      }

      expect(resolve).not.toThrow();
    });

    // convert Jane Doe <jdoe@example.org> to a mailto link.
    it('should convert email addresses in angle brackets *after* a name to mailto links', () => {
      const str = ' John Doe  <asdf.fdsa-2@gmail.com> ';
      const out = helper.resolveAuthorLinks(str);

      expect(out).toBe('<a href=""mailto:asdf.fdsa-2@gmail.com"">John Doe</a>');
    });

    it('should HTML-safe author names', () => {
      const str = ' John<Doe  <asdf.fdsa-2@gmail.com> ';
      const out = helper.resolveAuthorLinks(str);

      expect(out).toBe(`<a href=""mailto:asdf.fdsa-2@gmail.com"">${helper.htmlsafe('John<Doe')}</a>`);
    });

    it('should simply return the input string, HTML-safe, if no email is detected', () => {
      const str = 'John Doe <dummy>';
      const out = helper.resolveAuthorLinks(str);

      expect(out).toBe(helper.htmlsafe(str));
    });
  });

  // TODO: longnamesToTree tests
})",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Conditional Test Logic,"{'line': 711, 'column': 6, 'index': 20845}","describe('getAttribs', () => {
    let doc;
    let attribs;

    it('should return an array', () => {
      doc = new Doclet('/** ljklajsdf */', {}, jsdoc.env);
      attribs = helper.getAttribs(doc);

      expect(attribs).toBeEmptyArray();
    });

    // tests is an object of test[doclet src] = <result expected in attribs|false>
    // if false, we expect attribs to either not contain anything in whatNotToContain,
    // or be empty (if whatNotToContain was not provided).
    function doTests(tests, whatNotToContain) {
      for (const src in tests) {
        if (Object.hasOwn(tests, src)) {
          doc = new Doclet(`/** ${src} */`, {}, jsdoc.env);
          attribs = helper.getAttribs(doc);

          if (tests[src]) {
            expect(attribs).toContain(tests[src]);
          } else if (Array.isArray(whatNotToContain)) {
            for (let i = 0; i < whatNotToContain.length; ++i) {
              expect(attribs).not.toContain(whatNotToContain[i]);
            }
          } else {
            expect(attribs.length).toBe(0);
          }
        }
      }
    }

    it('should detect if a doclet is virtual', () => {
      const tests = {
        'My constant. \n @virtual': 'abstract',
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's access is not public"", () => {
      const tests = {
        '@private': 'private',
        '@access private': 'private',
        '@protected': 'protected',
        '@access protected': 'protected',
        '@public': false,
        '@access public': false,
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's scope is inner or static AND it is a function or member or constant"", () => {
      const tests = {
        // by default these are members
        '@inner': 'inner',
        '@instance': false,
        '@global': false,
        '@static': 'static',
        '@name Asdf.fdsa': 'static',
        '@name Outer~inner': 'inner',
        '@name Fdsa#asdf': false,
        '@name <global>.log': false,
        // some tests with functions and constants
        '@const Asdf#FOO': false,
        '@const Asdf\n@inner': 'inner',
        '@function Asdf#myFunction': false,
        '@function Fdsa.MyFunction': 'static',
        '@function Fdsa': false,
        // these are not functions or members or constants, they should not have their scope recorded.
        '@namespace Fdsa\n@inner': false,
        '@class asdf': false,
      };

      doTests(tests, ['inner', 'static', 'global', 'instance']);
    });

    it(""should detect if a doclet is readonly (and its kind is 'member')"", () => {
      const tests = {
        'asdf\n @readonly': 'readonly',
        asdf: false,
        '@name Fdsa#foo\n@readonly': 'readonly',
        // kind is not 'member'.
        '@const asdf\n@readonly': 'constant',
        '@function asdf\n@readonly': false,
        '@function Asdf#bar\n@readonly': false,
      };

      doTests(tests, 'readonly');
    });

    it('should detect if the doclet is a for constant', () => {
      const tests = {
        'Enum. @enum\n@constant': 'constant',
        '@function Foo#BAR\n@const': 'constant',
        '@const Asdf': 'constant',
      };

      doTests(tests, 'constant');
    });

    it('should detect if a doclet is async', () => {
      const tests = { '@async': 'async' };

      doTests(tests, 'async');
    });

    it('should detect if a doclet is a generator function', () => {
      const tests = { '@generator': 'generator' };

      doTests(tests, 'generator');
    });

    it('should detect multiple attributes', () => {
      const fdsaFoo = new Doclet(
        '/** @const module:fdsa~FOO\n@readonly\n@private */',
        {},
        jsdoc.env
      );

      attribs = helper.getAttribs(fdsaFoo);

      expect(attribs).toContain('private');
      // expect(attribs).toContain('readonly'); // kind is 'constant' not 'member'.
      expect(attribs).toContain('constant');
      expect(attribs).toContain('inner');
    });

    it('should return an empty array for null values', () => {
      let emptyAttribs;

      function getAttribs() {
        return helper.getAttribs();
      }

      expect(getAttribs).not.toThrow();

      emptyAttribs = getAttribs();

      expect(emptyAttribs).toBeEmptyArray();
    });
  })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Conditional Test Logic,"{'line': 712, 'column': 8, 'index': 20880}","describe('getAttribs', () => {
    let doc;
    let attribs;

    it('should return an array', () => {
      doc = new Doclet('/** ljklajsdf */', {}, jsdoc.env);
      attribs = helper.getAttribs(doc);

      expect(attribs).toBeEmptyArray();
    });

    // tests is an object of test[doclet src] = <result expected in attribs|false>
    // if false, we expect attribs to either not contain anything in whatNotToContain,
    // or be empty (if whatNotToContain was not provided).
    function doTests(tests, whatNotToContain) {
      for (const src in tests) {
        if (Object.hasOwn(tests, src)) {
          doc = new Doclet(`/** ${src} */`, {}, jsdoc.env);
          attribs = helper.getAttribs(doc);

          if (tests[src]) {
            expect(attribs).toContain(tests[src]);
          } else if (Array.isArray(whatNotToContain)) {
            for (let i = 0; i < whatNotToContain.length; ++i) {
              expect(attribs).not.toContain(whatNotToContain[i]);
            }
          } else {
            expect(attribs.length).toBe(0);
          }
        }
      }
    }

    it('should detect if a doclet is virtual', () => {
      const tests = {
        'My constant. \n @virtual': 'abstract',
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's access is not public"", () => {
      const tests = {
        '@private': 'private',
        '@access private': 'private',
        '@protected': 'protected',
        '@access protected': 'protected',
        '@public': false,
        '@access public': false,
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's scope is inner or static AND it is a function or member or constant"", () => {
      const tests = {
        // by default these are members
        '@inner': 'inner',
        '@instance': false,
        '@global': false,
        '@static': 'static',
        '@name Asdf.fdsa': 'static',
        '@name Outer~inner': 'inner',
        '@name Fdsa#asdf': false,
        '@name <global>.log': false,
        // some tests with functions and constants
        '@const Asdf#FOO': false,
        '@const Asdf\n@inner': 'inner',
        '@function Asdf#myFunction': false,
        '@function Fdsa.MyFunction': 'static',
        '@function Fdsa': false,
        // these are not functions or members or constants, they should not have their scope recorded.
        '@namespace Fdsa\n@inner': false,
        '@class asdf': false,
      };

      doTests(tests, ['inner', 'static', 'global', 'instance']);
    });

    it(""should detect if a doclet is readonly (and its kind is 'member')"", () => {
      const tests = {
        'asdf\n @readonly': 'readonly',
        asdf: false,
        '@name Fdsa#foo\n@readonly': 'readonly',
        // kind is not 'member'.
        '@const asdf\n@readonly': 'constant',
        '@function asdf\n@readonly': false,
        '@function Asdf#bar\n@readonly': false,
      };

      doTests(tests, 'readonly');
    });

    it('should detect if the doclet is a for constant', () => {
      const tests = {
        'Enum. @enum\n@constant': 'constant',
        '@function Foo#BAR\n@const': 'constant',
        '@const Asdf': 'constant',
      };

      doTests(tests, 'constant');
    });

    it('should detect if a doclet is async', () => {
      const tests = { '@async': 'async' };

      doTests(tests, 'async');
    });

    it('should detect if a doclet is a generator function', () => {
      const tests = { '@generator': 'generator' };

      doTests(tests, 'generator');
    });

    it('should detect multiple attributes', () => {
      const fdsaFoo = new Doclet(
        '/** @const module:fdsa~FOO\n@readonly\n@private */',
        {},
        jsdoc.env
      );

      attribs = helper.getAttribs(fdsaFoo);

      expect(attribs).toContain('private');
      // expect(attribs).toContain('readonly'); // kind is 'constant' not 'member'.
      expect(attribs).toContain('constant');
      expect(attribs).toContain('inner');
    });

    it('should return an empty array for null values', () => {
      let emptyAttribs;

      function getAttribs() {
        return helper.getAttribs();
      }

      expect(getAttribs).not.toThrow();

      emptyAttribs = getAttribs();

      expect(emptyAttribs).toBeEmptyArray();
    });
  })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Conditional Test Logic,"{'line': 716, 'column': 10, 'index': 21028}","describe('getAttribs', () => {
    let doc;
    let attribs;

    it('should return an array', () => {
      doc = new Doclet('/** ljklajsdf */', {}, jsdoc.env);
      attribs = helper.getAttribs(doc);

      expect(attribs).toBeEmptyArray();
    });

    // tests is an object of test[doclet src] = <result expected in attribs|false>
    // if false, we expect attribs to either not contain anything in whatNotToContain,
    // or be empty (if whatNotToContain was not provided).
    function doTests(tests, whatNotToContain) {
      for (const src in tests) {
        if (Object.hasOwn(tests, src)) {
          doc = new Doclet(`/** ${src} */`, {}, jsdoc.env);
          attribs = helper.getAttribs(doc);

          if (tests[src]) {
            expect(attribs).toContain(tests[src]);
          } else if (Array.isArray(whatNotToContain)) {
            for (let i = 0; i < whatNotToContain.length; ++i) {
              expect(attribs).not.toContain(whatNotToContain[i]);
            }
          } else {
            expect(attribs.length).toBe(0);
          }
        }
      }
    }

    it('should detect if a doclet is virtual', () => {
      const tests = {
        'My constant. \n @virtual': 'abstract',
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's access is not public"", () => {
      const tests = {
        '@private': 'private',
        '@access private': 'private',
        '@protected': 'protected',
        '@access protected': 'protected',
        '@public': false,
        '@access public': false,
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's scope is inner or static AND it is a function or member or constant"", () => {
      const tests = {
        // by default these are members
        '@inner': 'inner',
        '@instance': false,
        '@global': false,
        '@static': 'static',
        '@name Asdf.fdsa': 'static',
        '@name Outer~inner': 'inner',
        '@name Fdsa#asdf': false,
        '@name <global>.log': false,
        // some tests with functions and constants
        '@const Asdf#FOO': false,
        '@const Asdf\n@inner': 'inner',
        '@function Asdf#myFunction': false,
        '@function Fdsa.MyFunction': 'static',
        '@function Fdsa': false,
        // these are not functions or members or constants, they should not have their scope recorded.
        '@namespace Fdsa\n@inner': false,
        '@class asdf': false,
      };

      doTests(tests, ['inner', 'static', 'global', 'instance']);
    });

    it(""should detect if a doclet is readonly (and its kind is 'member')"", () => {
      const tests = {
        'asdf\n @readonly': 'readonly',
        asdf: false,
        '@name Fdsa#foo\n@readonly': 'readonly',
        // kind is not 'member'.
        '@const asdf\n@readonly': 'constant',
        '@function asdf\n@readonly': false,
        '@function Asdf#bar\n@readonly': false,
      };

      doTests(tests, 'readonly');
    });

    it('should detect if the doclet is a for constant', () => {
      const tests = {
        'Enum. @enum\n@constant': 'constant',
        '@function Foo#BAR\n@const': 'constant',
        '@const Asdf': 'constant',
      };

      doTests(tests, 'constant');
    });

    it('should detect if a doclet is async', () => {
      const tests = { '@async': 'async' };

      doTests(tests, 'async');
    });

    it('should detect if a doclet is a generator function', () => {
      const tests = { '@generator': 'generator' };

      doTests(tests, 'generator');
    });

    it('should detect multiple attributes', () => {
      const fdsaFoo = new Doclet(
        '/** @const module:fdsa~FOO\n@readonly\n@private */',
        {},
        jsdoc.env
      );

      attribs = helper.getAttribs(fdsaFoo);

      expect(attribs).toContain('private');
      // expect(attribs).toContain('readonly'); // kind is 'constant' not 'member'.
      expect(attribs).toContain('constant');
      expect(attribs).toContain('inner');
    });

    it('should return an empty array for null values', () => {
      let emptyAttribs;

      function getAttribs() {
        return helper.getAttribs();
      }

      expect(getAttribs).not.toThrow();

      emptyAttribs = getAttribs();

      expect(emptyAttribs).toBeEmptyArray();
    });
  })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Conditional Test Logic,"{'line': 718, 'column': 17, 'index': 21114}","describe('getAttribs', () => {
    let doc;
    let attribs;

    it('should return an array', () => {
      doc = new Doclet('/** ljklajsdf */', {}, jsdoc.env);
      attribs = helper.getAttribs(doc);

      expect(attribs).toBeEmptyArray();
    });

    // tests is an object of test[doclet src] = <result expected in attribs|false>
    // if false, we expect attribs to either not contain anything in whatNotToContain,
    // or be empty (if whatNotToContain was not provided).
    function doTests(tests, whatNotToContain) {
      for (const src in tests) {
        if (Object.hasOwn(tests, src)) {
          doc = new Doclet(`/** ${src} */`, {}, jsdoc.env);
          attribs = helper.getAttribs(doc);

          if (tests[src]) {
            expect(attribs).toContain(tests[src]);
          } else if (Array.isArray(whatNotToContain)) {
            for (let i = 0; i < whatNotToContain.length; ++i) {
              expect(attribs).not.toContain(whatNotToContain[i]);
            }
          } else {
            expect(attribs.length).toBe(0);
          }
        }
      }
    }

    it('should detect if a doclet is virtual', () => {
      const tests = {
        'My constant. \n @virtual': 'abstract',
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's access is not public"", () => {
      const tests = {
        '@private': 'private',
        '@access private': 'private',
        '@protected': 'protected',
        '@access protected': 'protected',
        '@public': false,
        '@access public': false,
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's scope is inner or static AND it is a function or member or constant"", () => {
      const tests = {
        // by default these are members
        '@inner': 'inner',
        '@instance': false,
        '@global': false,
        '@static': 'static',
        '@name Asdf.fdsa': 'static',
        '@name Outer~inner': 'inner',
        '@name Fdsa#asdf': false,
        '@name <global>.log': false,
        // some tests with functions and constants
        '@const Asdf#FOO': false,
        '@const Asdf\n@inner': 'inner',
        '@function Asdf#myFunction': false,
        '@function Fdsa.MyFunction': 'static',
        '@function Fdsa': false,
        // these are not functions or members or constants, they should not have their scope recorded.
        '@namespace Fdsa\n@inner': false,
        '@class asdf': false,
      };

      doTests(tests, ['inner', 'static', 'global', 'instance']);
    });

    it(""should detect if a doclet is readonly (and its kind is 'member')"", () => {
      const tests = {
        'asdf\n @readonly': 'readonly',
        asdf: false,
        '@name Fdsa#foo\n@readonly': 'readonly',
        // kind is not 'member'.
        '@const asdf\n@readonly': 'constant',
        '@function asdf\n@readonly': false,
        '@function Asdf#bar\n@readonly': false,
      };

      doTests(tests, 'readonly');
    });

    it('should detect if the doclet is a for constant', () => {
      const tests = {
        'Enum. @enum\n@constant': 'constant',
        '@function Foo#BAR\n@const': 'constant',
        '@const Asdf': 'constant',
      };

      doTests(tests, 'constant');
    });

    it('should detect if a doclet is async', () => {
      const tests = { '@async': 'async' };

      doTests(tests, 'async');
    });

    it('should detect if a doclet is a generator function', () => {
      const tests = { '@generator': 'generator' };

      doTests(tests, 'generator');
    });

    it('should detect multiple attributes', () => {
      const fdsaFoo = new Doclet(
        '/** @const module:fdsa~FOO\n@readonly\n@private */',
        {},
        jsdoc.env
      );

      attribs = helper.getAttribs(fdsaFoo);

      expect(attribs).toContain('private');
      // expect(attribs).toContain('readonly'); // kind is 'constant' not 'member'.
      expect(attribs).toContain('constant');
      expect(attribs).toContain('inner');
    });

    it('should return an empty array for null values', () => {
      let emptyAttribs;

      function getAttribs() {
        return helper.getAttribs();
      }

      expect(getAttribs).not.toThrow();

      emptyAttribs = getAttribs();

      expect(emptyAttribs).toBeEmptyArray();
    });
  })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Conditional Test Logic,"{'line': 719, 'column': 12, 'index': 21165}","describe('getAttribs', () => {
    let doc;
    let attribs;

    it('should return an array', () => {
      doc = new Doclet('/** ljklajsdf */', {}, jsdoc.env);
      attribs = helper.getAttribs(doc);

      expect(attribs).toBeEmptyArray();
    });

    // tests is an object of test[doclet src] = <result expected in attribs|false>
    // if false, we expect attribs to either not contain anything in whatNotToContain,
    // or be empty (if whatNotToContain was not provided).
    function doTests(tests, whatNotToContain) {
      for (const src in tests) {
        if (Object.hasOwn(tests, src)) {
          doc = new Doclet(`/** ${src} */`, {}, jsdoc.env);
          attribs = helper.getAttribs(doc);

          if (tests[src]) {
            expect(attribs).toContain(tests[src]);
          } else if (Array.isArray(whatNotToContain)) {
            for (let i = 0; i < whatNotToContain.length; ++i) {
              expect(attribs).not.toContain(whatNotToContain[i]);
            }
          } else {
            expect(attribs.length).toBe(0);
          }
        }
      }
    }

    it('should detect if a doclet is virtual', () => {
      const tests = {
        'My constant. \n @virtual': 'abstract',
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's access is not public"", () => {
      const tests = {
        '@private': 'private',
        '@access private': 'private',
        '@protected': 'protected',
        '@access protected': 'protected',
        '@public': false,
        '@access public': false,
        asdf: false,
      };

      doTests(tests);
    });

    it(""should detect if a doclet's scope is inner or static AND it is a function or member or constant"", () => {
      const tests = {
        // by default these are members
        '@inner': 'inner',
        '@instance': false,
        '@global': false,
        '@static': 'static',
        '@name Asdf.fdsa': 'static',
        '@name Outer~inner': 'inner',
        '@name Fdsa#asdf': false,
        '@name <global>.log': false,
        // some tests with functions and constants
        '@const Asdf#FOO': false,
        '@const Asdf\n@inner': 'inner',
        '@function Asdf#myFunction': false,
        '@function Fdsa.MyFunction': 'static',
        '@function Fdsa': false,
        // these are not functions or members or constants, they should not have their scope recorded.
        '@namespace Fdsa\n@inner': false,
        '@class asdf': false,
      };

      doTests(tests, ['inner', 'static', 'global', 'instance']);
    });

    it(""should detect if a doclet is readonly (and its kind is 'member')"", () => {
      const tests = {
        'asdf\n @readonly': 'readonly',
        asdf: false,
        '@name Fdsa#foo\n@readonly': 'readonly',
        // kind is not 'member'.
        '@const asdf\n@readonly': 'constant',
        '@function asdf\n@readonly': false,
        '@function Asdf#bar\n@readonly': false,
      };

      doTests(tests, 'readonly');
    });

    it('should detect if the doclet is a for constant', () => {
      const tests = {
        'Enum. @enum\n@constant': 'constant',
        '@function Foo#BAR\n@const': 'constant',
        '@const Asdf': 'constant',
      };

      doTests(tests, 'constant');
    });

    it('should detect if a doclet is async', () => {
      const tests = { '@async': 'async' };

      doTests(tests, 'async');
    });

    it('should detect if a doclet is a generator function', () => {
      const tests = { '@generator': 'generator' };

      doTests(tests, 'generator');
    });

    it('should detect multiple attributes', () => {
      const fdsaFoo = new Doclet(
        '/** @const module:fdsa~FOO\n@readonly\n@private */',
        {},
        jsdoc.env
      );

      attribs = helper.getAttribs(fdsaFoo);

      expect(attribs).toContain('private');
      // expect(attribs).toContain('readonly'); // kind is 'constant' not 'member'.
      expect(attribs).toContain('constant');
      expect(attribs).toContain('inner');
    });

    it('should return an empty array for null values', () => {
      let emptyAttribs;

      function getAttribs() {
        return helper.getAttribs();
      }

      expect(getAttribs).not.toThrow();

      emptyAttribs = getAttribs();

      expect(emptyAttribs).toBeEmptyArray();
    });
  })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 293, 'column': 6, 'index': 9268}","it('has an entry added into it by calling registerLink', () => {
      helper.registerLink('MySymbol', 'asdf.html');

      expect(helper.longnameToUrl.MySymbol).toBeDefined();
      expect(helper.longnameToUrl.MySymbol).toBe('asdf.html');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 294, 'column': 6, 'index': 9327}","it('has an entry added into it by calling registerLink', () => {
      helper.registerLink('MySymbol', 'asdf.html');

      expect(helper.longnameToUrl.MySymbol).toBeDefined();
      expect(helper.longnameToUrl.MySymbol).toBe('asdf.html');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 822, 'column': 6, 'index': 24128}","it('should detect multiple attributes', () => {
      const fdsaFoo = new Doclet(
        '/** @const module:fdsa~FOO\n@readonly\n@private */',
        {},
        jsdoc.env
      );

      attribs = helper.getAttribs(fdsaFoo);

      expect(attribs).toContain('private');
      // expect(attribs).toContain('readonly'); // kind is 'constant' not 'member'.
      expect(attribs).toContain('constant');
      expect(attribs).toContain('inner');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 824, 'column': 6, 'index': 24256}","it('should detect multiple attributes', () => {
      const fdsaFoo = new Doclet(
        '/** @const module:fdsa~FOO\n@readonly\n@private */',
        {},
        jsdoc.env
      );

      attribs = helper.getAttribs(fdsaFoo);

      expect(attribs).toContain('private');
      // expect(attribs).toContain('readonly'); // kind is 'constant' not 'member'.
      expect(attribs).toContain('constant');
      expect(attribs).toContain('inner');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 825, 'column': 6, 'index': 24301}","it('should detect multiple attributes', () => {
      const fdsaFoo = new Doclet(
        '/** @const module:fdsa~FOO\n@readonly\n@private */',
        {},
        jsdoc.env
      );

      attribs = helper.getAttribs(fdsaFoo);

      expect(attribs).toContain('private');
      // expect(attribs).toContain('readonly'); // kind is 'constant' not 'member'.
      expect(attribs).toContain('constant');
      expect(attribs).toContain('inner');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 860, 'column': 6, 'index': 25268}","it(""returns a string array of the doclet's types"", () => {
      const doc = new Doclet('/** @const {number|Array.<boolean>} ASDF */', {}, jsdoc.env);
      const types = helper.getSignatureTypes(doc);

      expect(types).toBeArrayOfSize(2);
      expect(types).toContain('number');
      expect(types).toContain('Array&lt;boolean&gt;');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 861, 'column': 6, 'index': 25308}","it(""returns a string array of the doclet's types"", () => {
      const doc = new Doclet('/** @const {number|Array.<boolean>} ASDF */', {}, jsdoc.env);
      const types = helper.getSignatureTypes(doc);

      expect(types).toBeArrayOfSize(2);
      expect(types).toContain('number');
      expect(types).toContain('Array&lt;boolean&gt;');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 862, 'column': 6, 'index': 25349}","it(""returns a string array of the doclet's types"", () => {
      const doc = new Doclet('/** @const {number|Array.<boolean>} ASDF */', {}, jsdoc.env);
      const types = helper.getSignatureTypes(doc);

      expect(types).toBeArrayOfSize(2);
      expect(types).toContain('number');
      expect(types).toContain('Array&lt;boolean&gt;');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 875, 'column': 6, 'index': 25697}","it('creates links for types if relevant', () => {
      let doc;
      let types;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet('/** @const {MyClass} ASDF */', {}, jsdoc.env);
      types = helper.getSignatureTypes(doc);

      expect(types).toBeArrayOfSize(1);
      expect(types).toContain('<a href=""MyClass.html"">MyClass</a>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 876, 'column': 6, 'index': 25737}","it('creates links for types if relevant', () => {
      let doc;
      let types;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet('/** @const {MyClass} ASDF */', {}, jsdoc.env);
      types = helper.getSignatureTypes(doc);

      expect(types).toBeArrayOfSize(1);
      expect(types).toContain('<a href=""MyClass.html"">MyClass</a>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 889, 'column': 6, 'index': 26133}","it('uses the cssClass parameter for links if it is provided', () => {
      let doc;
      let types;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet('/** @const {MyClass} ASDF */', {}, jsdoc.env);
      types = helper.getSignatureTypes(doc, 'myCSSClass');

      expect(types).toBeArrayOfSize(1);
      expect(types).toContain('<a href=""MyClass.html"" class=""myCSSClass"">MyClass</a>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 890, 'column': 6, 'index': 26173}","it('uses the cssClass parameter for links if it is provided', () => {
      let doc;
      let types;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet('/** @const {MyClass} ASDF */', {}, jsdoc.env);
      types = helper.getSignatureTypes(doc, 'myCSSClass');

      expect(types).toBeArrayOfSize(1);
      expect(types).toContain('<a href=""MyClass.html"" class=""myCSSClass"">MyClass</a>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 912, 'column': 6, 'index': 26965}","it(""returns a string array of the doclet's parameter names"", () => {
      const doc = new Doclet(
        '/** @function myFunction\n @param {string} foo - asdf. */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc);

      expect(params).toBeArrayOfSize(1);
      expect(params).toContain('foo');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 913, 'column': 6, 'index': 27006}","it(""returns a string array of the doclet's parameter names"", () => {
      const doc = new Doclet(
        '/** @function myFunction\n @param {string} foo - asdf. */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc);

      expect(params).toBeArrayOfSize(1);
      expect(params).toContain('foo');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 928, 'column': 6, 'index': 27517}","it('wraps optional parameters in <span class=..> if optClass is provided', () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc, 'cssClass');

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('<span class=""cssClass"">bar</span>');
      expect(params).toContain('<span class=""cssClass"">baz</span>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 929, 'column': 6, 'index': 27558}","it('wraps optional parameters in <span class=..> if optClass is provided', () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc, 'cssClass');

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('<span class=""cssClass"">bar</span>');
      expect(params).toContain('<span class=""cssClass"">baz</span>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 930, 'column': 6, 'index': 27597}","it('wraps optional parameters in <span class=..> if optClass is provided', () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc, 'cssClass');

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('<span class=""cssClass"">bar</span>');
      expect(params).toContain('<span class=""cssClass"">baz</span>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 931, 'column': 6, 'index': 27666}","it('wraps optional parameters in <span class=..> if optClass is provided', () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc, 'cssClass');

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('<span class=""cssClass"">bar</span>');
      expect(params).toContain('<span class=""cssClass"">baz</span>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 946, 'column': 6, 'index': 28206}","it(""doesn't wrap optional parameters in <span class=..> if optClass is not provided"", () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc);

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('bar');
      expect(params).toContain('baz');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 947, 'column': 6, 'index': 28247}","it(""doesn't wrap optional parameters in <span class=..> if optClass is not provided"", () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc);

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('bar');
      expect(params).toContain('baz');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 948, 'column': 6, 'index': 28286}","it(""doesn't wrap optional parameters in <span class=..> if optClass is not provided"", () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc);

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('bar');
      expect(params).toContain('baz');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 949, 'column': 6, 'index': 28325}","it(""doesn't wrap optional parameters in <span class=..> if optClass is not provided"", () => {
      const doc = new Doclet(
        '/** @function myFunction\n' +
          ' * @param {boolean} foo - explanation.\n' +
          ' * @param {number} [bar=1] - another explanation.\n' +
          ' * @param {string} [baz] - another explanation.\n' +
          ' */',
        {},
        jsdoc.env
      );
      const params = helper.getSignatureParams(doc);

      expect(params).toBeArrayOfSize(3);
      expect(params).toContain('foo');
      expect(params).toContain('bar');
      expect(params).toContain('baz');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 970, 'column': 6, 'index': 28784}","it('returns a value with correctly escaped HTML', () => {
      const mockDoclet = {
        returns: [
          {
            type: {
              names: ['Array.<string>'],
            },
          },
        ],
      };
      const html = helper.getSignatureReturns(mockDoclet);

      expect(html).not.toContain('Array<string>');
      expect(html).toContain('Array&lt;string&gt;');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 971, 'column': 6, 'index': 28835}","it('returns a value with correctly escaped HTML', () => {
      const mockDoclet = {
        returns: [
          {
            type: {
              names: ['Array.<string>'],
            },
          },
        ],
      };
      const html = helper.getSignatureReturns(mockDoclet);

      expect(html).not.toContain('Array<string>');
      expect(html).toContain('Array&lt;string&gt;');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1003, 'column': 6, 'index': 29914}","it('prefers `yields` over `returns`', () => {
      const doc = new Doclet('/** @yields {string}\n@returns {number} */', {}, jsdoc.env);
      const html = helper.getSignatureReturns(doc);

      expect(html).toContain('string');
      expect(html).not.toContain('number');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1004, 'column': 6, 'index': 29954}","it('prefers `yields` over `returns`', () => {
      const doc = new Doclet('/** @yields {string}\n@returns {number} */', {}, jsdoc.env);
      const html = helper.getSignatureReturns(doc);

      expect(html).toContain('string');
      expect(html).not.toContain('number');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1021, 'column': 6, 'index': 30384}","it('creates links for return types if relevant', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc);

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"">MyClass</a>');
      expect(returns).toContain('number');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1022, 'column': 6, 'index': 30426}","it('creates links for return types if relevant', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc);

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"">MyClass</a>');
      expect(returns).toContain('number');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1023, 'column': 6, 'index': 30497}","it('creates links for return types if relevant', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc);

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"">MyClass</a>');
      expect(returns).toContain('number');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1040, 'column': 6, 'index': 30953}","it('uses the cssClass parameter for links if it is provided', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc, 'myCssClass');

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"" class=""myCssClass"">MyClass</a>');
      expect(returns).toContain('number');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1041, 'column': 6, 'index': 30995}","it('uses the cssClass parameter for links if it is provided', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc, 'myCssClass');

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"" class=""myCssClass"">MyClass</a>');
      expect(returns).toContain('number');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1042, 'column': 6, 'index': 31085}","it('uses the cssClass parameter for links if it is provided', () => {
      let doc;
      let returns;

      // make some links.
      helper.longnameToUrl.MyClass = 'MyClass.html';

      doc = new Doclet(
        '/** @function myFunction\n@returns {number|MyClass} an interesting result.*/',
        {},
        jsdoc.env
      );
      returns = helper.getSignatureReturns(doc, 'myCssClass');

      expect(returns).toBeArrayOfSize(2);
      expect(returns).toContain('<a href=""MyClass.html"" class=""myCssClass"">MyClass</a>');
      expect(returns).toContain('number');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1079, 'column': 6, 'index': 32336}","it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1080, 'column': 6, 'index': 32376}","it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1081, 'column': 6, 'index': 32421}","it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1082, 'column': 6, 'index': 32463}","it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1082, 'column': 6, 'index': 32463}","it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1086, 'column': 6, 'index': 32566}","it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1087, 'column': 6, 'index': 32606}","it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1088, 'column': 6, 'index': 32649}","it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1088, 'column': 6, 'index': 32649}","it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1092, 'column': 6, 'index': 32748}","it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1093, 'column': 6, 'index': 32788}","it('returns an array of ancestor names (with preceding punctuation) if there are ancestors, the direct ancestor with following punctuation too', () => {
      let links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('~Henchman#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, henchman);

      expect(links).toBeArrayOfSize(2);
      expect(links).toContain('.Sharks~');
      expect(links).toContain('mafia/gangs');

      links = helper.getAncestorLinks(data, gang);

      expect(links).toBeArrayOfSize(1);
      expect(links).toContain('mafia/gangs.');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1105, 'column': 6, 'index': 33145}","it('adds links if they exist', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"">mafia/gangs</a>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1106, 'column': 6, 'index': 33185}","it('adds links if they exist', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"">mafia/gangs</a>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1107, 'column': 6, 'index': 33258}","it('adds links if they exist', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"">mafia/gangs</a>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1108, 'column': 6, 'index': 33300}","it('adds links if they exist', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys);

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"">mafia/gangs</a>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1120, 'column': 6, 'index': 33699}","it('adds cssClass to any link', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys, 'myClass');

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"" class=""myClass"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"" class=""myClass"">mafia/gangs</a>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1121, 'column': 6, 'index': 33739}","it('adds cssClass to any link', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys, 'myClass');

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"" class=""myClass"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"" class=""myClass"">mafia/gangs</a>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1122, 'column': 6, 'index': 33828}","it('adds cssClass to any link', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys, 'myClass');

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"" class=""myClass"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"" class=""myClass"">mafia/gangs</a>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1123, 'column': 6, 'index': 33870}","it('adds cssClass to any link', () => {
      let links;

      // register some links
      helper.longnameToUrl['module:mafia/gangs'] = 'mafia_gangs.html';
      helper.longnameToUrl['module:mafia/gangs.Sharks~Henchman'] = 'henchman.html';

      links = helper.getAncestorLinks(data, lackeys, 'myClass');

      expect(links).toBeArrayOfSize(3);
      expect(links).toContain('<a href=""henchman.html"" class=""myClass"">~Henchman</a>#');
      expect(links).toContain('.Sharks');
      expect(links).toContain('<a href=""mafia_gangs.html"" class=""myClass"">mafia/gangs</a>');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1137, 'column': 6, 'index': 34547}","it(""adds a 'listeners' array to events with the longnames of the listeners"", () => {
      expect(ev.listeners).toBeArrayOfSize(2);
      expect(ev.listeners).toContain('module:myModule~MyHandler');
      expect(ev.listeners).toContain('module:myModule~AnotherHandler');

      expect(ev2.listeners).toBeArrayOfSize(1);
      expect(ev2.listeners).toContain('module:myModule~MyHandler');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1138, 'column': 6, 'index': 34594}","it(""adds a 'listeners' array to events with the longnames of the listeners"", () => {
      expect(ev.listeners).toBeArrayOfSize(2);
      expect(ev.listeners).toContain('module:myModule~MyHandler');
      expect(ev.listeners).toContain('module:myModule~AnotherHandler');

      expect(ev2.listeners).toBeArrayOfSize(1);
      expect(ev2.listeners).toContain('module:myModule~MyHandler');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1139, 'column': 6, 'index': 34661}","it(""adds a 'listeners' array to events with the longnames of the listeners"", () => {
      expect(ev.listeners).toBeArrayOfSize(2);
      expect(ev.listeners).toContain('module:myModule~MyHandler');
      expect(ev.listeners).toContain('module:myModule~AnotherHandler');

      expect(ev2.listeners).toBeArrayOfSize(1);
      expect(ev2.listeners).toContain('module:myModule~MyHandler');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1141, 'column': 6, 'index': 34734}","it(""adds a 'listeners' array to events with the longnames of the listeners"", () => {
      expect(ev.listeners).toBeArrayOfSize(2);
      expect(ev.listeners).toContain('module:myModule~MyHandler');
      expect(ev.listeners).toContain('module:myModule~AnotherHandler');

      expect(ev2.listeners).toBeArrayOfSize(1);
      expect(ev2.listeners).toContain('module:myModule~MyHandler');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Duplicate Assert,"{'line': 1142, 'column': 6, 'index': 34782}","it(""adds a 'listeners' array to events with the longnames of the listeners"", () => {
      expect(ev.listeners).toBeArrayOfSize(2);
      expect(ev.listeners).toContain('module:myModule~MyHandler');
      expect(ev.listeners).toContain('module:myModule~AnotherHandler');

      expect(ev2.listeners).toBeArrayOfSize(1);
      expect(ev2.listeners).toContain('module:myModule~MyHandler');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 667}","it('classes are detected', () => {
      compareObjectArrays(classes, members.classes);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 671}","it('externals are detected', () => {
      compareObjectArrays(externals, members.externals);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 675}","it('events are detected', () => {
      compareObjectArrays(events, members.events);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 679}","it('mixins are detected', () => {
      compareObjectArrays(mixins, members.mixins);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 683}","it('modules are detected', () => {
      compareObjectArrays(modules, members.modules);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 687}","it('namespaces are detected', () => {
      compareObjectArrays(namespaces, members.namespaces);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 691}","it('globals are detected', () => {
      compareObjectArrays(miscGlobal, members.globals);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 729}","it('should detect if a doclet is virtual', () => {
      const tests = {
        'My constant. \n @virtual': 'abstract',
        asdf: false,
      };

      doTests(tests);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 738}","it(""should detect if a doclet's access is not public"", () => {
      const tests = {
        '@private': 'private',
        '@access private': 'private',
        '@protected': 'protected',
        '@access protected': 'protected',
        '@public': false,
        '@access public': false,
        asdf: false,
      };

      doTests(tests);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 752}","it(""should detect if a doclet's scope is inner or static AND it is a function or member or constant"", () => {
      const tests = {
        // by default these are members
        '@inner': 'inner',
        '@instance': false,
        '@global': false,
        '@static': 'static',
        '@name Asdf.fdsa': 'static',
        '@name Outer~inner': 'inner',
        '@name Fdsa#asdf': false,
        '@name <global>.log': false,
        // some tests with functions and constants
        '@const Asdf#FOO': false,
        '@const Asdf\n@inner': 'inner',
        '@function Asdf#myFunction': false,
        '@function Fdsa.MyFunction': 'static',
        '@function Fdsa': false,
        // these are not functions or members or constants, they should not have their scope recorded.
        '@namespace Fdsa\n@inner': false,
        '@class asdf': false,
      };

      doTests(tests, ['inner', 'static', 'global', 'instance']);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 777}","it(""should detect if a doclet is readonly (and its kind is 'member')"", () => {
      const tests = {
        'asdf\n @readonly': 'readonly',
        asdf: false,
        '@name Fdsa#foo\n@readonly': 'readonly',
        // kind is not 'member'.
        '@const asdf\n@readonly': 'constant',
        '@function asdf\n@readonly': false,
        '@function Asdf#bar\n@readonly': false,
      };

      doTests(tests, 'readonly');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 791}","it('should detect if the doclet is a for constant', () => {
      const tests = {
        'Enum. @enum\n@constant': 'constant',
        '@function Foo#BAR\n@const': 'constant',
        '@const Asdf': 'constant',
      };

      doTests(tests, 'constant');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 801}","it('should detect if a doclet is async', () => {
      const tests = { '@async': 'async' };

      doTests(tests, 'async');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 807}","it('should detect if a doclet is a generator function', () => {
      const tests = { '@generator': 'generator' };

      doTests(tests, 'generator');
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 1197}","it('should prune the correct members', () => {
      const pruned = helper.prune(taffy(array), jsdoc.env)().get();

      compareObjectArrays(keep, pruned);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 1203}","it('should prune private members if options.private is falsy', () => {
      let pruned;

      options.private = false;
      pruned = helper.prune(taffy(arrayPrivate), jsdoc.env)().get();

      compareObjectArrays([], pruned);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 1212}","it('should only keep package-private members if options.access only contains ""package""', () => {
      let pruned;
      const keepPackage = [{ access: 'package' }];

      options.access = 'package';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPackage, pruned);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 1222}","it('should only keep public members if options.access only contains ""public""', () => {
      let pruned;
      const keepPublic = [{ access: 'public' }];

      options.access = 'public';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPublic, pruned);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 1232}","it('should only keep undefined members if options.access only contains ""undefined""', () => {
      let pruned;
      const keepUndefined = [{ asdf: true }];

      options.access = 'undefined';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepUndefined, pruned);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 1242}","it('should only keep protected members if options.access only contains ""protected""', () => {
      let pruned;
      const keepProtected = [{ access: 'protected' }];

      options.access = 'protected';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepProtected, pruned);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 1252}","it('should only keep private members if options.access only contains ""private""', () => {
      let pruned;
      const keepPrivate = [{ access: 'private' }];

      options.access = 'private';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPrivate, pruned);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 1262}","it('should keep public and protected members if options.access contains ""public"" and ""protected""', () => {
      let pruned;
      const keepPublicProtected = [
        {
          access: 'public',
        },
        {
          access: 'protected',
        },
      ];

      options.access = ['public', 'protected'];
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(keepPublicProtected, pruned);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 1279}","it('should keep everything if options.access contains ""all""', () => {
      let pruned;

      options.access = 'all';
      pruned = helper.prune(taffy(arrayMixed), jsdoc.env)().get();

      compareObjectArrays(arrayMixed, pruned);
    })",steel
/packages/jsdoc-template-legacy/test/specs/lib/templateHelper.js,Unknown Test,"{'column': 4, 'line': 1288}","it('should not prune private members if options.private is truthy', () => {
      let pruned;

      options.private = true;
      pruned = helper.prune(taffy(arrayPrivate), jsdoc.env)().get();

      compareObjectArrays(arrayPrivate, pruned);
    })",steel
/packages/jsdoc-task-runner/test/specs/lib/task.js,Exception Handling,"{'line': 154, 'column': 6, 'index': 3568}","it('requires a name', async () => {
      let error;

      async function start() {
        const task = new Task({
          func: () => Promise.resolve(),
        });

        await task.run();
      }

      try {
        await start();
      } catch (e) {
        error = e;
      }

      expect(error).toBeDefined();
    })",steel
/packages/jsdoc-task-runner/test/specs/lib/task.js,Exception Handling,"{'line': 174, 'column': 6, 'index': 3889}","it('requires a function', async () => {
      let error;

      async function run() {
        const task = new Task({
          name: 'foo',
        });

        await task.run();
      }

      try {
        await run();
      } catch (e) {
        error = e;
      }

      expect(error).toBeDefined();
    })",steel
/packages/jsdoc-task-runner/test/specs/lib/task.js,Exception Handling,"{'line': 244, 'column': 8, 'index': 5292}","it('emits an `error` event if necessary', async () => {
        let error = new Error('oh no!');
        let event;
        const task = new Task({
          name: 'foo',
          func: () => Promise.reject(error),
        });

        task.on('error', (e) => {
          event = e;
        });

        try {
          await task.run();
        } catch (e) {
          // Expected behavior.
        }

        expect(event.error).toBe(error);
        expect(event.task).toBe(task);
      })",steel
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,Exception Handling,"{'line': 163, 'column': 6, 'index': 3885}","it('causes an error to be emitted if the task errors', async () => {
      let error;
      let event;
      let promise;

      runner.addTask(badTask);
      promise = runner.once('taskError');

      try {
        await runner.run();
      } catch (e) {
        error = e;
      }

      event = await promise;

      expect(event).toBeObject();
      expect(rethrower(event.error)).toThrowError();
      expect(event.error).toBe(error);
      expect(event.task).toBe(badTask);
    })",steel
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,Exception Handling,"{'line': 322, 'column': 6, 'index': 7377}","it('correctly removes the task', async () => {
      let error;

      runner.addTasks([foo, bar]);
      runner.removeTask(foo);

      try {
        await runner.run();
      } catch (e) {
        error = e;
      }

      expect(error).toBeUndefined();
      expect(fooResult).toBeNull();
      expect(barResult).toBeTrue();
    })",steel
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,Exception Handling,"{'line': 365, 'column': 6, 'index': 8339}","it('prevents `taskError` events for the task', async () => {
      let errorEvent;
      let taskErrorEvent;

      runner.addTask(badTask);
      runner.removeTask(badTask);

      badTask.on('error', (e) => {
        errorEvent = e;
      });
      runner.on('taskError', (e) => {
        taskErrorEvent = e;
      });

      try {
        await badTask.run();
      } catch (e) {
        // Expected behavior.
      }

      expect(errorEvent).toBeObject();
      expect(errorEvent.task).toBe(badTask);
      expect(taskErrorEvent).toBeUndefined();
    })",steel
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,Exception Handling,"{'line': 554, 'column': 6, 'index': 12245}","it('fails if the task runner is already running', async () => {
      let error;

      runner.addTask(taskA);
      runner.run();

      try {
        await runner.run();
      } catch (e) {
        error = e;
      }

      expect(rethrower(error)).toThrowErrorOfType(STATE_ERROR);
    })",steel
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,Exception Handling,"{'line': 574, 'column': 6, 'index': 12675}","it('fails if a task errors', async () => {
      let error;

      runner.addTask(badTask);
      try {
        await runner.run();
      } catch (e) {
        error = e;
      }

      expect(rethrower(error)).toThrowError();
    })",steel
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,Exception Handling,"{'line': 625, 'column': 8, 'index': 13787}","it('fails if the context is not an object', async () => {
        let error;

        try {
          await new TaskRunner().run(7);
        } catch (e) {
          error = e;
        }

        expect(error).toBeErrorOfType(ARGUMENT_ERROR);
      })",steel
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,Exception Handling,"{'line': 694, 'column': 8, 'index': 15372}","it('errors if a task depends on an unknown task', async () => {
        let error;

        runner.addTask(
          new Task({
            name: 'badDependsOn',
            func: () => Promise.resolve(),
            dependsOn: ['mysteryTask'],
          })
        );

        try {
          await runner.run();
        } catch (e) {
          error = e;
        }

        expect(rethrower(error)).toThrowErrorOfType(UNKNOWN_DEPENDENCY_ERROR);
      })",steel
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,Exception Handling,"{'line': 719, 'column': 8, 'index': 15957}","it('errors if there are circular dependencies', async () => {
        let error;

        runner.addTasks([
          new Task({
            name: 'one',
            func: () => Promise.resolve(),
            dependsOn: ['two'],
          }),
          new Task({
            name: 'two',
            func: () => Promise.resolve(),
            dependsOn: ['one'],
          }),
        ]);

        try {
          await runner.run();
        } catch (e) {
          error = e;
        }

        expect(rethrower(error)).toThrowErrorOfType(DEPENDENCY_CYCLE_ERROR);
      })",steel
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,Exception Handling,"{'line': 764, 'column': 8, 'index': 16952}","it('fails and emits an error in the `end` event if necessary', async () => {
        let endError;
        let error;

        runner.addTask(badTask);
        runner.on('end', (e) => {
          endError = e.error;
        });

        try {
          await runner.run();
        } catch (e) {
          error = e;
        }

        expect(rethrower(endError)).toThrowError();
        expect(endError).toBe(error);
      })",steel
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,Magic Number,"{'line': 524, 'column': 21, 'index': 11615}","it('runs every task', async () => {
      runner.addTasks([taskA, taskB, taskC]);
      await runner.run();

      expect(a).toBe(5);
      expect(b).toBe(15);
      expect(c).toBe(20);
    })",steel
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,Magic Number,"{'line': 525, 'column': 21, 'index': 11640}","it('runs every task', async () => {
      runner.addTasks([taskA, taskB, taskC]);
      await runner.run();

      expect(a).toBe(5);
      expect(b).toBe(15);
      expect(c).toBe(20);
    })",steel
/packages/jsdoc-task-runner/test/specs/lib/task-runner.js,Magic Number,"{'line': 526, 'column': 21, 'index': 11666}","it('runs every task', async () => {
      runner.addTasks([taskA, taskB, taskC]);
      await runner.run();

      expect(a).toBe(5);
      expect(b).toBe(15);
      expect(c).toBe(20);
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Conditional Test Logic,"{'line': 23, 'column': 4, 'index': 743}","describe('@jsdoc/tag/lib/type', () => {
  function buildText(typeInfo, name, desc) {
    let text = '';

    if (typeInfo) {
      text += `{${typeInfo}}`;
      if (name || desc) {
        text += ' ';
      }
    }

    if (name) {
      text += name;
      if (desc) {
        text += ' ';
      }
    }

    if (desc) {
      text += desc;
    }

    return text;
  }

  it('is an object', () => {
    expect(type).toBeObject();
  });

  it('exports a parse function', () => {
    expect(type.parse).toBeFunction();
  });

  describe('parse', () => {
    it('returns an object with name, type, and text properties', () => {
      const info = type.parse('');

      expect(info.name).toBeString();
      expect(info.type).toBeArray();
      expect(info.text).toBeString();
    });

    it('does not extract a name or type if canHaveName and canHaveType are not set', () => {
      const desc = '{number} foo The foo parameter.';
      const info = type.parse(desc);

      expect(info.type).toBeEmptyArray();
      expect(info.name).toBe('');
      expect(info.text).toBe(desc);
    });

    it('extracts a name, but not a type, if canHaveName is true and canHaveType is false', () => {
      const name = 'bar';
      const desc = 'The bar parameter.';
      const info = type.parse(buildText(null, name, desc), true, false);

      expect(info.type).toBeEmptyArray();
      expect(info.name).toBe(name);
      expect(info.text).toBe(desc);
    });

    it('extracts a type, but not a name, if canHaveName is false and canHaveType is true', () => {
      const typeString = 'boolean';
      const desc = 'Set to true on alternate Thursdays.';
      const info = type.parse(buildText(typeString, null, desc), false, true);

      expect(info.type).toEqual([typeString]);
      expect(info.name).toBe('');
      expect(info.text).toBe(desc);
    });

    it('extracts a name and type if canHaveName and canHaveType are true', () => {
      const typeString = 'string';
      const name = 'baz';
      const desc = 'The baz parameter.';
      const info = type.parse(buildText(typeString, name, desc), true, true);

      expect(info.type).toEqual([typeString]);
      expect(info.name).toBe(name);
      expect(info.text).toBe(desc);
    });

    it('reports optional types correctly for both JSDoc and Closure syntax', () => {
      let desc = '{string} [foo]';
      let info = type.parse(desc, true, true);

      expect(info.optional).toBeTrue();

      desc = '{string=} [foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();

      desc = '[foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();
    });

    it('returnsthe types as an array', () => {
      const desc = '{string} foo';
      const info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string']);
    });

    it('recognizes the entire list of possible types', () => {
      let desc = '{(string|number)} foo';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string', 'number']);

      desc = '{ ( string | number ) } foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{  (   string  | number)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{(string|number|boolean|function)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number', 'boolean', 'function']);
    });

    it('does not find any type if there is no text in braces', () => {
      const desc = 'braceless text';
      const info = type.parse(desc, false, true);

      expect(info.type).toBeEmptyArray();
    });

    it('copes with bad escapement at the end of the string', () => {
      const desc = 'bad {escapement \\';
      const info = type.parse(desc, false, true);

      expect(info.type).toBeEmptyArray();
      expect(info.text).toBe(desc);
    });

    it('handles escaped braces correctly', () => {
      const desc = '{weirdObject.""with\\}AnnoyingProperty""}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('weirdObject.""with}AnnoyingProperty""');
    });

    it('works if the type expression is the entire string', () => {
      const desc = '{textInBraces}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('textInBraces');
    });

    it('works if the type expression is at the beginning of the string', () => {
      const desc = '{testString} ahoy';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('ahoy');
    });

    it('works if the type expression is in the middle of the string', () => {
      const desc = 'a {testString} yay';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('a  yay');
    });

    it('works if the tag is at the end of the string', () => {
      const desc = 'a {testString}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('a');
    });

    it('works when there are nested braces', () => {
      const desc = 'some {{double}} braces';
      const info = type.parse(desc, false, true);

      // we currently stringify all record types as 'Object'
      expect(info.type[0]).toBe('Object');
      expect(info.text).toBe('some  braces');
    });

    it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    });

    describe('JSDoc-style type info', () => {
      it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      });
    });

    // TODO: Add more tests related to how JSDoc mangles the Catharsis parse results.
    describe('Closure Compiler-style type info', () => {
      it('recognizes variable (repeatable) parameters', () => {
        const desc = '{...string} foo - Foo.';
        const info = type.parse(desc, true, true);

        expect(info.type).toEqual(['string']);
        expect(info.variable).toBeTrue();
      });

      it('sets the type correctly for type applications that contain type unions', () => {
        const desc = '{Array.<(string|number)>} foo - Foo.';
        const info = type.parse(desc, true, true);

        expect(info.type).toEqual(['Array.<(string|number)>']);
      });
    });
  });
})",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Conditional Test Logic,"{'line': 25, 'column': 6, 'index': 796}","describe('@jsdoc/tag/lib/type', () => {
  function buildText(typeInfo, name, desc) {
    let text = '';

    if (typeInfo) {
      text += `{${typeInfo}}`;
      if (name || desc) {
        text += ' ';
      }
    }

    if (name) {
      text += name;
      if (desc) {
        text += ' ';
      }
    }

    if (desc) {
      text += desc;
    }

    return text;
  }

  it('is an object', () => {
    expect(type).toBeObject();
  });

  it('exports a parse function', () => {
    expect(type.parse).toBeFunction();
  });

  describe('parse', () => {
    it('returns an object with name, type, and text properties', () => {
      const info = type.parse('');

      expect(info.name).toBeString();
      expect(info.type).toBeArray();
      expect(info.text).toBeString();
    });

    it('does not extract a name or type if canHaveName and canHaveType are not set', () => {
      const desc = '{number} foo The foo parameter.';
      const info = type.parse(desc);

      expect(info.type).toBeEmptyArray();
      expect(info.name).toBe('');
      expect(info.text).toBe(desc);
    });

    it('extracts a name, but not a type, if canHaveName is true and canHaveType is false', () => {
      const name = 'bar';
      const desc = 'The bar parameter.';
      const info = type.parse(buildText(null, name, desc), true, false);

      expect(info.type).toBeEmptyArray();
      expect(info.name).toBe(name);
      expect(info.text).toBe(desc);
    });

    it('extracts a type, but not a name, if canHaveName is false and canHaveType is true', () => {
      const typeString = 'boolean';
      const desc = 'Set to true on alternate Thursdays.';
      const info = type.parse(buildText(typeString, null, desc), false, true);

      expect(info.type).toEqual([typeString]);
      expect(info.name).toBe('');
      expect(info.text).toBe(desc);
    });

    it('extracts a name and type if canHaveName and canHaveType are true', () => {
      const typeString = 'string';
      const name = 'baz';
      const desc = 'The baz parameter.';
      const info = type.parse(buildText(typeString, name, desc), true, true);

      expect(info.type).toEqual([typeString]);
      expect(info.name).toBe(name);
      expect(info.text).toBe(desc);
    });

    it('reports optional types correctly for both JSDoc and Closure syntax', () => {
      let desc = '{string} [foo]';
      let info = type.parse(desc, true, true);

      expect(info.optional).toBeTrue();

      desc = '{string=} [foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();

      desc = '[foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();
    });

    it('returnsthe types as an array', () => {
      const desc = '{string} foo';
      const info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string']);
    });

    it('recognizes the entire list of possible types', () => {
      let desc = '{(string|number)} foo';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string', 'number']);

      desc = '{ ( string | number ) } foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{  (   string  | number)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{(string|number|boolean|function)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number', 'boolean', 'function']);
    });

    it('does not find any type if there is no text in braces', () => {
      const desc = 'braceless text';
      const info = type.parse(desc, false, true);

      expect(info.type).toBeEmptyArray();
    });

    it('copes with bad escapement at the end of the string', () => {
      const desc = 'bad {escapement \\';
      const info = type.parse(desc, false, true);

      expect(info.type).toBeEmptyArray();
      expect(info.text).toBe(desc);
    });

    it('handles escaped braces correctly', () => {
      const desc = '{weirdObject.""with\\}AnnoyingProperty""}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('weirdObject.""with}AnnoyingProperty""');
    });

    it('works if the type expression is the entire string', () => {
      const desc = '{textInBraces}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('textInBraces');
    });

    it('works if the type expression is at the beginning of the string', () => {
      const desc = '{testString} ahoy';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('ahoy');
    });

    it('works if the type expression is in the middle of the string', () => {
      const desc = 'a {testString} yay';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('a  yay');
    });

    it('works if the tag is at the end of the string', () => {
      const desc = 'a {testString}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('a');
    });

    it('works when there are nested braces', () => {
      const desc = 'some {{double}} braces';
      const info = type.parse(desc, false, true);

      // we currently stringify all record types as 'Object'
      expect(info.type[0]).toBe('Object');
      expect(info.text).toBe('some  braces');
    });

    it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    });

    describe('JSDoc-style type info', () => {
      it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      });
    });

    // TODO: Add more tests related to how JSDoc mangles the Catharsis parse results.
    describe('Closure Compiler-style type info', () => {
      it('recognizes variable (repeatable) parameters', () => {
        const desc = '{...string} foo - Foo.';
        const info = type.parse(desc, true, true);

        expect(info.type).toEqual(['string']);
        expect(info.variable).toBeTrue();
      });

      it('sets the type correctly for type applications that contain type unions', () => {
        const desc = '{Array.<(string|number)>} foo - Foo.';
        const info = type.parse(desc, true, true);

        expect(info.type).toEqual(['Array.<(string|number)>']);
      });
    });
  });
})",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Conditional Test Logic,"{'line': 30, 'column': 4, 'index': 856}","describe('@jsdoc/tag/lib/type', () => {
  function buildText(typeInfo, name, desc) {
    let text = '';

    if (typeInfo) {
      text += `{${typeInfo}}`;
      if (name || desc) {
        text += ' ';
      }
    }

    if (name) {
      text += name;
      if (desc) {
        text += ' ';
      }
    }

    if (desc) {
      text += desc;
    }

    return text;
  }

  it('is an object', () => {
    expect(type).toBeObject();
  });

  it('exports a parse function', () => {
    expect(type.parse).toBeFunction();
  });

  describe('parse', () => {
    it('returns an object with name, type, and text properties', () => {
      const info = type.parse('');

      expect(info.name).toBeString();
      expect(info.type).toBeArray();
      expect(info.text).toBeString();
    });

    it('does not extract a name or type if canHaveName and canHaveType are not set', () => {
      const desc = '{number} foo The foo parameter.';
      const info = type.parse(desc);

      expect(info.type).toBeEmptyArray();
      expect(info.name).toBe('');
      expect(info.text).toBe(desc);
    });

    it('extracts a name, but not a type, if canHaveName is true and canHaveType is false', () => {
      const name = 'bar';
      const desc = 'The bar parameter.';
      const info = type.parse(buildText(null, name, desc), true, false);

      expect(info.type).toBeEmptyArray();
      expect(info.name).toBe(name);
      expect(info.text).toBe(desc);
    });

    it('extracts a type, but not a name, if canHaveName is false and canHaveType is true', () => {
      const typeString = 'boolean';
      const desc = 'Set to true on alternate Thursdays.';
      const info = type.parse(buildText(typeString, null, desc), false, true);

      expect(info.type).toEqual([typeString]);
      expect(info.name).toBe('');
      expect(info.text).toBe(desc);
    });

    it('extracts a name and type if canHaveName and canHaveType are true', () => {
      const typeString = 'string';
      const name = 'baz';
      const desc = 'The baz parameter.';
      const info = type.parse(buildText(typeString, name, desc), true, true);

      expect(info.type).toEqual([typeString]);
      expect(info.name).toBe(name);
      expect(info.text).toBe(desc);
    });

    it('reports optional types correctly for both JSDoc and Closure syntax', () => {
      let desc = '{string} [foo]';
      let info = type.parse(desc, true, true);

      expect(info.optional).toBeTrue();

      desc = '{string=} [foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();

      desc = '[foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();
    });

    it('returnsthe types as an array', () => {
      const desc = '{string} foo';
      const info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string']);
    });

    it('recognizes the entire list of possible types', () => {
      let desc = '{(string|number)} foo';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string', 'number']);

      desc = '{ ( string | number ) } foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{  (   string  | number)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{(string|number|boolean|function)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number', 'boolean', 'function']);
    });

    it('does not find any type if there is no text in braces', () => {
      const desc = 'braceless text';
      const info = type.parse(desc, false, true);

      expect(info.type).toBeEmptyArray();
    });

    it('copes with bad escapement at the end of the string', () => {
      const desc = 'bad {escapement \\';
      const info = type.parse(desc, false, true);

      expect(info.type).toBeEmptyArray();
      expect(info.text).toBe(desc);
    });

    it('handles escaped braces correctly', () => {
      const desc = '{weirdObject.""with\\}AnnoyingProperty""}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('weirdObject.""with}AnnoyingProperty""');
    });

    it('works if the type expression is the entire string', () => {
      const desc = '{textInBraces}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('textInBraces');
    });

    it('works if the type expression is at the beginning of the string', () => {
      const desc = '{testString} ahoy';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('ahoy');
    });

    it('works if the type expression is in the middle of the string', () => {
      const desc = 'a {testString} yay';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('a  yay');
    });

    it('works if the tag is at the end of the string', () => {
      const desc = 'a {testString}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('a');
    });

    it('works when there are nested braces', () => {
      const desc = 'some {{double}} braces';
      const info = type.parse(desc, false, true);

      // we currently stringify all record types as 'Object'
      expect(info.type[0]).toBe('Object');
      expect(info.text).toBe('some  braces');
    });

    it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    });

    describe('JSDoc-style type info', () => {
      it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      });
    });

    // TODO: Add more tests related to how JSDoc mangles the Catharsis parse results.
    describe('Closure Compiler-style type info', () => {
      it('recognizes variable (repeatable) parameters', () => {
        const desc = '{...string} foo - Foo.';
        const info = type.parse(desc, true, true);

        expect(info.type).toEqual(['string']);
        expect(info.variable).toBeTrue();
      });

      it('sets the type correctly for type applications that contain type unions', () => {
        const desc = '{Array.<(string|number)>} foo - Foo.';
        const info = type.parse(desc, true, true);

        expect(info.type).toEqual(['Array.<(string|number)>']);
      });
    });
  });
})",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Conditional Test Logic,"{'line': 32, 'column': 6, 'index': 894}","describe('@jsdoc/tag/lib/type', () => {
  function buildText(typeInfo, name, desc) {
    let text = '';

    if (typeInfo) {
      text += `{${typeInfo}}`;
      if (name || desc) {
        text += ' ';
      }
    }

    if (name) {
      text += name;
      if (desc) {
        text += ' ';
      }
    }

    if (desc) {
      text += desc;
    }

    return text;
  }

  it('is an object', () => {
    expect(type).toBeObject();
  });

  it('exports a parse function', () => {
    expect(type.parse).toBeFunction();
  });

  describe('parse', () => {
    it('returns an object with name, type, and text properties', () => {
      const info = type.parse('');

      expect(info.name).toBeString();
      expect(info.type).toBeArray();
      expect(info.text).toBeString();
    });

    it('does not extract a name or type if canHaveName and canHaveType are not set', () => {
      const desc = '{number} foo The foo parameter.';
      const info = type.parse(desc);

      expect(info.type).toBeEmptyArray();
      expect(info.name).toBe('');
      expect(info.text).toBe(desc);
    });

    it('extracts a name, but not a type, if canHaveName is true and canHaveType is false', () => {
      const name = 'bar';
      const desc = 'The bar parameter.';
      const info = type.parse(buildText(null, name, desc), true, false);

      expect(info.type).toBeEmptyArray();
      expect(info.name).toBe(name);
      expect(info.text).toBe(desc);
    });

    it('extracts a type, but not a name, if canHaveName is false and canHaveType is true', () => {
      const typeString = 'boolean';
      const desc = 'Set to true on alternate Thursdays.';
      const info = type.parse(buildText(typeString, null, desc), false, true);

      expect(info.type).toEqual([typeString]);
      expect(info.name).toBe('');
      expect(info.text).toBe(desc);
    });

    it('extracts a name and type if canHaveName and canHaveType are true', () => {
      const typeString = 'string';
      const name = 'baz';
      const desc = 'The baz parameter.';
      const info = type.parse(buildText(typeString, name, desc), true, true);

      expect(info.type).toEqual([typeString]);
      expect(info.name).toBe(name);
      expect(info.text).toBe(desc);
    });

    it('reports optional types correctly for both JSDoc and Closure syntax', () => {
      let desc = '{string} [foo]';
      let info = type.parse(desc, true, true);

      expect(info.optional).toBeTrue();

      desc = '{string=} [foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();

      desc = '[foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();
    });

    it('returnsthe types as an array', () => {
      const desc = '{string} foo';
      const info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string']);
    });

    it('recognizes the entire list of possible types', () => {
      let desc = '{(string|number)} foo';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string', 'number']);

      desc = '{ ( string | number ) } foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{  (   string  | number)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{(string|number|boolean|function)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number', 'boolean', 'function']);
    });

    it('does not find any type if there is no text in braces', () => {
      const desc = 'braceless text';
      const info = type.parse(desc, false, true);

      expect(info.type).toBeEmptyArray();
    });

    it('copes with bad escapement at the end of the string', () => {
      const desc = 'bad {escapement \\';
      const info = type.parse(desc, false, true);

      expect(info.type).toBeEmptyArray();
      expect(info.text).toBe(desc);
    });

    it('handles escaped braces correctly', () => {
      const desc = '{weirdObject.""with\\}AnnoyingProperty""}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('weirdObject.""with}AnnoyingProperty""');
    });

    it('works if the type expression is the entire string', () => {
      const desc = '{textInBraces}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('textInBraces');
    });

    it('works if the type expression is at the beginning of the string', () => {
      const desc = '{testString} ahoy';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('ahoy');
    });

    it('works if the type expression is in the middle of the string', () => {
      const desc = 'a {testString} yay';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('a  yay');
    });

    it('works if the tag is at the end of the string', () => {
      const desc = 'a {testString}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('a');
    });

    it('works when there are nested braces', () => {
      const desc = 'some {{double}} braces';
      const info = type.parse(desc, false, true);

      // we currently stringify all record types as 'Object'
      expect(info.type[0]).toBe('Object');
      expect(info.text).toBe('some  braces');
    });

    it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    });

    describe('JSDoc-style type info', () => {
      it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      });
    });

    // TODO: Add more tests related to how JSDoc mangles the Catharsis parse results.
    describe('Closure Compiler-style type info', () => {
      it('recognizes variable (repeatable) parameters', () => {
        const desc = '{...string} foo - Foo.';
        const info = type.parse(desc, true, true);

        expect(info.type).toEqual(['string']);
        expect(info.variable).toBeTrue();
      });

      it('sets the type correctly for type applications that contain type unions', () => {
        const desc = '{Array.<(string|number)>} foo - Foo.';
        const info = type.parse(desc, true, true);

        expect(info.type).toEqual(['Array.<(string|number)>']);
      });
    });
  });
})",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Conditional Test Logic,"{'line': 37, 'column': 4, 'index': 946}","describe('@jsdoc/tag/lib/type', () => {
  function buildText(typeInfo, name, desc) {
    let text = '';

    if (typeInfo) {
      text += `{${typeInfo}}`;
      if (name || desc) {
        text += ' ';
      }
    }

    if (name) {
      text += name;
      if (desc) {
        text += ' ';
      }
    }

    if (desc) {
      text += desc;
    }

    return text;
  }

  it('is an object', () => {
    expect(type).toBeObject();
  });

  it('exports a parse function', () => {
    expect(type.parse).toBeFunction();
  });

  describe('parse', () => {
    it('returns an object with name, type, and text properties', () => {
      const info = type.parse('');

      expect(info.name).toBeString();
      expect(info.type).toBeArray();
      expect(info.text).toBeString();
    });

    it('does not extract a name or type if canHaveName and canHaveType are not set', () => {
      const desc = '{number} foo The foo parameter.';
      const info = type.parse(desc);

      expect(info.type).toBeEmptyArray();
      expect(info.name).toBe('');
      expect(info.text).toBe(desc);
    });

    it('extracts a name, but not a type, if canHaveName is true and canHaveType is false', () => {
      const name = 'bar';
      const desc = 'The bar parameter.';
      const info = type.parse(buildText(null, name, desc), true, false);

      expect(info.type).toBeEmptyArray();
      expect(info.name).toBe(name);
      expect(info.text).toBe(desc);
    });

    it('extracts a type, but not a name, if canHaveName is false and canHaveType is true', () => {
      const typeString = 'boolean';
      const desc = 'Set to true on alternate Thursdays.';
      const info = type.parse(buildText(typeString, null, desc), false, true);

      expect(info.type).toEqual([typeString]);
      expect(info.name).toBe('');
      expect(info.text).toBe(desc);
    });

    it('extracts a name and type if canHaveName and canHaveType are true', () => {
      const typeString = 'string';
      const name = 'baz';
      const desc = 'The baz parameter.';
      const info = type.parse(buildText(typeString, name, desc), true, true);

      expect(info.type).toEqual([typeString]);
      expect(info.name).toBe(name);
      expect(info.text).toBe(desc);
    });

    it('reports optional types correctly for both JSDoc and Closure syntax', () => {
      let desc = '{string} [foo]';
      let info = type.parse(desc, true, true);

      expect(info.optional).toBeTrue();

      desc = '{string=} [foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();

      desc = '[foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();
    });

    it('returnsthe types as an array', () => {
      const desc = '{string} foo';
      const info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string']);
    });

    it('recognizes the entire list of possible types', () => {
      let desc = '{(string|number)} foo';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string', 'number']);

      desc = '{ ( string | number ) } foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{  (   string  | number)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{(string|number|boolean|function)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number', 'boolean', 'function']);
    });

    it('does not find any type if there is no text in braces', () => {
      const desc = 'braceless text';
      const info = type.parse(desc, false, true);

      expect(info.type).toBeEmptyArray();
    });

    it('copes with bad escapement at the end of the string', () => {
      const desc = 'bad {escapement \\';
      const info = type.parse(desc, false, true);

      expect(info.type).toBeEmptyArray();
      expect(info.text).toBe(desc);
    });

    it('handles escaped braces correctly', () => {
      const desc = '{weirdObject.""with\\}AnnoyingProperty""}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('weirdObject.""with}AnnoyingProperty""');
    });

    it('works if the type expression is the entire string', () => {
      const desc = '{textInBraces}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('textInBraces');
    });

    it('works if the type expression is at the beginning of the string', () => {
      const desc = '{testString} ahoy';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('ahoy');
    });

    it('works if the type expression is in the middle of the string', () => {
      const desc = 'a {testString} yay';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('a  yay');
    });

    it('works if the tag is at the end of the string', () => {
      const desc = 'a {testString}';
      const info = type.parse(desc, false, true);

      expect(info.type[0]).toBe('testString');
      expect(info.text).toBe('a');
    });

    it('works when there are nested braces', () => {
      const desc = 'some {{double}} braces';
      const info = type.parse(desc, false, true);

      // we currently stringify all record types as 'Object'
      expect(info.type[0]).toBe('Object');
      expect(info.text).toBe('some  braces');
    });

    it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    });

    describe('JSDoc-style type info', () => {
      it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      });
    });

    // TODO: Add more tests related to how JSDoc mangles the Catharsis parse results.
    describe('Closure Compiler-style type info', () => {
      it('recognizes variable (repeatable) parameters', () => {
        const desc = '{...string} foo - Foo.';
        const info = type.parse(desc, true, true);

        expect(info.type).toEqual(['string']);
        expect(info.variable).toBeTrue();
      });

      it('sets the type correctly for type applications that contain type unions', () => {
        const desc = '{Array.<(string|number)>} foo - Foo.';
        const info = type.parse(desc, true, true);

        expect(info.type).toEqual(['Array.<(string|number)>']);
      });
    });
  });
})",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 105, 'column': 6, 'index': 3054}","it('reports optional types correctly for both JSDoc and Closure syntax', () => {
      let desc = '{string} [foo]';
      let info = type.parse(desc, true, true);

      expect(info.optional).toBeTrue();

      desc = '{string=} [foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();

      desc = '[foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 109, 'column': 6, 'index': 3170}","it('reports optional types correctly for both JSDoc and Closure syntax', () => {
      let desc = '{string} [foo]';
      let info = type.parse(desc, true, true);

      expect(info.optional).toBeTrue();

      desc = '{string=} [foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();

      desc = '[foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 113, 'column': 6, 'index': 3276}","it('reports optional types correctly for both JSDoc and Closure syntax', () => {
      let desc = '{string} [foo]';
      let info = type.parse(desc, true, true);

      expect(info.optional).toBeTrue();

      desc = '{string=} [foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();

      desc = '[foo]';
      info = type.parse(desc, true, true);
      expect(info.optional).toBeTrue();
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 127, 'column': 6, 'index': 3664}","it('recognizes the entire list of possible types', () => {
      let desc = '{(string|number)} foo';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string', 'number']);

      desc = '{ ( string | number ) } foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{  (   string  | number)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{(string|number|boolean|function)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number', 'boolean', 'function']);
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 127, 'column': 6, 'index': 3664}","it('recognizes the entire list of possible types', () => {
      let desc = '{(string|number)} foo';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string', 'number']);

      desc = '{ ( string | number ) } foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{  (   string  | number)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{(string|number|boolean|function)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number', 'boolean', 'function']);
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 131, 'column': 6, 'index': 3807}","it('recognizes the entire list of possible types', () => {
      let desc = '{(string|number)} foo';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string', 'number']);

      desc = '{ ( string | number ) } foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{  (   string  | number)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{(string|number|boolean|function)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number', 'boolean', 'function']);
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 131, 'column': 6, 'index': 3807}","it('recognizes the entire list of possible types', () => {
      let desc = '{(string|number)} foo';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string', 'number']);

      desc = '{ ( string | number ) } foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{  (   string  | number)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{(string|number|boolean|function)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number', 'boolean', 'function']);
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 135, 'column': 6, 'index': 3952}","it('recognizes the entire list of possible types', () => {
      let desc = '{(string|number)} foo';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string', 'number']);

      desc = '{ ( string | number ) } foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{  (   string  | number)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{(string|number|boolean|function)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number', 'boolean', 'function']);
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 135, 'column': 6, 'index': 3952}","it('recognizes the entire list of possible types', () => {
      let desc = '{(string|number)} foo';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string', 'number']);

      desc = '{ ( string | number ) } foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{  (   string  | number)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{(string|number|boolean|function)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number', 'boolean', 'function']);
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 139, 'column': 6, 'index': 4106}","it('recognizes the entire list of possible types', () => {
      let desc = '{(string|number)} foo';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['string', 'number']);

      desc = '{ ( string | number ) } foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{  (   string  | number)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number']);

      desc = '{(string|number|boolean|function)} foo';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['string', 'number', 'boolean', 'function']);
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 208, 'column': 6, 'index': 6376}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 208, 'column': 6, 'index': 6376}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 209, 'column': 6, 'index': 6422}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 209, 'column': 6, 'index': 6422}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 213, 'column': 6, 'index': 6550}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 213, 'column': 6, 'index': 6550}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 214, 'column': 6, 'index': 6596}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 214, 'column': 6, 'index': 6596}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 218, 'column': 6, 'index': 6746}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 218, 'column': 6, 'index': 6746}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 219, 'column': 6, 'index': 6792}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 219, 'column': 6, 'index': 6792}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 223, 'column': 6, 'index': 6969}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 223, 'column': 6, 'index': 6969}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 224, 'column': 6, 'index': 7022}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 224, 'column': 6, 'index': 7022}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 228, 'column': 6, 'index': 7212}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 228, 'column': 6, 'index': 7212}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 229, 'column': 6, 'index': 7265}","it('overrides the type expression if an inline @type tag is specified', () => {
      let desc = '{Object} cookie {@type Monster}';
      let info = type.parse(desc, true, true);

      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('');

      desc = '{Object} cookie - The cookie parameter. {@type Monster}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)}';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.');

      desc = '{Object} cookie - The cookie parameter. {@type (Monster|Jar)} Mmm, cookie.';
      info = type.parse(desc, true, true);
      expect(info.type).toEqual(['Monster', 'Jar']);
      expect(info.text).toBe('The cookie parameter.  Mmm, cookie.');
    })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 238, 'column': 8, 'index': 7595}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 238, 'column': 8, 'index': 7595}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 239, 'column': 8, 'index': 7634}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 239, 'column': 8, 'index': 7634}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 240, 'column': 8, 'index': 7672}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 244, 'column': 8, 'index': 7810}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 244, 'column': 8, 'index': 7810}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 245, 'column': 8, 'index': 7849}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 245, 'column': 8, 'index': 7849}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 246, 'column': 8, 'index': 7887}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 250, 'column': 8, 'index': 8030}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 250, 'column': 8, 'index': 8030}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 251, 'column': 8, 'index': 8069}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 251, 'column': 8, 'index': 8069}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 252, 'column': 8, 'index': 8107}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 253, 'column': 8, 'index': 8149}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 253, 'column': 8, 'index': 8149}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 257, 'column': 8, 'index': 8308}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 257, 'column': 8, 'index': 8308}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 258, 'column': 8, 'index': 8347}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 258, 'column': 8, 'index': 8347}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 259, 'column': 8, 'index': 8385}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 260, 'column': 8, 'index': 8427}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/type.js,Duplicate Assert,"{'line': 260, 'column': 8, 'index': 8427}","it('parses JSDoc-style optional parameters', () => {
        let name = '[qux]';
        const desc = 'The qux parameter.';
        let info = type.parse(buildText(null, name, desc), true, false);

        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[ qux ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();

        name = '[qux=hooray]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');

        name = '[  qux   =  hooray ]';
        info = type.parse(buildText(null, name, desc), true, false);
        expect(info.name).toBe('qux');
        expect(info.text).toBe(desc);
        expect(info.optional).toBeTrue();
        expect(info.defaultvalue).toBe('hooray');
      })",steel
/packages/jsdoc-tag/test/specs/lib/tag.js,Conditional Test Logic,"{'line': 168, 'column': 61, 'index': 5886}","describe('`value` property', () => {
      const debug = Boolean(options.debug);

      afterEach(() => {
        options.debug = debug;
      });

      it('has a `value` property', () => {
        expect(tagArg.value).toBeDefined();
        expect(tagExample.value).toBeDefined();
        expect(tagType.value).toBeDefined();
      });

      it('is the tag text if the tag cannot have a type or name', () => {
        // @example can't have type or name
        expect(typeof tagExample.value).toBe('string');
        expect(tagExample.value).toBe(tagExample.text);
      });

      it('is an object if the tag can have a type or name', () => {
        expect(typeof tagType.value).toBe('object');
        expect(typeof tagArg.value).toBe('object');
      });

      function verifyTagType(tag) {
        let def;
        let info;

        def = jsdocDictionary.lookUp(tag.title);

        expect(def).toBeObject();

        info = parseType(tag.text, def.canHaveName, def.canHaveType);

        ['optional', 'nullable', 'variable', 'defaultvalue'].forEach((prop) => {
          if (Object.hasOwn(info, prop)) {
            expect(tag.value[prop]).toBe(info[prop]);
          }
        });

        if (info.type?.length) {
          expect(tag.value.type).toBeObject();
          expect(tag.value.type.names).toEqual(info.type);

          expect(tag.value.type.expression).toBeString();
        }
      }

      it('contains the type information for tags with types', () => {
        verifyTagType(tagType);
        verifyTagType(tagArg);
        verifyTagType(tagParam);
      });

      it('contains any additional descriptive text', () => {
        expect(tagType.value.description).toBeUndefined();
        expect(tagArg.value.description).toBe(desc);
      });

      it('contains the name for tags with names', () => {
        expect(tagArg.value.name).toBe('foo');
        expect(tagType.value.name).toBeUndefined();
      });

      it('does not include type modifier properties on the tag value', () => {
        ['optional', 'nullable', 'variable', 'defaultvalue'].forEach((modifier) => {
          expect(Object.hasOwn(tagParamWithType.value, modifier)).toBeFalse();
        });
      });

      it('contains the original type expression', () => {
        const paramWithTypeModifiers = new Tag('param', '{?Object} foo', meta, jsdoc.env);

        expect(paramWithTypeModifiers.value.type.expression).toBe('?Object');
      });
    })",steel
/packages/jsdoc-tag/test/specs/lib/tag.js,Conditional Test Logic,"{'line': 169, 'column': 10, 'index': 5916}","describe('`value` property', () => {
      const debug = Boolean(options.debug);

      afterEach(() => {
        options.debug = debug;
      });

      it('has a `value` property', () => {
        expect(tagArg.value).toBeDefined();
        expect(tagExample.value).toBeDefined();
        expect(tagType.value).toBeDefined();
      });

      it('is the tag text if the tag cannot have a type or name', () => {
        // @example can't have type or name
        expect(typeof tagExample.value).toBe('string');
        expect(tagExample.value).toBe(tagExample.text);
      });

      it('is an object if the tag can have a type or name', () => {
        expect(typeof tagType.value).toBe('object');
        expect(typeof tagArg.value).toBe('object');
      });

      function verifyTagType(tag) {
        let def;
        let info;

        def = jsdocDictionary.lookUp(tag.title);

        expect(def).toBeObject();

        info = parseType(tag.text, def.canHaveName, def.canHaveType);

        ['optional', 'nullable', 'variable', 'defaultvalue'].forEach((prop) => {
          if (Object.hasOwn(info, prop)) {
            expect(tag.value[prop]).toBe(info[prop]);
          }
        });

        if (info.type?.length) {
          expect(tag.value.type).toBeObject();
          expect(tag.value.type.names).toEqual(info.type);

          expect(tag.value.type.expression).toBeString();
        }
      }

      it('contains the type information for tags with types', () => {
        verifyTagType(tagType);
        verifyTagType(tagArg);
        verifyTagType(tagParam);
      });

      it('contains any additional descriptive text', () => {
        expect(tagType.value.description).toBeUndefined();
        expect(tagArg.value.description).toBe(desc);
      });

      it('contains the name for tags with names', () => {
        expect(tagArg.value.name).toBe('foo');
        expect(tagType.value.name).toBeUndefined();
      });

      it('does not include type modifier properties on the tag value', () => {
        ['optional', 'nullable', 'variable', 'defaultvalue'].forEach((modifier) => {
          expect(Object.hasOwn(tagParamWithType.value, modifier)).toBeFalse();
        });
      });

      it('contains the original type expression', () => {
        const paramWithTypeModifiers = new Tag('param', '{?Object} foo', meta, jsdoc.env);

        expect(paramWithTypeModifiers.value.type.expression).toBe('?Object');
      });
    })",steel
/packages/jsdoc-tag/test/specs/lib/tag.js,Conditional Test Logic,"{'line': 174, 'column': 8, 'index': 6036}","describe('`value` property', () => {
      const debug = Boolean(options.debug);

      afterEach(() => {
        options.debug = debug;
      });

      it('has a `value` property', () => {
        expect(tagArg.value).toBeDefined();
        expect(tagExample.value).toBeDefined();
        expect(tagType.value).toBeDefined();
      });

      it('is the tag text if the tag cannot have a type or name', () => {
        // @example can't have type or name
        expect(typeof tagExample.value).toBe('string');
        expect(tagExample.value).toBe(tagExample.text);
      });

      it('is an object if the tag can have a type or name', () => {
        expect(typeof tagType.value).toBe('object');
        expect(typeof tagArg.value).toBe('object');
      });

      function verifyTagType(tag) {
        let def;
        let info;

        def = jsdocDictionary.lookUp(tag.title);

        expect(def).toBeObject();

        info = parseType(tag.text, def.canHaveName, def.canHaveType);

        ['optional', 'nullable', 'variable', 'defaultvalue'].forEach((prop) => {
          if (Object.hasOwn(info, prop)) {
            expect(tag.value[prop]).toBe(info[prop]);
          }
        });

        if (info.type?.length) {
          expect(tag.value.type).toBeObject();
          expect(tag.value.type.names).toEqual(info.type);

          expect(tag.value.type.expression).toBeString();
        }
      }

      it('contains the type information for tags with types', () => {
        verifyTagType(tagType);
        verifyTagType(tagArg);
        verifyTagType(tagParam);
      });

      it('contains any additional descriptive text', () => {
        expect(tagType.value.description).toBeUndefined();
        expect(tagArg.value.description).toBe(desc);
      });

      it('contains the name for tags with names', () => {
        expect(tagArg.value.name).toBe('foo');
        expect(tagType.value.name).toBeUndefined();
      });

      it('does not include type modifier properties on the tag value', () => {
        ['optional', 'nullable', 'variable', 'defaultvalue'].forEach((modifier) => {
          expect(Object.hasOwn(tagParamWithType.value, modifier)).toBeFalse();
        });
      });

      it('contains the original type expression', () => {
        const paramWithTypeModifiers = new Tag('param', '{?Object} foo', meta, jsdoc.env);

        expect(paramWithTypeModifiers.value.type.expression).toBe('?Object');
      });
    })",steel
/packages/jsdoc-tag/test/specs/lib/tag.js,Conditional Test Logic,"{'line': 199, 'column': 61, 'index': 6914}","it('does not include type modifier properties on the tag value', () => {
        ['optional', 'nullable', 'variable', 'defaultvalue'].forEach((modifier) => {
          expect(Object.hasOwn(tagParamWithType.value, modifier)).toBeFalse();
        });
      })",steel
/packages/jsdoc-tag/test/specs/lib/tag.js,Unknown Test,"{'column': 6, 'line': 182}","it('contains the type information for tags with types', () => {
        verifyTagType(tagType);
        verifyTagType(tagArg);
        verifyTagType(tagParam);
      })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Duplicate Assert,"{'line': 284, 'column': 10, 'index': 9292}","it('works with multiple replacers', () => {
      const text = 'some {@foo text} with {@bar multiple} tags';
      const replacers = {
        foo(string, tagInfo) {
          expect(tagInfo.completeTag).toBe('{@foo text}');
          expect(tagInfo.text).toBe('text');

          return string.replace(tagInfo.completeTag, 'stuff');
        },
        bar(string, tagInfo) {
          expect(tagInfo.completeTag).toBe('{@bar multiple}');
          expect(tagInfo.text).toBe('multiple');

          return string.replace(tagInfo.completeTag, 'awesome');
        },
      };
      const result = inline.replaceInlineTags(text, replacers);

      expect(result.newString).toBe('some stuff with awesome tags');
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Duplicate Assert,"{'line': 285, 'column': 10, 'index': 9351}","it('works with multiple replacers', () => {
      const text = 'some {@foo text} with {@bar multiple} tags';
      const replacers = {
        foo(string, tagInfo) {
          expect(tagInfo.completeTag).toBe('{@foo text}');
          expect(tagInfo.text).toBe('text');

          return string.replace(tagInfo.completeTag, 'stuff');
        },
        bar(string, tagInfo) {
          expect(tagInfo.completeTag).toBe('{@bar multiple}');
          expect(tagInfo.text).toBe('multiple');

          return string.replace(tagInfo.completeTag, 'awesome');
        },
      };
      const result = inline.replaceInlineTags(text, replacers);

      expect(result.newString).toBe('some stuff with awesome tags');
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Duplicate Assert,"{'line': 290, 'column': 10, 'index': 9502}","it('works with multiple replacers', () => {
      const text = 'some {@foo text} with {@bar multiple} tags';
      const replacers = {
        foo(string, tagInfo) {
          expect(tagInfo.completeTag).toBe('{@foo text}');
          expect(tagInfo.text).toBe('text');

          return string.replace(tagInfo.completeTag, 'stuff');
        },
        bar(string, tagInfo) {
          expect(tagInfo.completeTag).toBe('{@bar multiple}');
          expect(tagInfo.text).toBe('multiple');

          return string.replace(tagInfo.completeTag, 'awesome');
        },
      };
      const result = inline.replaceInlineTags(text, replacers);

      expect(result.newString).toBe('some stuff with awesome tags');
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Duplicate Assert,"{'line': 291, 'column': 10, 'index': 9565}","it('works with multiple replacers', () => {
      const text = 'some {@foo text} with {@bar multiple} tags';
      const replacers = {
        foo(string, tagInfo) {
          expect(tagInfo.completeTag).toBe('{@foo text}');
          expect(tagInfo.text).toBe('text');

          return string.replace(tagInfo.completeTag, 'stuff');
        },
        bar(string, tagInfo) {
          expect(tagInfo.completeTag).toBe('{@bar multiple}');
          expect(tagInfo.text).toBe('multiple');

          return string.replace(tagInfo.completeTag, 'awesome');
        },
      };
      const result = inline.replaceInlineTags(text, replacers);

      expect(result.newString).toBe('some stuff with awesome tags');
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 44, 'column': 13, 'index': 1346}","it('identifies a string that is an inline tag', () => {
      expect(includesInlineTag('{@mytag hooray}', 'mytag')).toBeTrue();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 48, 'column': 13, 'index': 1501}","it('identifies when a string does not include an inline tag', () => {
      expect(includesInlineTag('mytag hooray', 'mytag')).toBeFalse();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 52, 'column': 13, 'index': 1669}","it('identifies when a string contains an inline tag, plus extra characters', () => {
      expect(includesInlineTag('this is {@mytag hooray}', 'mytag')).toBeTrue();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 56, 'column': 13, 'index': 1809}","it('allows any inline tag by default', () => {
      expect(includesInlineTag('Hello, {@anyoldtag will do}')).toBeTrue();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 60, 'column': 13, 'index': 1986}","it('identifies things that are not inline tags when a tag name is not provided', () => {
      expect(includesInlineTag('mytag hooray')).toBeFalse();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 64, 'column': 13, 'index': 2115}","it('allows regexp characters in the tag name', () => {
      expect(includesInlineTag('{@mytags hooray}', 'mytag\\S')).toBeTrue();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 69, 'column': 15, 'index': 2304}","it('returns false (rather than throwing) with invalid input', () => {
      function badInput() {
        return includesInlineTag();
      }

      expect(badInput).not.toThrow();
      expect(badInput()).toBeFalse();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 81, 'column': 13, 'index': 2552}","it('identifies an inline tag', () => {
      expect(isInlineTag('{@mytag hooray}', 'mytag')).toBeTrue();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 85, 'column': 13, 'index': 2692}","it('identifies when something is not an inline tag', () => {
      expect(isInlineTag('mytag hooray', 'mytag')).toBeFalse();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 89, 'column': 13, 'index': 2851}","it('reports that a string containing an inline tag is not an inline tag', () => {
      expect(isInlineTag('this is {@mytag hooray}', 'mytag')).toBeFalse();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 93, 'column': 13, 'index': 2986}","it('allows any inline tag by default', () => {
      expect(isInlineTag('{@anyoldtag will do}')).toBeTrue();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 97, 'column': 13, 'index': 3150}","it('identifies things that are not inline tags when a tag name is not provided', () => {
      expect(isInlineTag('mytag hooray')).toBeFalse();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 101, 'column': 13, 'index': 3273}","it('allows regexp characters in the tag name', () => {
      expect(isInlineTag('{@mytags hooray}', 'mytag\\S')).toBeTrue();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Lazy Test,"{'line': 106, 'column': 15, 'index': 3456}","it('returns false (rather than throwing) with invalid input', () => {
      function badInput() {
        return isInlineTag();
      }

      expect(badInput).not.toThrow();
      expect(badInput()).toBeFalse();
    })",steel
/packages/jsdoc-tag/test/specs/lib/inline.js,Magic Number,"{'line': 233, 'column': 38, 'index': 7610}","it('processes all occurrences of a tag', () => {
      function replacer(string, { completeTag }) {
        return string.replace(completeTag, 'stuff');
      }

      const result = inline.replaceInlineTag(
        'some {@foo text} with multiple {@foo tags}, {@foo like} {@foo this}',
        'foo',
        replacer
      );

      expect(result.tags.length).toBe(4);

      expect(result.tags[0]).toBeObject();
      expect(result.tags[0].tag).toBe('foo');
      expect(result.tags[0].text).toBe('text');

      expect(result.tags[1]).toBeObject();
      expect(result.tags[1].tag).toBe('foo');
      expect(result.tags[1].text).toBe('tags');

      expect(result.tags[2]).toBeObject();
      expect(result.tags[2].tag).toBe('foo');
      expect(result.tags[2].text).toBe('like');

      expect(result.tags[3]).toBeObject();
      expect(result.tags[3].tag).toBe('foo');
      expect(result.tags[3].text).toBe('this');

      expect(result.newString).toBe('some stuff with multiple stuff, stuff stuff');
    })",steel
/packages/jsdoc-tag/test/specs/lib/dictionary.js,Conditional Test Logic,"{'line': 106, 'column': 6, 'index': 3042}","it('returns the tags it added', () => {
      const tags = {
        tag1: {
          tag1Attribute: 'foo',
        },
        tag2: {
          tag2Attribute: 'bar',
        },
      };
      const actualTags = testDictionary.defineTags(tags);

      for (const tag of Object.keys(tags)) {
        expect(actualTags[tag]).toBeObject();
        for (const attrib of Object.keys(tags[tag])) {
          expect(tags[tag][attrib]).toBe(actualTags[tag][attrib]);
        }
      }
    })",steel
/packages/jsdoc-tag/test/specs/lib/dictionary.js,Conditional Test Logic,"{'line': 108, 'column': 8, 'index': 3135}","it('returns the tags it added', () => {
      const tags = {
        tag1: {
          tag1Attribute: 'foo',
        },
        tag2: {
          tag2Attribute: 'bar',
        },
      };
      const actualTags = testDictionary.defineTags(tags);

      for (const tag of Object.keys(tags)) {
        expect(actualTags[tag]).toBeObject();
        for (const attrib of Object.keys(tags[tag])) {
          expect(tags[tag][attrib]).toBe(actualTags[tag][attrib]);
        }
      }
    })",steel
/packages/jsdoc-salty/test/specs/lib/salty.js,Magic Number,"{'line': 255, 'column': 46, 'index': 7863}","it('returns the number of removed items', () => {
        expect(db({ c: true }).remove()).toBe(6);
      })",steel
/packages/jsdoc-plugins/test/specs/source-tag.js,Magic Number,"{'line': 42, 'column': 36, 'index': 1370}","it(""should set the lineno and filename of the doclet's meta property"", () => {
    const doclet = docSet.getByLongname('handlers.newDoclet')[0];

    expect(doclet.meta).toBeObject();
    expect(doclet.meta.filename).toBe('sourcetag.js');
    expect(doclet.meta.lineno).toBe(9);
  })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 58, 'column': 31, 'index': 1935}","it('does not add unique longnames to constructors', () => {
      const soup = docSet.getByLongname('Soup');
      const soup1 = docSet.getByLongname('Soup()');
      const soup2 = docSet.getByLongname('Soup(spiciness)');

      expect(soup.length).toBe(2);
      expect(soup1.length).toBe(0);
      expect(soup2.length).toBe(0);
    })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 59, 'column': 32, 'index': 1971}","it('does not add unique longnames to constructors', () => {
      const soup = docSet.getByLongname('Soup');
      const soup1 = docSet.getByLongname('Soup()');
      const soup2 = docSet.getByLongname('Soup(spiciness)');

      expect(soup.length).toBe(2);
      expect(soup1.length).toBe(0);
      expect(soup2.length).toBe(0);
    })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 60, 'column': 32, 'index': 2007}","it('does not add unique longnames to constructors', () => {
      const soup = docSet.getByLongname('Soup');
      const soup1 = docSet.getByLongname('Soup()');
      const soup2 = docSet.getByLongname('Soup(spiciness)');

      expect(soup.length).toBe(2);
      expect(soup1.length).toBe(0);
      expect(soup2.length).toBe(0);
    })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 68, 'column': 32, 'index': 2281}","it('adds unique longnames to methods', () => {
      const slurp = docSet.getByLongname('Soup#slurp');
      const slurp1 = docSet.getByLongname('Soup#slurp()');
      const slurp2 = docSet.getByLongname('Soup#slurp(dBA)');

      expect(slurp.length).toBe(0);
      expect(slurp1.length).toBe(1);
      expect(slurp2.length).toBe(1);
    })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 69, 'column': 33, 'index': 2318}","it('adds unique longnames to methods', () => {
      const slurp = docSet.getByLongname('Soup#slurp');
      const slurp1 = docSet.getByLongname('Soup#slurp()');
      const slurp2 = docSet.getByLongname('Soup#slurp(dBA)');

      expect(slurp.length).toBe(0);
      expect(slurp1.length).toBe(1);
      expect(slurp2.length).toBe(1);
    })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 70, 'column': 33, 'index': 2355}","it('adds unique longnames to methods', () => {
      const slurp = docSet.getByLongname('Soup#slurp');
      const slurp1 = docSet.getByLongname('Soup#slurp()');
      const slurp2 = docSet.getByLongname('Soup#slurp(dBA)');

      expect(slurp.length).toBe(0);
      expect(slurp1.length).toBe(1);
      expect(slurp2.length).toBe(1);
    })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 85, 'column': 32, 'index': 2882}","it('does not add to or change existing variations that are unique', () => {
      const salt1 = docSet.getByLongname('Soup#salt');
      const salt2 = docSet.getByLongname('Soup#salt(mg)');

      expect(salt1.length).toBe(1);
      expect(salt2.length).toBe(1);
    })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 86, 'column': 32, 'index': 2918}","it('does not add to or change existing variations that are unique', () => {
      const salt1 = docSet.getByLongname('Soup#salt');
      const salt2 = docSet.getByLongname('Soup#salt(mg)');

      expect(salt1.length).toBe(1);
      expect(salt2.length).toBe(1);
    })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 94, 'column': 32, 'index': 3216}","it('does not duplicate the names of existing numeric variations', () => {
      const heat1 = docSet.getByLongname('Soup#heat(1)');
      const heat2 = docSet.getByLongname('Soup#heat(2)');
      const heat3 = docSet.getByLongname('Soup#heat(3)');

      expect(heat1.length).toBe(1);
      expect(heat2.length).toBe(1);
      expect(heat3.length).toBe(1);
    })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 95, 'column': 32, 'index': 3252}","it('does not duplicate the names of existing numeric variations', () => {
      const heat1 = docSet.getByLongname('Soup#heat(1)');
      const heat2 = docSet.getByLongname('Soup#heat(2)');
      const heat3 = docSet.getByLongname('Soup#heat(3)');

      expect(heat1.length).toBe(1);
      expect(heat2.length).toBe(1);
      expect(heat3.length).toBe(1);
    })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 96, 'column': 32, 'index': 3288}","it('does not duplicate the names of existing numeric variations', () => {
      const heat1 = docSet.getByLongname('Soup#heat(1)');
      const heat2 = docSet.getByLongname('Soup#heat(2)');
      const heat3 = docSet.getByLongname('Soup#heat(3)');

      expect(heat1.length).toBe(1);
      expect(heat2.length).toBe(1);
      expect(heat3.length).toBe(1);
    })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 103, 'column': 35, 'index': 3548}","it('replaces identical variations with new, unique variations', () => {
      const discard1 = docSet.getByLongname('Soup#discard()');
      const discard2 = docSet.getByLongname('Soup#discard(container)');

      expect(discard1.length).toBe(1);
      expect(discard2.length).toBe(1);
    })",steel
/packages/jsdoc-plugins/test/specs/overload-helper.js,Magic Number,"{'line': 104, 'column': 35, 'index': 3587}","it('replaces identical variations with new, unique variations', () => {
      const discard1 = docSet.getByLongname('Soup#discard()');
      const discard2 = docSet.getByLongname('Soup#discard(container)');

      expect(discard1.length).toBe(1);
      expect(discard2.length).toBe(1);
    })",steel
/packages/jsdoc-plugins/test/specs/comment-convert.js,Magic Number,"{'line': 37, 'column': 31, 'index': 1247}","it('converts ///-style comments into jsdoc comments', () => {
    const doclet = docSet.getByLongname(
      'module:@jsdoc/plugins/comment-convert.handlers.beforeParse'
    );

    expect(doclet.length).toBe(1);
  })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Conditional Test Logic,"{'line': 175, 'column': 12, 'index': 5287}","it('calls AST node visitors', () => {
        let args;
        const sourceCode = ['javascript:/** foo */var foo;'];
        const visitor = {
          visitNode(node, e) {
            if (e && e.code && !args) {
              args = Array.prototype.slice.call(arguments);
            }
          },
        };

        attachTo(parser);
        parser.addAstNodeVisitor(visitor);
        parser.parse(sourceCode);

        expect(args).toBeArrayOfSize(4);

        // args[0]: AST node
        expect(args[0].type).toBe(Syntax.VariableDeclarator);

        // args[1]: JSDoc event
        expect(args[1]).toBeObject();
        expect(args[1].code).toBeObject();
        expect(args[1].code.name).toBe('foo');

        // args[2]: parser
        expect(args[2]).toBeObject();
        expect(args[2] instanceof jsdocParser.Parser).toBeTrue();

        // args[3]: current source name
        expect(String(args[3])).toBe('[[string0]]');
      })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Conditional Test Logic,"{'line': 208, 'column': 12, 'index': 6263}","it('reflects changes made by AST node visitors', () => {
        let doclet;
        const sourceCode = ['javascript:/** foo */var foo;'];
        const visitor = {
          visitNode(node, e) {
            if (e && e.code && e.code.name === 'foo') {
              e.code.name = 'bar';
            }
          },
        };

        attachTo(parser);
        parser.addAstNodeVisitor(visitor);
        parser.parse(sourceCode);

        doclet = parser.results()[0];

        expect(doclet).toBeObject();
        expect(doclet.name).toBe('bar');
      })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Conditional Test Logic,"{'line': 351, 'column': 10, 'index': 10498}","describe('results', () => {
      it('returns an empty array before files are parsed', () => {
        const results = parser.results();

        expect(results).toBeEmptyArray();
      });

      it('returns an array of doclets after files are parsed', () => {
        const source = 'javascript:var foo;';
        let results;

        attachTo(parser);

        parser.parse(source);
        results = parser.results();

        expect(results).toBeArrayOfSize(1);
        expect(results[0]).toBeObject();
        expect(results[0].name).toBe('foo');
      });

      it('reflects comment changes made by `jsdocCommentFound` handlers', () => {
        // we test both POSIX and Windows line endings
        const source =
          'javascript:/**\n * replaceme\r\n * @module foo\n */\n\n' +
          '/**\n * replaceme\n */\nvar bar;';

        parser.on('jsdocCommentFound', (e) => {
          e.comment = e.comment.replace('replaceme', 'REPLACED!');
        });
        attachTo(parser);

        parser.parse(source);
        parser.results().forEach(({ comment }) => {
          expect(comment).not.toMatch('replaceme');
          expect(comment).toMatch('REPLACED!');
        });
      });

      // TODO: this test appears to be doing nothing...
      xdescribe('event order', () => {
        const events = {
          all: [],
          jsdocCommentFound: [],
          symbolFound: [],
        };
        const source = fs.readFileSync(path.join(dirname, 'test/fixtures/eventorder.js'), 'utf8');

        /*
                function pushEvent(e) {
                    events.all.push(e);
                    events[e.event].push(e);
                }
                */

        function sourceOrderSort(atom1, atom2) {
          if (atom1.range[1] < atom2.range[0]) {
            return -1;
          } else if (atom1.range[0] < atom2.range[0] && atom1.range[1] === atom2.range[1]) {
            return 1;
          } else {
            return 0;
          }
        }

        it('emits interleaved `jsdocCommentFound` and `symbolFound` events, in source order', () => {
          attachTo(parser);
          parser.parse(source);
          events.all
            .slice()
            .sort(sourceOrderSort)
            .forEach((e, i) => {
              expect(e).toBe(events.all[i]);
            });
        });
      });
    })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Conditional Test Logic,"{'line': 353, 'column': 17, 'index': 10577}","describe('results', () => {
      it('returns an empty array before files are parsed', () => {
        const results = parser.results();

        expect(results).toBeEmptyArray();
      });

      it('returns an array of doclets after files are parsed', () => {
        const source = 'javascript:var foo;';
        let results;

        attachTo(parser);

        parser.parse(source);
        results = parser.results();

        expect(results).toBeArrayOfSize(1);
        expect(results[0]).toBeObject();
        expect(results[0].name).toBe('foo');
      });

      it('reflects comment changes made by `jsdocCommentFound` handlers', () => {
        // we test both POSIX and Windows line endings
        const source =
          'javascript:/**\n * replaceme\r\n * @module foo\n */\n\n' +
          '/**\n * replaceme\n */\nvar bar;';

        parser.on('jsdocCommentFound', (e) => {
          e.comment = e.comment.replace('replaceme', 'REPLACED!');
        });
        attachTo(parser);

        parser.parse(source);
        parser.results().forEach(({ comment }) => {
          expect(comment).not.toMatch('replaceme');
          expect(comment).toMatch('REPLACED!');
        });
      });

      // TODO: this test appears to be doing nothing...
      xdescribe('event order', () => {
        const events = {
          all: [],
          jsdocCommentFound: [],
          symbolFound: [],
        };
        const source = fs.readFileSync(path.join(dirname, 'test/fixtures/eventorder.js'), 'utf8');

        /*
                function pushEvent(e) {
                    events.all.push(e);
                    events[e.event].push(e);
                }
                */

        function sourceOrderSort(atom1, atom2) {
          if (atom1.range[1] < atom2.range[0]) {
            return -1;
          } else if (atom1.range[0] < atom2.range[0] && atom1.range[1] === atom2.range[1]) {
            return 1;
          } else {
            return 0;
          }
        }

        it('emits interleaved `jsdocCommentFound` and `symbolFound` events, in source order', () => {
          attachTo(parser);
          parser.parse(source);
          events.all
            .slice()
            .sort(sourceOrderSort)
            .forEach((e, i) => {
              expect(e).toBe(events.all[i]);
            });
        });
      });
    })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Duplicate Assert,"{'line': 329, 'column': 10, 'index': 9842}","it('reflects comment changes made by `jsdocCommentFound` handlers', () => {
        // we test both POSIX and Windows line endings
        const source =
          'javascript:/**\n * replaceme\r\n * @module foo\n */\n\n' +
          '/**\n * replaceme\n */\nvar bar;';

        parser.on('jsdocCommentFound', (e) => {
          e.comment = e.comment.replace('replaceme', 'REPLACED!');
        });
        attachTo(parser);

        parser.parse(source);
        parser.results().forEach(({ comment }) => {
          expect(comment).not.toMatch('replaceme');
          expect(comment).toMatch('REPLACED!');
        });
      })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Duplicate Assert,"{'line': 330, 'column': 10, 'index': 9894}","it('reflects comment changes made by `jsdocCommentFound` handlers', () => {
        // we test both POSIX and Windows line endings
        const source =
          'javascript:/**\n * replaceme\r\n * @module foo\n */\n\n' +
          '/**\n * replaceme\n */\nvar bar;';

        parser.on('jsdocCommentFound', (e) => {
          e.comment = e.comment.replace('replaceme', 'REPLACED!');
        });
        attachTo(parser);

        parser.parse(source);
        parser.results().forEach(({ comment }) => {
          expect(comment).not.toMatch('replaceme');
          expect(comment).toMatch('REPLACED!');
        });
      })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Lazy Test,"{'line': 163, 'column': 8, 'index': 4865}","it('allows `newDoclet` handlers to modify doclets', () => {
        let doclets;
        let docletStore;
        const sourceCode = 'javascript:/** @class */function Foo() {}';

        function handler(e) {
          e.doclet = Doclet.combineDoclets(e.doclet, new Doclet('', {}, jsdoc.env));
          e.doclet.foo = 'bar';
        }

        attachTo(parser);
        docletStore = parser.on('newDoclet', handler).parse(sourceCode);
        doclets = Array.from(docletStore.doclets).filter((d) => d.foo === 'bar');

        expect(doclets).toBeArrayOfSize(1);
      })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Lazy Test,"{'line': 181, 'column': 8, 'index': 5422}","it('calls AST node visitors', () => {
        let args;
        const sourceCode = ['javascript:/** foo */var foo;'];
        const visitor = {
          visitNode(node, e) {
            if (e && e.code && !args) {
              args = Array.prototype.slice.call(arguments);
            }
          },
        };

        attachTo(parser);
        parser.addAstNodeVisitor(visitor);
        parser.parse(sourceCode);

        expect(args).toBeArrayOfSize(4);

        // args[0]: AST node
        expect(args[0].type).toBe(Syntax.VariableDeclarator);

        // args[1]: JSDoc event
        expect(args[1]).toBeObject();
        expect(args[1].code).toBeObject();
        expect(args[1].code.name).toBe('foo');

        // args[2]: parser
        expect(args[2]).toBeObject();
        expect(args[2] instanceof jsdocParser.Parser).toBeTrue();

        // args[3]: current source name
        expect(String(args[3])).toBe('[[string0]]');
      })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Lazy Test,"{'line': 214, 'column': 8, 'index': 6389}","it('reflects changes made by AST node visitors', () => {
        let doclet;
        const sourceCode = ['javascript:/** foo */var foo;'];
        const visitor = {
          visitNode(node, e) {
            if (e && e.code && e.code.name === 'foo') {
              e.code.name = 'bar';
            }
          },
        };

        attachTo(parser);
        parser.addAstNodeVisitor(visitor);
        parser.parse(sourceCode);

        doclet = parser.results()[0];

        expect(doclet).toBeObject();
        expect(doclet.name).toBe('bar');
      })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Lazy Test,"{'line': 229, 'column': 8, 'index': 6843}","it('emits `parseComplete` events after it finishes parsing files', () => {
        let eventObject;
        const spy = jasmine.createSpy();
        const sourceCode = ['javascript:/** @class */function Foo() {}'];

        attachTo(parser);
        parser.on('parseComplete', spy).parse(sourceCode);

        expect(spy).toHaveBeenCalled();

        eventObject = spy.calls.mostRecent().args[0];

        expect(eventObject).toBeDefined();
        expect(eventObject.sourcefiles).toEqual(['[[string0]]']);

        expect(eventObject.doclets).toBeArrayOfSize(1);
        expect(eventObject.doclets[0].kind).toBe('class');
        expect(eventObject.doclets[0].longname).toBe('Foo');
      })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Lazy Test,"{'line': 306, 'column': 8, 'index': 9092}","it('returns an array of doclets after files are parsed', () => {
        const source = 'javascript:var foo;';
        let results;

        attachTo(parser);

        parser.parse(source);
        results = parser.results();

        expect(results).toBeArrayOfSize(1);
        expect(results[0]).toBeObject();
        expect(results[0].name).toBe('foo');
      })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Lazy Test,"{'line': 325, 'column': 8, 'index': 9731}","it('reflects comment changes made by `jsdocCommentFound` handlers', () => {
        // we test both POSIX and Windows line endings
        const source =
          'javascript:/**\n * replaceme\r\n * @module foo\n */\n\n' +
          '/**\n * replaceme\n */\nvar bar;';

        parser.on('jsdocCommentFound', (e) => {
          e.comment = e.comment.replace('replaceme', 'REPLACED!');
        });
        attachTo(parser);

        parser.parse(source);
        parser.results().forEach(({ comment }) => {
          expect(comment).not.toMatch('replaceme');
          expect(comment).toMatch('REPLACED!');
        });
      })",steel
/packages/jsdoc-parse/test/specs/lib/parser.js,Lazy Test,"{'line': 361, 'column': 10, 'index': 10851}","it('emits interleaved `jsdocCommentFound` and `symbolFound` events, in source order', () => {
          attachTo(parser);
          parser.parse(source);
          events.all
            .slice()
            .sort(sourceOrderSort)
            .forEach((e, i) => {
              expect(e).toBe(events.all[i]);
            });
        })",steel
/packages/jsdoc-name/test/specs/index.js,Conditional Test Logic,"{'line': 26, 'column': 4, 'index': 874}","it('is lib/name', () => {
    const indexKeys = Object.keys(index).sort();
    const nameKeys = Object.keys(name).sort();

    expect(indexKeys).toEqual(nameKeys);
    for (const indexKey of indexKeys) {
      expect(index[indexKey]).toBe(name[indexKey]);
    }
  })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 80}","it('contains the value from the package file', () => {
        checkPackageProperty('author', {
          name: 'Jane Smith',
          email: 'jsmith@example.com',
        });
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 93}","it('contains the value from the package file', () => {
        checkPackageProperty('bugs', { url: 'http://example.com/bugs' });
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 103}","it('contains the value from the package file', () => {
        checkPackageProperty('contributors', [
          {
            name: 'Jane Smith',
            email: 'jsmith@example.com',
          },
        ]);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 118}","it('contains the value from the package file', () => {
        checkPackageProperty('dependencies', { bar: '~1.1.0' });
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 128}","it('contains the value from the package file', () => {
        checkPackageProperty('description', 'My package.');
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 138}","it('contains the value from the package file', () => {
        checkPackageProperty('devDependencies', { baz: '~3.4.5' });
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 148}","it('contains the value from the package file', () => {
        checkPackageProperty('engines', { node: '>=0.10.3' });
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 170}","it('contains the value from the package file', () => {
        checkPackageProperty('homepage', 'http://example.com/');
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 180}","it('contains the value from the package file', () => {
        checkPackageProperty('keywords', ['foo', 'bar']);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 190}","it('contains the value from the package file', () => {
        checkPackageProperty('licenses', [
          {
            type: 'My Open-Source License',
            url: 'http://example.com/oss',
          },
        ]);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 240}","it('contains the value from the package file', () => {
        checkPackageProperty('main', 'foo');
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 250}","it('contains the value from the package file', () => {
        checkPackageProperty('name', 'foo');
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 260}","it('contains the value from the package file', () => {
        checkPackageProperty('repository', {
          type: 'git',
          url: 'git@example.org:foo/bar/baz.git',
        });
      })",steel
/packages/jsdoc-doclet/test/specs/lib/package.js,Unknown Test,"{'column': 6, 'line': 273}","it('contains the value from the package file', () => {
        checkPackageProperty('version', '0.1.2');
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet.js,Conditional Test Logic,"{'line': 253, 'column': 10, 'index': 9517}","it('overrides most properties of the secondary doclet', () => {
        let descriptors;
        const primaryDoclet = new Doclet(
          '/** New and improved!\n@version 2.0.0 */',
          null,
          jsdoc.env
        );
        const secondaryDoclet = new Doclet('/** Hello!\n@version 1.0.0 */', null, jsdoc.env);
        const newDoclet = Doclet.combineDoclets(primaryDoclet, secondaryDoclet);

        descriptors = Object.getOwnPropertyDescriptors(newDoclet);
        Object.keys(descriptors).forEach((property) => {
          if (!descriptors[property].enumerable) {
            return;
          }

          expect(newDoclet[property]).toEqual(primaryDoclet[property]);
        });
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet.js,Conditional Test Logic,"{'line': 358, 'column': 8, 'index': 13171}","describe('isVisible', () => {
      function makeEnv(access) {
        const env = _.cloneDeep(jsdoc.env);

        if (access) {
          env.config.opts.access = access.slice();
        }

        return env;
      }

      it('returns `false` for ignored doclets', () => {
        const newDoclet = makeDoclet(['@ignore', '@name foo', '@function']);

        expect(newDoclet.isVisible()).toBeFalse();
      });

      it('returns `false` for undocumented doclets', () => {
        const newDoclet = makeDoclet(['@name foo', '@function']);

        newDoclet.undocumented = true;

        expect(newDoclet.isVisible()).toBeFalse();
      });

      it('returns `false` for members of anonymous scopes', () => {
        const newDoclet = makeDoclet(['@name foo', '@function']);

        newDoclet.memberof = '<anonymous>';

        expect(newDoclet.isVisible()).toBeFalse();
      });

      describe('access', () => {
        it('returns `false` for `private` doclets by default', () => {
          const newDoclet = makeDoclet(['@name foo', '@function', '@private']);

          expect(newDoclet.isVisible()).toBeFalse();
        });

        it('returns `true` with `access === undefined` by default', () => {
          const newDoclet = makeDoclet(['@name foo', '@function']);

          // Just to be sure.
          newDoclet.access = undefined;

          expect(newDoclet.isVisible()).toBeTrue();
        });

        it('always returns `true` based on `doclet.access` when `access` config includes `all`', () => {
          const fakeEnv = makeEnv(['all']);
          const doclets = ACCESS_VALUES.map((value) => {
            let newDoclet;
            const tags = ['@function', '@name foo'];

            if (value) {
              tags.push('@' + value);
            }
            newDoclet = makeDoclet(tags, fakeEnv);
            // Just to be sure.
            if (!value) {
              newDoclet.access = undefined;
            }

            return newDoclet;
          });

          doclets.forEach((d) => {
            expect(d.isVisible()).toBeTrue();
          });
        });

        it('returns `false` for `package` doclets when config omits `package`', () => {
          const fakeEnv = makeEnv(['public']);
          const newDoclet = makeDoclet(['@function', '@name foo', '@package'], fakeEnv);

          expect(newDoclet.isVisible()).toBeFalse();
        });

        it('returns `false` for `protected` doclets when config omits `protected`', () => {
          const fakeEnv = makeEnv(['public']);
          const newDoclet = makeDoclet(['@function', '@name foo', '@protected'], fakeEnv);

          expect(newDoclet.isVisible()).toBeFalse();
        });

        it('returns `false` for `public` doclets when config omits `public`', () => {
          const fakeEnv = makeEnv(['private']);
          const newDoclet = makeDoclet(['@function', '@name foo', '@public'], fakeEnv);

          expect(newDoclet.isVisible()).toBeFalse();
        });

        it('returns `false` for undefined-access doclets when config omits `undefined`', () => {
          const fakeEnv = makeEnv(['public']);
          const newDoclet = makeDoclet(['@function', '@name foo'], fakeEnv);

          // Just to be sure.
          newDoclet.access = undefined;

          expect(newDoclet.isVisible()).toBeFalse();
        });
      });

      xdescribe('mix', () => {
        xit('TODO: write tests');
      });

      xdescribe('postProcess', () => {
        xit('TODO: write tests');
      });

      xdescribe('setLongname', () => {
        xit('TODO: write tests');
      });

      xdescribe('setMemberof', () => {
        xit('TODO: write tests');
      });

      xdescribe('setMeta', () => {
        xit('TODO: write tests');
      });

      describe('setScope', () => {
        it('accepts the correct scope names', () => {
          function setScope(scopeName) {
            const newDoclet = new Doclet('/** Huzzah, a doclet! */', null, jsdoc.env);

            newDoclet.setScope(scopeName);
          }

          _.values(SCOPE.NAMES).forEach((scopeName) => {
            expect(setScope.bind(null, scopeName)).not.toThrow();
          });
        });

        it('throws an error for invalid scope names', () => {
          function setScope() {
            const newDoclet = new Doclet('/** Woe betide this doclet. */', null, jsdoc.env);

            newDoclet.setScope('fiddlesticks');
          }

          expect(setScope).toThrow();
        });
      });

      describe('watchable properties', () => {
        const { emitter } = jsdoc.env;
        let events;

        function listener(e) {
          events.push(e);
        }

        beforeEach(() => {
          emitter.on('docletChanged', listener);
          events = [];
        });

        afterEach(() => {
          emitter.removeListener('docletChanged', listener);
        });

        it('sends events to the event bus when watchable properties change', () => {
          const propValues = {
            access: 'private',
            augments: ['Foo'],
            borrowed: true,
            ignore: true,
            implements: ['Foo'],
            kind: 'class',
            listens: ['event:foo'],
            longname: 'foo',
            memberof: 'foo',
            mixes: ['foo'],
            scope: 'static',
            undocumented: true,
          };
          const keys = Object.keys(propValues);

          // Make sure this test covers all watchable properties.
          expect(keys).toEqual(doclet.WATCHABLE_PROPS);

          keys.forEach((key) => {
            const newDoclet = new Doclet('/** Huzzah, a doclet! */', null, jsdoc.env);

            events = [];

            // Generates first event.
            newDoclet[key] = propValues[key];
            // Generates second event.
            newDoclet[key] = undefined;

            expect(events.length).toBe(2);

            expect(events[0]).toBeObject();
            expect(events[0].doclet).toBe(newDoclet);
            expect(events[0].property).toBe(key);
            if (key === 'kind') {
              expect(events[0].oldValue).toBe('member');
            } else if (key === 'longname') {
              expect(events[0].oldValue).toBeEmptyString();
            } else {
              expect(events[0].oldValue).toBeUndefined();
            }
            expect(events[0].newValue).toEqual(propValues[key]);

            expect(events[1]).toBeObject();
            expect(events[1].doclet).toBe(newDoclet);
            expect(events[1].property).toBe(key);
            expect(events[1].oldValue).toEqual(propValues[key]);
            expect(events[1].newValue).toBeUndefined();
          });
        });
      });
    })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet.js,Conditional Test Logic,"{'line': 409, 'column': 12, 'index': 14775}","it('always returns `true` based on `doclet.access` when `access` config includes `all`', () => {
          const fakeEnv = makeEnv(['all']);
          const doclets = ACCESS_VALUES.map((value) => {
            let newDoclet;
            const tags = ['@function', '@name foo'];

            if (value) {
              tags.push('@' + value);
            }
            newDoclet = makeDoclet(tags, fakeEnv);
            // Just to be sure.
            if (!value) {
              newDoclet.access = undefined;
            }

            return newDoclet;
          });

          doclets.forEach((d) => {
            expect(d.isVisible()).toBeTrue();
          });
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet.js,Conditional Test Logic,"{'line': 414, 'column': 12, 'index': 14935}","it('always returns `true` based on `doclet.access` when `access` config includes `all`', () => {
          const fakeEnv = makeEnv(['all']);
          const doclets = ACCESS_VALUES.map((value) => {
            let newDoclet;
            const tags = ['@function', '@name foo'];

            if (value) {
              tags.push('@' + value);
            }
            newDoclet = makeDoclet(tags, fakeEnv);
            // Just to be sure.
            if (!value) {
              newDoclet.access = undefined;
            }

            return newDoclet;
          });

          doclets.forEach((d) => {
            expect(d.isVisible()).toBeTrue();
          });
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet.js,Conditional Test Logic,"{'line': 554, 'column': 12, 'index': 19112}","it('sends events to the event bus when watchable properties change', () => {
          const propValues = {
            access: 'private',
            augments: ['Foo'],
            borrowed: true,
            ignore: true,
            implements: ['Foo'],
            kind: 'class',
            listens: ['event:foo'],
            longname: 'foo',
            memberof: 'foo',
            mixes: ['foo'],
            scope: 'static',
            undocumented: true,
          };
          const keys = Object.keys(propValues);

          // Make sure this test covers all watchable properties.
          expect(keys).toEqual(doclet.WATCHABLE_PROPS);

          keys.forEach((key) => {
            const newDoclet = new Doclet('/** Huzzah, a doclet! */', null, jsdoc.env);

            events = [];

            // Generates first event.
            newDoclet[key] = propValues[key];
            // Generates second event.
            newDoclet[key] = undefined;

            expect(events.length).toBe(2);

            expect(events[0]).toBeObject();
            expect(events[0].doclet).toBe(newDoclet);
            expect(events[0].property).toBe(key);
            if (key === 'kind') {
              expect(events[0].oldValue).toBe('member');
            } else if (key === 'longname') {
              expect(events[0].oldValue).toBeEmptyString();
            } else {
              expect(events[0].oldValue).toBeUndefined();
            }
            expect(events[0].newValue).toEqual(propValues[key]);

            expect(events[1]).toBeObject();
            expect(events[1].doclet).toBe(newDoclet);
            expect(events[1].property).toBe(key);
            expect(events[1].oldValue).toEqual(propValues[key]);
            expect(events[1].newValue).toBeUndefined();
          });
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet.js,Conditional Test Logic,"{'line': 556, 'column': 19, 'index': 19210}","it('sends events to the event bus when watchable properties change', () => {
          const propValues = {
            access: 'private',
            augments: ['Foo'],
            borrowed: true,
            ignore: true,
            implements: ['Foo'],
            kind: 'class',
            listens: ['event:foo'],
            longname: 'foo',
            memberof: 'foo',
            mixes: ['foo'],
            scope: 'static',
            undocumented: true,
          };
          const keys = Object.keys(propValues);

          // Make sure this test covers all watchable properties.
          expect(keys).toEqual(doclet.WATCHABLE_PROPS);

          keys.forEach((key) => {
            const newDoclet = new Doclet('/** Huzzah, a doclet! */', null, jsdoc.env);

            events = [];

            // Generates first event.
            newDoclet[key] = propValues[key];
            // Generates second event.
            newDoclet[key] = undefined;

            expect(events.length).toBe(2);

            expect(events[0]).toBeObject();
            expect(events[0].doclet).toBe(newDoclet);
            expect(events[0].property).toBe(key);
            if (key === 'kind') {
              expect(events[0].oldValue).toBe('member');
            } else if (key === 'longname') {
              expect(events[0].oldValue).toBeEmptyString();
            } else {
              expect(events[0].oldValue).toBeUndefined();
            }
            expect(events[0].newValue).toEqual(propValues[key]);

            expect(events[1]).toBeObject();
            expect(events[1].doclet).toBe(newDoclet);
            expect(events[1].property).toBe(key);
            expect(events[1].oldValue).toEqual(propValues[key]);
            expect(events[1].newValue).toBeUndefined();
          });
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet.js,Duplicate Assert,"{'line': 555, 'column': 14, 'index': 19148}","it('sends events to the event bus when watchable properties change', () => {
          const propValues = {
            access: 'private',
            augments: ['Foo'],
            borrowed: true,
            ignore: true,
            implements: ['Foo'],
            kind: 'class',
            listens: ['event:foo'],
            longname: 'foo',
            memberof: 'foo',
            mixes: ['foo'],
            scope: 'static',
            undocumented: true,
          };
          const keys = Object.keys(propValues);

          // Make sure this test covers all watchable properties.
          expect(keys).toEqual(doclet.WATCHABLE_PROPS);

          keys.forEach((key) => {
            const newDoclet = new Doclet('/** Huzzah, a doclet! */', null, jsdoc.env);

            events = [];

            // Generates first event.
            newDoclet[key] = propValues[key];
            // Generates second event.
            newDoclet[key] = undefined;

            expect(events.length).toBe(2);

            expect(events[0]).toBeObject();
            expect(events[0].doclet).toBe(newDoclet);
            expect(events[0].property).toBe(key);
            if (key === 'kind') {
              expect(events[0].oldValue).toBe('member');
            } else if (key === 'longname') {
              expect(events[0].oldValue).toBeEmptyString();
            } else {
              expect(events[0].oldValue).toBeUndefined();
            }
            expect(events[0].newValue).toEqual(propValues[key]);

            expect(events[1]).toBeObject();
            expect(events[1].doclet).toBe(newDoclet);
            expect(events[1].property).toBe(key);
            expect(events[1].oldValue).toEqual(propValues[key]);
            expect(events[1].newValue).toBeUndefined();
          });
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet.js,Duplicate Assert,"{'line': 557, 'column': 14, 'index': 19250}","it('sends events to the event bus when watchable properties change', () => {
          const propValues = {
            access: 'private',
            augments: ['Foo'],
            borrowed: true,
            ignore: true,
            implements: ['Foo'],
            kind: 'class',
            listens: ['event:foo'],
            longname: 'foo',
            memberof: 'foo',
            mixes: ['foo'],
            scope: 'static',
            undocumented: true,
          };
          const keys = Object.keys(propValues);

          // Make sure this test covers all watchable properties.
          expect(keys).toEqual(doclet.WATCHABLE_PROPS);

          keys.forEach((key) => {
            const newDoclet = new Doclet('/** Huzzah, a doclet! */', null, jsdoc.env);

            events = [];

            // Generates first event.
            newDoclet[key] = propValues[key];
            // Generates second event.
            newDoclet[key] = undefined;

            expect(events.length).toBe(2);

            expect(events[0]).toBeObject();
            expect(events[0].doclet).toBe(newDoclet);
            expect(events[0].property).toBe(key);
            if (key === 'kind') {
              expect(events[0].oldValue).toBe('member');
            } else if (key === 'longname') {
              expect(events[0].oldValue).toBeEmptyString();
            } else {
              expect(events[0].oldValue).toBeUndefined();
            }
            expect(events[0].newValue).toEqual(propValues[key]);

            expect(events[1]).toBeObject();
            expect(events[1].doclet).toBe(newDoclet);
            expect(events[1].property).toBe(key);
            expect(events[1].oldValue).toEqual(propValues[key]);
            expect(events[1].newValue).toBeUndefined();
          });
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet.js,Duplicate Assert,"{'line': 559, 'column': 14, 'index': 19331}","it('sends events to the event bus when watchable properties change', () => {
          const propValues = {
            access: 'private',
            augments: ['Foo'],
            borrowed: true,
            ignore: true,
            implements: ['Foo'],
            kind: 'class',
            listens: ['event:foo'],
            longname: 'foo',
            memberof: 'foo',
            mixes: ['foo'],
            scope: 'static',
            undocumented: true,
          };
          const keys = Object.keys(propValues);

          // Make sure this test covers all watchable properties.
          expect(keys).toEqual(doclet.WATCHABLE_PROPS);

          keys.forEach((key) => {
            const newDoclet = new Doclet('/** Huzzah, a doclet! */', null, jsdoc.env);

            events = [];

            // Generates first event.
            newDoclet[key] = propValues[key];
            // Generates second event.
            newDoclet[key] = undefined;

            expect(events.length).toBe(2);

            expect(events[0]).toBeObject();
            expect(events[0].doclet).toBe(newDoclet);
            expect(events[0].property).toBe(key);
            if (key === 'kind') {
              expect(events[0].oldValue).toBe('member');
            } else if (key === 'longname') {
              expect(events[0].oldValue).toBeEmptyString();
            } else {
              expect(events[0].oldValue).toBeUndefined();
            }
            expect(events[0].newValue).toEqual(propValues[key]);

            expect(events[1]).toBeObject();
            expect(events[1].doclet).toBe(newDoclet);
            expect(events[1].property).toBe(key);
            expect(events[1].oldValue).toEqual(propValues[key]);
            expect(events[1].newValue).toBeUndefined();
          });
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet.js,Magic Number,"{'line': 549, 'column': 39, 'index': 18947}","it('sends events to the event bus when watchable properties change', () => {
          const propValues = {
            access: 'private',
            augments: ['Foo'],
            borrowed: true,
            ignore: true,
            implements: ['Foo'],
            kind: 'class',
            listens: ['event:foo'],
            longname: 'foo',
            memberof: 'foo',
            mixes: ['foo'],
            scope: 'static',
            undocumented: true,
          };
          const keys = Object.keys(propValues);

          // Make sure this test covers all watchable properties.
          expect(keys).toEqual(doclet.WATCHABLE_PROPS);

          keys.forEach((key) => {
            const newDoclet = new Doclet('/** Huzzah, a doclet! */', null, jsdoc.env);

            events = [];

            // Generates first event.
            newDoclet[key] = propValues[key];
            // Generates second event.
            newDoclet[key] = undefined;

            expect(events.length).toBe(2);

            expect(events[0]).toBeObject();
            expect(events[0].doclet).toBe(newDoclet);
            expect(events[0].property).toBe(key);
            if (key === 'kind') {
              expect(events[0].oldValue).toBe('member');
            } else if (key === 'longname') {
              expect(events[0].oldValue).toBeEmptyString();
            } else {
              expect(events[0].oldValue).toBeUndefined();
            }
            expect(events[0].newValue).toEqual(propValues[key]);

            expect(events[1]).toBeObject();
            expect(events[1].doclet).toBe(newDoclet);
            expect(events[1].property).toBe(key);
            expect(events[1].oldValue).toEqual(propValues[key]);
            expect(events[1].newValue).toBeUndefined();
          });
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Conditional Test Logic,"{'line': 31, 'column': 2, 'index': 975}",Unknown,steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 148, 'column': 10, 'index': 4236}","it('tracks changes to a normal doclet', () => {
          // Create a doclet without emitting it.
          const doclet = makeDoclet(['@namespace', '@name Foo'], { _emitEvent: false });

          store.add(doclet);
          doclet.longname = doclet.name = 'Bar';

          expect(store.docletsByLongname).not.toHave('Foo');
          expect(store.docletsByLongname).toHave('Bar');
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 149, 'column': 10, 'index': 4297}","it('tracks changes to a normal doclet', () => {
          // Create a doclet without emitting it.
          const doclet = makeDoclet(['@namespace', '@name Foo'], { _emitEvent: false });

          store.add(doclet);
          doclet.longname = doclet.name = 'Bar';

          expect(store.docletsByLongname).not.toHave('Foo');
          expect(store.docletsByLongname).toHave('Bar');
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 394, 'column': 8, 'index': 13801}","it('contains both visible and hidden doclets', () => {
        const fooDoclet = makeDoclet(['@function', '@name foo']);
        const barDoclet = makeDoclet(['@function', '@name bar', '@ignore']);

        expect(store.allDoclets.size).toBe(2);
        expect(store.allDoclets).toHave(fooDoclet);
        expect(store.allDoclets).toHave(barDoclet);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 395, 'column': 8, 'index': 13853}","it('contains both visible and hidden doclets', () => {
        const fooDoclet = makeDoclet(['@function', '@name foo']);
        const barDoclet = makeDoclet(['@function', '@name bar', '@ignore']);

        expect(store.allDoclets.size).toBe(2);
        expect(store.allDoclets).toHave(fooDoclet);
        expect(store.allDoclets).toHave(barDoclet);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 477, 'column': 8, 'index': 16521}","it('works twice in a row', () => {
        const meta = {
          filename: '/Users/carolr/code/foo.js',
          lineno: 1,
        };

        makeDoclet(['@function', '@global', '@name baz'], meta);

        expect(store.commonPathPrefix).toBe('/Users/carolr/code');
        expect(store.commonPathPrefix).toBe('/Users/carolr/code');
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 477, 'column': 8, 'index': 16521}","it('works twice in a row', () => {
        const meta = {
          filename: '/Users/carolr/code/foo.js',
          lineno: 1,
        };

        makeDoclet(['@function', '@global', '@name baz'], meta);

        expect(store.commonPathPrefix).toBe('/Users/carolr/code');
        expect(store.commonPathPrefix).toBe('/Users/carolr/code');
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 478, 'column': 8, 'index': 16588}","it('works twice in a row', () => {
        const meta = {
          filename: '/Users/carolr/code/foo.js',
          lineno: 1,
        };

        makeDoclet(['@function', '@global', '@name baz'], meta);

        expect(store.commonPathPrefix).toBe('/Users/carolr/code');
        expect(store.commonPathPrefix).toBe('/Users/carolr/code');
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 478, 'column': 8, 'index': 16588}","it('works twice in a row', () => {
        const meta = {
          filename: '/Users/carolr/code/foo.js',
          lineno: 1,
        };

        makeDoclet(['@function', '@global', '@name baz'], meta);

        expect(store.commonPathPrefix).toBe('/Users/carolr/code');
        expect(store.commonPathPrefix).toBe('/Users/carolr/code');
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 573, 'column': 10, 'index': 19608}","it('marks a public doclet as unused if it becomes private', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.unusedDoclets).not.toHave(doclet);

          doclet.access = 'private';

          expect(store.unusedDoclets).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 577, 'column': 10, 'index': 19705}","it('marks a public doclet as unused if it becomes private', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.unusedDoclets).not.toHave(doclet);

          doclet.access = 'private';

          expect(store.unusedDoclets).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 583, 'column': 10, 'index': 19941}","it('marks a private doclet as visible if it becomes public', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@private']);

          expect(store.unusedDoclets).toHave(doclet);

          doclet.access = 'public';

          expect(store.unusedDoclets).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 587, 'column': 10, 'index': 20033}","it('marks a private doclet as visible if it becomes public', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@private']);

          expect(store.unusedDoclets).toHave(doclet);

          doclet.access = 'public';

          expect(store.unusedDoclets).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 595, 'column': 10, 'index': 20352}","it('adds a doclet to the list of doclets that augment others when the doclet gains an `augments` value', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsWithAugments).not.toHave(doclet);

          doclet.augments = ['Baz'];

          expect(store.docletsWithAugments).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 599, 'column': 10, 'index': 20455}","it('adds a doclet to the list of doclets that augment others when the doclet gains an `augments` value', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsWithAugments).not.toHave(doclet);

          doclet.augments = ['Baz'];

          expect(store.docletsWithAugments).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 605, 'column': 10, 'index': 20752}","it('removes a doclet from the list of doclets that augment others when the doclet loses all `augments` values', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@extends Baz']);

          expect(store.docletsWithAugments).toHave(doclet);

          doclet.augments.pop();

          expect(store.docletsWithAugments).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 609, 'column': 10, 'index': 20847}","it('removes a doclet from the list of doclets that augment others when the doclet loses all `augments` values', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@extends Baz']);

          expect(store.docletsWithAugments).toHave(doclet);

          doclet.augments.pop();

          expect(store.docletsWithAugments).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 615, 'column': 10, 'index': 21150}","it('removes a doclet from the list of doclets that augment others when the doclet loses its `augments` property', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@extends Baz']);

          expect(store.docletsWithAugments).toHave(doclet);

          doclet.augments = undefined;

          expect(store.docletsWithAugments).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 619, 'column': 10, 'index': 21251}","it('removes a doclet from the list of doclets that augment others when the doclet loses its `augments` property', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@extends Baz']);

          expect(store.docletsWithAugments).toHave(doclet);

          doclet.augments = undefined;

          expect(store.docletsWithAugments).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 625, 'column': 10, 'index': 21516}","it('does nothing when a doclet augmented A, but it now augments B instead', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@extends Baz']);

          expect(store.docletsWithAugments).toHave(doclet);

          doclet.augments[0] = 'Qux';

          expect(store.docletsWithAugments).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 629, 'column': 10, 'index': 21616}","it('does nothing when a doclet augmented A, but it now augments B instead', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@extends Baz']);

          expect(store.docletsWithAugments).toHave(doclet);

          doclet.augments[0] = 'Qux';

          expect(store.docletsWithAugments).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 637, 'column': 10, 'index': 21951}","it('adds a doclet to the list of doclets that borrow others when the doclet gains a `borrowed` value', () => {
          const doclet = makeDoclet(['@function', '@memberof Foo', '@name bar', '@instance']);

          expect(store.docletsWithBorrowed).not.toHave(doclet);

          doclet.borrowed = [{ from: 'Baz#bar' }];

          expect(store.docletsWithBorrowed).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 641, 'column': 10, 'index': 22068}","it('adds a doclet to the list of doclets that borrow others when the doclet gains a `borrowed` value', () => {
          const doclet = makeDoclet(['@function', '@memberof Foo', '@name bar', '@instance']);

          expect(store.docletsWithBorrowed).not.toHave(doclet);

          doclet.borrowed = [{ from: 'Baz#bar' }];

          expect(store.docletsWithBorrowed).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 653, 'column': 10, 'index': 22457}","it('removes a doclet from the list of doclets that borrow others when the doclet loses all `borrowed` values', () => {
          const doclet = makeDoclet([
            '@function',
            '@memberof Foo',
            '@name bar',
            '@instance',
            '@borrows Baz#bar',
          ]);

          expect(store.docletsWithBorrowed).toHave(doclet);

          doclet.borrowed.pop();

          expect(store.docletsWithBorrowed).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 657, 'column': 10, 'index': 22552}","it('removes a doclet from the list of doclets that borrow others when the doclet loses all `borrowed` values', () => {
          const doclet = makeDoclet([
            '@function',
            '@memberof Foo',
            '@name bar',
            '@instance',
            '@borrows Baz#bar',
          ]);

          expect(store.docletsWithBorrowed).toHave(doclet);

          doclet.borrowed.pop();

          expect(store.docletsWithBorrowed).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 669, 'column': 10, 'index': 22947}","it('removes a doclet from the list of doclets that borrow others when the doclet loses its `borrowed` property', () => {
          const doclet = makeDoclet([
            '@function',
            '@memberof Foo',
            '@name bar',
            '@instance',
            '@borrows Baz#bar',
          ]);

          expect(store.docletsWithBorrowed).toHave(doclet);

          doclet.borrowed = undefined;

          expect(store.docletsWithBorrowed).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 673, 'column': 10, 'index': 23048}","it('removes a doclet from the list of doclets that borrow others when the doclet loses its `borrowed` property', () => {
          const doclet = makeDoclet([
            '@function',
            '@memberof Foo',
            '@name bar',
            '@instance',
            '@borrows Baz#bar',
          ]);

          expect(store.docletsWithBorrowed).toHave(doclet);

          doclet.borrowed = undefined;

          expect(store.docletsWithBorrowed).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 685, 'column': 10, 'index': 23404}","it('does nothing when a doclet borrowed A, but it now borrows B instead', () => {
          const doclet = makeDoclet([
            '@function',
            '@memberof Foo',
            '@name bar',
            '@instance',
            '@borrows Baz#bar',
          ]);

          expect(store.docletsWithBorrowed).toHave(doclet);

          doclet.borrowed[0] = { from: 'Qux#bar' };

          expect(store.docletsWithBorrowed).toContain(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 689, 'column': 10, 'index': 23518}","it('does nothing when a doclet borrowed A, but it now borrows B instead', () => {
          const doclet = makeDoclet([
            '@function',
            '@memberof Foo',
            '@name bar',
            '@instance',
            '@borrows Baz#bar',
          ]);

          expect(store.docletsWithBorrowed).toHave(doclet);

          doclet.borrowed[0] = { from: 'Qux#bar' };

          expect(store.docletsWithBorrowed).toContain(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 697, 'column': 10, 'index': 23779}","it('marks the doclet as unused when added', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);

          doclet.ignore = true;

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 698, 'column': 10, 'index': 23827}","it('marks the doclet as unused when added', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);

          doclet.ignore = true;

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 702, 'column': 10, 'index': 23919}","it('marks the doclet as unused when added', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);

          doclet.ignore = true;

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 703, 'column': 10, 'index': 23971}","it('marks the doclet as unused when added', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);

          doclet.ignore = true;

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 709, 'column': 10, 'index': 24192}","it('marks the doclet as visible when removed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@ignore']);

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);

          doclet.ignore = undefined;

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 710, 'column': 10, 'index': 24244}","it('marks the doclet as visible when removed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@ignore']);

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);

          doclet.ignore = undefined;

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 714, 'column': 10, 'index': 24337}","it('marks the doclet as visible when removed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@ignore']);

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);

          doclet.ignore = undefined;

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 715, 'column': 10, 'index': 24385}","it('marks the doclet as visible when removed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@ignore']);

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);

          doclet.ignore = undefined;

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 723, 'column': 10, 'index': 24710}","it('adds a doclet to the list of doclets that implement others when the doclet gains an `implements` value', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsWithImplements).not.toHave(doclet);

          doclet.implements = ['IBar'];

          expect(store.docletsWithImplements).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 727, 'column': 10, 'index': 24818}","it('adds a doclet to the list of doclets that implement others when the doclet gains an `implements` value', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsWithImplements).not.toHave(doclet);

          doclet.implements = ['IBar'];

          expect(store.docletsWithImplements).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 733, 'column': 10, 'index': 25125}","it('removes a doclet from the list of doclets that implement others when the doclet loses all `implements` values', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@implements IBar']);

          expect(store.docletsWithImplements).toHave(doclet);

          doclet.implements.pop();

          expect(store.docletsWithImplements).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 737, 'column': 10, 'index': 25224}","it('removes a doclet from the list of doclets that implement others when the doclet loses all `implements` values', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@implements IBar']);

          expect(store.docletsWithImplements).toHave(doclet);

          doclet.implements.pop();

          expect(store.docletsWithImplements).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 743, 'column': 10, 'index': 25537}","it('removes a doclet from the list of doclets that implement others when the doclet loses its `implements` property', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@implements IBar']);

          expect(store.docletsWithImplements).toHave(doclet);

          doclet.implements = undefined;

          expect(store.docletsWithImplements).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 747, 'column': 10, 'index': 25642}","it('removes a doclet from the list of doclets that implement others when the doclet loses its `implements` property', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@implements IBar']);

          expect(store.docletsWithImplements).toHave(doclet);

          doclet.implements = undefined;

          expect(store.docletsWithImplements).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 753, 'column': 10, 'index': 25917}","it('does nothing when a doclet implemented A, but it now implements B instead', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@implements IBar']);

          expect(store.docletsWithImplements).toHave(doclet);

          doclet.implements[0] = 'IBaz';

          expect(store.docletsWithImplements).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 757, 'column': 10, 'index': 26022}","it('does nothing when a doclet implemented A, but it now implements B instead', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@implements IBar']);

          expect(store.docletsWithImplements).toHave(doclet);

          doclet.implements[0] = 'IBaz';

          expect(store.docletsWithImplements).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 771, 'column': 10, 'index': 26528}","it('removes a doclet from the list of doclets for a kind when the kind changes', () => {
          const doclet = makeDoclet(['@function', '@name foo']);

          expect(store.docletsByKind.get('constant')).not.toHave(doclet);
          expect(store.docletsByKind.get('function')).toHave(doclet);

          doclet.kind = 'constant';

          expect(store.docletsByKind.get('constant')).toHave(doclet);
          expect(store.docletsByKind.get('function')).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 772, 'column': 10, 'index': 26602}","it('removes a doclet from the list of doclets for a kind when the kind changes', () => {
          const doclet = makeDoclet(['@function', '@name foo']);

          expect(store.docletsByKind.get('constant')).not.toHave(doclet);
          expect(store.docletsByKind.get('function')).toHave(doclet);

          doclet.kind = 'constant';

          expect(store.docletsByKind.get('constant')).toHave(doclet);
          expect(store.docletsByKind.get('function')).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 776, 'column': 10, 'index': 26710}","it('removes a doclet from the list of doclets for a kind when the kind changes', () => {
          const doclet = makeDoclet(['@function', '@name foo']);

          expect(store.docletsByKind.get('constant')).not.toHave(doclet);
          expect(store.docletsByKind.get('function')).toHave(doclet);

          doclet.kind = 'constant';

          expect(store.docletsByKind.get('constant')).toHave(doclet);
          expect(store.docletsByKind.get('function')).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 777, 'column': 10, 'index': 26780}","it('removes a doclet from the list of doclets for a kind when the kind changes', () => {
          const doclet = makeDoclet(['@function', '@name foo']);

          expect(store.docletsByKind.get('constant')).not.toHave(doclet);
          expect(store.docletsByKind.get('function')).toHave(doclet);

          doclet.kind = 'constant';

          expect(store.docletsByKind.get('constant')).toHave(doclet);
          expect(store.docletsByKind.get('function')).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 784, 'column': 10, 'index': 27126}","it('removes a doclet from the list of doclets for a kind when the doclet loses its kind', () => {
          const doclet = makeDoclet(['@function', '@name foo']);

          expect(store.docletsByKind.get('function')).toHave(doclet);

          doclet.kind = 'undefined';

          expect(store.docletsByKind.get('function')).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 788, 'column': 10, 'index': 27235}","it('removes a doclet from the list of doclets for a kind when the doclet loses its kind', () => {
          const doclet = makeDoclet(['@function', '@name foo']);

          expect(store.docletsByKind.get('function')).toHave(doclet);

          doclet.kind = 'undefined';

          expect(store.docletsByKind.get('function')).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 794, 'column': 10, 'index': 27504}","it('adds a doclet to the list of global doclets when it gains a `kind` that can be global', () => {
          const doclet = makeDoclet(['@class', '@name foo', '@global']);

          expect(store.globals).toBeEmptySet();

          doclet.kind = 'function';

          expect(store.globals).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 798, 'column': 10, 'index': 27590}","it('adds a doclet to the list of global doclets when it gains a `kind` that can be global', () => {
          const doclet = makeDoclet(['@class', '@name foo', '@global']);

          expect(store.globals).toBeEmptySet();

          doclet.kind = 'function';

          expect(store.globals).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 804, 'column': 10, 'index': 27836}","it('removes a doclet from the list of global doclets when its new `kind` cannot be global', () => {
          const doclet = makeDoclet(['@function', '@name foo', '@global']);

          expect(store.globals).toHave(doclet);

          doclet.kind = 'class';

          expect(store.globals).toBeEmptySet();
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 808, 'column': 10, 'index': 27919}","it('removes a doclet from the list of global doclets when its new `kind` cannot be global', () => {
          const doclet = makeDoclet(['@function', '@name foo', '@global']);

          expect(store.globals).toHave(doclet);

          doclet.kind = 'class';

          expect(store.globals).toBeEmptySet();
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 825, 'column': 10, 'index': 28499}","it('adds a doclet to the list of listeners when the doclet gains a `listens` value', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.listenersByListensTo.get('event:baz')).toBeUndefined();

          doclet.listens = ['event:baz'];

          expect(store.listenersByListensTo.get('event:baz')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 829, 'column': 10, 'index': 28622}","it('adds a doclet to the list of listeners when the doclet gains a `listens` value', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.listenersByListensTo.get('event:baz')).toBeUndefined();

          doclet.listens = ['event:baz'];

          expect(store.listenersByListensTo.get('event:baz')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 835, 'column': 10, 'index': 28924}","it('removes a doclet from the list of listeners when the doclet loses all `listens` values', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@listens event:baz']);

          expect(store.listenersByListensTo.get('event:baz')).toHave(doclet);

          doclet.listens.pop();

          expect(store.listenersByListensTo.get('event:baz')).toBeUndefined();
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 839, 'column': 10, 'index': 29036}","it('removes a doclet from the list of listeners when the doclet loses all `listens` values', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@listens event:baz']);

          expect(store.listenersByListensTo.get('event:baz')).toHave(doclet);

          doclet.listens.pop();

          expect(store.listenersByListensTo.get('event:baz')).toBeUndefined();
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 845, 'column': 10, 'index': 29341}","it('removes a doclet from the list of listeners when the doclet loses its `listens` property', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@listens event:baz']);

          expect(store.listenersByListensTo.get('event:baz')).toHave(doclet);

          doclet.listens = undefined;

          expect(store.listenersByListensTo.get('event:baz')).toBeUndefined();
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 849, 'column': 10, 'index': 29459}","it('removes a doclet from the list of listeners when the doclet loses its `listens` property', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@listens event:baz']);

          expect(store.listenersByListensTo.get('event:baz')).toHave(doclet);

          doclet.listens = undefined;

          expect(store.listenersByListensTo.get('event:baz')).toBeUndefined();
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 855, 'column': 10, 'index': 29733}","it('changes the longname that a doclet listens to when needed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@listens event:baz']);

          expect(store.listenersByListensTo.get('event:baz')).toHave(doclet);
          expect(store.listenersByListensTo.get('event:qux')).toBeUndefined();

          doclet.listens[0] = 'event:qux';

          expect(store.listenersByListensTo.get('event:baz')).toBeUndefined();
          expect(store.listenersByListensTo.get('event:qux')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 856, 'column': 10, 'index': 29811}","it('changes the longname that a doclet listens to when needed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@listens event:baz']);

          expect(store.listenersByListensTo.get('event:baz')).toHave(doclet);
          expect(store.listenersByListensTo.get('event:qux')).toBeUndefined();

          doclet.listens[0] = 'event:qux';

          expect(store.listenersByListensTo.get('event:baz')).toBeUndefined();
          expect(store.listenersByListensTo.get('event:qux')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 860, 'column': 10, 'index': 29935}","it('changes the longname that a doclet listens to when needed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@listens event:baz']);

          expect(store.listenersByListensTo.get('event:baz')).toHave(doclet);
          expect(store.listenersByListensTo.get('event:qux')).toBeUndefined();

          doclet.listens[0] = 'event:qux';

          expect(store.listenersByListensTo.get('event:baz')).toBeUndefined();
          expect(store.listenersByListensTo.get('event:qux')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 861, 'column': 10, 'index': 30014}","it('changes the longname that a doclet listens to when needed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@listens event:baz']);

          expect(store.listenersByListensTo.get('event:baz')).toHave(doclet);
          expect(store.listenersByListensTo.get('event:qux')).toBeUndefined();

          doclet.listens[0] = 'event:qux';

          expect(store.listenersByListensTo.get('event:baz')).toBeUndefined();
          expect(store.listenersByListensTo.get('event:qux')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 878, 'column': 10, 'index': 30653}","it('tracks a doclet by its new longname after it changes', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsByLongname.get('foo.Bar')).toHave(doclet);
          expect(store.docletsByLongname.get('zoo.Bar')).toBeUndefined();

          doclet.memberof = 'zoo';
          doclet.longname = 'zoo.Bar';

          expect(store.docletsByLongname.get('foo.Bar')).toBeUndefined();
          expect(store.docletsByLongname.get('zoo.Bar')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 879, 'column': 10, 'index': 30726}","it('tracks a doclet by its new longname after it changes', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsByLongname.get('foo.Bar')).toHave(doclet);
          expect(store.docletsByLongname.get('zoo.Bar')).toBeUndefined();

          doclet.memberof = 'zoo';
          doclet.longname = 'zoo.Bar';

          expect(store.docletsByLongname.get('foo.Bar')).toBeUndefined();
          expect(store.docletsByLongname.get('zoo.Bar')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 884, 'column': 10, 'index': 30876}","it('tracks a doclet by its new longname after it changes', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsByLongname.get('foo.Bar')).toHave(doclet);
          expect(store.docletsByLongname.get('zoo.Bar')).toBeUndefined();

          doclet.memberof = 'zoo';
          doclet.longname = 'zoo.Bar';

          expect(store.docletsByLongname.get('foo.Bar')).toBeUndefined();
          expect(store.docletsByLongname.get('zoo.Bar')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 885, 'column': 10, 'index': 30950}","it('tracks a doclet by its new longname after it changes', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsByLongname.get('foo.Bar')).toHave(doclet);
          expect(store.docletsByLongname.get('zoo.Bar')).toBeUndefined();

          doclet.memberof = 'zoo';
          doclet.longname = 'zoo.Bar';

          expect(store.docletsByLongname.get('foo.Bar')).toBeUndefined();
          expect(store.docletsByLongname.get('zoo.Bar')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 899, 'column': 10, 'index': 31472}","it('does not track a doclet by longname if it is no longer visible', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsByLongname.get('foo.Bar')).toHave(doclet);

          doclet.undocumented = true;

          expect(store.docletsByLongname.get('foo.Bar')).toBeUndefined();
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 903, 'column': 10, 'index': 31585}","it('does not track a doclet by longname if it is no longer visible', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsByLongname.get('foo.Bar')).toHave(doclet);

          doclet.undocumented = true;

          expect(store.docletsByLongname.get('foo.Bar')).toBeUndefined();
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 911, 'column': 10, 'index': 31874}","it('tracks a doclet by its new memberof after it changes', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsByMemberof.get('foo')).toHave(doclet);
          expect(store.docletsByMemberof.get('zoo')).toBeUndefined();

          doclet.memberof = 'zoo';
          doclet.longname = 'zoo.Bar';

          expect(store.docletsByMemberof.get('foo')).toBeUndefined();
          expect(store.docletsByMemberof.get('zoo')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 912, 'column': 10, 'index': 31943}","it('tracks a doclet by its new memberof after it changes', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsByMemberof.get('foo')).toHave(doclet);
          expect(store.docletsByMemberof.get('zoo')).toBeUndefined();

          doclet.memberof = 'zoo';
          doclet.longname = 'zoo.Bar';

          expect(store.docletsByMemberof.get('foo')).toBeUndefined();
          expect(store.docletsByMemberof.get('zoo')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 917, 'column': 10, 'index': 32089}","it('tracks a doclet by its new memberof after it changes', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsByMemberof.get('foo')).toHave(doclet);
          expect(store.docletsByMemberof.get('zoo')).toBeUndefined();

          doclet.memberof = 'zoo';
          doclet.longname = 'zoo.Bar';

          expect(store.docletsByMemberof.get('foo')).toBeUndefined();
          expect(store.docletsByMemberof.get('zoo')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 918, 'column': 10, 'index': 32159}","it('tracks a doclet by its new memberof after it changes', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.docletsByMemberof.get('foo')).toHave(doclet);
          expect(store.docletsByMemberof.get('zoo')).toBeUndefined();

          doclet.memberof = 'zoo';
          doclet.longname = 'zoo.Bar';

          expect(store.docletsByMemberof.get('foo')).toBeUndefined();
          expect(store.docletsByMemberof.get('zoo')).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 935, 'column': 10, 'index': 32789}","it('adds a doclet to the list of doclets that mix in others when the doclet gains a `mixes` value', () => {
          const doclet = makeDoclet(['@class', '@name Foo']);

          expect(store.docletsWithMixes).not.toHave(doclet);

          doclet.mixes = ['bar'];

          expect(store.docletsWithMixes).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 939, 'column': 10, 'index': 32886}","it('adds a doclet to the list of doclets that mix in others when the doclet gains a `mixes` value', () => {
          const doclet = makeDoclet(['@class', '@name Foo']);

          expect(store.docletsWithMixes).not.toHave(doclet);

          doclet.mixes = ['bar'];

          expect(store.docletsWithMixes).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 945, 'column': 10, 'index': 33157}","it('removes a doclet from the list of doclets that mix in others when the doclet loses all `mixes` values', () => {
          const doclet = makeDoclet(['@class', '@name Foo', '@mixes bar']);

          expect(store.docletsWithMixes).toHave(doclet);

          doclet.mixes.pop();

          expect(store.docletsWithMixes).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 949, 'column': 10, 'index': 33246}","it('removes a doclet from the list of doclets that mix in others when the doclet loses all `mixes` values', () => {
          const doclet = makeDoclet(['@class', '@name Foo', '@mixes bar']);

          expect(store.docletsWithMixes).toHave(doclet);

          doclet.mixes.pop();

          expect(store.docletsWithMixes).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 955, 'column': 10, 'index': 33523}","it('removes a doclet from the list of doclets that mix in others when the doclet loses its `mixes` property', () => {
          const doclet = makeDoclet(['@class', '@name Foo', '@mixes bar']);

          expect(store.docletsWithMixes).toHave(doclet);

          doclet.mixes = undefined;

          expect(store.docletsWithMixes).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 959, 'column': 10, 'index': 33618}","it('removes a doclet from the list of doclets that mix in others when the doclet loses its `mixes` property', () => {
          const doclet = makeDoclet(['@class', '@name Foo', '@mixes bar']);

          expect(store.docletsWithMixes).toHave(doclet);

          doclet.mixes = undefined;

          expect(store.docletsWithMixes).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 965, 'column': 10, 'index': 33860}","it('does nothing when a doclet mixed in A, but it now mixes in B instead', () => {
          const doclet = makeDoclet(['@class', '@name Foo', '@mixes bar']);

          expect(store.docletsWithMixes).toHave(doclet);

          doclet.mixes[0] = 'baz';

          expect(store.docletsWithMixes).toContain(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 969, 'column': 10, 'index': 33954}","it('does nothing when a doclet mixed in A, but it now mixes in B instead', () => {
          const doclet = makeDoclet(['@class', '@name Foo', '@mixes bar']);

          expect(store.docletsWithMixes).toHave(doclet);

          doclet.mixes[0] = 'baz';

          expect(store.docletsWithMixes).toContain(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 977, 'column': 10, 'index': 34230}","it('adds a doclet to the list of global doclets when it gains global scope', () => {
          const doclet = makeDoclet(['@function', '@name foo']);

          expect(store.globals).toBeEmptySet();

          doclet.scope = 'global';

          expect(store.globals).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 981, 'column': 10, 'index': 34315}","it('adds a doclet to the list of global doclets when it gains global scope', () => {
          const doclet = makeDoclet(['@function', '@name foo']);

          expect(store.globals).toBeEmptySet();

          doclet.scope = 'global';

          expect(store.globals).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 987, 'column': 10, 'index': 34551}","it('removes a doclet from the list of global doclets when it loses global scope', () => {
          const doclet = makeDoclet(['@function', '@name foo', '@global']);

          expect(store.globals).toHave(doclet);

          doclet.scope = 'static';

          expect(store.globals).toBeEmptySet();
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 991, 'column': 10, 'index': 34636}","it('removes a doclet from the list of global doclets when it loses global scope', () => {
          const doclet = makeDoclet(['@function', '@name foo', '@global']);

          expect(store.globals).toHave(doclet);

          doclet.scope = 'static';

          expect(store.globals).toBeEmptySet();
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 999, 'column': 10, 'index': 34888}","it('marks the doclet as unused when added', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);

          doclet.undocumented = true;

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1000, 'column': 10, 'index': 34936}","it('marks the doclet as unused when added', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);

          doclet.undocumented = true;

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1004, 'column': 10, 'index': 35034}","it('marks the doclet as unused when added', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);

          doclet.undocumented = true;

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1005, 'column': 10, 'index': 35086}","it('marks the doclet as unused when added', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar']);

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);

          doclet.undocumented = true;

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1011, 'column': 10, 'index': 35313}","it('marks the doclet as visible when removed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@undocumented']);

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);

          doclet.undocumented = undefined;

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1012, 'column': 10, 'index': 35365}","it('marks the doclet as visible when removed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@undocumented']);

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);

          doclet.undocumented = undefined;

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1016, 'column': 10, 'index': 35464}","it('marks the doclet as visible when removed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@undocumented']);

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);

          doclet.undocumented = undefined;

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1017, 'column': 10, 'index': 35512}","it('marks the doclet as visible when removed', () => {
          const doclet = makeDoclet(['@class', '@memberof foo', '@name Bar', '@undocumented']);

          expect(store.doclets).not.toHave(doclet);
          expect(store.unusedDoclets).toHave(doclet);

          doclet.undocumented = undefined;

          expect(store.doclets).toHave(doclet);
          expect(store.unusedDoclets).not.toHave(doclet);
        })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1052, 'column': 8, 'index': 36533}","it('starts listening for events if necessary', () => {
        const foo = makeDoclet(['@class', '@name Foo']);
        const bar = makeDoclet(['@class', '@name Bar']);

        expect(store.doclets).toHave(foo);
        expect(store.doclets).toHave(bar);

        // Stop listening for events.
        store.stopListening();
        // Change the doclet for `Foo` so that it's not visible.
        foo.undocumented = true;
        // Start listening for events.
        store.startListening();
        // Change the doclet for `Bar` so that it's not visible.
        bar.undocumented = true;

        // The doclet store didn't observe the change to `Foo`, but it did observe the change to
        // `Bar`. Therefore, `Foo` should be treated as if it's still visible, and `Bar` shouldn't.
        expect(store.doclets).toHave(foo);
        expect(store.unusedDoclets).not.toHave(foo);
        expect(store.doclets).not.toHave(bar);
        expect(store.unusedDoclets).toHave(bar);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1053, 'column': 8, 'index': 36576}","it('starts listening for events if necessary', () => {
        const foo = makeDoclet(['@class', '@name Foo']);
        const bar = makeDoclet(['@class', '@name Bar']);

        expect(store.doclets).toHave(foo);
        expect(store.doclets).toHave(bar);

        // Stop listening for events.
        store.stopListening();
        // Change the doclet for `Foo` so that it's not visible.
        foo.undocumented = true;
        // Start listening for events.
        store.startListening();
        // Change the doclet for `Bar` so that it's not visible.
        bar.undocumented = true;

        // The doclet store didn't observe the change to `Foo`, but it did observe the change to
        // `Bar`. Therefore, `Foo` should be treated as if it's still visible, and `Bar` shouldn't.
        expect(store.doclets).toHave(foo);
        expect(store.unusedDoclets).not.toHave(foo);
        expect(store.doclets).not.toHave(bar);
        expect(store.unusedDoclets).toHave(bar);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1066, 'column': 8, 'index': 37154}","it('starts listening for events if necessary', () => {
        const foo = makeDoclet(['@class', '@name Foo']);
        const bar = makeDoclet(['@class', '@name Bar']);

        expect(store.doclets).toHave(foo);
        expect(store.doclets).toHave(bar);

        // Stop listening for events.
        store.stopListening();
        // Change the doclet for `Foo` so that it's not visible.
        foo.undocumented = true;
        // Start listening for events.
        store.startListening();
        // Change the doclet for `Bar` so that it's not visible.
        bar.undocumented = true;

        // The doclet store didn't observe the change to `Foo`, but it did observe the change to
        // `Bar`. Therefore, `Foo` should be treated as if it's still visible, and `Bar` shouldn't.
        expect(store.doclets).toHave(foo);
        expect(store.unusedDoclets).not.toHave(foo);
        expect(store.doclets).not.toHave(bar);
        expect(store.unusedDoclets).toHave(bar);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1067, 'column': 8, 'index': 37197}","it('starts listening for events if necessary', () => {
        const foo = makeDoclet(['@class', '@name Foo']);
        const bar = makeDoclet(['@class', '@name Bar']);

        expect(store.doclets).toHave(foo);
        expect(store.doclets).toHave(bar);

        // Stop listening for events.
        store.stopListening();
        // Change the doclet for `Foo` so that it's not visible.
        foo.undocumented = true;
        // Start listening for events.
        store.startListening();
        // Change the doclet for `Bar` so that it's not visible.
        bar.undocumented = true;

        // The doclet store didn't observe the change to `Foo`, but it did observe the change to
        // `Bar`. Therefore, `Foo` should be treated as if it's still visible, and `Bar` shouldn't.
        expect(store.doclets).toHave(foo);
        expect(store.unusedDoclets).not.toHave(foo);
        expect(store.doclets).not.toHave(bar);
        expect(store.unusedDoclets).toHave(bar);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1068, 'column': 8, 'index': 37250}","it('starts listening for events if necessary', () => {
        const foo = makeDoclet(['@class', '@name Foo']);
        const bar = makeDoclet(['@class', '@name Bar']);

        expect(store.doclets).toHave(foo);
        expect(store.doclets).toHave(bar);

        // Stop listening for events.
        store.stopListening();
        // Change the doclet for `Foo` so that it's not visible.
        foo.undocumented = true;
        // Start listening for events.
        store.startListening();
        // Change the doclet for `Bar` so that it's not visible.
        bar.undocumented = true;

        // The doclet store didn't observe the change to `Foo`, but it did observe the change to
        // `Bar`. Therefore, `Foo` should be treated as if it's still visible, and `Bar` shouldn't.
        expect(store.doclets).toHave(foo);
        expect(store.unusedDoclets).not.toHave(foo);
        expect(store.doclets).not.toHave(bar);
        expect(store.unusedDoclets).toHave(bar);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Duplicate Assert,"{'line': 1069, 'column': 8, 'index': 37297}","it('starts listening for events if necessary', () => {
        const foo = makeDoclet(['@class', '@name Foo']);
        const bar = makeDoclet(['@class', '@name Bar']);

        expect(store.doclets).toHave(foo);
        expect(store.doclets).toHave(bar);

        // Stop listening for events.
        store.stopListening();
        // Change the doclet for `Foo` so that it's not visible.
        foo.undocumented = true;
        // Start listening for events.
        store.startListening();
        // Change the doclet for `Bar` so that it's not visible.
        bar.undocumented = true;

        // The doclet store didn't observe the change to `Foo`, but it did observe the change to
        // `Bar`. Therefore, `Foo` should be treated as if it's still visible, and `Bar` shouldn't.
        expect(store.doclets).toHave(foo);
        expect(store.unusedDoclets).not.toHave(foo);
        expect(store.doclets).not.toHave(bar);
        expect(store.unusedDoclets).toHave(bar);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Magic Number,"{'line': 393, 'column': 43, 'index': 13789}","it('contains both visible and hidden doclets', () => {
        const fooDoclet = makeDoclet(['@function', '@name foo']);
        const barDoclet = makeDoclet(['@function', '@name bar', '@ignore']);

        expect(store.allDoclets.size).toBe(2);
        expect(store.allDoclets).toHave(fooDoclet);
        expect(store.allDoclets).toHave(barDoclet);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Magic Number,"{'line': 416, 'column': 43, 'index': 14537}","it('does not contain anonymous doclets that were added directly', () => {
        const anonymousDoclet = makeDoclet(['@function', `@name ${ANONYMOUS_LONGNAME}`], {
          _emitEvent: false,
          code: {
            node: {
              nodeId: 'a',
            },
          },
        });

        anonymousDoclet.longname = ANONYMOUS_LONGNAME;
        store.add(anonymousDoclet);

        makeDoclet(['@function', '@name foo']);

        // Confirm that the anonymous doclet wasn't just ignored.
        expect(store.docletsByNodeId.get('a')).toHave(anonymousDoclet);

        expect(store.allDoclets.size).toBe(1);
        expect(store.allDoclets).not.toContain(anonymousDoclet);
      })",steel
/packages/jsdoc-doclet/test/specs/lib/doclet-store.js,Magic Number,"{'line': 1080, 'column': 61, 'index': 37706}","it('stops listening for events if necessary', () => {
        makeDoclet(['@class', '@name Foo']);
        store.stopListening();
        makeDoclet(['@class', '@name Bar']);

        // The doclet store should know about `Foo`, but not `Bar`.
        expect(store.docletsByLongname.get('Foo').size).toBe(1);
        expect(store.docletsByLongname.get('Bar')).toBeUndefined();
      })",steel
/packages/jsdoc-core/test/specs/lib/plugins.js,Conditional Test Logic,"{'line': 90, 'column': 8, 'index': 2828}","it('adds tags to the dictionary', async () => {
      const doclets = [];
      let pluginPath = path.resolve(__dirname, '../../fixtures/plugin-test-tags.js');

      await plugins.installPlugins([pluginPath], parser, jsdoc.env);
      parser.on('newDoclet', (e) => {
        if (e.doclet.longname === 'test') {
          doclets.push(e.doclet);
        }
      });
      jsdoc.getDocSetFromFile(
        path.resolve(__dirname, '../../fixtures/plugin-source-file.js'),
        parser
      );

      expect(doclets.length).toBe(1);
      expect(doclets[0].foo).toBeTrue();
    })",steel
/packages/jsdoc-core/test/specs/lib/plugins.js,Magic Number,"{'line': 64, 'column': 62, 'index': 2009}","it('adds event handlers to the parser', async () => {
      let pluginPath = path.resolve(__dirname, '../../fixtures/plugin-test-handlers.js');
      const { eventCounts, init } = await import(pluginPath);

      init();

      await plugins.installPlugins([pluginPath], parser, jsdoc.env);
      jsdoc.getDocSetFromFile(
        path.resolve(__dirname, '../../fixtures/plugin-source-file.js'),
        parser
      );
      // The `processingComplete` event is triggered by code that wouldn't normally be called during
      // this test, so we trigger the event manually.
      parser.fireProcessingComplete();

      // Confirm that each type of event was emitted at least once.
      events.forEach((eventName) => {
        expect(eventCounts[eventName]).toBeGreaterThanOrEqual(1);
      });
    })",steel
/packages/jsdoc-core/test/specs/lib/plugins.js,Magic Number,"{'line': 80, 'column': 32, 'index': 2488}","it('adds AST node visitors to the parser', async () => {
      let pluginPath = path.resolve(__dirname, '../../fixtures/plugin-test-ast-visitor.js');
      const { nodes, init } = await import(pluginPath);

      init();

      await plugins.installPlugins([pluginPath], parser, jsdoc.env);
      jsdoc.getDocSetFromFile(
        path.resolve(__dirname, '../../fixtures/plugin-source-file.js'),
        parser
      );

      expect(nodes.length).toBe(1);
      expect(nodes[0].init.value).toBe('bar');
    })",steel
/packages/jsdoc-core/test/specs/lib/plugins.js,Magic Number,"{'line': 99, 'column': 34, 'index': 3081}","it('adds tags to the dictionary', async () => {
      const doclets = [];
      let pluginPath = path.resolve(__dirname, '../../fixtures/plugin-test-tags.js');

      await plugins.installPlugins([pluginPath], parser, jsdoc.env);
      parser.on('newDoclet', (e) => {
        if (e.doclet.longname === 'test') {
          doclets.push(e.doclet);
        }
      });
      jsdoc.getDocSetFromFile(
        path.resolve(__dirname, '../../fixtures/plugin-source-file.js'),
        parser
      );

      expect(doclets.length).toBe(1);
      expect(doclets[0].foo).toBeTrue();
    })",steel
/packages/jsdoc-core/test/specs/lib/env.js,Conditional Test Logic,"{'line': 52, 'column': 6, 'index': 1412}","it('has a `log` property that contains logging functions', () => {
      expect(env.log).toBeObject();

      for (const key of Object.keys(env.log)) {
        expect(env.log[key]).toBeFunction();
      }
    })",steel
/packages/jsdoc-core/test/specs/lib/api.js,Exception Handling,"{'line': 205, 'column': 6, 'index': 6576}","it('rejects the promise and logs a fatal error if the template cannot be found', async () => {
      spyOn(env.log, 'fatal');
      options.template = 'fleeble';

      try {
        await instance.generateDocs();

        // We shouldn't get here.
        expect(false).toBeTrue();
      } catch (e) {
        expect(e.message).toContain('fleeble');
      }

      expect(env.log.fatal).toHaveBeenCalled();
      expect(env.log.fatal.calls.first().args[0]).toContain('fleeble');
    })",steel
/packages/jsdoc-core/test/specs/lib/api.js,Exception Handling,"{'line': 224, 'column': 6, 'index': 7155}","it('rejects the promise and logs a fatal error if `publish` is undefined', async () => {
      spyOn(env.log, 'fatal');
      options.template = path.resolve(
        path.join(__dirname, '../../fixtures/templates/no-publish-template.js')
      );

      try {
        await instance.generateDocs();

        // We shouldn't get here.
        expect(false).toBeTrue();
      } catch (e) {
        expect(e.message).toContain('no-publish-template.js');
      }

      expect(env.log.fatal).toHaveBeenCalled();
      expect(env.log.fatal.calls.first().args[0]).toContain('no-publish-template.js');
    })",steel
/packages/jsdoc-core/test/specs/lib/api.js,Exception Handling,"{'line': 243, 'column': 6, 'index': 7770}","it('rejects the promise and logs a fatal error if `publish` is not a function', async () => {
      spyOn(env.log, 'fatal');
      options.template = path.resolve(
        path.join(__dirname, '../../fixtures/templates/bad-publish-template.js')
      );

      try {
        await instance.generateDocs();

        // We shouldn't get here.
        expect(false).toBeTrue();
      } catch (e) {
        expect(e.message).toContain('bad-publish-template.js');
      }

      expect(env.log.fatal).toHaveBeenCalled();
      expect(env.log.fatal.calls.first().args[0]).toContain('bad-publish-template.js');
    })",steel
/packages/jsdoc-core/test/specs/lib/api.js,Redundant Assertion,"{'column': 8, 'line': 209}","it('rejects the promise and logs a fatal error if the template cannot be found', async () => {
      spyOn(env.log, 'fatal');
      options.template = 'fleeble';

      try {
        await instance.generateDocs();

        // We shouldn't get here.
        expect(false).toBeTrue();
      } catch (e) {
        expect(e.message).toContain('fleeble');
      }

      expect(env.log.fatal).toHaveBeenCalled();
      expect(env.log.fatal.calls.first().args[0]).toContain('fleeble');
    })",steel
/packages/jsdoc-core/test/specs/lib/api.js,Redundant Assertion,"{'column': 8, 'line': 228}","it('rejects the promise and logs a fatal error if `publish` is undefined', async () => {
      spyOn(env.log, 'fatal');
      options.template = path.resolve(
        path.join(__dirname, '../../fixtures/templates/no-publish-template.js')
      );

      try {
        await instance.generateDocs();

        // We shouldn't get here.
        expect(false).toBeTrue();
      } catch (e) {
        expect(e.message).toContain('no-publish-template.js');
      }

      expect(env.log.fatal).toHaveBeenCalled();
      expect(env.log.fatal.calls.first().args[0]).toContain('no-publish-template.js');
    })",steel
/packages/jsdoc-core/test/specs/lib/api.js,Redundant Assertion,"{'column': 8, 'line': 247}","it('rejects the promise and logs a fatal error if `publish` is not a function', async () => {
      spyOn(env.log, 'fatal');
      options.template = path.resolve(
        path.join(__dirname, '../../fixtures/templates/bad-publish-template.js')
      );

      try {
        await instance.generateDocs();

        // We shouldn't get here.
        expect(false).toBeTrue();
      } catch (e) {
        expect(e.message).toContain('bad-publish-template.js');
      }

      expect(env.log.fatal).toHaveBeenCalled();
      expect(env.log.fatal.calls.first().args[0]).toContain('bad-publish-template.js');
    })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Conditional Test Logic,"{'line': 33, 'column': 41, 'index': 1005}","beforeEach(() => {
      emitter = new EventEmitter();
      logger = new Logger({ emitter });

      ['debug', 'error', 'info', 'warn'].forEach((func) => spyOn(console, func));
    })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 86, 'column': 15, 'index': 2432}","it('passes all event arguments through', () => {
        const args = ['My name is %s %s %s', 'foo', 'bar', 'baz'];
        const eventType = 'logger:info';

        logger.level = LEVELS.VERBOSE;
        emitter.emit(eventType, ...args);

        expect(console.info).toHaveBeenCalledWith(...args);
      })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 92, 'column': 15, 'index': 2598}","it('logs logger:fatal events by default', () => {
        emitter.emit('logger:fatal');

        expect(console.error).toHaveBeenCalled();
      })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 99, 'column': 15, 'index': 2810}","it('does not log logger:fatal events when level is SILENT', () => {
        logger.level = LEVELS.SILENT;
        emitter.emit('logger:fatal');

        expect(console.error).not.toHaveBeenCalled();
      })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 105, 'column': 15, 'index': 2970}","it('logs logger:error events by default', () => {
        emitter.emit('logger:error');

        expect(console.error).toHaveBeenCalled();
      })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 112, 'column': 15, 'index': 3180}","it('does not log logger:error events when level is FATAL', () => {
        logger.level = LEVELS.FATAL;
        emitter.emit('logger:error');

        expect(console.error).not.toHaveBeenCalled();
      })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 118, 'column': 15, 'index': 3338}","it('logs logger:warn events by default', () => {
        emitter.emit('logger:warn');

        expect(console.warn).toHaveBeenCalled();
      })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 125, 'column': 15, 'index': 3545}","it('does not log logger:warn events when level is ERROR', () => {
        logger.level = LEVELS.ERROR;
        emitter.emit('logger:warn');

        expect(console.warn).not.toHaveBeenCalled();
      })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 131, 'column': 15, 'index': 3710}","it('does not log logger:info events by default', () => {
        emitter.emit('logger:info');

        expect(console.info).not.toHaveBeenCalled();
      })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 138, 'column': 15, 'index': 3911}","it('logs logger:info events when level is INFO', () => {
        logger.level = LEVELS.INFO;
        emitter.emit('logger:info');

        expect(console.info).toHaveBeenCalled();
      })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 144, 'column': 15, 'index': 4074}","it('does not log logger:debug events by default', () => {
        emitter.emit('logger:debug');

        expect(console.debug).not.toHaveBeenCalled();
      })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 151, 'column': 15, 'index': 4280}","it('logs logger:debug events when level is DEBUG', () => {
        logger.level = LEVELS.DEBUG;
        emitter.emit('logger:debug');

        expect(console.debug).toHaveBeenCalled();
      })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 157, 'column': 15, 'index': 4448}","it('does not log logger:verbose events by default', () => {
        emitter.emit('logger:verbose');

        expect(console.debug).not.toHaveBeenCalled();
      })",steel
/packages/jsdoc-cli/test/specs/lib/logger.js,Redundant Print,"{'line': 164, 'column': 15, 'index': 4662}","it('logs logger:verbose events when level is VERBOSE', () => {
        logger.level = LEVELS.VERBOSE;
        emitter.emit('logger:verbose');

        expect(console.debug).toHaveBeenCalled();
      })",steel
/packages/jsdoc-cli/test/specs/lib/flags.js,Conditional Test Logic,"{'line': 24, 'column': 2, 'index': 726}",Unknown,steel
/packages/jsdoc-cli/test/specs/lib/flags.js,Conditional Test Logic,"{'line': 28, 'column': 2, 'index': 821}",Unknown,steel
/packages/jsdoc-cli/test/specs/lib/flags.js,Conditional Test Logic,"{'line': 32, 'column': 2, 'index': 941}",Unknown,steel
/packages/jsdoc-cli/test/specs/lib/flags.js,Conditional Test Logic,"{'line': 42, 'column': 2, 'index': 1225}",Unknown,steel
/packages/jsdoc-cli/test/specs/lib/flags.js,Conditional Test Logic,"{'line': 54, 'column': 6, 'index': 1555}","it('has reasonable settings for each flag', () => {
      for (let flag of Object.keys(flags)) {
        expect(() => validate(flag, flags[flag])).not.toThrow();
      }
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Conditional Test Logic,"{'line': 228, 'column': 6, 'index': 6589}","afterEach(() => {
      if (docletStore) {
        docletStore.stopListening();
      }
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Conditional Test Logic,"{'line': 405, 'column': 6, 'index': 11869}","it('honors a reasonable maxLength option', () => {
      const max = 70;
      const help = instance.help({ maxLength: max }).split('\n');

      for (let line of help) {
        expect(line.length).toBeLessThanOrEqualTo(max);
      }
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Duplicate Assert,"{'line': 571, 'column': 6, 'index': 16497}","it('prints the version number, then the help text', () => {
      const instance = new Engine({ version: '1.2.3' });

      instance.printHelp();

      expect(console.log.calls.argsFor(0)[0]).toContain('JSDoc 1.2.3');
      expect(console.log.calls.argsFor(1)[0]).not.toContain('JSDoc 1.2.3');
      expect(console.log.calls.argsFor(1)[0]).toContain('-v, --version');
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Duplicate Assert,"{'line': 572, 'column': 6, 'index': 16573}","it('prints the version number, then the help text', () => {
      const instance = new Engine({ version: '1.2.3' });

      instance.printHelp();

      expect(console.log.calls.argsFor(0)[0]).toContain('JSDoc 1.2.3');
      expect(console.log.calls.argsFor(1)[0]).not.toContain('JSDoc 1.2.3');
      expect(console.log.calls.argsFor(1)[0]).toContain('-v, --version');
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Exception Handling,"{'line': 439, 'column': 6, 'index': 12805}","it('exits if the command-line flags cannot be parsed', async () => {
      instance.env.args = ['--not-a-real-flag'];

      spyOn(instance, 'exit');
      try {
        await instance.loadConfig();

        // We shouldn't get here.
        expect(false).toBeTrue();
      } catch (e) {
        // Expected exit code.
        expect(instance.exit.calls.argsFor(0)[0]).toBe(1);
        // Expected error message.
        expect(instance.exit.calls.argsFor(0)[1]).toContain(
          'Unknown command-line option: --not-a-real-flag'
        );
      }
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Exception Handling,"{'line': 514, 'column': 6, 'index': 14951}","it('includes the long and short name in the error if a value is invalid', () => {
      let error;

      try {
        new Engine().parseFlags(['--access', 'just-this-once']);
      } catch (e) {
        error = e;
      }

      expect(error.message).toContain('-a/--access');
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Exception Handling,"{'line': 526, 'column': 6, 'index': 15238}","it('includes the allowed values in the error if a value is invalid', () => {
      let error;

      try {
        new Engine().parseFlags(['--access', 'maybe-later']);
      } catch (e) {
        error = e;
      }

      expect(error.message).toContain(flags.access.choices.join(', '));
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Magic Number,"{'line': 238, 'column': 42, 'index': 6924}","it('only dumps visible doclets by default', async () => {
      docletStore = await api.parseSourceFiles([sourceFile]);
      instance.dumpParseResults(docletStore);
      reparsedDoclets = JSON.parse(jsonDoclets);

      expect(reparsedDoclets.length).toBe(1);
      expect(reparsedDoclets[0].kind).toBe('class');
      expect(reparsedDoclets[0].name).toBe('NiceClass');
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Magic Number,"{'line': 249, 'column': 42, 'index': 7383}","it('dumps all doclets when the `debug` option is set', async () => {
      env.opts.debug = true;
      docletStore = await api.parseSourceFiles([sourceFile]);
      instance.dumpParseResults(docletStore);
      reparsedDoclets = JSON.parse(jsonDoclets).filter((d) => d.kind === 'class');

      expect(reparsedDoclets.length).toBe(2);
      expect(reparsedDoclets[0].name).toBe('NiceClass');
      expect(reparsedDoclets[1].name).toBe('NotSoNiceClass');
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Magic Number,"{'line': 260, 'column': 42, 'index': 7855}","it('dumps all doclets when the `verbose` option is set', async () => {
      env.opts.verbose = true;
      docletStore = await api.parseSourceFiles([sourceFile]);
      instance.dumpParseResults(docletStore);
      reparsedDoclets = JSON.parse(jsonDoclets).filter((d) => d.kind === 'class');

      expect(reparsedDoclets.length).toBe(2);
      expect(reparsedDoclets[0].name).toBe('NiceClass');
      expect(reparsedDoclets[1].name).toBe('NotSoNiceClass');
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Magic Number,"{'line': 446, 'column': 55, 'index': 13023}","it('exits if the command-line flags cannot be parsed', async () => {
      instance.env.args = ['--not-a-real-flag'];

      spyOn(instance, 'exit');
      try {
        await instance.loadConfig();

        // We shouldn't get here.
        expect(false).toBeTrue();
      } catch (e) {
        // Expected exit code.
        expect(instance.exit.calls.argsFor(0)[0]).toBe(1);
        // Expected error message.
        expect(instance.exit.calls.argsFor(0)[1]).toContain(
          'Unknown command-line option: --not-a-real-flag'
        );
      }
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Magic Number,"{'line': 562, 'column': 31, 'index': 16255}","it('returns a promise that resolves to 0', async () => {
      const instance = new Engine({ version: '1.2.3' });
      const returnValue = await instance.printHelp();

      expect(returnValue).toBe(0);
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Magic Number,"{'line': 585, 'column': 31, 'index': 16959}","it('returns a promise that resolves to 0', async () => {
      const instance = new Engine({ version: '1.2.3' });
      const returnValue = await instance.printVersion();

      expect(returnValue).toBe(0);
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Redundant Assertion,"{'column': 8, 'line': 443}","it('exits if the command-line flags cannot be parsed', async () => {
      instance.env.args = ['--not-a-real-flag'];

      spyOn(instance, 'exit');
      try {
        await instance.loadConfig();

        // We shouldn't get here.
        expect(false).toBeTrue();
      } catch (e) {
        // Expected exit code.
        expect(instance.exit.calls.argsFor(0)[0]).toBe(1);
        // Expected error message.
        expect(instance.exit.calls.argsFor(0)[1]).toContain(
          'Unknown command-line option: --not-a-real-flag'
        );
      }
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Redundant Print,"{'line': 345, 'column': 13, 'index': 10161}","it('logs a message if no source files are found', async () => {
      env.sourceFiles = [];
      spyOn(console, 'log');
      await instance.generate();

      expect(api.findSourceFiles).toHaveBeenCalled();
      expect(console.log).toHaveBeenCalled();
      expect(api.parseSourceFiles).not.toHaveBeenCalled();
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Redundant Print,"{'line': 570, 'column': 13, 'index': 16432}","it('prints the version number, then the help text', () => {
      const instance = new Engine({ version: '1.2.3' });

      instance.printHelp();

      expect(console.log.calls.argsFor(0)[0]).toContain('JSDoc 1.2.3');
      expect(console.log.calls.argsFor(1)[0]).not.toContain('JSDoc 1.2.3');
      expect(console.log.calls.argsFor(1)[0]).toContain('-v, --version');
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Redundant Print,"{'line': 571, 'column': 13, 'index': 16504}","it('prints the version number, then the help text', () => {
      const instance = new Engine({ version: '1.2.3' });

      instance.printHelp();

      expect(console.log.calls.argsFor(0)[0]).toContain('JSDoc 1.2.3');
      expect(console.log.calls.argsFor(1)[0]).not.toContain('JSDoc 1.2.3');
      expect(console.log.calls.argsFor(1)[0]).toContain('-v, --version');
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Redundant Print,"{'line': 572, 'column': 13, 'index': 16580}","it('prints the version number, then the help text', () => {
      const instance = new Engine({ version: '1.2.3' });

      instance.printHelp();

      expect(console.log.calls.argsFor(0)[0]).toContain('JSDoc 1.2.3');
      expect(console.log.calls.argsFor(1)[0]).not.toContain('JSDoc 1.2.3');
      expect(console.log.calls.argsFor(1)[0]).toContain('-v, --version');
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Redundant Print,"{'line': 593, 'column': 13, 'index': 17119}","it('prints the version number', () => {
      const instance = new Engine({ version: '1.2.3' });

      instance.printVersion();

      expect(console.log).toHaveBeenCalledOnceWith('JSDoc 1.2.3');
    })",steel
/packages/jsdoc-cli/test/specs/lib/engine.js,Redundant Print,"{'line': 602, 'column': 13, 'index': 17394}","it('prints the revision if present', () => {
      const date = new Date(1700000000000);
      const instance = new Engine({ version: '1.2.3', revision: date });

      instance.printVersion();

      expect(console.log).toHaveBeenCalledOnceWith('JSDoc 1.2.3 (Tue, 14 Nov 2023 22:13:20 GMT)');
    })",steel
/packages/jsdoc-ast/test/specs/lib/syntax.js,Conditional Test Logic,"{'line': 24, 'column': 4, 'index': 798}","it('has values identical to their keys', () => {
    for (const key of Object.keys(Syntax)) {
      expect(key).toBe(Syntax[key]);
    }
  })",steel
/packages/jsdoc-ast/test/specs/lib/ast-node.js,Lazy Test,"{'line': 199, 'column': 13, 'index': 7594}","it('returns `null` if the module type cannot be inferred from the node', () => {
      expect(detectModuleType(identifier)).toBeNull();
    })",steel
/packages/jsdoc-ast/test/specs/lib/ast-node.js,Lazy Test,"{'line': 203, 'column': 13, 'index': 7716}","it('detects AMD modules that use `define()`', () => {
      expect(detectModuleType(amdDefine)).toBe(MODULE_TYPES.AMD);
    })",steel
/packages/jsdoc-ast/test/specs/lib/ast-node.js,Lazy Test,"{'line': 207, 'column': 13, 'index': 7836}","it('detects AMD driver scripts', () => {
      expect(detectModuleType(amdDriverScript)).toBe(MODULE_TYPES.AMD);
    })",steel
/packages/jsdoc-ast/test/specs/lib/ast-node.js,Lazy Test,"{'line': 211, 'column': 13, 'index': 7985}","it('detects CommonJS modules that assign to `exports`', () => {
      expect(detectModuleType(commonJsExports)).toBe(MODULE_TYPES.COMMON_JS);
    })",steel
/packages/jsdoc-ast/test/specs/lib/ast-node.js,Lazy Test,"{'line': 215, 'column': 13, 'index': 8137}","it('detects CommonJS modules that call `require()`', () => {
      expect(detectModuleType(commonJsRequire)).toBe(MODULE_TYPES.COMMON_JS);
    })",steel
/packages/jsdoc-ast/test/specs/lib/ast-node.js,Lazy Test,"{'line': 219, 'column': 13, 'index': 8280}","it('detects ES6 modules that use `export`', () => {
      expect(detectModuleType(es6Export)).toBe(MODULE_TYPES.ES6);
    })",steel
/packages/jsdoc-ast/test/specs/lib/ast-node.js,Lazy Test,"{'line': 223, 'column': 13, 'index': 8411}","it('detects ES6 modules that use `import`', () => {
      expect(detectModuleType(es6Import)).toBe(MODULE_TYPES.ES6);
    })",steel
/packages/jsdoc-ast/test/specs/lib/ast-node.js,Magic Number,"{'line': 243, 'column': 35, 'index': 8966}","it('should return the correct info for an AssignmentExpression', () => {
      const info = astNode.getInfo(assignmentExpression);

      expect(info).toBeObject();

      expect(info.node).toBeObject();
      expect(info.node.type).toBe(Syntax.Literal);
      expect(info.node.value).toBe(1);

      expect(info.name).toBe('foo');
      expect(info.type).toBe(Syntax.Literal);
      expect(info.value).toBe(1);
    })",steel
/packages/jsdoc-ast/test/specs/lib/ast-node.js,Magic Number,"{'line': 247, 'column': 30, 'index': 9084}","it('should return the correct info for an AssignmentExpression', () => {
      const info = astNode.getInfo(assignmentExpression);

      expect(info).toBeObject();

      expect(info.node).toBeObject();
      expect(info.node.type).toBe(Syntax.Literal);
      expect(info.node.value).toBe(1);

      expect(info.name).toBe('foo');
      expect(info.type).toBe(Syntax.Literal);
      expect(info.value).toBe(1);
    })",steel
/packages/jsdoc-ast/test/specs/lib/ast-node.js,Magic Number,"{'line': 344, 'column': 30, 'index': 12090}","it('should return the correct info for a VariableDeclarator with a value', () => {
      const info = astNode.getInfo(variableDeclarator1);

      expect(info).toBeObject();

      expect(info.node).toBeObject();
      expect(info.node.type).toBe(Syntax.Literal);

      expect(info.name).toBe('foo');
      expect(info.type).toBe(Syntax.Literal);
      expect(info.value).toBe(1);
    })",steel
/packages/jsdoc-ast/test/specs/lib/ast-node.js,Magic Number,"{'line': 532, 'column': 48, 'index': 18188}","it('should return the literal value for literals', () => {
      expect(astNode.nodeToValue(literal)).toBe(1);
    })",steel
/packages/jsdoc/test/specs/validate.js,Conditional Test Logic,"{'line': 42, 'column': 6, 'index': 1265}","it('finds no validation errors in the JSDoc parse results', () => {
    jsdoc.getParseResults().forEach((doclets) => {
      const isValid = validate(doclets.doclets);

      // Hack to get the filename/errors in the test results.
      if (!isValid) {
        expect(doclets.filename).toBe('');
        expect(validate.errors).toBeEmptyArray();
      } else {
        expect(validate.errors).toBeNull();
      }
    });
  })",steel
/packages/jsdoc/test/specs/validate.js,Duplicate Assert,"{'line': 44, 'column': 8, 'index': 1332}","it('finds no validation errors in the JSDoc parse results', () => {
    jsdoc.getParseResults().forEach((doclets) => {
      const isValid = validate(doclets.doclets);

      // Hack to get the filename/errors in the test results.
      if (!isValid) {
        expect(doclets.filename).toBe('');
        expect(validate.errors).toBeEmptyArray();
      } else {
        expect(validate.errors).toBeNull();
      }
    });
  })",steel
/packages/jsdoc/test/specs/validate.js,Duplicate Assert,"{'line': 46, 'column': 8, 'index': 1397}","it('finds no validation errors in the JSDoc parse results', () => {
    jsdoc.getParseResults().forEach((doclets) => {
      const isValid = validate(doclets.doclets);

      // Hack to get the filename/errors in the test results.
      if (!isValid) {
        expect(doclets.filename).toBe('');
        expect(validate.errors).toBeEmptyArray();
      } else {
        expect(validate.errors).toBeNull();
      }
    });
  })",steel
/packages/jsdoc/test/specs/tags/todotag.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 802}","it(""adds the entries into a 'todo' array on the doclet"", () => {
    expect(doc.todo).toBeArrayOfSize(2);
    expect(doc.todo).toContain('something');
    expect(doc.todo).toContain('something else');
  })",steel
/packages/jsdoc/test/specs/tags/todotag.js,Duplicate Assert,"{'line': 22, 'column': 4, 'index': 843}","it(""adds the entries into a 'todo' array on the doclet"", () => {
    expect(doc.todo).toBeArrayOfSize(2);
    expect(doc.todo).toContain('something');
    expect(doc.todo).toContain('something else');
  })",steel
/packages/jsdoc/test/specs/tags/todotag.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 888}","it(""adds the entries into a 'todo' array on the doclet"", () => {
    expect(doc.todo).toBeArrayOfSize(2);
    expect(doc.todo).toContain('something');
    expect(doc.todo).toContain('something else');
  })",steel
/packages/jsdoc/test/specs/tags/propertytag.js,Magic Number,"{'line': 29, 'column': 53, 'index': 1243}","it('When a symbol has a @property tag, the property appears in the doclet.', () => {
    const docSet = jsdoc.getDocSetFromFile('test/fixtures/propertytag.js');
    const myobject = docSet.getByLongname('myobject')[0];

    expect(myobject.properties).toBeArrayOfSize(4);

    expect(myobject.properties[0].name).toBe('id');
    expect(myobject.properties[1].name).toBe('defaults');
    expect(myobject.properties[2].name).toBe('defaults.a');
    expect(myobject.properties[3].name).toBe('defaults.b');

    expect(myobject.properties[0].defaultvalue).toBe('abc123');
    expect(myobject.properties[2].defaultvalue).toBe(1);

    expect(myobject.properties[1].description).toBe('The default values.');
    expect(myobject.properties[1].type.names[0]).toBe('Object');
  })",steel
/packages/jsdoc/test/specs/tags/mixestag.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 1110}","it('When a symbol has more than one @mixes tag, all of the mixins are added', () => {
    expect(MyClass.mixes).toBeArrayOfSize(2);
    expect(MyClass.mixes).toContain('Eventful');
    expect(MyClass.mixes).toContain('AnotherMixin');
  })",steel
/packages/jsdoc/test/specs/tags/mixestag.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 1156}","it('When a symbol has more than one @mixes tag, all of the mixins are added', () => {
    expect(MyClass.mixes).toBeArrayOfSize(2);
    expect(MyClass.mixes).toContain('Eventful');
    expect(MyClass.mixes).toContain('AnotherMixin');
  })",steel
/packages/jsdoc/test/specs/tags/mixestag.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 1205}","it('When a symbol has more than one @mixes tag, all of the mixins are added', () => {
    expect(MyClass.mixes).toBeArrayOfSize(2);
    expect(MyClass.mixes).toContain('Eventful');
    expect(MyClass.mixes).toContain('AnotherMixin');
  })",steel
/packages/jsdoc/test/specs/tags/listenstag.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 901}","it(""should create a 'listens' property on the doclet, an array, with the events that are listened to (with event namespace)"", () => {
    expect(doc.listens).toBeArray();
    expect(doc.listens).toContain('module:myModule.event:MyEvent');
    expect(doc.listens).toContain('module:myModule~Events.event:Event2');
  })",steel
/packages/jsdoc/test/specs/tags/listenstag.js,Duplicate Assert,"{'line': 22, 'column': 4, 'index': 938}","it(""should create a 'listens' property on the doclet, an array, with the events that are listened to (with event namespace)"", () => {
    expect(doc.listens).toBeArray();
    expect(doc.listens).toContain('module:myModule.event:MyEvent');
    expect(doc.listens).toContain('module:myModule~Events.event:Event2');
  })",steel
/packages/jsdoc/test/specs/tags/listenstag.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 1006}","it(""should create a 'listens' property on the doclet, an array, with the events that are listened to (with event namespace)"", () => {
    expect(doc.listens).toBeArray();
    expect(doc.listens).toContain('module:myModule.event:MyEvent');
    expect(doc.listens).toContain('module:myModule~Events.event:Event2');
  })",steel
/packages/jsdoc/test/specs/tags/listenstag.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 1160}","it('includes events that do not have their own documentation', () => {
    expect(doc.listens).toBeArrayOfSize(3);
    expect(doc.listens).toContain('event:fakeEvent');
  })",steel
/packages/jsdoc/test/specs/tags/listenstag.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 1204}","it('includes events that do not have their own documentation', () => {
    expect(doc.listens).toBeArrayOfSize(3);
    expect(doc.listens).toContain('event:fakeEvent');
  })",steel
/packages/jsdoc/test/specs/tags/exampletag.js,Duplicate Assert,"{'line': 24, 'column': 4, 'index': 1014}","it(""creates an 'examples' property on the doclet with the example"", () => {
    expect(doc.examples).toBeArrayOfSize(1);
    expect(doc.examples).toMatch(txtRegExp);
  })",steel
/packages/jsdoc/test/specs/tags/exampletag.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 1059}","it(""creates an 'examples' property on the doclet with the example"", () => {
    expect(doc.examples).toBeArrayOfSize(1);
    expect(doc.examples).toMatch(txtRegExp);
  })",steel
/packages/jsdoc/test/specs/tags/exampletag.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 1173}","it('can be specified multiple times on one doclet', () => {
    expect(doc2.examples).toBeArrayOfSize(2);
    expect(doc2.examples).toMatch(txtRegExp);
    expect(doc2.examples).toMatch(txt2RegExp);
  })",steel
/packages/jsdoc/test/specs/tags/exampletag.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 1219}","it('can be specified multiple times on one doclet', () => {
    expect(doc2.examples).toBeArrayOfSize(2);
    expect(doc2.examples).toMatch(txtRegExp);
    expect(doc2.examples).toMatch(txt2RegExp);
  })",steel
/packages/jsdoc/test/specs/tags/exampletag.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 1265}","it('can be specified multiple times on one doclet', () => {
    expect(doc2.examples).toBeArrayOfSize(2);
    expect(doc2.examples).toMatch(txtRegExp);
    expect(doc2.examples).toMatch(txt2RegExp);
  })",steel
/packages/jsdoc/test/specs/tags/defaulttag.js,Magic Number,"{'line': 34, 'column': 36, 'index': 1396}","it(""When symbol set to a number has a @default tag with no text, the doclet's defaultValue property should be that number."", () => {
    const rcode = docSet.getByLongname('rcode')[0];

    expect(rcode.defaultvalue).toBe(200);
  })",steel
/packages/jsdoc/test/specs/tags/authortag.js,Duplicate Assert,"{'line': 27, 'column': 4, 'index': 1139}","it('When a symbol has multiple @author tags, the doclet has a author property, an array with those values.', () => {
    expect(Thingy2.author).toBeArray();
    expect(Thingy2.author).toContain('Jane Doe <jane.doe@gmail.com>');
    expect(Thingy2.author).toContain('John Doe <john.doe@gmail.com>');
  })",steel
/packages/jsdoc/test/specs/tags/authortag.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 1179}","it('When a symbol has multiple @author tags, the doclet has a author property, an array with those values.', () => {
    expect(Thingy2.author).toBeArray();
    expect(Thingy2.author).toContain('Jane Doe <jane.doe@gmail.com>');
    expect(Thingy2.author).toContain('John Doe <john.doe@gmail.com>');
  })",steel
/packages/jsdoc/test/specs/tags/authortag.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 1250}","it('When a symbol has multiple @author tags, the doclet has a author property, an array with those values.', () => {
    expect(Thingy2.author).toBeArray();
    expect(Thingy2.author).toContain('Jane Doe <jane.doe@gmail.com>');
    expect(Thingy2.author).toContain('John Doe <john.doe@gmail.com>');
  })",steel
/packages/jsdoc/test/specs/documentation/typetaginline.js,Conditional Test Logic,"{'line': 27, 'column': 6, 'index': 1034}","describe('@type tag inline with function parameters', () => {
  const docSet = jsdoc.getDocSetFromFile('test/fixtures/typetaginline.js');
  let info;

  function checkParams({ params }, paramInfo) {
    expect(params).toBeDefined();
    expect(params.length).toBe(paramInfo.length);

    params.forEach(({ name, type, description }, i) => {
      expect(name).toBe(paramInfo[i].name);
      expect(type.names[0]).toBe(paramInfo[i].typeName);
      if (paramInfo[i].description !== undefined) {
        expect(description).toBe(paramInfo[i].description);
      }
    });
  }

  beforeEach(() => {
    info = [];
  });

  it('When a function parameter has an inline @type tag, the parameter type is documented', () => {
    const dispense = docSet.getByLongname('dispense')[0];

    info[0] = {
      name: 'candy',
      typeName: 'string',
    };

    checkParams(dispense, info);
  });

  it(
    'When a function parameter has a standard JSDoc comment and an inline @type tag, the docs ' +
      'reflect the standard JSDoc comment',
    () => {
      const Dispenser = docSet.getByLongname('Dispenser')[0];

      info[0] = {
        name: 'candyId',
        typeName: 'number',
        description: ""The candy's identifier."",
      };

      checkParams(Dispenser, info);
    }
  );

  it(
    'When a function accepts multiple parameters, and only the first parameter is documented ' +
      'with an inline @type tag, the function parameters are documented in the correct order',
    () => {
      const restock = docSet.getByLongname('restock')[0];

      info[0] = {
        name: 'dispenser',
        typeName: 'Dispenser',
      };
      info[1] = {
        name: 'item',
        typeName: 'string',
      };

      checkParams(restock, info);
    }
  );

  it(
    'When a function accepts multiple parameters, and only the last parameter is documented ' +
      'with an inline @type tag, the function parameters are documented in the correct order',
    () => {
      const clean = docSet.getByLongname('clean')[0];

      info[0] = {
        name: 'dispenser',
        typeName: 'Dispenser',
      };
      info[1] = {
        name: 'cleaner',
        typeName: 'string',
      };

      checkParams(clean, info);
    }
  );

  it(
    'When a function accepts multiple parameters, and a parameter in the middle is documented ' +
      'with an inline @type tag, the function parameters are documented in the correct order',
    () => {
      const paint = docSet.getByLongname('paint')[0];

      info[0] = {
        name: 'dispenser',
        typeName: 'Dispenser',
      };
      info[1] = {
        name: 'color',
        typeName: 'Color',
      };
      info[2] = {
        name: 'shade',
        typeName: 'number',
      };
      info[3] = {
        name: 'brand',
        typeName: 'string',
      };

      checkParams(paint, info);
    }
  );
})",steel
/packages/jsdoc/test/specs/documentation/typetaginline.js,Unknown Test,"{'column': 2, 'line': 37}","it('When a function parameter has an inline @type tag, the parameter type is documented', () => {
    const dispense = docSet.getByLongname('dispense')[0];

    info[0] = {
      name: 'candy',
      typeName: 'string',
    };

    checkParams(dispense, info);
  })",steel
/packages/jsdoc/test/specs/documentation/modules.js,Conditional Test Logic,"{'line': 51, 'column': 2, 'index': 1504}","describe('module names', () => {
  let doclets;
  const env = jsdoc.env;
  let srcParser = null;

  beforeEach(() => {
    env.opts._ = [path.resolve(__dirname, '../../fixtures/modules/data')];
    env.sourceFiles = [];
    srcParser = jsdoc.createParser();
    handlers.attachTo(srcParser);
  });

  afterEach(() => {
    srcParser._stopListening();
  });

  it('should create a name from the file path when no documented module name exists', () => {
    const filename = path.resolve(__dirname, '../../fixtures/modules/data/mod-1.js');

    env.sourceFiles.push(filename);
    doclets = Array.from(srcParser.parse(filename).doclets);

    expect(doclets[0].longname).toBe('module:mod-1');
  });

  // Windows-specific test
  if (/^win/.test(os.platform())) {
    it('should always use forward slashes when creating a name from the file path', () => {
      let doclet;

      env.sourceFiles = [
        'C:\\Users\\Jane Smith\\myproject\\index.js',
        'C:\\Users\\Jane Smith\\myproject\\lib\\mymodule.js',
      ];
      env.opts._ = [];

      doclet = new Doclet(
        '/** @module */',
        {
          lineno: 1,
          filename: 'C:\\Users\\Jane Smith\\myproject\\lib\\mymodule.js',
        },
        jsdoc.env
      );

      expect(doclet.name).toBe('lib/mymodule');
    });
  }

  it('should use the documented module name if available', () => {
    const filename = path.resolve(__dirname, '../../fixtures/modules/data/mod-2.js');

    env.sourceFiles.push(filename);
    doclets = Array.from(srcParser.parse(filename).doclets);

    expect(doclets[0].longname).toBe('module:my/module/name');
  });
})",steel
/packages/jsdoc/test/specs/documentation/defaultparams.js,Magic Number,"{'line': 59, 'column': 53, 'index': 2427}","it('should work with numeric literals', () => {
    expect(setBirthYear.params[0].defaultvalue).toBe(3000);
  })",steel
/packages/jsdoc/test/specs/documentation/classwithoutname.js,Magic Number,"{'line': 23, 'column': 31, 'index': 923}","it('When the doclet for a class has an empty name, it should also have an empty longname', () => {
    expect(docSet).toBeArray();
    expect(docSet.length).toBe(1);
    expect(docSet[0].description).toBe('Create an instance of MyClass.');
    expect(docSet[0].longname).toBe('');
  })",steel
/packages/jsdoc/test/specs/documentation/callback.js,Unknown Test,"{'column': 2, 'line': 29}","it('correctly handles callbacks that do not define a {type}', () => {
    const callback = docSet.getByLongname('requestResponseCallback')[0];

    callbackTests(callback);
  })",steel
/packages/jsdoc/test/specs/documentation/callback.js,Unknown Test,"{'column': 2, 'line': 35}","it('correctly handles callbacks that define an incorrect {type}', () => {
    const callback = docSet.getByLongname('wrongTypeCallback')[0];

    callbackTests(callback);
  })",steel
/packages/jsdoc/test/specs/documentation/alias.js,Magic Number,"{'line': 55, 'column': 36, 'index': 2486}","it('When a symbol is a function expression that has an alias, the symbol should get the correct longname', () => {
    const docSet = jsdoc.getDocSetFromFile('test/fixtures/alias4.js');
    const jacketClass = docSet
      .getByLongname('module:jacket')
      .filter(({ kind }) => kind === 'class');

    expect(jacketClass.length).toBe(1);
    expect(jacketClass[0].longname).toBe('module:jacket');
  })",steel
