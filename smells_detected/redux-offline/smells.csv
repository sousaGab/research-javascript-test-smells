file,type,line,method,source
/src/__tests__/send.js,NonFunctionalStatement,"{'startLine':179,'endLine':179}","beforeEach(() => {
    trackerMock = {
      registerAction: () => {},
      resolveAction: jest.fn(),
      rejectAction: jest.fn()
    }
  })",snuts
/src/__tests__/middleware.js,AnonymousTest,"{'startLine':68,'endLine':75}","test('creates middleware', () => {
  const { config, store, next, action } = setup();
  const middleware = createOfflineMiddleware(config);

  const result = middleware(store)(next)(action);
  expect(next).toBeCalled();
  expect(result).toEqual(next(action));
})",snuts
/src/__tests__/middleware.js,IdenticalTestDescription,"{'startLine':105,'endLine':109}","it('processes outbox when idle', () => {
    const { config, store, next } = setup();
    createOfflineMiddleware(config)(store)(next)(offlineSend());
    expect(send).toBeCalled();
  })",snuts
/src/__tests__/middleware.js,IdenticalTestDescription,"{'startLine':111,'endLine':115}","it('does not process outbox when busy', () => {
    const { config, store, next } = setup({ busy: true });
    createOfflineMiddleware(config)(store)(next)(offlineSend());
    expect(send).not.toBeCalled();
  })",snuts
/src/__tests__/index.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/src/__tests__/defaults/effect.js,GeneralFixture,"{'startLine':14,'endLine':14}","beforeAll(() => {
  globalFetch = global.fetch;
})",snuts
/src/__tests__/send.js,Duplicate Assert,"{'line': 45, 'column': 4, 'index': 1236}","test('dispatches busy action', () => {
  const { action, config, dispatch } = setup();
  const promise = send(action, dispatch, config);

  expect.assertions(2);
  return promise.then(() => {
    expect(dispatch).toBeCalledWith(busy(true));
    expect(dispatch).toHaveBeenLastCalledWith(busy(false));
  });
})",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1285}","test('dispatches busy action', () => {
  const { action, config, dispatch } = setup();
  const promise = send(action, dispatch, config);

  expect.assertions(2);
  return promise.then(() => {
    expect(dispatch).toBeCalledWith(busy(true));
    expect(dispatch).toHaveBeenLastCalledWith(busy(false));
  });
})",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 65, 'column': 6, 'index': 1926}","test('dispatches complete action', () => {
    const effect = () => Promise.resolve();
    const { action, config, dispatch } = setup({ effect });
    const promise = send(action, dispatch, config);

    const { commit } = action.meta.offline;
    expect.assertions(2);
    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(commit));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 66, 'column': 6, 'index': 1998}","test('dispatches complete action', () => {
    const effect = () => Promise.resolve();
    const { action, config, dispatch } = setup({ effect });
    const promise = send(action, dispatch, config);

    const { commit } = action.meta.offline;
    expect.assertions(2);
    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(commit));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 92, 'column': 6, 'index': 2833}","test('dispatches complete action on discard', () => {
    const effect = () => Promise.reject();
    const discard = () => true;
    const { action, config, dispatch } = setup({ effect, discard });
    const promise = send(action, dispatch, config);

    const { rollback } = action.meta.offline;
    expect.assertions(2);
    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(rollback));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 93, 'column': 6, 'index': 2907}","test('dispatches complete action on discard', () => {
    const effect = () => Promise.reject();
    const discard = () => true;
    const { action, config, dispatch } = setup({ effect, discard });
    const promise = send(action, dispatch, config);

    const { rollback } = action.meta.offline;
    expect.assertions(2);
    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(rollback));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 106, 'column': 6, 'index': 3386}","test('dispatches complete action with promised discard', () => {
    const effect = () => Promise.reject();
    const discard = () => Promise.resolve(true);
    const { action, config, dispatch } = setup({ effect, discard });
    const promise = send(action, dispatch, config);

    const { rollback } = action.meta.offline;
    expect.assertions(2);
    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(rollback));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 107, 'column': 6, 'index': 3460}","test('dispatches complete action with promised discard', () => {
    const effect = () => Promise.reject();
    const discard = () => Promise.resolve(true);
    const { action, config, dispatch } = setup({ effect, discard });
    const promise = send(action, dispatch, config);

    const { rollback } = action.meta.offline;
    expect.assertions(2);
    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(rollback));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 120, 'column': 6, 'index': 3945}","test('dispatches complete action when discard throw an exception', () => {
    const effect = () => Promise.reject();
    const discard = () => {throw new Error};
    const { action, config, dispatch } = setup({ effect, discard });
    const promise = send(action, dispatch, config);

    const { rollback } = action.meta.offline;
    expect.assertions(2);
    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(rollback));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 121, 'column': 6, 'index': 4019}","test('dispatches complete action when discard throw an exception', () => {
    const effect = () => Promise.reject();
    const discard = () => {throw new Error};
    const { action, config, dispatch } = setup({ effect, discard });
    const promise = send(action, dispatch, config);

    const { rollback } = action.meta.offline;
    expect.assertions(2);
    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(rollback));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 144, 'column': 6, 'index': 4557}","test('dispatches default commit action', () => {
    const effect = () => Promise.resolve();

    const action = {
      type: 'REQUEST',
      meta: {
        offline: {
          effect: { type: 'MOCK' },
        },
      },
    };

    const { config, dispatch } = setup({ effect });

    const promise = send(action, dispatch, config)

    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(defaultCommitAction));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 145, 'column': 6, 'index': 4642}","test('dispatches default commit action', () => {
    const effect = () => Promise.resolve();

    const action = {
      type: 'REQUEST',
      meta: {
        offline: {
          effect: { type: 'MOCK' },
        },
      },
    };

    const { config, dispatch } = setup({ effect });

    const promise = send(action, dispatch, config)

    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(defaultCommitAction));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 169, 'column': 6, 'index': 5234}","test('dispatches default rollback action', () => {
    const effect = () => Promise.reject();
    const discard = () => true;

    const action = {
      type: 'REQUEST',
      meta: {
        offline: {
          effect: { type: 'MOCK' },
        },
      },
    };

    const { config, dispatch } = setup({ effect, discard });

    const promise = send(action, dispatch, config)

    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(defaultRollbackAction));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
/src/__tests__/send.js,Duplicate Assert,"{'line': 170, 'column': 6, 'index': 5321}","test('dispatches default rollback action', () => {
    const effect = () => Promise.reject();
    const discard = () => true;

    const action = {
      type: 'REQUEST',
      meta: {
        offline: {
          effect: { type: 'MOCK' },
        },
      },
    };

    const { config, dispatch } = setup({ effect, discard });

    const promise = send(action, dispatch, config)

    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(defaultRollbackAction));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
/src/__tests__/send.js,Exception Handling,"{'line': 113, 'column': 27, 'index': 3695}","test('dispatches complete action when discard throw an exception', () => {
    const effect = () => Promise.reject();
    const discard = () => {throw new Error};
    const { action, config, dispatch } = setup({ effect, discard });
    const promise = send(action, dispatch, config);

    const { rollback } = action.meta.offline;
    expect.assertions(2);
    return promise.then(() => {
      expect(dispatch).toBeCalledWith(expect.objectContaining(rollback));
      expect(dispatch).toBeCalledWith(expect.objectContaining(completedMeta));
    });
  })",steel
