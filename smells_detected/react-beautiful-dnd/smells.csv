file,type,line,method,source
/test/unit/dev-warning.spec.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/cypress/integration/reorder.spec.js,OvercommentedTest,"{'startLine':11,'endLine':35}","it('should reorder within a list', () => {
    // order: 1, 2
    cy.get(getHandleSelector()).eq(0).as('first').should('contain', 'id:1');
    cy.get(getHandleSelector()).eq(1).should('contain', 'id:2');

    // reorder operation
    cy.get('@first')
      .focus()
      .trigger('keydown', { keyCode: keyCodes.space })
      // need to re-query for a clone
      .get('@first')
      .trigger('keydown', { keyCode: keyCodes.arrowDown, force: true })
      // finishing before the movement time is fine - but this looks nice
      .wait(timings.outOfTheWay * 1000)
      .trigger('keydown', { keyCode: keyCodes.space, force: true });

    // order now 2, 1
    // note: not using get aliases as they where returning incorrect results
    cy.get(getHandleSelector()).eq(0).should('contain', 'id:2');

    cy.get(getHandleSelector()).eq(1).should('contain', 'id:1');

    // element should maintain focus post drag
    cy.focused().should('contain', 'id:1');
  })",snuts
/cypress/integration/reorder-virtual.spec.js,OvercommentedTest,"{'startLine':11,'endLine':52}","it('should reorder within a list', () => {
    const movements: number = 12;

    cy.get(getHandleSelector()).first().as('item');

    cy.get('@item').invoke('attr', 'data-testid').as('item-id');

    cy.get('@item')
      .invoke('attr', 'data-index')
      .as('item-index')
      .should('equal', '0');

    // lift
    cy.get('@item')
      .focus()
      .trigger('keydown', { keyCode: keyCodes.space })
      // need to re-query for a clone
      .get('@item');

    cy.wrap(Array.from({ length: movements })).each(() => {
      cy.get('@item')
        .trigger('keydown', { keyCode: keyCodes.arrowDown, force: true })
        // finishing before the movement time is fine - but this looks nice
        // waiting longer than we should (timings.outOfTheWay * 1000) as electron is being strange
        .wait(timings.outOfTheWay * 1000 * 2);
    });

    // drop
    cy.get('@item').trigger('keydown', {
      keyCode: keyCodes.space,
      force: true,
    });

    // This is setting up a chain of commands and this test will not wait
    // for a 'promise' to resolve. Linting is getting confused by .then
    // eslint-disable-next-line jest/valid-expect-in-promise
    cy.get('@item-id').then((id) => {
      cy.get(getHandleSelector(id))
        .invoke('attr', 'data-index')
        .should('equal', `${movements}`);
    });
  })",snuts
/cypress/integration/reorder-lists.spec.js,OvercommentedTest,"{'startLine':11,'endLine':33}","it('should reorder lists', () => {
    // order: Jake, BMO
    cy.get('h4').eq(0).as('first').should('contain', 'Jake');

    cy.get('h4').eq(1).should('contain', 'BMO');

    // reorder operation
    cy.get('@first')
      .closest(getHandleSelector())
      .focus()
      .trigger('keydown', { keyCode: keyCodes.space })
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // finishing before the movement time is fine - but this looks nice
      .wait(timings.outOfTheWay * 1000)
      .trigger('keydown', { keyCode: keyCodes.space, force: true });

    // order now 2, 1
    // note: not using get aliases as they where returning incorrect results
    cy.get('h4').eq(0).should('contain', 'BMO');

    // index of the drag handle has changed
    cy.get('h4').eq(1).should('contain', 'Jake');
  })",snuts
/cypress/integration/focus.spec.js,OvercommentedTest,"{'startLine':48,'endLine':83}","it('should maintain focus if dragging a clone', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2'))
      // no longer dragging
      .should('have.attr', 'data-is-dragging', 'false')
      // is in the second column (normally would loose focus moving between lists)
      .closest(getDraggableSelector('BMO'));

    // focus maintained
    cy.focused().should('contain', 'id:2');
  })",snuts
/cypress/integration/focus.spec.js,OvercommentedTest,"{'startLine':85,'endLine':115}","it('should give focus to a combine target', () => {
    cy.visit('/iframe.html?id=board--with-combining-and-cloning');
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // combining with item:1
      .trigger('keydown', { keyCode: keyCodes.arrowUp, force: true })
      // dropping
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // focus giving to item:1 the combine target
    cy.focused().should('contain', 'id:1');
  })",snuts
/cypress/integration/focus.spec.js,OvercommentedTest,"{'startLine':117,'endLine':147}","it('should not give focus to a combine target if source did not have focus at start of drag', () => {
    cy.visit('/iframe.html?id=board--with-combining-and-cloning');
    // focusing on something unrelated to the drag
    cy.get(getHandleSelector('3')).focus();

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:3');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // combining with item:1
      .trigger('keydown', { keyCode: keyCodes.arrowUp, force: true })
      // dropping
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // focus not given to the combine target
    cy.focused().should('contain', 'id:3');
  })",snuts
/test/unit/view/use-draggable-publisher.spec.js,OvercommentedTest,"{'startLine':130,'endLine':182}","it('should update its registration when a descriptor property changes', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const updateSpy = jest.spyOn(registry.draggable, 'update');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expectedInitial: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    // asserting shape of original publish
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expectedInitial);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expectedInitial);

    expect(updateSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();

    registerSpy.mockReset();

    // updating the index
    wrapper.setProps({
      index: 1000,
    });

    // Descriptor updated
    const expectedUpdate: DraggableEntry = {
      uniqueId: entry.uniqueId,
      descriptor: {
        ...preset.inHome1.descriptor,
        index: 1000,
      },
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(updateSpy).toHaveBeenCalledTimes(1);
    // new descriptor
    expect(updateSpy.mock.calls[0][0]).toEqual(expectedUpdate);
    // late reference: same reference
    expect(updateSpy.mock.calls[0][1]).toBe(entry);

    // Nothing else changed
    expect(registerSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();
  })",snuts
/test/unit/view/use-draggable-publisher.spec.js,NonFunctionalStatement,"{'startLine':77,'endLine':77}","beforeEach(() => {
  // having issues on CI
  tryCleanPrototypeStubs();
  jest.spyOn(console, 'error').mockImplementation(() => {});
})",snuts
/test/unit/view/use-draggable-publisher.spec.js,VerboseStatement,"{'startLine':130,'endLine':182}","it('should update its registration when a descriptor property changes', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const updateSpy = jest.spyOn(registry.draggable, 'update');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expectedInitial: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    // asserting shape of original publish
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expectedInitial);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expectedInitial);

    expect(updateSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();

    registerSpy.mockReset();

    // updating the index
    wrapper.setProps({
      index: 1000,
    });

    // Descriptor updated
    const expectedUpdate: DraggableEntry = {
      uniqueId: entry.uniqueId,
      descriptor: {
        ...preset.inHome1.descriptor,
        index: 1000,
      },
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(updateSpy).toHaveBeenCalledTimes(1);
    // new descriptor
    expect(updateSpy.mock.calls[0][0]).toEqual(expectedUpdate);
    // late reference: same reference
    expect(updateSpy.mock.calls[0][1]).toBe(entry);

    // Nothing else changed
    expect(registerSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();
  })",snuts
/test/unit/health/src-file-name-convention.spec.js,ConditionalTestLogic,"{'startLine':28,'endLine':30}","it('should have every prettier target following the file name convention', async () => {
  const targets: string[] = pkg.config.prettier_target.split(' ');
  const paths: string[] = await globby(targets);

  invariant(
    paths.length,
    'Could not find files to test against file name convention',
  );

  paths.forEach((filePath: string) => {
    if (exceptions.includes(filePath)) {
      return;
    }

    const isMatching: boolean = isSnakeCase(filePath);

    invariant(
      isMatching,
      `${filePath} does not follow the file path convention (snake-case.js) ${convention.toString()}`,
    );

    expect(isMatching).toBe(true);
  });
})",snuts
/test/unit/integration/responders-timing.spec.js,OvercommentedTest,"{'startLine':42,'endLine':126}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  let onBeforeDragStartTime: ?DOMHighResTimeStamp = null;
  let onDragStartTime: ?DOMHighResTimeStamp = null;
  let renderTime: ?DOMHighResTimeStamp = null;
  const responders: Responders = {
    onBeforeDragStart: jest.fn().mockImplementation(() => {
      invariant(!onBeforeDragStartTime, 'onBeforeDragStartTime already set');
      onBeforeDragStartTime = performance.now();
    }),
    onDragStart: jest.fn().mockImplementation(() => {
      invariant(!onDragStartTime, 'onDragStartTime already set');
      onDragStartTime = performance.now();
    }),
    onDragEnd: jest.fn(),
  };
  const onItemRender = jest.fn().mockImplementation(() => {
    invariant(!renderTime, 'renderTime already set');
    renderTime = performance.now();
  });
  // Both list and item will have the same dimensions
  jest
    .spyOn(Element.prototype, 'getBoundingClientRect')
    .mockImplementation(() =>
      getRect({
        top: 0,
        left: 0,
        right: 100,
        bottom: 100,
      }),
    );

  // Stubbing out totally - not including margins in this
  jest
    .spyOn(window, 'getComputedStyle')
    .mockImplementation(() => getComputedSpacing({}));
  const { getByTestId, unmount } = render(
    <DragDropContext {...responders}>
      <Droppable droppableId=""droppable"">
        {(droppableProvided: DroppableProvided) => (
          <div
            ref={droppableProvided.innerRef}
            {...droppableProvided.droppableProps}
          >
            <h2>Droppable</h2>
            <Draggable draggableId=""draggable"" index={0}>
              {(draggableProvided: DraggableProvided) => (
                <Item onRender={onItemRender} provided={draggableProvided} />
              )}
            </Draggable>
            {droppableProvided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>,
  );

  // clearing the initial render before a drag
  expect(onItemRender).toHaveBeenCalledTimes(1);
  renderTime = null;
  onItemRender.mockClear();

  // start a drag
  const handle: HTMLElement = getByTestId('drag-handle');
  simpleLift(keyboard, handle);
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking values are set
  invariant(onBeforeDragStartTime, 'onBeforeDragStartTime should be set');
  invariant(onDragStartTime, 'onDragStartTime should be set');
  invariant(renderTime, 'renderTime should be set');

  // expected order
  // 1. onBeforeDragStart
  // 2. item render
  // 3. onDragStart
  expect(onBeforeDragStartTime).toBeLessThan(renderTime);
  expect(renderTime).toBeLessThan(onDragStartTime);

  // validation
  expect(responders.onBeforeDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(onItemRender).toHaveBeenCalledTimes(1);
  unmount();
})",snuts
/test/unit/integration/responders-timing.spec.js,VerboseStatement,"{'startLine':42,'endLine':126}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  let onBeforeDragStartTime: ?DOMHighResTimeStamp = null;
  let onDragStartTime: ?DOMHighResTimeStamp = null;
  let renderTime: ?DOMHighResTimeStamp = null;
  const responders: Responders = {
    onBeforeDragStart: jest.fn().mockImplementation(() => {
      invariant(!onBeforeDragStartTime, 'onBeforeDragStartTime already set');
      onBeforeDragStartTime = performance.now();
    }),
    onDragStart: jest.fn().mockImplementation(() => {
      invariant(!onDragStartTime, 'onDragStartTime already set');
      onDragStartTime = performance.now();
    }),
    onDragEnd: jest.fn(),
  };
  const onItemRender = jest.fn().mockImplementation(() => {
    invariant(!renderTime, 'renderTime already set');
    renderTime = performance.now();
  });
  // Both list and item will have the same dimensions
  jest
    .spyOn(Element.prototype, 'getBoundingClientRect')
    .mockImplementation(() =>
      getRect({
        top: 0,
        left: 0,
        right: 100,
        bottom: 100,
      }),
    );

  // Stubbing out totally - not including margins in this
  jest
    .spyOn(window, 'getComputedStyle')
    .mockImplementation(() => getComputedSpacing({}));
  const { getByTestId, unmount } = render(
    <DragDropContext {...responders}>
      <Droppable droppableId=""droppable"">
        {(droppableProvided: DroppableProvided) => (
          <div
            ref={droppableProvided.innerRef}
            {...droppableProvided.droppableProps}
          >
            <h2>Droppable</h2>
            <Draggable draggableId=""draggable"" index={0}>
              {(draggableProvided: DraggableProvided) => (
                <Item onRender={onItemRender} provided={draggableProvided} />
              )}
            </Draggable>
            {droppableProvided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>,
  );

  // clearing the initial render before a drag
  expect(onItemRender).toHaveBeenCalledTimes(1);
  renderTime = null;
  onItemRender.mockClear();

  // start a drag
  const handle: HTMLElement = getByTestId('drag-handle');
  simpleLift(keyboard, handle);
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking values are set
  invariant(onBeforeDragStartTime, 'onBeforeDragStartTime should be set');
  invariant(onDragStartTime, 'onDragStartTime should be set');
  invariant(renderTime, 'renderTime should be set');

  // expected order
  // 1. onBeforeDragStart
  // 2. item render
  // 3. onDragStart
  expect(onBeforeDragStartTime).toBeLessThan(renderTime);
  expect(renderTime).toBeLessThan(onDragStartTime);

  // validation
  expect(responders.onBeforeDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(onItemRender).toHaveBeenCalledTimes(1);
  unmount();
})",snuts
/test/unit/integration/responders-integration.spec.js,IdenticalTestDescription,"{'startLine':308,'endLine':320}","it('should not call onDragStart while the drag is occurring', () => {
      drag.start();

      wasDragStarted();

      drag.move();

      // should not have called on drag start again
      expect(responders.onDragStart).toHaveBeenCalledTimes(1);

      // cleanup
      drag.stop();
    })",snuts
/test/unit/integration/responders-integration.spec.js,NonFunctionalStatement,"{'startLine':107,'endLine':107}","beforeEach(() => {
    jest.useFakeTimers();
    responders = {
      onBeforeCapture: jest.fn(),
      onBeforeDragStart: jest.fn(),
      onDragStart: jest.fn(),
      onDragUpdate: jest.fn(),
      onDragEnd: jest.fn(),
    };
    wrapper = render(<App responders={responders} />);
    // unmounting during a drag can cause a warning
    jest.spyOn(console, 'warn').mockImplementation(() => {});
  })",snuts
/test/unit/integration/reorder-render-sync.spec.js,OvercommentedTest,"{'startLine':181,'endLine':233}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  jest.useFakeTimers();
  const clearRenderMocks = () => {
    first.onRender.mockClear();
    second.onRender.mockClear();
  };

  const { getAllByTestId, unmount } = render(<App />);

  // clearing the initial render before a drag
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // start a drag
  const handle: HTMLElement = getAllByTestId('drag-handle')[0];
  simpleLift(keyboard, handle);

  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // initial lift will render the first item
  expect(first.onRender).toHaveBeenCalledTimes(1);
  // it will also render the second item as it needs to be pushed down
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  fireEvent.keyDown(handle, { keyCode: keyCodes.arrowDown });
  // flushing keyboard movement
  requestAnimationFrame.step();

  // item1: moving down
  // item2: moving up
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // drop (there is no animation because already in the home spot)
  keyboard.drop(handle);

  // only a single render for the reorder and connected component update
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);

  // checking for no post renders
  clearRenderMocks();
  requestAnimationFrame.flush();
  jest.runAllTimers();
  expect(first.onRender).toHaveBeenCalledTimes(0);
  expect(second.onRender).toHaveBeenCalledTimes(0);

  unmount();
})",snuts
/test/unit/integration/reorder-render-sync.spec.js,VerboseStatement,"{'startLine':181,'endLine':233}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  jest.useFakeTimers();
  const clearRenderMocks = () => {
    first.onRender.mockClear();
    second.onRender.mockClear();
  };

  const { getAllByTestId, unmount } = render(<App />);

  // clearing the initial render before a drag
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // start a drag
  const handle: HTMLElement = getAllByTestId('drag-handle')[0];
  simpleLift(keyboard, handle);

  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // initial lift will render the first item
  expect(first.onRender).toHaveBeenCalledTimes(1);
  // it will also render the second item as it needs to be pushed down
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  fireEvent.keyDown(handle, { keyCode: keyCodes.arrowDown });
  // flushing keyboard movement
  requestAnimationFrame.step();

  // item1: moving down
  // item2: moving up
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // drop (there is no animation because already in the home spot)
  keyboard.drop(handle);

  // only a single render for the reorder and connected component update
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);

  // checking for no post renders
  clearRenderMocks();
  requestAnimationFrame.flush();
  jest.runAllTimers();
  expect(first.onRender).toHaveBeenCalledTimes(0);
  expect(second.onRender).toHaveBeenCalledTimes(0);

  unmount();
})",snuts
/test/unit/docs/content.spec.js,ConditionalTestLogic,"{'startLine':20,'endLine':25}","it('should end all nested docs with a link back to the documentation root', async () => {
  const files: string[] = await globby('docs/**/*.md');
  expect(files.length).toBeGreaterThan(0);
  const backLink: string =
    '[â† Back to documentation](/README.md#documentation-)';

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    // Printing a nice message to allow for quick fixing
    const endsWithBacklink: boolean = contents.trim().endsWith(backLink);

    if (!endsWithBacklink) {
      expect(`
        File: ""${file}""
        Did not end with back link
      `).toBe(true);
    }

    // need at least one assertion
    expect(true).toBe(true);
  }
})",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,OvercommentedTest,"{'startLine':59,'endLine':100}","it('should not fire a scroll if the value has not changed since the previous call', () => {
    // this can happen if you scroll backward and forward super quick
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

    // first event
    scroll(container, { x: 500, y: 1000 });
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1000 },
    );
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event - scroll to same spot
    scroll(container, { x: 500, y: 1000 });
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();

    // third event - new value
    scroll(container, { x: 500, y: 1001 });
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1001 },
    );
  })",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,OvercommentedTest,"{'startLine':134,'endLine':171}","it('should throttle multiple scrolls into a animation frame', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    // second event in same frame
    scroll(container, { x: 200, y: 800 });

    // release the update animation frame
    requestAnimationFrame.step();

    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 200, y: 800 },
    );

    // also checking that no loose frames are stored up
    requestAnimationFrame.flush();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
  })",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,OvercommentedTest,"{'startLine':173,'endLine':215}","it('should not fire a scroll if the value has not changed since the previous frame', () => {
    // this can happen if you scroll backward and forward super quick
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    // release the frame
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1000 },
    );
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event
    scroll(container, { x: 501, y: 1001 });
    // no frame to release change yet

    // third event - back to original value
    scroll(container, { x: 500, y: 1000 });
    // release the frame
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  })",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,OvercommentedTest,"{'startLine':217,'endLine':254}","it('should not publish a scroll update after requested not to update while an animation frame is occurring', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event
    scroll(container, { x: 400, y: 100 });
    // no animation frame to release event fired yet

    // unwatching before frame fired
    callbacks.dragStopped();

    // flushing any frames
    requestAnimationFrame.flush();
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  })",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,OvercommentedTest,"{'startLine':257,'endLine':288}","it('should stop watching scroll when no longer required to publish', () => {
  // this can happen if you scroll backward and forward super quick
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

  // first event
  scroll(container, { x: 500, y: 1000 });
  expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
  // $ExpectError
  marshal.updateDroppableScroll.mockReset();

  callbacks.dragStopped();

  // scroll event after no longer watching
  scroll(container, { x: 190, y: 400 });
  expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
})",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,OvercommentedTest,"{'startLine':290,'endLine':321}","it('should stop watching for scroll events when the component is unmounted', () => {
  jest.spyOn(console, 'warn').mockImplementation(() => {});
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

  wrapper.unmount();

  // second event - will not fire any updates
  scroll(container, { x: 100, y: 300 });
  expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  // also logs a warning
  expect(console.warn).toHaveBeenCalled();

  // cleanup
  // $ExpectError
  console.warn.mockRestore();
})",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,NonFunctionalStatement,"{'startLine':291,'endLine':291}","it('should stop watching for scroll events when the component is unmounted', () => {
  jest.spyOn(console, 'warn').mockImplementation(() => {});
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

  wrapper.unmount();

  // second event - will not fire any updates
  scroll(container, { x: 100, y: 300 });
  expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  // also logs a warning
  expect(console.warn).toHaveBeenCalled();

  // cleanup
  // $ExpectError
  console.warn.mockRestore();
})",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,VerboseStatement,"{'startLine':59,'endLine':100}","it('should not fire a scroll if the value has not changed since the previous call', () => {
    // this can happen if you scroll backward and forward super quick
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

    // first event
    scroll(container, { x: 500, y: 1000 });
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1000 },
    );
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event - scroll to same spot
    scroll(container, { x: 500, y: 1000 });
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();

    // third event - new value
    scroll(container, { x: 500, y: 1001 });
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1001 },
    );
  })",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,VerboseStatement,"{'startLine':134,'endLine':171}","it('should throttle multiple scrolls into a animation frame', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    // second event in same frame
    scroll(container, { x: 200, y: 800 });

    // release the update animation frame
    requestAnimationFrame.step();

    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 200, y: 800 },
    );

    // also checking that no loose frames are stored up
    requestAnimationFrame.flush();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
  })",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,VerboseStatement,"{'startLine':173,'endLine':215}","it('should not fire a scroll if the value has not changed since the previous frame', () => {
    // this can happen if you scroll backward and forward super quick
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    // release the frame
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1000 },
    );
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event
    scroll(container, { x: 501, y: 1001 });
    // no frame to release change yet

    // third event - back to original value
    scroll(container, { x: 500, y: 1000 });
    // release the frame
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  })",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,VerboseStatement,"{'startLine':217,'endLine':254}","it('should not publish a scroll update after requested not to update while an animation frame is occurring', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event
    scroll(container, { x: 400, y: 100 });
    // no animation frame to release event fired yet

    // unwatching before frame fired
    callbacks.dragStopped();

    // flushing any frames
    requestAnimationFrame.flush();
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  })",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,VerboseStatement,"{'startLine':257,'endLine':288}","it('should stop watching scroll when no longer required to publish', () => {
  // this can happen if you scroll backward and forward super quick
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

  // first event
  scroll(container, { x: 500, y: 1000 });
  expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
  // $ExpectError
  marshal.updateDroppableScroll.mockReset();

  callbacks.dragStopped();

  // scroll event after no longer watching
  scroll(container, { x: 190, y: 400 });
  expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
})",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,VerboseStatement,"{'startLine':290,'endLine':321}","it('should stop watching for scroll events when the component is unmounted', () => {
  jest.spyOn(console, 'warn').mockImplementation(() => {});
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

  wrapper.unmount();

  // second event - will not fire any updates
  scroll(container, { x: 100, y: 300 });
  expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  // also logs a warning
  expect(console.warn).toHaveBeenCalled();

  // cleanup
  // $ExpectError
  console.warn.mockRestore();
})",snuts
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,VerboseStatement,"{'startLine':347,'endLine':396}","it('should add and remove events with the same event options', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  jest.spyOn(container, 'addEventListener');
  jest.spyOn(container, 'removeEventListener');

  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // assertion
  const expectedOptions = {
    passive: true,
  };
  expect(container.addEventListener).toHaveBeenCalledWith(
    'scroll',
    expect.any(Function),
    expectedOptions,
  );
  expect(container.removeEventListener).not.toHaveBeenCalled();
  container.addEventListener.mockReset();

  // unwatching scroll
  callbacks.dragStopped();

  // assertion
  expect(container.removeEventListener).toHaveBeenCalledWith(
    'scroll',
    expect.any(Function),
    expectedOptions,
  );
  expect(container.removeEventListener).toHaveBeenCalledTimes(1);
  expect(container.addEventListener).not.toHaveBeenCalled();

  // cleanup
  container.addEventListener.mockRestore();
  container.removeEventListener.mockRestore();
})",snuts
/test/unit/view/use-droppable-publisher/registration.spec.js,VerboseStatement,"{'startLine':60,'endLine':109}","it('should update its registration when a descriptor property changes', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const unregisterSpy = jest.spyOn(registry.droppable, 'unregister');

  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext registry={registry}>
          <ScrollableItem {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // $ExpectError: using awesome matchers
  const expectedFirst: DroppableEntry = {
    uniqueId: expect.any(String),
    descriptor: preset.home.descriptor,
    callbacks: expect.any(Object),
  };

  // asserting shape of original publish
  const first = registerSpy.mock.calls[0][0];
  expect(first).toEqual(expectedFirst);

  registerSpy.mockClear();

  // updating the index
  wrapper.setProps({
    droppableId: 'some-new-id',
  });
  const updated: DroppableDescriptor = {
    ...preset.home.descriptor,
    id: 'some-new-id',
  };

  // old descriptor removed
  expect(unregisterSpy).toHaveBeenCalledTimes(1);
  expect(unregisterSpy).toHaveBeenCalledWith(first);

  // new descriptor added
  // $ExpectError: using awesome matchers
  const expectedSecond: DroppableEntry = {
    uniqueId: first.uniqueId,
    descriptor: updated,
    callbacks: expect.any(Object),
  };
  expect(registerSpy.mock.calls[0][0]).toEqual(expectedSecond);
})",snuts
/test/unit/view/use-droppable-publisher/recollection.spec.js,OvercommentedTest,"{'startLine':63,'endLine':102}","it('should recollect scroll if requested', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  // both the droppable and the parent are scrollable
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App droppableIsScrollable />
    </WithAppContext>,
  );
  const el: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(el);
  // returning smaller border box as this is what occurs when the element is scrollable
  jest
    .spyOn(el, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  // scrollWidth / scrollHeight are based on the paddingBox of an element
  Object.defineProperty(el, 'scrollWidth', {
    value: bigClient.paddingBox.width,
  });
  Object.defineProperty(el, 'scrollHeight', {
    value: bigClient.paddingBox.height,
  });

  // pull the get dimension function out
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // execute it to get the dimension
  const initial: DroppableDimension = callbacks.getDimensionAndWatchScroll(
    preset.windowScroll,
    immediate,
  );

  expect(initial).toEqual(expected);

  // ensuring that we have the updated scroll
  const newScroll: Position = { x: 100, y: 200 };
  callbacks.scroll(newScroll);
  const result: Position = callbacks.getScrollWhileDragging();
  expect(result).toEqual(newScroll);
})",snuts
/test/unit/view/use-droppable-publisher/recollection.spec.js,VerboseStatement,"{'startLine':63,'endLine':102}","it('should recollect scroll if requested', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  // both the droppable and the parent are scrollable
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App droppableIsScrollable />
    </WithAppContext>,
  );
  const el: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(el);
  // returning smaller border box as this is what occurs when the element is scrollable
  jest
    .spyOn(el, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  // scrollWidth / scrollHeight are based on the paddingBox of an element
  Object.defineProperty(el, 'scrollWidth', {
    value: bigClient.paddingBox.width,
  });
  Object.defineProperty(el, 'scrollHeight', {
    value: bigClient.paddingBox.height,
  });

  // pull the get dimension function out
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // execute it to get the dimension
  const initial: DroppableDimension = callbacks.getDimensionAndWatchScroll(
    preset.windowScroll,
    immediate,
  );

  expect(initial).toEqual(expected);

  // ensuring that we have the updated scroll
  const newScroll: Position = { x: 100, y: 200 };
  callbacks.scroll(newScroll);
  const result: Position = callbacks.getScrollWhileDragging();
  expect(result).toEqual(newScroll);
})",snuts
/test/unit/view/use-droppable-publisher/publishing.spec.js,OvercommentedTest,"{'startLine':170,'endLine':232}","it('should collect information about the scrollable', () => {
    // When collecting a droppable that is itself scrollable we store
    // the client: BoxModel as if it did not have a frame. This brings
    // its usage into line with elements that have a wrapping scrollable
    // element.

    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      // as expected
      borderBox: bigClient.borderBox,
      margin,
      padding,
      border,
      windowScroll: preset.windowScroll,
      closest: {
        // we are using the smallFrameClient as a stand in for the elements
        // actual borderBox which is cut off when it is a scroll container
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        // scroll width and height are based on the padding box
        scrollSize: {
          scrollWidth: bigClient.paddingBox.width,
          scrollHeight: bigClient.paddingBox.height,
        },
        scroll: { x: 0, y: 0 },
        shouldClipSubject: true,
      },
    });
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    // both the droppable and the parent are scrollable
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App droppableIsScrollable />
      </WithAppContext>,
    );
    const el: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(el);
    // returning smaller border box as this is what occurs when the element is scrollable
    jest
      .spyOn(el, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    // scrollWidth / scrollHeight are based on the paddingBox of an element
    Object.defineProperty(el, 'scrollWidth', {
      value: bigClient.paddingBox.width,
    });
    Object.defineProperty(el, 'scrollHeight', {
      value: bigClient.paddingBox.height,
    });

    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );

    expect(result).toEqual(expected);
  })",snuts
/test/unit/view/use-droppable-publisher/publishing.spec.js,OvercommentedTest,"{'startLine':234,'endLine':299}","it('should account for a change in scroll when crafting its custom borderBox', () => {
    const scroll: Position = {
      x: 10,
      y: 10,
    };
    // the displacement of a scroll is in the opposite direction to a scroll
    const displacement: Position = negate(scroll);
    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      // as expected
      borderBox: offsetByPosition(bigClient.borderBox, displacement),
      margin,
      padding,
      border,
      closest: {
        // we are using the smallFrameClient as a stand in for the elements
        // actual borderBox which is cut off when it is a scroll container
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        scrollSize: {
          scrollWidth: bigClient.paddingBox.width,
          scrollHeight: bigClient.paddingBox.height,
        },
        scroll,
        shouldClipSubject: true,
      },
      windowScroll: preset.windowScroll,
    });

    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    // both the droppable and the parent are scrollable
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App droppableIsScrollable />
      </WithAppContext>,
    );
    const el: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(el);
    // returning smaller border box as this is what occurs when the element is scrollable
    jest
      .spyOn(el, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    // scrollWidth / scrollHeight are based on the paddingBox of an element
    Object.defineProperty(el, 'scrollWidth', {
      value: bigClient.paddingBox.width,
    });
    Object.defineProperty(el, 'scrollHeight', {
      value: bigClient.paddingBox.height,
    });
    el.scrollTop = scroll.y;
    el.scrollLeft = scroll.x;

    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );

    expect(result).toEqual(expected);
  })",snuts
/test/unit/view/use-droppable-publisher/publishing.spec.js,IdenticalTestDescription,"{'startLine':303,'endLine':357}","it('should collect information about the scrollable', () => {
    const scrollSize: ScrollSize = {
      scrollHeight: bigClient.paddingBox.height,
      scrollWidth: bigClient.paddingBox.width,
    };
    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      borderBox: bigClient.borderBox,
      margin,
      padding,
      border,
      closest: {
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        scrollSize,
        scroll: { x: 0, y: 0 },
        shouldClipSubject: true,
      },
      windowScroll: preset.windowScroll,
    });
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App parentIsScrollable droppableIsScrollable={false} />
      </WithAppContext>,
    );
    const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(droppable);
    jest
      .spyOn(droppable, 'getBoundingClientRect')
      .mockImplementation(() => bigClient.borderBox);
    const parent: HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
    jest
      .spyOn(parent, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    Object.defineProperty(parent, 'scrollWidth', {
      value: scrollSize.scrollWidth,
    });
    Object.defineProperty(parent, 'scrollHeight', {
      value: scrollSize.scrollHeight,
    });
    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );

    expect(result).toEqual(expected);
  })",snuts
/test/unit/view/use-droppable-publisher/publishing.spec.js,NonFunctionalStatement,"{'startLine':362,'endLine':362}","it('should log a warning as the use case is not supported', () => {
    jest.spyOn(console, 'warn').mockImplementation(() => {});
    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      borderBox: bigClient.borderBox,
      margin,
      padding,
      border,
      closest: {
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        scrollSize: {
          scrollWidth: bigClient.paddingBox.width,
          scrollHeight: bigClient.paddingBox.height,
        },
        scroll: { x: 0, y: 0 },
        shouldClipSubject: true,
      },
      windowScroll: preset.windowScroll,
    });
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App parentIsScrollable droppableIsScrollable />,
      </WithAppContext>,
    );
    const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(droppable);
    const parent: HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
    jest
      .spyOn(droppable, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    Object.defineProperty(droppable, 'scrollWidth', {
      value: bigClient.paddingBox.width,
    });
    Object.defineProperty(droppable, 'scrollHeight', {
      value: bigClient.paddingBox.height,
    });
    // should never be called!
    jest.spyOn(parent, 'getBoundingClientRect').mockImplementation(() => {
      throw new Error(
        'Should not be getting the boundingClientRect on the parent',
      );
    });

    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    expect(console.warn).not.toHaveBeenCalled();
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );
    expect(console.warn).toHaveBeenCalled();

    expect(result).toEqual(expected);
    // $FlowFixMe
    console.warn.mockRestore();
  })",snuts
/test/unit/view/use-droppable-publisher/publishing.spec.js,VerboseStatement,"{'startLine':234,'endLine':299}","it('should account for a change in scroll when crafting its custom borderBox', () => {
    const scroll: Position = {
      x: 10,
      y: 10,
    };
    // the displacement of a scroll is in the opposite direction to a scroll
    const displacement: Position = negate(scroll);
    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      // as expected
      borderBox: offsetByPosition(bigClient.borderBox, displacement),
      margin,
      padding,
      border,
      closest: {
        // we are using the smallFrameClient as a stand in for the elements
        // actual borderBox which is cut off when it is a scroll container
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        scrollSize: {
          scrollWidth: bigClient.paddingBox.width,
          scrollHeight: bigClient.paddingBox.height,
        },
        scroll,
        shouldClipSubject: true,
      },
      windowScroll: preset.windowScroll,
    });

    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    // both the droppable and the parent are scrollable
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App droppableIsScrollable />
      </WithAppContext>,
    );
    const el: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(el);
    // returning smaller border box as this is what occurs when the element is scrollable
    jest
      .spyOn(el, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    // scrollWidth / scrollHeight are based on the paddingBox of an element
    Object.defineProperty(el, 'scrollWidth', {
      value: bigClient.paddingBox.width,
    });
    Object.defineProperty(el, 'scrollHeight', {
      value: bigClient.paddingBox.height,
    });
    el.scrollTop = scroll.y;
    el.scrollLeft = scroll.x;

    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );

    expect(result).toEqual(expected);
  })",snuts
/test/unit/view/use-droppable-publisher/publishing.spec.js,VerboseStatement,"{'startLine':303,'endLine':357}","it('should collect information about the scrollable', () => {
    const scrollSize: ScrollSize = {
      scrollHeight: bigClient.paddingBox.height,
      scrollWidth: bigClient.paddingBox.width,
    };
    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      borderBox: bigClient.borderBox,
      margin,
      padding,
      border,
      closest: {
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        scrollSize,
        scroll: { x: 0, y: 0 },
        shouldClipSubject: true,
      },
      windowScroll: preset.windowScroll,
    });
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App parentIsScrollable droppableIsScrollable={false} />
      </WithAppContext>,
    );
    const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(droppable);
    jest
      .spyOn(droppable, 'getBoundingClientRect')
      .mockImplementation(() => bigClient.borderBox);
    const parent: HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
    jest
      .spyOn(parent, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    Object.defineProperty(parent, 'scrollWidth', {
      value: scrollSize.scrollWidth,
    });
    Object.defineProperty(parent, 'scrollHeight', {
      value: scrollSize.scrollHeight,
    });
    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );

    expect(result).toEqual(expected);
  })",snuts
/test/unit/view/use-droppable-publisher/publishing.spec.js,VerboseStatement,"{'startLine':361,'endLine':423}","it('should log a warning as the use case is not supported', () => {
    jest.spyOn(console, 'warn').mockImplementation(() => {});
    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      borderBox: bigClient.borderBox,
      margin,
      padding,
      border,
      closest: {
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        scrollSize: {
          scrollWidth: bigClient.paddingBox.width,
          scrollHeight: bigClient.paddingBox.height,
        },
        scroll: { x: 0, y: 0 },
        shouldClipSubject: true,
      },
      windowScroll: preset.windowScroll,
    });
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App parentIsScrollable droppableIsScrollable />,
      </WithAppContext>,
    );
    const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(droppable);
    const parent: HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
    jest
      .spyOn(droppable, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    Object.defineProperty(droppable, 'scrollWidth', {
      value: bigClient.paddingBox.width,
    });
    Object.defineProperty(droppable, 'scrollHeight', {
      value: bigClient.paddingBox.height,
    });
    // should never be called!
    jest.spyOn(parent, 'getBoundingClientRect').mockImplementation(() => {
      throw new Error(
        'Should not be getting the boundingClientRect on the parent',
      );
    });

    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    expect(console.warn).not.toHaveBeenCalled();
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );
    expect(console.warn).toHaveBeenCalled();

    expect(result).toEqual(expected);
    // $FlowFixMe
    console.warn.mockRestore();
  })",snuts
/test/unit/view/use-droppable-publisher/publishing.spec.js,VerboseStatement,"{'startLine':426,'endLine':485}","it('should capture the initial scroll of the closest scrollable', () => {
  // in this case the parent of the droppable is the closest scrollable
  const frameScroll: Position = { x: 10, y: 20 };
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext registry={registry}>
      <App parentIsScrollable droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  // manually setting the scroll of the parent node
  parent.scrollTop = frameScroll.y;
  parent.scrollLeft = frameScroll.x;
  Object.defineProperty(parent, 'scrollWidth', {
    value: bigClient.paddingBox.width,
  });
  Object.defineProperty(parent, 'scrollHeight', {
    value: bigClient.paddingBox.height,
  });
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  const expected: DroppableDimension = getDroppableDimension({
    descriptor,
    borderBox: bigClient.borderBox,
    margin,
    border,
    padding,
    closest: {
      borderBox: smallFrameClient.borderBox,
      margin,
      border,
      padding,
      scrollSize: {
        scrollWidth: bigClient.paddingBox.width,
        scrollHeight: bigClient.paddingBox.height,
      },
      scroll: frameScroll,
      shouldClipSubject: true,
    },
    windowScroll: preset.windowScroll,
  });

  // pull the get dimension function out
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // execute it to get the dimension
  const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
    preset.windowScroll,
    immediate,
  );

  expect(result).toEqual(expected);
})",snuts
/test/unit/view/use-droppable-publisher/publishing.spec.js,VerboseStatement,"{'startLine':487,'endLine':546}","it('should indicate if subject clipping is permitted based on the ignoreContainerClipping prop', () => {
  // in this case the parent of the droppable is the closest scrollable
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext registry={registry}>
      <App
        parentIsScrollable
        droppableIsScrollable={false}
        ignoreContainerClipping
      />
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  const scrollSize: ScrollSize = {
    scrollWidth: bigClient.paddingBox.width,
    scrollHeight: bigClient.paddingBox.height,
  };
  Object.defineProperty(parent, 'scrollWidth', {
    value: scrollSize.scrollWidth,
  });
  Object.defineProperty(parent, 'scrollHeight', {
    value: scrollSize.scrollHeight,
  });
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  const expected: DroppableDimension = getDroppableDimension({
    descriptor,
    borderBox: bigClient.borderBox,
    margin,
    padding,
    border,
    closest: {
      borderBox: smallFrameClient.borderBox,
      margin,
      padding,
      border,
      scrollSize,
      scroll: { x: 0, y: 0 },
      shouldClipSubject: false,
    },
    windowScroll: preset.windowScroll,
  });

  // pull the get dimension function out
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // execute it to get the dimension
  const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
    preset.windowScroll,
    immediate,
  );

  expect(result).toEqual(expected);
})",snuts
/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js,NonFunctionalStatement,"{'startLine':47,'endLine':47}","beforeEach(() => {
    reset(body);
    reset(html);
    jest.spyOn(console, 'warn').mockImplementation(() => {});
  })",snuts
/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js,SubOptimalAssert,"{'startLine':21,'endLine':21}","it('should return false if an element has overflow:visible', () => {
  ['overflowY', 'overflowX'].forEach((overflow: string) => {
    const el: HTMLElement = document.createElement('div');
    // $ExpectError - flow being mean
    el.style[overflow] = 'visible';
    expect(getClosestScrollable(el)).toBe(null);
  });
})",snuts
/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js,SubOptimalAssert,"{'startLine':64,'endLine':64}","it('should warn if the body might be a scroll container', () => {
    body.style.overflowX = 'auto';
    html.style.overflowY = 'auto';

    expect(getClosestScrollable(body)).toBe(null);
    expect(console.warn).toHaveBeenCalled();
  })",snuts
/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js,SubOptimalAssert,"{'startLine':70,'endLine':70}","it('should not mark the body as a scroll container if it does not have any overflow set', () => {
    body.style.overflowX = 'visible';
    expect(getClosestScrollable(body)).toBe(null);
    expect(console.warn).not.toHaveBeenCalled();
  })",snuts
/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js,SubOptimalAssert,"{'startLine':77,'endLine':77}","it('should not mark the body as a scroll container if the html element has visible overflow', () => {
    body.style.overflowX = 'auto';
    html.style.overflowY = 'visible';
    expect(getClosestScrollable(body)).toBe(null);
    expect(console.warn).not.toHaveBeenCalled();
  })",snuts
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,VerboseStatement,"{'startLine':23,'endLine':63}","it('should publish updates to the enabled state when dragging', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );
  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // changing to false
  wrapper.setProps({
    isCombineEnabled: false,
  });
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    false,
  );
  // $FlowFixMe
  marshal.updateDroppableIsCombineEnabled.mockClear();

  // now setting to true
  wrapper.setProps({
    isCombineEnabled: true,
  });
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    true,
  );
})",snuts
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,VerboseStatement,"{'startLine':31,'endLine':70}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",snuts
/test/unit/view/placeholder/on-transition-end.spec.js,OvercommentedTest,"{'startLine':12,'endLine':63}","it('should only fire a single transitionend event a single time when transitioning multiple properties', () => {
  const onTransitionEnd = jest.fn();
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={onTransitionEnd}
      contextId=""hey""
    />,
  );
  // finish the animate open timer
  act(() => {
    jest.runOnlyPendingTimers();
  });
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));

  // first event: a 'height' event will trigger the handler

  // $ExpectError - not a complete event
  const height: TransitionEvent = {
    propertyName: 'height',
  };
  wrapper.simulate('transitionend', height);
  expect(onTransitionEnd).toHaveBeenCalledTimes(1);
  onTransitionEnd.mockClear();

  // subsequent transition events will not trigger

  // $ExpectError - not a complete event
  const margin: TransitionEvent = {
    propertyName: 'margin',
  };
  // $ExpectError - not a complete event
  const width: TransitionEvent = {
    propertyName: 'width',
  };
  wrapper.simulate('transitionend', margin);
  wrapper.simulate('transitionend', width);
  expect(onTransitionEnd).not.toHaveBeenCalled();

  // another transition event of height would trigger the handler
  wrapper.simulate('transitionend', height);
  expect(onTransitionEnd).toHaveBeenCalledTimes(1);

  // validate: this should not have triggered any close events
  expect(onClose).not.toHaveBeenCalled();
})",snuts
/test/unit/view/placeholder/on-transition-end.spec.js,VerboseStatement,"{'startLine':12,'endLine':63}","it('should only fire a single transitionend event a single time when transitioning multiple properties', () => {
  const onTransitionEnd = jest.fn();
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={onTransitionEnd}
      contextId=""hey""
    />,
  );
  // finish the animate open timer
  act(() => {
    jest.runOnlyPendingTimers();
  });
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));

  // first event: a 'height' event will trigger the handler

  // $ExpectError - not a complete event
  const height: TransitionEvent = {
    propertyName: 'height',
  };
  wrapper.simulate('transitionend', height);
  expect(onTransitionEnd).toHaveBeenCalledTimes(1);
  onTransitionEnd.mockClear();

  // subsequent transition events will not trigger

  // $ExpectError - not a complete event
  const margin: TransitionEvent = {
    propertyName: 'margin',
  };
  // $ExpectError - not a complete event
  const width: TransitionEvent = {
    propertyName: 'width',
  };
  wrapper.simulate('transitionend', margin);
  wrapper.simulate('transitionend', width);
  expect(onTransitionEnd).not.toHaveBeenCalled();

  // another transition event of height would trigger the handler
  wrapper.simulate('transitionend', height);
  expect(onTransitionEnd).toHaveBeenCalledTimes(1);

  // validate: this should not have triggered any close events
  expect(onClose).not.toHaveBeenCalled();
})",snuts
/test/unit/view/placeholder/animated-mount.spec.js,OvercommentedTest,"{'startLine':60,'endLine':98}","it('should not animate a mount if interrupted', () => {
  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      contextId={contextId}
      placeholder={placeholder}
      onClose={jest.fn()}
      onTransitionEnd={jest.fn()}
    />,
  );
  const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsEmpty(onMount);

  expect(getCreatePlaceholderCalls()).toHaveLength(1);

  // interrupting animation
  wrapper.setProps({
    animate: 'none',
  });

  // render 1: normal
  // render 2: useEffect calling setState
  // render 3: result of setState
  expect(getCreatePlaceholderCalls()).toHaveLength(3);

  // no timers are run
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();

  const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsFull(postMount);

  // validation - no further updates
  spy.mockClear();
  jest.runOnlyPendingTimers();
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));
  expect(getCreatePlaceholderCalls()).toHaveLength(0);
})",snuts
/test/unit/view/placeholder/animated-mount.spec.js,SubOptimalAssert,"{'startLine':42,'endLine':42}","it('should animate a mount', () => {
  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      contextId={contextId}
      animate=""open""
      placeholder={placeholder}
      onClose={jest.fn()}
      onTransitionEnd={jest.fn()}
    />,
  );

  expect(getCreatePlaceholderCalls().length).toBe(1);

  // first call had an empty size
  const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsEmpty(onMount);

  // Will trigger a .setState
  act(() => {
    jest.runOnlyPendingTimers();
  });

  // tell enzyme that something has changed
  wrapper.update();

  const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsFull(postMount);
})",snuts
/test/unit/view/placeholder/animated-mount.spec.js,VerboseStatement,"{'startLine':60,'endLine':98}","it('should not animate a mount if interrupted', () => {
  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      contextId={contextId}
      placeholder={placeholder}
      onClose={jest.fn()}
      onTransitionEnd={jest.fn()}
    />,
  );
  const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsEmpty(onMount);

  expect(getCreatePlaceholderCalls()).toHaveLength(1);

  // interrupting animation
  wrapper.setProps({
    animate: 'none',
  });

  // render 1: normal
  // render 2: useEffect calling setState
  // render 3: result of setState
  expect(getCreatePlaceholderCalls()).toHaveLength(3);

  // no timers are run
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();

  const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsFull(postMount);

  // validation - no further updates
  spy.mockClear();
  jest.runOnlyPendingTimers();
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));
  expect(getCreatePlaceholderCalls()).toHaveLength(0);
})",snuts
/test/unit/view/is-type-of-element/is-svg-element.spec.js,SubOptimalAssert,"{'startLine':10,'endLine':10}","it('should allow svg elements through', () => {
  // $FlowFixMe - does not know what SVGElement is
  const svg: SVGElement = getSvg(document);

  expect(svg instanceof SVGElement).toBe(true);
  expect(isSvgElement(svg)).toBe(true);
})",snuts
/test/unit/view/is-type-of-element/is-svg-element.spec.js,SubOptimalAssert,"{'startLine':27,'endLine':27}","it('should allow svg elements from another window', () => {
  const other = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
  const svg: HTMLElement = getSvg(other.window.document);

  expect(isSvgElement(svg)).toBe(true);
  // validation
  // $FlowFixMe - does not know what SVGElement is
  expect(svg instanceof SVGElement).toBe(false);
  expect(svg instanceof other.window.SVGElement).toBe(true);
})",snuts
/test/unit/view/is-type-of-element/is-svg-element.spec.js,SubOptimalAssert,"{'startLine':28,'endLine':28}","it('should allow svg elements from another window', () => {
  const other = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
  const svg: HTMLElement = getSvg(other.window.document);

  expect(isSvgElement(svg)).toBe(true);
  // validation
  // $FlowFixMe - does not know what SVGElement is
  expect(svg instanceof SVGElement).toBe(false);
  expect(svg instanceof other.window.SVGElement).toBe(true);
})",snuts
/test/unit/view/is-type-of-element/is-svg-element.spec.js,SubOptimalAssert,"{'startLine':36,'endLine':36}","it('should not allow html elements from another window', () => {
  const other = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
  const anchor: HTMLElement = other.window.document.createElement('a');

  // normally would not pass an instanceof check
  expect(anchor instanceof HTMLElement).toBe(false);
  expect(anchor instanceof other.window.HTMLElement).toBe(true);

  expect(isSvgElement(anchor)).toBe(false);
})",snuts
/test/unit/view/is-type-of-element/is-svg-element.spec.js,SubOptimalAssert,"{'startLine':37,'endLine':37}","it('should not allow html elements from another window', () => {
  const other = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
  const anchor: HTMLElement = other.window.document.createElement('a');

  // normally would not pass an instanceof check
  expect(anchor instanceof HTMLElement).toBe(false);
  expect(anchor instanceof other.window.HTMLElement).toBe(true);

  expect(isSvgElement(anchor)).toBe(false);
})",snuts
/test/unit/view/is-type-of-element/is-html-element.spec.js,SubOptimalAssert,"{'startLine':12,'endLine':12}","it('should allow html elements through', () => {
  const anchor: HTMLElement = document.createElement('a');

  expect(isHtmlElement(anchor)).toBe(true);
  // validation
  expect(anchor instanceof HTMLElement).toBe(true);
})",snuts
/test/unit/view/is-type-of-element/is-html-element.spec.js,SubOptimalAssert,"{'startLine':21,'endLine':21}","it('should not allow svg elements through', () => {
  // $FlowFixMe - does not know what SVGElement is
  const svg: SVGElement = getSvg(document);

  expect(isHtmlElement(svg)).toBe(false);
  // validation
  expect(svg instanceof SVGElement).toBe(true);
  expect(isSvgElement(svg)).toBe(true);
})",snuts
/test/unit/view/is-type-of-element/is-html-element.spec.js,SubOptimalAssert,"{'startLine':30,'endLine':30}","it('should allow html elements from another window', () => {
  const other = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
  const anchor: HTMLElement = other.window.document.createElement('a');

  // normally would not pass an instanceof check
  expect(anchor instanceof HTMLElement).toBe(false);
  expect(anchor instanceof other.window.HTMLElement).toBe(true);

  // passes our html element check
  expect(isHtmlElement(anchor)).toBe(true);
})",snuts
/test/unit/view/is-type-of-element/is-html-element.spec.js,SubOptimalAssert,"{'startLine':31,'endLine':31}","it('should allow html elements from another window', () => {
  const other = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
  const anchor: HTMLElement = other.window.document.createElement('a');

  // normally would not pass an instanceof check
  expect(anchor instanceof HTMLElement).toBe(false);
  expect(anchor instanceof other.window.HTMLElement).toBe(true);

  // passes our html element check
  expect(isHtmlElement(anchor)).toBe(true);
})",snuts
/test/unit/view/is-type-of-element/is-html-element.spec.js,SubOptimalAssert,"{'startLine':44,'endLine':44}","it('should not allow svg elements from another window', () => {
  const other = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
  const svg: HTMLElement = getSvg(other.window.document);

  expect(isHtmlElement(svg)).toBe(false);
  // validation
  // $FlowFixMe - does not know what SVGElement is
  expect(svg instanceof SVGElement).toBe(false);
  expect(svg instanceof other.window.SVGElement).toBe(true);
  expect(isSvgElement(svg)).toBe(true);
})",snuts
/test/unit/view/is-type-of-element/is-html-element.spec.js,SubOptimalAssert,"{'startLine':45,'endLine':45}","it('should not allow svg elements from another window', () => {
  const other = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
  const svg: HTMLElement = getSvg(other.window.document);

  expect(isHtmlElement(svg)).toBe(false);
  // validation
  // $FlowFixMe - does not know what SVGElement is
  expect(svg instanceof SVGElement).toBe(false);
  expect(svg instanceof other.window.SVGElement).toBe(true);
  expect(isSvgElement(svg)).toBe(true);
})",snuts
/test/unit/view/is-type-of-element/is-element.spec.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}","it('should not let other types through', () => {
  [null, 1, true, {}, () => {}].forEach((value: mixed) =>
    expect(isElement(value)).toBe(false),
  );
})",snuts
/test/unit/view/is-type-of-element/is-element.spec.js,SubOptimalAssert,"{'startLine':30,'endLine':30}","it('should not allow svg elements from another window', () => {
  const other = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
  const anchor: HTMLElement = other.window.document.createElement('a');
  const svg: HTMLElement = getSvg(other.window.document);

  expect(isElement(anchor)).toBe(true);
  expect(isElement(svg)).toBe(true);

  // validation
  expect(svg instanceof Element).toBe(false);
  expect(svg instanceof other.window.Element).toBe(true);
  expect(anchor instanceof Element).toBe(false);
  expect(anchor instanceof other.window.Element).toBe(true);
})",snuts
/test/unit/view/is-type-of-element/is-element.spec.js,SubOptimalAssert,"{'startLine':31,'endLine':31}","it('should not allow svg elements from another window', () => {
  const other = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
  const anchor: HTMLElement = other.window.document.createElement('a');
  const svg: HTMLElement = getSvg(other.window.document);

  expect(isElement(anchor)).toBe(true);
  expect(isElement(svg)).toBe(true);

  // validation
  expect(svg instanceof Element).toBe(false);
  expect(svg instanceof other.window.Element).toBe(true);
  expect(anchor instanceof Element).toBe(false);
  expect(anchor instanceof other.window.Element).toBe(true);
})",snuts
/test/unit/view/is-type-of-element/is-element.spec.js,SubOptimalAssert,"{'startLine':32,'endLine':32}","it('should not allow svg elements from another window', () => {
  const other = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
  const anchor: HTMLElement = other.window.document.createElement('a');
  const svg: HTMLElement = getSvg(other.window.document);

  expect(isElement(anchor)).toBe(true);
  expect(isElement(svg)).toBe(true);

  // validation
  expect(svg instanceof Element).toBe(false);
  expect(svg instanceof other.window.Element).toBe(true);
  expect(anchor instanceof Element).toBe(false);
  expect(anchor instanceof other.window.Element).toBe(true);
})",snuts
/test/unit/view/is-type-of-element/is-element.spec.js,SubOptimalAssert,"{'startLine':33,'endLine':33}","it('should not allow svg elements from another window', () => {
  const other = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
  const anchor: HTMLElement = other.window.document.createElement('a');
  const svg: HTMLElement = getSvg(other.window.document);

  expect(isElement(anchor)).toBe(true);
  expect(isElement(svg)).toBe(true);

  // validation
  expect(svg instanceof Element).toBe(false);
  expect(svg instanceof other.window.Element).toBe(true);
  expect(anchor instanceof Element).toBe(false);
  expect(anchor instanceof other.window.Element).toBe(true);
})",snuts
/test/unit/view/drag-drop-context/content-security-protection-nonce.spec.js,NonFunctionalStatement,"{'startLine':13,'endLine':13}","it('should insert nonce into style tag', () => {
  const nonce = 'ThisShouldBeACryptographicallySecurePseudorandomNumber';

  resetServerContext();
  const wrapper1: ReactWrapper<*> = mount(
    <DragDropContext nonce={nonce} onDragEnd={() => {}}>
      {null}
    </DragDropContext>,
  );
  const styleTag = document.querySelector(`[${attributes.prefix}-always=""0""]`);
  const nonceAttribute = styleTag ? styleTag.getAttribute('nonce') : '';
  expect(nonceAttribute).toEqual(nonce);

  wrapper1.unmount();
})",snuts
/test/unit/view/droppable/placeholder.spec.js,IdenticalTestDescription,"{'startLine':54,'endLine':61}","it('should not render a placeholder when not dragging', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: homeAtRest,
    });

    expect(wrapper.find(Placeholder)).toHaveLength(0);
  })",snuts
/test/unit/view/droppable/placeholder.spec.js,IdenticalTestDescription,"{'startLine':63,'endLine':70}","it('should render a placeholder when dragging over', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: isOverForeign,
    });

    expect(wrapper.find(Placeholder)).toHaveLength(1);
  })",snuts
/test/unit/view/droppable/placeholder-setup-warning.spec.js,NonFunctionalStatement,"{'startLine':29,'endLine':29}","beforeEach(() => {
  jest.spyOn(console, 'warn').mockImplementation(() => {});
})",snuts
/test/unit/view/droppable/own-props-validation.spec.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}","beforeAll(() => {
  jest.spyOn(console, 'error').mockImplementation(() => {});
})",snuts
/test/unit/view/connected-droppable/post-drop.spec.js,IdenticalTestDescription,"{'startLine':110,'endLine':132}","it('should animate a placeholder closed', () => {
    const ownProps: OwnProps = getOwnProps(preset.foreign);
    const selector: Selector = makeMapStateToProps();
    const atRest: MapProps = selector(state.idle, ownProps);

    // while dropping
    const dropping: DropAnimatingState = state.dropAnimating();
    const whileDropping: MapProps = selector(dropping, ownProps);
    const expected: MapProps = {
      ...atRest,
      shouldAnimatePlaceholder: true,
    };
    expect(whileDropping).toEqual(expected);

    // drop complete
    const idle: IdleState = {
      phase: 'IDLE',
      completed: dropping.completed,
      shouldFlush: false,
    };
    const postDrop: MapProps = selector(idle, ownProps);
    expect(postDrop).toBe(atRest);
  })",snuts
/test/unit/view/connected-droppable/dropping.spec.js,OvercommentedTest,"{'startLine':82,'endLine':111}","it('should use the completed.result and not the completed.impact for determining if over', () => {
      const ownProps: OwnProps = getOwnProps(preset.home);
      const selector: Selector = makeMapStateToProps();

      const stateWhenDropping: DropAnimatingState = state.userCancel();
      // the impact has the home destination
      expect(
        tryGetDestination(stateWhenDropping.completed.impact),
      ).toBeTruthy();
      // the user facing result has been cleared
      expect(stateWhenDropping.completed.result.destination).toBe(null);

      const whileDropping: MapProps = selector(stateWhenDropping, ownProps);
      const expected: MapProps = {
        // placeholder is still present
        placeholder: preset.inHome1.placeholder,
        shouldAnimatePlaceholder: false,
        snapshot: {
          // is using a placeholder
          isUsingPlaceholder: true,
          // still the home list so this is populated
          draggingFromThisWith: preset.inHome1.descriptor.id,
          // cleared from result and cleared version is given to consumer
          isDraggingOver: false,
          draggingOverWith: null,
        },
        useClone: null,
      };
      expect(whileDropping).toEqual(expected);
    })",snuts
/test/unit/view/connected-droppable/dropping.spec.js,SubOptimalAssert,"{'startLine':92,'endLine':92}","it('should use the completed.result and not the completed.impact for determining if over', () => {
      const ownProps: OwnProps = getOwnProps(preset.home);
      const selector: Selector = makeMapStateToProps();

      const stateWhenDropping: DropAnimatingState = state.userCancel();
      // the impact has the home destination
      expect(
        tryGetDestination(stateWhenDropping.completed.impact),
      ).toBeTruthy();
      // the user facing result has been cleared
      expect(stateWhenDropping.completed.result.destination).toBe(null);

      const whileDropping: MapProps = selector(stateWhenDropping, ownProps);
      const expected: MapProps = {
        // placeholder is still present
        placeholder: preset.inHome1.placeholder,
        shouldAnimatePlaceholder: false,
        snapshot: {
          // is using a placeholder
          isUsingPlaceholder: true,
          // still the home list so this is populated
          draggingFromThisWith: preset.inHome1.descriptor.id,
          // cleared from result and cleared version is given to consumer
          isDraggingOver: false,
          draggingOverWith: null,
        },
        useClone: null,
      };
      expect(whileDropping).toEqual(expected);
    })",snuts
/test/unit/view/connected-droppable/dragging.spec.js,IdenticalTestDescription,"{'startLine':126,'endLine':150}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isHomeButNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      const combine: Combine = {
        draggableId: preset.inForeign1.descriptor.id,
        droppableId: preset.foreign.descriptor.id,
      };
      const withCombine: IsDraggingState = withImpact(
        state.dragging(),
        withCombineImpact(state.dragging().impact, combine),
      );
      expect(selector(withCombine, ownProps)).toBe(first);
    })",snuts
/test/unit/view/connected-droppable/dragging.spec.js,IdenticalTestDescription,"{'startLine':186,'endLine':195}","it('should indicate that it is being dragged over', () => {
      const selector: Selector = makeMapStateToProps();
      const current: IsDraggingState = withImpact(
        state.dragging(preset.inHome1.descriptor.id),
        overForeign,
      );
      const props: MapProps = selector(current, ownProps);

      expect(props).toEqual(isOverForeignMapProps);
    })",snuts
/test/unit/view/connected-droppable/dragging.spec.js,IdenticalTestDescription,"{'startLine':196,'endLine':211}","it('should indicate that it is being combined over', () => {
      const selector: Selector = makeMapStateToProps();
      const base: IsDraggingState = state.dragging(
        preset.inHome1.descriptor.id,
      );
      const combine: Combine = {
        draggableId: preset.inForeign1.descriptor.id,
        droppableId: preset.foreign.descriptor.id,
      };
      const withCombine: IsDraggingState = withImpact(
        base,
        withCombineImpact(base.impact, combine),
      );
      const props: MapProps = selector(withCombine, ownProps);
      expect(props).toEqual(isOverForeignMapProps);
    })",snuts
/test/unit/view/connected-droppable/dragging.spec.js,IdenticalTestDescription,"{'startLine':213,'endLine':230}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();
      const base: IsDraggingState = withImpact(
        state.dragging(preset.inHome1.descriptor.id),
        overForeign,
      );
      const first: IsDraggingState = move(base, { x: 1, y: 1 });
      const second: IsDraggingState = move(first, { x: 0, y: 1 });
      const third: IsDraggingState = move(second, { x: -1, y: 0 });
      const props1: MapProps = selector(first, ownProps);
      const props2: MapProps = selector(second, ownProps);
      const props3: MapProps = selector(third, ownProps);

      expect(props1).toEqual(isOverForeignMapProps);
      // memoization check
      expect(props2).toBe(props1);
      expect(props3).toBe(props1);
    })",snuts
/test/unit/view/connected-droppable/dragging.spec.js,IdenticalTestDescription,"{'startLine':244,'endLine':249}","it('should indicate that it is not being dragged over', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isNotOver);
    })",snuts
/test/unit/view/connected-droppable/dragging.spec.js,IdenticalTestDescription,"{'startLine':251,'endLine':266}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
    })",snuts
/test/unit/view/connected-droppable/dragging.spec.js,VerboseStatement,"{'startLine':73,'endLine':98}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();
      const base: DraggingState = state.dragging(preset.inHome1.descriptor.id);

      const first: IsDraggingState = move(base, { x: 1, y: 1 });
      const second: IsDraggingState = move(first, { x: 0, y: 1 });
      const third: IsDraggingState = move(second, { x: -1, y: 0 });
      const combine: Combine = {
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      };
      const fourth: IsDraggingState = withImpact(
        third,
        withCombineImpact(third.impact, combine),
      );
      const props1: MapProps = selector(first, ownProps);
      const props2: MapProps = selector(second, ownProps);
      const props3: MapProps = selector(third, ownProps);
      const props4: MapProps = selector(fourth, ownProps);

      expect(props1).toEqual(isOverMapProps);
      // memoization check
      expect(props2).toBe(props1);
      expect(props3).toBe(props1);
      expect(props4).toBe(props1);
    })",snuts
/test/unit/view/connected-droppable/disabled.spec.js,IdenticalTestDescription,"{'startLine':67,'endLine':69}","it('should have the expected disabled props while resting', () => {
    expect(defaultDisabledProps).toEqual(resting);
  })",snuts
/test/unit/view/connected-droppable/child-render-behaviour.spec.js,NonFunctionalStatement,"{'startLine':23,'endLine':23}",Unknown,snuts
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,OvercommentedTest,"{'startLine':181,'endLine':230}","it('should order published draggables by their index', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'b',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        // if ordered by a key, this would be first
        id: 'a',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // publishing the higher index value first
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    // publishing the lower index value second
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      // we expect this to be ordered by index
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",snuts
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,VerboseStatement,"{'startLine':112,'endLine':158}","it('should collect and publish the draggables', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'addition1',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const registry: Registry = createRegistry();
    const callbacks: Callbacks = getCallbacksStub();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",snuts
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,VerboseStatement,"{'startLine':181,'endLine':230}","it('should order published draggables by their index', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'b',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        // if ordered by a key, this would be first
        id: 'a',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // publishing the higher index value first
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    // publishing the lower index value second
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      // we expect this to be ordered by index
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",snuts
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,VerboseStatement,"{'startLine':410,'endLine':454}","it('should recollect the scroll from droppables that had draggable additions', () => {
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [beforeInHome2],
      removals: [],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",snuts
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,VerboseStatement,"{'startLine':456,'endLine':492}","it('should recollect the scroll from droppables that had draggable removals', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [],
      removals: [preset.inHome2.descriptor.id],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",snuts
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,VerboseStatement,"{'startLine':559,'endLine':588}","it('should allow subsequent publishes between drags', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
    // $FlowFixMe
    callbacks.publishWhileDragging.mockReset();

    marshal.stopPublishing();

    // second drag
    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome3 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
  })",snuts
/test/unit/view/dimension-marshal/initial-publish.spec.js,VerboseStatement,"{'startLine':309,'endLine':355}","it('should account for changes after the last call', () => {
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      getCallbacksStub(),
    );
    populate(registry, preset.dimensions);

    // Start first publish
    const result1: StartPublishingResult = start(marshal);
    expect(result1).toEqual({
      critical,
      dimensions: preset.dimensions,
      viewport,
    });

    // Update while first drag is occurring

    const updatedInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        index: 10000,
      },
    };
    const last: DraggableEntry = registry.draggable.getById(
      preset.inHome2.descriptor.id,
    );
    const fresh: DraggableEntry = getDraggableEntry({
      uniqueId: last.uniqueId,
      dimension: updatedInHome2,
    });
    registry.draggable.update(fresh, last);
    const expected: DimensionMap = copy(preset.dimensions);
    expected.draggables[updatedInHome2.descriptor.id] = updatedInHome2;

    // Stop the first publish
    stop(marshal);

    // Start the second publish
    const result2: StartPublishingResult = start(marshal);
    expect(result2).toEqual({
      critical,
      dimensions: expected,
      viewport,
    });
  })",snuts
/test/unit/view/dimension-marshal/droppable-passthrough.spec.js,IdenticalTestDescription,"{'startLine':91,'endLine':112}","it('should throw if the droppable cannot be found', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    // initial lift
    marshal.startPublishing(defaultRequest);
    expect(callbacks.updateDroppableScroll).not.toHaveBeenCalled();

    expect(() => {
      marshal.updateDroppableScroll(preset.foreign.descriptor.id, {
        x: 10,
        y: 20,
      });
    }).toThrow(
      'Invariant failed: Cannot update the scroll on Droppable foreign as it is not registered',
    );
  })",snuts
/test/unit/view/dimension-marshal/droppable-passthrough.spec.js,IdenticalTestDescription,"{'startLine':129,'endLine':147}","it('should let consumers know', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry);

    // initial lift
    marshal.startPublishing(defaultRequest);
    expect(callbacks.updateDroppableIsEnabled).not.toHaveBeenCalled();

    marshal.updateDroppableIsEnabled(critical.droppable.id, false);
    expect(callbacks.updateDroppableIsEnabled).toHaveBeenCalledWith({
      id: critical.droppable.id,
      isEnabled: false,
    });
  })",snuts
/test/unit/view/dimension-marshal/droppable-passthrough.spec.js,IdenticalTestDescription,"{'startLine':149,'endLine':167}","it('should throw if the droppable cannot be found', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    // initial lift
    marshal.startPublishing(defaultRequest);
    expect(callbacks.updateDroppableIsEnabled).not.toHaveBeenCalled();

    expect(() =>
      marshal.updateDroppableIsEnabled(preset.foreign.descriptor.id, false),
    ).toThrow(
      'Invariant failed: Cannot update is enabled flag of Droppable foreign as it is not registered',
    );
  })",snuts
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,IdenticalTestDescription,"{'startLine':162,'endLine':202}","it('should not break memoization on multiple calls', () => {
        const selector: Selector = makeMapStateToProps();
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              { dimension: preset.inHome3, shouldAnimate: true },
              { dimension: preset.inHome4, shouldAnimate: true },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: inHome1Location,
          },
        };
        const first: MapProps = selector(withImpact(current, impact), ownProps);

        const expected: MapProps = {
          mapped: {
            type: 'SECONDARY',
            offset: displacedBy.point,
            shouldAnimateDisplacement: true,
            combineTargetFor: null,
            snapshot: getSecondarySnapshot({
              combineTargetFor: null,
            }),
          },
        };
        expect(first).toEqual(expected);

        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
      })",snuts
/test/unit/view/connected-draggable/dropping-with-result-mismatch.spec.js,SubOptimalAssert,"{'startLine':25,'endLine':25}","it('should use result for providing data and not the impact', () => {
  const current: DropAnimatingState = state.userCancel();

  // little validation: the result is null, but the impact has a destination
  expect(current.completed.result.destination).toBe(null);
  expect(tryGetDestination(current.completed.impact)).toBeTruthy();

  const selector: Selector = makeMapStateToProps();

  const dropping: DropAnimation = {
    duration: current.dropDuration,
    curve: curves.drop,
    moveTo: current.newHomeClientOffset,
    opacity: null,
    scale: null,
  };

  const expected: MapProps = {
    mapped: {
      type: 'DRAGGING',
      dimension: preset.inHome1,
      // using result
      draggingOver: null,
      forceShouldAnimate: null,
      offset: current.newHomeClientOffset,
      mode: current.completed.result.mode,
      combineWith: null,
      dropping,
      snapshot: getDraggingSnapshot({
        mode: current.completed.result.mode,
        // using result
        draggingOver: null,
        combineWith: null,
        dropping,
      }),
    },
  };

  const whileDropping: MapProps = selector(current, ownProps);

  expect(whileDropping).toEqual(expected);
})",snuts
/test/unit/view/connected-draggable/dragging.spec.js,SubOptimalAssert,"{'startLine':61,'endLine':63}","it('should allow force control of drag animation', () => {
      const selector: Selector = makeMapStateToProps();

      expect(
        getDraggingMapProps(selector(current, ownProps)).forceShouldAnimate,
      ).toBe(null);

      const withAnimation: IsDraggingState = ({
        ...current,
        forceShouldAnimate: true,
      }: any);

      expect(
        getDraggingMapProps(selector(withAnimation, ownProps))
          .forceShouldAnimate,
      ).toBe(true);

      const withoutAnimation: IsDraggingState = ({
        ...current,
        forceShouldAnimate: false,
      }: any);

      expect(
        getDraggingMapProps(selector(withoutAnimation, ownProps))
          .forceShouldAnimate,
      ).toBe(false);
    })",snuts
/test/unit/view/connected-draggable/dragging.spec.js,SubOptimalAssert,"{'startLine':105,'endLine':105}","it('should indicate when over a droppable', () => {
      const selector: Selector = makeMapStateToProps();
      const { impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome1,
        draggables: preset.draggables,
        viewport: preset.viewport,
        home: preset.home,
      });

      const inHome: IsDraggingState = withImpact(current, homeImpact);
      const overHome: DraggingMapProps = getDraggingMapProps(
        selector(inHome, ownProps),
      );
      const noWhere: IsDraggingState = withImpact(current, noImpact);
      const overNothing: DraggingMapProps = getDraggingMapProps(
        selector(noWhere, ownProps),
      );

      expect(overHome.draggingOver).toBe(state.critical.droppable.id);
      expect(overNothing.draggingOver).toBe(null);
    })",snuts
/test/unit/view/connected-draggable/child-render-behaviour.spec.js,NonFunctionalStatement,"{'startLine':42,'endLine':42}",Unknown,snuts
/test/unit/view/animate-in-out/animate-in-out.spec.js,OvercommentedTest,"{'startLine':121,'endLine':175}","it('should animate closed if required', () => {
  const child = jest.fn().mockReturnValue(<div>hi</div>);
  const data = { hello: 'world' };

  type Props = {|
    value: ?Object,
    shouldAnimate: boolean,
  |};

  function App({ value, shouldAnimate }: Props) {
    return (
      <AnimateInOut on={value} shouldAnimate={shouldAnimate}>
        {child}
      </AnimateInOut>
    );
  }

  const { container, rerender } = render(
    <App value={data} shouldAnimate={false} />,
  );

  const initial: AnimateProvided = {
    data,
    animate: 'none',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(initial);
  expect(child).toHaveBeenCalledTimes(1);
  expect(container.innerHTML).toEqual('<div>hi</div>');
  child.mockClear();

  // start closing
  // data is gone! this should trigger a close
  rerender(<App value={null} shouldAnimate />);

  const second: AnimateProvided = {
    // data is still provided to child for final render
    data,
    // still visible while animating
    animate: 'close',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(second);

  // telling AnimateInOut that the animation is finished
  const provided: AnimateProvided = child.mock.calls[0][0];
  child.mockClear();
  // this will trigger a setState that will stop rendering the child
  provided.onClose();

  expect(container.innerHTML).toEqual('');
  expect(child).not.toHaveBeenCalled();
})",snuts
/test/unit/view/animate-in-out/animate-in-out.spec.js,VerboseStatement,"{'startLine':121,'endLine':175}","it('should animate closed if required', () => {
  const child = jest.fn().mockReturnValue(<div>hi</div>);
  const data = { hello: 'world' };

  type Props = {|
    value: ?Object,
    shouldAnimate: boolean,
  |};

  function App({ value, shouldAnimate }: Props) {
    return (
      <AnimateInOut on={value} shouldAnimate={shouldAnimate}>
        {child}
      </AnimateInOut>
    );
  }

  const { container, rerender } = render(
    <App value={data} shouldAnimate={false} />,
  );

  const initial: AnimateProvided = {
    data,
    animate: 'none',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(initial);
  expect(child).toHaveBeenCalledTimes(1);
  expect(container.innerHTML).toEqual('<div>hi</div>');
  child.mockClear();

  // start closing
  // data is gone! this should trigger a close
  rerender(<App value={null} shouldAnimate />);

  const second: AnimateProvided = {
    // data is still provided to child for final render
    data,
    // still visible while animating
    animate: 'close',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(second);

  // telling AnimateInOut that the animation is finished
  const provided: AnimateProvided = child.mock.calls[0][0];
  child.mockClear();
  // this will trigger a setState that will stop rendering the child
  provided.onClose();

  expect(container.innerHTML).toEqual('');
  expect(child).not.toHaveBeenCalled();
})",snuts
/test/unit/integration/server-side-rendering/client-hydration.spec.js,OvercommentedTest,"{'startLine':22,'endLine':47}","it('should support hydrating a server side rendered application', () => {
  // would be done server side
  // we need to mock out the warnings caused by useLayoutEffect
  // This will not happen on the client as the string is rendered
  // on the server
  const error = jest.spyOn(console, 'error').mockImplementation(noop);

  resetServerContext();
  const serverHTML: string = ReactDOMServer.renderToString(<App />);

  error.mock.calls.forEach((call) => {
    expect(
      call[0].includes('Warning: useLayoutEffect does nothing on the server'),
    ).toBe(true);
  });
  error.mockRestore();

  // would be done client side
  // would have a fresh server context on the client
  resetServerContext();
  const el = document.createElement('div');
  el.innerHTML = serverHTML;
  getBodyElement().appendChild(el);

  expect(() => ReactDOM.hydrate(<App />, el)).not.toThrow();
})",snuts
/test/unit/integration/draggable/validation.spec.js,NonFunctionalStatement,"{'startLine':28,'endLine':28}",Unknown,snuts
/test/unit/integration/draggable/validation.spec.js,NonFunctionalStatement,"{'startLine':83,'endLine':83}","it('should log an error if innerRef is not provided', () => {
  function App() {
    return (
      <DragDropContext onDragEnd={() => {}}>
        <Droppable droppableId=""droppable"">
          {(droppableProvided: DroppableProvided) => (
            <div
              ref={droppableProvided.innerRef}
              {...droppableProvided.droppableProps}
            >
              <Draggable draggableId=""draggable"" index={0}>
                {(provided: DraggableProvided) => (
                  <div
                    /* not providing a ref */
                    /* ref={provided.innerRef} */
                    {...provided.draggableProps}
                    {...provided.dragHandleProps}
                  >
                    Drag me!
                  </div>
                )}
              </Draggable>
              {droppableProvided.placeholder}
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  render(<App />);

  expect(error).toHaveBeenCalled();
})",snuts
/test/unit/integration/draggable/validation.spec.js,NonFunctionalStatement,"{'startLine':118,'endLine':118}","it('should log an error if innerRef is an SVG', () => {
  function App() {
    return (
      <DragDropContext onDragEnd={() => {}}>
        <Droppable droppableId=""droppable"">
          {(droppableProvided: DroppableProvided) => (
            <div
              ref={droppableProvided.innerRef}
              {...droppableProvided.droppableProps}
            >
              <Draggable draggableId=""draggable"" index={0}>
                {(provided: DraggableProvided) => (
                  <svg
                    // $ExpectError - invalid ref type
                    ref={provided.innerRef}
                    {...provided.draggableProps}
                    {...provided.dragHandleProps}
                  >
                    Drag me!
                  </svg>
                )}
              </Draggable>
              {droppableProvided.placeholder}
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  render(<App />);

  expect(error).toHaveBeenCalled();
})",snuts
/test/unit/integration/draggable/validation.spec.js,NonFunctionalStatement,"{'startLine':153,'endLine':153}","it('should log an error if no drag handle props are applied', () => {
  function App() {
    return (
      <DragDropContext onDragEnd={() => {}}>
        <Droppable droppableId=""droppable"">
          {(droppableProvided: DroppableProvided) => (
            <div
              ref={droppableProvided.innerRef}
              {...droppableProvided.droppableProps}
            >
              <Draggable draggableId=""draggable"" index={0}>
                {(provided: DraggableProvided) => (
                  <div
                    ref={provided.innerRef}
                    {...provided.draggableProps}
                    /* not being applied */
                    /* {...dragProvided.dragHandleProps} */
                  >
                    Drag me!
                  </div>
                )}
              </Draggable>
              {droppableProvided.placeholder}
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  render(<App />);

  expect(error).toHaveBeenCalled();
})",snuts
/test/unit/integration/draggable/validation.spec.js,NonFunctionalStatement,"{'startLine':188,'endLine':188}","it('should log an error if the draggable is disabled as there will be no drag handle', () => {
  function App() {
    return (
      <DragDropContext onDragEnd={() => {}}>
        <Droppable droppableId=""droppable"">
          {(droppableProvided: DroppableProvided) => (
            <div
              ref={droppableProvided.innerRef}
              {...droppableProvided.droppableProps}
            >
              <Draggable draggableId=""draggable"" index={0} isDragDisabled>
                {(provided: DraggableProvided) => (
                  <div
                    ref={provided.innerRef}
                    {...provided.draggableProps}
                    {...provided.dragHandleProps}
                  >
                    Drag me!
                  </div>
                )}
              </Draggable>
              {droppableProvided.placeholder}
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  error.mockRestore();
  render(<App />);

  expect(error).not.toHaveBeenCalled();
})",snuts
/test/unit/integration/draggable/portal.spec.js,VerboseStatement,"{'startLine':44,'endLine':65}","it('should allow consumers to use their own portal', () => {
  const { getByTestId } = render(<App renderItem={renderItem} />);
  const before: HTMLElement = getByTestId('0');

  // not in portal yet
  expect(before.parentElement).not.toBe(portal);
  expect(isDragging(before)).toBe(false);

  // moved to portal after lift
  simpleLift(mouse, before);
  const inPortal: HTMLElement = getByTestId('0');
  expect(inPortal.parentElement).toBe(portal);
  expect(before).not.toBe(inPortal);
  expect(isDragging(inPortal)).toBe(true);

  // out of portal after drop
  mouse.drop(inPortal);
  const after: HTMLElement = getByTestId('0');
  expect(after.parentElement).not.toBe(portal);
  expect(after).not.toBe(inPortal);
  expect(isDragging(after)).toBe(false);
})",snuts
/test/unit/integration/draggable/moving-out-of-the-way.spec.js,OvercommentedTest,"{'startLine':12,'endLine':48}","it('should move out of the way when requested', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem = renderItemAndSpy(spy);
    const { getByText } = render(<App renderItem={renderItem} />);
    const before: HTMLElement = getByText('item: 0');
    const critical: HTMLElement = getByText('item: 1');
    const after: HTMLElement = getByText('item: 2');
    const criticalBox = preset.inHome2.client.borderBox;
    const afterBox = preset.inHome3.client.borderBox;

    expandedMouse.powerLift(critical, criticalBox.center);
    expect(isDragging(critical)).toBe(true);

    // before critical
    expect(before.style.transform).toBe('');

    // no movement yet so no transform
    expect(critical.style.transform).toBe('');

    // after critical is moved forward
    expect(after.style.transform).toBe(
      `translate(0px, ${preset.inHome2.displaceBy.y}px)`,
    );

    expandedMouse.move(critical, afterBox.center);

    // still not moved
    expect(after.style.transform).toBe('');

    // critical has now moved
    expect(critical.style.transform.startsWith('translate')).toBe(true);

    // after no longer displaced (moved backwards)
    expect(after.style.transform).toBe('');
  });
})",snuts
/test/unit/integration/draggable/dropping.spec.js,VerboseStatement,"{'startLine':29,'endLine':55}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",snuts
/test/unit/integration/draggable/dropping.spec.js,VerboseStatement,"{'startLine':57,'endLine':97}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",snuts
/test/unit/integration/draggable/dropping.spec.js,VerboseStatement,"{'startLine':194,'endLine':217}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",snuts
/test/unit/integration/droppable/placeholder.spec.js,OvercommentedTest,"{'startLine':159,'endLine':199}","it('should animate the home placeholder closed after dropping into a foreign list', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

      expandedMouse.startDrop(handle);
      // foreign placeholder remaining in place
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );
      // home placeholder remaining in place
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // gone after drop finished
      expandedMouse.finishDrop(handle);

      // foreign placeholder is now gone
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
      // home placeholder is still around and will now animate closed
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder is now collapsing
      const placeholder: HTMLElement = getPlaceholder(
        preset.home.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // faking a transition end
      fireEvent(placeholder, getTransitionEnd('height'));

      // placeholder is gone
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",snuts
/test/unit/integration/droppable/placeholder.spec.js,SubOptimalAssert,"{'startLine':144,'endLine':144}","it('should immediately remove the home placeholder after dropping nowhere', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, { x: 10000, y: 10000 });
      expect(isOver(handle)).toBe(null);

      // placeholder present when over nothing
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder present when drop started
      expandedMouse.startDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder gone after drop finished
      expandedMouse.finishDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",snuts
/test/unit/integration/droppable/clone.spec.js,OvercommentedTest,"{'startLine':90,'endLine':121}","it('should allow reordering other items when dropping', () => {
  withPoorDimensionMocks((preset) => {
    const { getByTestId } = render(<App useClone />);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    expandedMouse.powerLift(getByTestId('0'), box0.center);

    const clone: HTMLElement = getByTestId('0');
    expect(isClone(clone)).toBe(true);
    expect(isDragging(clone)).toBe(true);

    // move item 0 to index 1
    expandedMouse.move(clone, box1.center);

    // drop started, but still occurring
    expandedMouse.startDrop(clone);
    expect(isDropAnimating(clone)).toBe(true);

    // starting a new drag with item 1 (which is in index 0 visually now)
    // using box0.center as the lifting point
    // we are relying on a sync render from a dispatched action
    // act(() => {}); is joining the two into one update which is
    // causing unexpected mounting behaviour
    withError(() => {
      expandedMouse.rawPowerLift(getByTestId('1'), box0.center);
    });

    expect(isDragging(getByTestId('1'))).toBe(true);
    expect(isDragging(getByTestId('0'))).toBe(false);
  });
})",snuts
/test/unit/integration/drag-drop-context/unmount.spec.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}","it('should not throw when unmounting', () => {
  const { unmount } = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  expect(() => unmount()).not.toThrow();
})",snuts
/test/unit/integration/drag-drop-context/unmount.spec.js,NonFunctionalStatement,"{'startLine':19,'endLine':19}","it('should clean up any window event handlers', () => {
  jest.spyOn(window, 'addEventListener');
  jest.spyOn(window, 'removeEventListener');

  const { unmount } = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  unmount();

  expect(window.addEventListener.mock.calls).toHaveLength(
    window.removeEventListener.mock.calls.length,
  );
  // validation
  expect(window.addEventListener).toHaveBeenCalled();
  expect(window.removeEventListener).toHaveBeenCalled();
})",snuts
/test/unit/integration/drag-drop-context/reset-server-context.spec.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}","it('should reset the style marshal context', () => {
  expect(doesStyleElementExist(1)).toBe(false);

  const wrapper1 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(0)).toBe(true);

  const wrapper2 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(1)).toBe(true);

  // not created yet
  expect(doesStyleElementExist(2)).toBe(false);

  // clearing away the old wrappers
  wrapper1.unmount();
  wrapper2.unmount();
  resetServerContext();

  // a new wrapper after the reset
  const wrapper3 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  // now only '0' exists
  expect(doesStyleElementExist(0)).toBe(true);
  expect(doesStyleElementExist(1)).toBe(false);

  wrapper3.unmount();
})",snuts
/test/unit/integration/drag-drop-context/reset-server-context.spec.js,NonFunctionalStatement,"{'startLine':22,'endLine':22}","it('should reset the style marshal context', () => {
  expect(doesStyleElementExist(1)).toBe(false);

  const wrapper1 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(0)).toBe(true);

  const wrapper2 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(1)).toBe(true);

  // not created yet
  expect(doesStyleElementExist(2)).toBe(false);

  // clearing away the old wrappers
  wrapper1.unmount();
  wrapper2.unmount();
  resetServerContext();

  // a new wrapper after the reset
  const wrapper3 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  // now only '0' exists
  expect(doesStyleElementExist(0)).toBe(true);
  expect(doesStyleElementExist(1)).toBe(false);

  wrapper3.unmount();
})",snuts
/test/unit/integration/drag-drop-context/reset-server-context.spec.js,NonFunctionalStatement,"{'startLine':36,'endLine':36}","it('should reset the style marshal context', () => {
  expect(doesStyleElementExist(1)).toBe(false);

  const wrapper1 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(0)).toBe(true);

  const wrapper2 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(1)).toBe(true);

  // not created yet
  expect(doesStyleElementExist(2)).toBe(false);

  // clearing away the old wrappers
  wrapper1.unmount();
  wrapper2.unmount();
  resetServerContext();

  // a new wrapper after the reset
  const wrapper3 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  // now only '0' exists
  expect(doesStyleElementExist(0)).toBe(true);
  expect(doesStyleElementExist(1)).toBe(false);

  wrapper3.unmount();
})",snuts
/test/unit/integration/drag-drop-context/clashing-with-consumers-redux.spec.js,NonFunctionalStatement,"{'startLine':40,'endLine':40}","it('should avoid clashes with parent redux applications', () => {
  class App extends Component<*> {
    render() {
      return (
        <Provider store={store}>
          <DragDropContext onDragEnd={() => {}}>
            <Droppable droppableId=""droppable"">
              {(droppableProvided: DroppableProvided) => (
                <div
                  ref={droppableProvided.innerRef}
                  {...droppableProvided.droppableProps}
                >
                  <Draggable draggableId=""draggableId"" index={0}>
                    {(draggableProvided: DraggableProvided) => (
                      <div
                        ref={draggableProvided.innerRef}
                        {...draggableProvided.dragHandleProps}
                        {...draggableProvided.draggableProps}
                      >
                        <Connected />
                      </div>
                    )}
                  </Draggable>
                  {droppableProvided.placeholder}
                </div>
              )}
            </Droppable>
          </DragDropContext>
        </Provider>
      );
    }
  }
  const { container, unmount } = render(<App />);

  expect(container.textContent).toBe(original.foo);

  unmount();
})",snuts
/test/unit/integration/drag-drop-context/clashing-with-consumers-redux.spec.js,NonFunctionalStatement,"{'startLine':78,'endLine':78}","it('should avoid clashes with child redux applications', () => {
  class App extends Component<*> {
    render() {
      return (
        <DragDropContext onDragEnd={() => {}}>
          <Droppable droppableId=""droppable"">
            {(droppableProvided: DroppableProvided) => (
              <div
                ref={droppableProvided.innerRef}
                {...droppableProvided.droppableProps}
              >
                <Draggable draggableId=""draggableId"" index={0}>
                  {(draggableProvided: DraggableProvided) => (
                    <div
                      ref={draggableProvided.innerRef}
                      {...draggableProvided.dragHandleProps}
                      {...draggableProvided.draggableProps}
                    >
                      <Provider store={store}>
                        <Connected />
                      </Provider>
                    </div>
                  )}
                </Draggable>
                {droppableProvided.placeholder}
              </div>
            )}
          </Droppable>
        </DragDropContext>
      );
    }
  }
  const { container } = render(<App />);

  expect(container.textContent).toBe(original.foo);
})",snuts
/test/unit/integration/drag-drop-context/check-react-version.spec.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/test/unit/integration/drag-drop-context/check-doctype.spec.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/test/unit/state/visibility/is-totally-visible.spec.js,IdenticalTestDescription,"{'startLine':186,'endLine':213}","it('should take into account the droppable scroll when detecting visibility', () => {
          const originallyVisible: Spacing = {
            top: viewport.top,
            bottom: viewport.top + 50,
            right: viewport.left + 1,
            left: viewport.left + 100,
          };

          // originally visible
          expect(
            isTotallyVisible({
              withDroppableDisplacement: true,
              target: originallyVisible,
              destination: clippedByViewport,
              viewport,
            }),
          ).toBe(true);

          // after scroll the target is now invisible
          expect(
            isTotallyVisible({
              withDroppableDisplacement: true,
              target: originallyVisible,
              destination: scrollDroppable(clippedByViewport, { x: 0, y: 100 }),
              viewport,
            }),
          ).toBe(false);
        })",snuts
/test/unit/state/visibility/is-totally-visible.spec.js,IdenticalTestDescription,"{'startLine':384,'endLine':415}","it('should take into account the droppable scroll when detecting visibility', () => {
          const originallyInvisible: Spacing = {
            left: frame.left,
            right: frame.right,
            top: frame.bottom + 10,
            bottom: frame.bottom + 20,
          };

          // originally invisible
          expect(
            isTotallyVisible({
              withDroppableDisplacement: true,
              target: originallyInvisible,
              destination: scrollable,
              viewport,
            }),
          ).toBe(false);

          // after scroll the target is now visible
          const scrolled: DroppableDimension = scrollDroppable(scrollable, {
            x: 0,
            y: 100,
          });
          expect(
            isTotallyVisible({
              withDroppableDisplacement: true,
              target: originallyInvisible,
              destination: scrolled,
              viewport,
            }),
          ).toBe(true);
        })",snuts
/test/unit/state/visibility/is-totally-visible.spec.js,IdenticalTestDescription,"{'startLine':419,'endLine':445}","it('should take into account the droppable scroll when detecting visibility', () => {
          const originallyVisible: Spacing = {
            ...frame,
            top: 10,
            bottom: 20,
          };

          // originally visible
          expect(
            isTotallyVisible({
              withDroppableDisplacement: true,
              target: originallyVisible,
              destination: scrollable,
              viewport,
            }),
          ).toBe(true);

          // after scroll the target is now invisible
          expect(
            isTotallyVisible({
              withDroppableDisplacement: true,
              target: originallyVisible,
              destination: scrollDroppable(scrollable, { x: 0, y: 100 }),
              viewport,
            }),
          ).toBe(false);
        })",snuts
/test/unit/state/visibility/is-totally-visible.spec.js,SubOptimalAssert,"{'startLine':543,'endLine':543}","it('should return false when subject is totally invisible', () => {
        // creating a droppable where the frame is bigger than the subject
        const droppable: DroppableDimension = getDroppableDimension({
          descriptor: {
            id: 'droppable',
            type: 'TYPE',
            mode: 'standard',
          },
          borderBox: {
            top: 0,
            left: 0,
            bottom: 100,
            right: 100,
          },
          closest: {
            borderBox: {
              top: 0,
              left: 0,
              bottom: 100,
              right: 100,
            },
            scrollSize: {
              scrollHeight: 600,
              scrollWidth: 600,
            },
            scroll: { x: 0, y: 0 },
            shouldClipSubject: true,
          },
        });

        const originallyVisible: Spacing = {
          ...frame,
          top: 10,
          bottom: 20,
        };

        // originally visible
        expect(
          isTotallyVisible({
            withDroppableDisplacement: true,
            target: originallyVisible,
            destination: droppable,
            viewport,
          }),
        ).toBe(true);

        // subject is now totally invisible
        const scrolled: DroppableDimension = scrollDroppable(
          droppable,
          getFrame(droppable).scroll.max,
        );
        // asserting frame is not visible
        expect(scrolled.subject.active).toBe(null);

        // now asserting that this check will fail
        expect(
          isTotallyVisible({
            withDroppableDisplacement: true,
            target: originallyVisible,
            destination: scrolled,
            viewport,
          }),
        ).toBe(false);
      })",snuts
/test/unit/state/visibility/is-partially-visible.spec.js,IdenticalTestDescription,"{'startLine':173,'endLine':200}","it('should take into account the droppable scroll when detecting visibility', () => {
          const originallyVisible: Spacing = {
            top: viewport.top,
            bottom: viewport.top + 50,
            right: viewport.left + 1,
            left: viewport.left + 100,
          };

          // originally visible
          expect(
            isPartiallyVisible({
              target: originallyVisible,
              destination: clippedByViewport,
              viewport,
              withDroppableDisplacement: true,
            }),
          ).toBe(true);

          // after scroll the target is now invisible
          expect(
            isPartiallyVisible({
              target: originallyVisible,
              destination: scrollDroppable(clippedByViewport, { x: 0, y: 100 }),
              viewport,
              withDroppableDisplacement: true,
            }),
          ).toBe(false);
        })",snuts
/test/unit/state/visibility/is-partially-visible.spec.js,IdenticalTestDescription,"{'startLine':361,'endLine':388}","it('should take into account the droppable scroll when detecting visibility', () => {
          const originallyInvisible: Spacing = {
            left: frameBorderBox.left,
            right: frameBorderBox.right,
            top: frameBorderBox.bottom + 10,
            bottom: frameBorderBox.bottom + 20,
          };

          // originally invisible
          expect(
            isPartiallyVisible({
              target: originallyInvisible,
              destination: scrollable,
              withDroppableDisplacement: true,
              viewport,
            }),
          ).toBe(false);

          // after scroll the target is now visible
          expect(
            isPartiallyVisible({
              target: originallyInvisible,
              destination: scrollDroppable(scrollable, { x: 0, y: 100 }),
              viewport,
              withDroppableDisplacement: true,
            }),
          ).toBe(true);
        })",snuts
/test/unit/state/visibility/is-partially-visible.spec.js,IdenticalTestDescription,"{'startLine':392,'endLine':418}","it('should take into account the droppable scroll when detecting visibility', () => {
          const originallyVisible: Spacing = {
            ...frameBorderBox,
            top: 10,
            bottom: 20,
          };

          // originally visible
          expect(
            isPartiallyVisible({
              target: originallyVisible,
              destination: scrollable,
              viewport,
              withDroppableDisplacement: true,
            }),
          ).toBe(true);

          // after scroll the target is now invisible
          expect(
            isPartiallyVisible({
              target: originallyVisible,
              destination: scrollDroppable(scrollable, { x: 0, y: 100 }),
              viewport,
              withDroppableDisplacement: true,
            }),
          ).toBe(false);
        })",snuts
/test/unit/state/visibility/is-partially-visible.spec.js,SubOptimalAssert,"{'startLine':518,'endLine':518}","it('should return false when subject is totally invisible', () => {
        // creating a droppable where the frame is bigger than the subject
        const droppable: DroppableDimension = getDroppableDimension({
          descriptor: {
            id: 'droppable',
            type: 'TYPE',
            mode: 'standard',
          },
          borderBox: {
            top: 0,
            left: 0,
            bottom: 100,
            right: 100,
          },
          closest: {
            borderBox: {
              top: 0,
              left: 0,
              bottom: 100,
              right: 100,
            },
            scrollSize: {
              scrollHeight: 600,
              scrollWidth: 600,
            },
            scroll: { x: 0, y: 0 },
            shouldClipSubject: true,
          },
        });

        const originallyVisible: Spacing = {
          ...frameBorderBox,
          top: 10,
          bottom: 20,
        };

        // originally visible
        expect(
          isPartiallyVisible({
            target: originallyVisible,
            destination: droppable,
            viewport,
            withDroppableDisplacement: true,
          }),
        ).toBe(true);

        // subject is now totally invisible
        const scrolled: DroppableDimension = scrollDroppable(
          droppable,
          getFrame(droppable).scroll.max,
        );
        // asserting frame is not visible
        expect(scrolled.subject.active).toBe(null);

        // now asserting that this check will fail
        expect(
          isPartiallyVisible({
            target: originallyVisible,
            destination: scrolled,
            viewport,
            withDroppableDisplacement: true,
          }),
        ).toBe(false);
      })",snuts
/test/unit/state/update-displacement-visibility/speculative-displacement.spec.js,OvercommentedTest,"{'startLine':175,'endLine':293}","it('should increase the visible displacement in the window by the amount of the max scroll change', () => {
      const foreign: DroppableDimension = getDroppableDimension({
        descriptor: {
          id: foreignId,
          type: 'huge',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          [axis.crossAxisStart]: foreignCrossAxisStart,
          [axis.crossAxisEnd]: foreignCrossAxisEnd,
          [axis.start]: 0,
          [axis.end]: 10000,
        },
      });
      // Viewport is big enough to fit inForeign1 and inForeign2
      const sizeOfViewport: number = itemSize + itemSize - 1;

      const viewport: Viewport = createViewport({
        frame: getRect({
          [axis.crossAxisStart]: 0,
          [axis.crossAxisEnd]: 10000,
          [axis.start]: 0,
          [axis.end]: sizeOfViewport,
        }),
        scroll: origin,
        // some massive number
        scrollHeight: 20000,
        scrollWidth: 20000,
      });
      // visiblity validation
      // in the foreign list, these should be visible
      expect(
        isPartiallyVisible({
          target: inForeign1.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      expect(
        isPartiallyVisible({
          target: inForeign2.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      // the rest should be invisible
      expect(
        isPartiallyVisible({
          target: inForeign3.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign4.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign5.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);

      // inHome1 has moved into the foreign list below inForeign1
      const displacedBy: DisplacedBy = getDisplacedBy(axis, inHome1.displaceBy);

      const previousImpact: DragImpact = {
        displaced: getForcedDisplacement({
          // would normally be visible in viewport
          visible: [{ dimension: inForeign2 }],
          // normally not visible in viewport
          invisible: [inForeign3, inForeign4, inForeign5],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: foreign.descriptor.id,
            index: inForeign2.descriptor.index,
          },
        },
      };

      const result: DragImpact = speculativelyIncrease({
        impact: previousImpact,
        viewport,
        destination: foreign,
        draggables,
        maxScrollChange: patch(axis.line, itemSize),
      });

      const expected: DragImpact = {
        // unchanged locations
        ...previousImpact,
        displaced: getForcedDisplacement({
          visible: [
            // already visibly displaced: inside viewport
            { dimension: inForeign2, shouldAnimate: true },
            // speculatively increased. Forced to not animate
            { dimension: inForeign3, shouldAnimate: false },
            { dimension: inForeign4, shouldAnimate: false },
          ],
          // Bigger than 2x the size of the viewport - outside of the overscanning reach
          invisible: [inForeign5],
        }),
      };
      expect(result).toEqual(expected);
    })",snuts
/test/unit/state/update-displacement-visibility/speculative-displacement.spec.js,OvercommentedTest,"{'startLine':295,'endLine':430}","it('should increase the visible displacement in the droppable by the amount of the max scroll change', () => {
      // when moving into the foreign list there will be enough room for inHome1 and inForeign1
      // inHome1 and inForeign1 can be visible in the viewport at the same time
      const sizeOfDroppable: number = itemSize + itemSize - 1;

      const foreign: DroppableDimension = getDroppableDimension({
        descriptor: {
          id: foreignId,
          type: 'huge',
          mode: 'standard',
        },
        direction: axis.direction,
        // large subject
        borderBox: {
          [axis.crossAxisStart]: foreignCrossAxisStart,
          [axis.crossAxisEnd]: foreignCrossAxisEnd,
          [axis.start]: 0,
          [axis.end]: 10000,
        },
        // small frame (will clip subject)
        closest: {
          borderBox: {
            [axis.crossAxisStart]: foreignCrossAxisStart,
            [axis.crossAxisEnd]: foreignCrossAxisEnd,
            [axis.start]: 0,
            [axis.end]: sizeOfDroppable,
          },
          shouldClipSubject: true,
          scroll: origin,
          scrollSize: {
            scrollHeight: 10000,
            scrollWidth: 10000,
          },
        },
      });
      // huge viewport
      const viewport: Viewport = createViewport({
        frame: getRect({
          [axis.crossAxisStart]: 0,
          [axis.crossAxisEnd]: 10000,
          [axis.start]: 0,
          [axis.end]: 10000,
        }),
        scroll: origin,
        scrollHeight: 10000,
        scrollWidth: 10000,
      });
      // visiblity validation
      // in the foreign list, these should be visible
      expect(
        isPartiallyVisible({
          target: inForeign1.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      expect(
        isPartiallyVisible({
          target: inForeign2.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      // the rest should be invisible
      expect(
        isPartiallyVisible({
          target: inForeign3.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign4.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign5.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);

      // inHome1 has moved into the foreign list below inForeign1
      const displacedBy: DisplacedBy = getDisplacedBy(axis, inHome1.displaceBy);

      const previousImpact: DragImpact = {
        displaced: getForcedDisplacement({
          // would normally be visible in viewport
          visible: [{ dimension: inForeign2 }],
          // normally not visible in viewport
          invisible: [inForeign3, inForeign4, inForeign5],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: foreign.descriptor.id,
            index: inForeign2.descriptor.index,
          },
        },
      };

      const result: DragImpact = speculativelyIncrease({
        impact: previousImpact,
        viewport,
        destination: foreign,
        draggables,
        maxScrollChange: patch(axis.line, itemSize),
      });

      const expected: DragImpact = {
        // unchanged locations
        ...previousImpact,
        displaced: getForcedDisplacement({
          visible: [
            // already visibly displaced
            { dimension: inForeign2, shouldAnimate: true },
            // speculatively increased. Forced to not animate
            { dimension: inForeign3, shouldAnimate: false },
            { dimension: inForeign4, shouldAnimate: false },
          ],
          // not speculatively increased
          invisible: [inForeign5],
        }),
      };
      expect(result).toEqual(expected);
    })",snuts
/test/unit/state/publish-while-dragging/displacement-animation.spec.js,OvercommentedTest,"{'startLine':27,'endLine':116}","it('should not animate any displacement', () => {
  // inHome1 currently in foreign
  // adding item to foreign list
  // we are ensuring this displacement is not animated

  const inHomeState: DraggingState = addDroppable(
    state.dragging(),
    virtualForeign,
  );
  const moveToForeign: ?PublicResult = moveInDirection({
    state: inHomeState,
    type: 'MOVE_RIGHT',
  });
  invariant(moveToForeign);
  const inForeignImpact: DragImpact = moveToForeign.impact;
  // validation
  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        // initial movement goes after inForeign1
        { dimension: preset.inForeign2, shouldAnimate: true },
        { dimension: preset.inForeign3, shouldAnimate: true },
        { dimension: preset.inForeign4, shouldAnimate: true },
      ],
    });
    const impact: DragImpact = {
      displaced,
      displacedBy: getDisplacedBy(vertical, preset.inHome1.displaceBy),
      at: {
        type: 'REORDER',
        destination: {
          index: preset.inForeign2.descriptor.index,
          droppableId: preset.foreign.descriptor.id,
        },
      },
    };
    expect(impact).toEqual(inForeignImpact);
  }
  // $ExpectError - casting as different state type
  const inForeignState: DraggingState = update({
    state: inHomeState,
    clientSelection: moveToForeign.clientSelection,
    impact: inForeignImpact,
  });

  // adding item after inHome4
  const added: DraggableDimension = {
    ...preset.inForeign4,
    descriptor: {
      ...preset.inForeign4.descriptor,
      index: preset.inForeign4.descriptor.index + 1,
      id: 'added',
    },
  };
  const collectingState: CollectingState = {
    phase: 'COLLECTING',
    ...inForeignState,
    // appeasing flow
    // eslint-disable-next-line
    phase: 'COLLECTING',
  };
  const published: Published = {
    ...empty,
    additions: [added],
    modified: [{ droppableId: virtualForeign.descriptor.id, scroll: origin }],
  };

  const result: DraggingState | DropPendingState = publish({
    state: collectingState,
    published,
  });
  invariant(result.phase === 'DRAGGING');

  const displaced: DisplacementGroups = getForcedDisplacement({
    visible: [
      // original animation unchanged
      { dimension: preset.inForeign2, shouldAnimate: true },
      { dimension: preset.inForeign3, shouldAnimate: true },
      { dimension: preset.inForeign4, shouldAnimate: true },
      // addition
      { dimension: added, shouldAnimate: true },
    ],
  });
  const expected: DragImpact = {
    // same destination
    ...inForeignImpact,
    displaced,
  };
  expect(result.impact).toEqual(expected);
})",snuts
/test/unit/state/publish-while-dragging/displacement-animation.spec.js,VerboseStatement,"{'startLine':27,'endLine':116}","it('should not animate any displacement', () => {
  // inHome1 currently in foreign
  // adding item to foreign list
  // we are ensuring this displacement is not animated

  const inHomeState: DraggingState = addDroppable(
    state.dragging(),
    virtualForeign,
  );
  const moveToForeign: ?PublicResult = moveInDirection({
    state: inHomeState,
    type: 'MOVE_RIGHT',
  });
  invariant(moveToForeign);
  const inForeignImpact: DragImpact = moveToForeign.impact;
  // validation
  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        // initial movement goes after inForeign1
        { dimension: preset.inForeign2, shouldAnimate: true },
        { dimension: preset.inForeign3, shouldAnimate: true },
        { dimension: preset.inForeign4, shouldAnimate: true },
      ],
    });
    const impact: DragImpact = {
      displaced,
      displacedBy: getDisplacedBy(vertical, preset.inHome1.displaceBy),
      at: {
        type: 'REORDER',
        destination: {
          index: preset.inForeign2.descriptor.index,
          droppableId: preset.foreign.descriptor.id,
        },
      },
    };
    expect(impact).toEqual(inForeignImpact);
  }
  // $ExpectError - casting as different state type
  const inForeignState: DraggingState = update({
    state: inHomeState,
    clientSelection: moveToForeign.clientSelection,
    impact: inForeignImpact,
  });

  // adding item after inHome4
  const added: DraggableDimension = {
    ...preset.inForeign4,
    descriptor: {
      ...preset.inForeign4.descriptor,
      index: preset.inForeign4.descriptor.index + 1,
      id: 'added',
    },
  };
  const collectingState: CollectingState = {
    phase: 'COLLECTING',
    ...inForeignState,
    // appeasing flow
    // eslint-disable-next-line
    phase: 'COLLECTING',
  };
  const published: Published = {
    ...empty,
    additions: [added],
    modified: [{ droppableId: virtualForeign.descriptor.id, scroll: origin }],
  };

  const result: DraggingState | DropPendingState = publish({
    state: collectingState,
    published,
  });
  invariant(result.phase === 'DRAGGING');

  const displaced: DisplacementGroups = getForcedDisplacement({
    visible: [
      // original animation unchanged
      { dimension: preset.inForeign2, shouldAnimate: true },
      { dimension: preset.inForeign3, shouldAnimate: true },
      { dimension: preset.inForeign4, shouldAnimate: true },
      // addition
      { dimension: added, shouldAnimate: true },
    ],
  });
  const expected: DragImpact = {
    // same destination
    ...inForeignImpact,
    displaced,
  };
  expect(result.impact).toEqual(expected);
})",snuts
/test/unit/state/registry/queries.spec.js,IdenticalTestDescription,"{'startLine':65,'endLine':67}","it('should return null if an item does not exist', () => {
      expect(registry.draggable.exists('unknown id')).toBe(false);
    })",snuts
/test/unit/state/registry/queries.spec.js,IdenticalTestDescription,"{'startLine':104,'endLine':106}","it('should return an item', () => {
      expect(registry.droppable.getById(preset.home.descriptor.id)).toBe(home);
    })",snuts
/test/unit/state/registry/queries.spec.js,IdenticalTestDescription,"{'startLine':107,'endLine':109}","it('should throw if no item exists', () => {
      expect(() => registry.droppable.getById('some unknown id')).toThrow();
    })",snuts
/test/unit/state/registry/queries.spec.js,IdenticalTestDescription,"{'startLine':112,'endLine':114}","it('should return an item if it exists', () => {
      expect(registry.droppable.findById(preset.home.descriptor.id)).toBe(home);
    })",snuts
/test/unit/state/registry/queries.spec.js,IdenticalTestDescription,"{'startLine':115,'endLine':117}","it('should return null if an item does not exist', () => {
      expect(registry.droppable.findById('unknown id')).toBe(null);
    })",snuts
/test/unit/state/registry/queries.spec.js,IdenticalTestDescription,"{'startLine':120,'endLine':122}","it('should return true if an item exists', () => {
      expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(true);
    })",snuts
/test/unit/state/registry/queries.spec.js,IdenticalTestDescription,"{'startLine':123,'endLine':125}","it('should return null if an item does not exist', () => {
      expect(registry.droppable.exists('unknown id')).toBe(false);
    })",snuts
/test/unit/state/registry/queries.spec.js,IdenticalTestDescription,"{'startLine':128,'endLine':132}","it('should only return items of the correct type', () => {
      expect(
        registry.droppable.getAllByType(preset.home.descriptor.type),
      ).toEqual([home, foreign]);
    })",snuts
/test/unit/state/registry/queries.spec.js,SubOptimalAssert,"{'startLine':56,'endLine':56}","it('should return null if an item does not exist', () => {
      expect(registry.draggable.findById('unknown id')).toBe(null);
    })",snuts
/test/unit/state/registry/queries.spec.js,SubOptimalAssert,"{'startLine':116,'endLine':116}","it('should return null if an item does not exist', () => {
      expect(registry.droppable.findById('unknown id')).toBe(null);
    })",snuts
/test/unit/state/registry/droppable-registration.spec.js,SubOptimalAssert,"{'startLine':34,'endLine':34}","it('should allow unregistration', () => {
  const registry: Registry = createRegistry();
  const entry: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });

  registry.droppable.register(entry);
  registry.droppable.unregister(entry);

  expect(registry.droppable.findById(entry.descriptor.id)).toBe(null);
})",snuts
/test/unit/state/registry/droppable-registration.spec.js,SubOptimalAssert,"{'startLine':86,'endLine':86}","it('should allow unregistrations when there is no entry', () => {
  const registry: Registry = createRegistry();
  const entry1: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });

  // no registration
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(null);

  expect(() => {
    registry.droppable.unregister(entry1);
  }).not.toThrow();
})",snuts
/test/unit/state/registry/draggable-registration.spec.js,SubOptimalAssert,"{'startLine':34,'endLine':34}","it('should allow unregistration', () => {
  const registry: Registry = createRegistry();
  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry);
  registry.draggable.unregister(entry);

  expect(registry.draggable.findById(entry.descriptor.id)).toBe(null);
})",snuts
/test/unit/state/registry/draggable-registration.spec.js,SubOptimalAssert,"{'startLine':136,'endLine':136}","it('should allow unregistrations when there is no entry', () => {
  // this can happen if an unregistration occurs after a .clean
  const registry: Registry = createRegistry();
  const entry1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });

  // no registration
  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(null);

  expect(() => {
    registry.draggable.unregister(entry1);
  }).not.toThrow();
})",snuts
/test/unit/state/move-in-direction/move-in-direction.spec.js,SubOptimalAssert,"{'startLine':158,'endLine':163}","it('should not allow movement on the main axis if lifting in a disabled droppable', () => {
      const custom: DraggingState = state.dragging();

      // no destination when lifting in disabled droppable
      custom.impact.at = null;
      // disabling the droppable for good measure
      const critical: DroppableDimension =
        custom.dimensions.droppables[custom.critical.droppable.id];
      custom.dimensions.droppables[
        custom.critical.droppable.id
      ] = disableDroppable(critical);

      // Main axis movement not allowed
      const forward = axis.direction === 'vertical' ? 'MOVE_DOWN' : 'MOVE_LEFT';
      const backward = axis.direction === 'vertical' ? 'MOVE_UP' : 'MOVE_RIGHT';
      expect(
        moveInDirection({
          state: custom,
          type: forward,
        }),
      ).toBe(null);
      expect(
        moveInDirection({
          state: custom,
          type: backward,
        }),
      ).toBe(null);

      // cross axis movement allowed
      const crossAxisForward =
        axis.direction === 'vertical' ? 'MOVE_RIGHT' : 'MOVE_DOWN';

      const result: ?PublicResult = moveInDirection({
        state: state.dragging(),
        type: crossAxisForward,
      });

      invariant(result, 'expected a result');
      const expected: DraggableLocation = {
        droppableId: preset.foreign.descriptor.id,
        index: 1,
      };
      expect(tryGetDestination(result.impact)).toEqual(expected);
    })",snuts
/test/unit/state/move-in-direction/move-in-direction.spec.js,SubOptimalAssert,"{'startLine':164,'endLine':169}","it('should not allow movement on the main axis if lifting in a disabled droppable', () => {
      const custom: DraggingState = state.dragging();

      // no destination when lifting in disabled droppable
      custom.impact.at = null;
      // disabling the droppable for good measure
      const critical: DroppableDimension =
        custom.dimensions.droppables[custom.critical.droppable.id];
      custom.dimensions.droppables[
        custom.critical.droppable.id
      ] = disableDroppable(critical);

      // Main axis movement not allowed
      const forward = axis.direction === 'vertical' ? 'MOVE_DOWN' : 'MOVE_LEFT';
      const backward = axis.direction === 'vertical' ? 'MOVE_UP' : 'MOVE_RIGHT';
      expect(
        moveInDirection({
          state: custom,
          type: forward,
        }),
      ).toBe(null);
      expect(
        moveInDirection({
          state: custom,
          type: backward,
        }),
      ).toBe(null);

      // cross axis movement allowed
      const crossAxisForward =
        axis.direction === 'vertical' ? 'MOVE_RIGHT' : 'MOVE_DOWN';

      const result: ?PublicResult = moveInDirection({
        state: state.dragging(),
        type: crossAxisForward,
      });

      invariant(result, 'expected a result');
      const expected: DraggableLocation = {
        droppableId: preset.foreign.descriptor.id,
        index: 1,
      };
      expect(tryGetDestination(result.impact)).toEqual(expected);
    })",snuts
/test/unit/state/middleware/validate-indexes.spec.js,OvercommentedTest,"{'startLine':45,'endLine':93}","it('should log a warning if items are added that do not have consecutive indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome2: DraggableDimension = {
    ...preset.inHome2,
    descriptor: {
      ...preset.inHome2.descriptor,
      index: preset.inHome2.descriptor.index + 5,
    },
  };
  const copied: DimensionMap = copy(preset.dimensions);
  copied.draggables[preset.inHome2.descriptor.id] = customInHome2;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(copied),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions: copied,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    // dimensions will be ordered by index
    // inHome1: index 0: all good
    // inHome3: index 2: boom
    // inHome4: index 3: all good (2 + 1)
    // inHome2: index 6: boom
    expect.stringContaining(`0, [ðŸ”¥2], 3, [ðŸ”¥6]`),
  );

  warn.mockRestore();
})",snuts
/test/unit/state/middleware/validate-indexes.spec.js,NonFunctionalStatement,"{'startLine':46,'endLine':46}","it('should log a warning if items are added that do not have consecutive indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome2: DraggableDimension = {
    ...preset.inHome2,
    descriptor: {
      ...preset.inHome2.descriptor,
      index: preset.inHome2.descriptor.index + 5,
    },
  };
  const copied: DimensionMap = copy(preset.dimensions);
  copied.draggables[preset.inHome2.descriptor.id] = customInHome2;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(copied),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions: copied,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    // dimensions will be ordered by index
    // inHome1: index 0: all good
    // inHome3: index 2: boom
    // inHome4: index 3: all good (2 + 1)
    // inHome2: index 6: boom
    expect.stringContaining(`0, [ðŸ”¥2], 3, [ðŸ”¥6]`),
  );

  warn.mockRestore();
})",snuts
/test/unit/state/middleware/validate-indexes.spec.js,NonFunctionalStatement,"{'startLine':96,'endLine':96}","it('should log a warning if items are added have duplicate indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome4: DraggableDimension = {
    ...preset.inHome4,
    descriptor: {
      ...preset.inHome4.descriptor,
      // duplicate index
      index: preset.inHome3.descriptor.index,
    },
  };
  const dimensions: DimensionMap = copy(preset.dimensions);
  dimensions.draggables[preset.inHome4.descriptor.id] = customInHome4;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(dimensions),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('0, 1, [ðŸ”¥2], [ðŸ”¥2]'),
  );

  warn.mockRestore();
})",snuts
/test/unit/state/middleware/validate-indexes.spec.js,VerboseStatement,"{'startLine':45,'endLine':93}","it('should log a warning if items are added that do not have consecutive indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome2: DraggableDimension = {
    ...preset.inHome2,
    descriptor: {
      ...preset.inHome2.descriptor,
      index: preset.inHome2.descriptor.index + 5,
    },
  };
  const copied: DimensionMap = copy(preset.dimensions);
  copied.draggables[preset.inHome2.descriptor.id] = customInHome2;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(copied),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions: copied,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    // dimensions will be ordered by index
    // inHome1: index 0: all good
    // inHome3: index 2: boom
    // inHome4: index 3: all good (2 + 1)
    // inHome2: index 6: boom
    expect.stringContaining(`0, [ðŸ”¥2], 3, [ðŸ”¥6]`),
  );

  warn.mockRestore();
})",snuts
/test/unit/state/middleware/validate-indexes.spec.js,VerboseStatement,"{'startLine':95,'endLine':139}","it('should log a warning if items are added have duplicate indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome4: DraggableDimension = {
    ...preset.inHome4,
    descriptor: {
      ...preset.inHome4.descriptor,
      // duplicate index
      index: preset.inHome3.descriptor.index,
    },
  };
  const dimensions: DimensionMap = copy(preset.dimensions);
  dimensions.draggables[preset.inHome4.descriptor.id] = customInHome4;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(dimensions),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('0, 1, [ðŸ”¥2], [ðŸ”¥2]'),
  );

  warn.mockRestore();
})",snuts
/test/unit/state/middleware/pending-drop.spec.js,VerboseStatement,"{'startLine':21,'endLine':55}","it('should trigger a drop on a dynamic publish if a drop pending is waiting', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    // will fire the pending drop action
    dropMiddleware,
    middleware,
  );

  store.dispatch(initialPublish(initialPublishWithScrollables));
  store.dispatch(collectionStarting());
  store.dispatch(drop({ reason: 'DROP' }));

  const postDrop: State = store.getState();
  invariant(
    postDrop.phase === 'DROP_PENDING',
    `Incorrect phase : ${postDrop.phase}`,
  );
  expect(postDrop.isWaiting).toBe(true);

  // This will finish the drag
  mock.mockReset();
  store.dispatch(publishWhileDragging(publishAdditionArgs));

  expect(mock).toHaveBeenCalledWith(drop({ reason: 'DROP' }));

  expect(mock).toHaveBeenCalledWith(
    // $ExpectError - this calculation is not completed by this module and it is non trival
    completeDrop({
      completed: expect.any(Object),
    }),
  );
  expect(mock).toHaveBeenCalledTimes(3);
  expect(store.getState().phase).toBe('IDLE');
})",snuts
/test/unit/state/middleware/lift.spec.js,OvercommentedTest,"{'startLine':71,'endLine':109}","it('should flush any animating drops', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // start a drag
  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');

  const completed: CompletedDrag = getCompletedArgs('DROP').completed;

  // start a drop
  const args: AnimateDropArgs = {
    newHomeClientOffset: { x: -1, y: -1 },
    dropDuration: 1,
    completed,
  };
  store.dispatch(animateDrop(args));
  expect(store.getState().phase).toBe('DROP_ANIMATING');

  // while drop animating a lift occurs
  mock.mockReset();
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // the previous drag is flushed
  expect(mock).toHaveBeenCalledWith(completeDrop({ completed }));
  // any animations are flushed
  expect(mock).toHaveBeenCalledWith(flush());
  // a before capture is fired
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  // the new lift continues
  expect(mock).toHaveBeenCalledTimes(5);
})",snuts
/test/unit/state/middleware/lift.spec.js,VerboseStatement,"{'startLine':71,'endLine':109}","it('should flush any animating drops', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // start a drag
  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');

  const completed: CompletedDrag = getCompletedArgs('DROP').completed;

  // start a drop
  const args: AnimateDropArgs = {
    newHomeClientOffset: { x: -1, y: -1 },
    dropDuration: 1,
    completed,
  };
  store.dispatch(animateDrop(args));
  expect(store.getState().phase).toBe('DROP_ANIMATING');

  // while drop animating a lift occurs
  mock.mockReset();
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // the previous drag is flushed
  expect(mock).toHaveBeenCalledWith(completeDrop({ completed }));
  // any animations are flushed
  expect(mock).toHaveBeenCalledWith(flush());
  // a before capture is fired
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  // the new lift continues
  expect(mock).toHaveBeenCalledTimes(5);
})",snuts
/test/unit/state/get-droppable-over/is-over-nothing.spec.js,SubOptimalAssert,"{'startLine':19,'endLine':19}","it('should return null when over nothing', () => {
  const result: ?DroppableId = getDroppableOver({
    pageBorderBox: offsetRectByPosition(preset.inHome1.page.borderBox, {
      x: 10000,
      y: 10000,
    }),
    draggable: preset.inHome1,
    droppables: preset.droppables,
  });

  expect(result).toBe(null);
})",snuts
/test/unit/state/get-droppable-over/is-not-visible.spec.js,SubOptimalAssert,"{'startLine':122,'endLine':122}","it('should not hit when inside subject, but outside the frame', () => {
  const droppable: DroppableDimension = getDroppableDimension({
    descriptor: {
      id: droppableId,
      type,
      mode: 'standard',
    },
    borderBox: {
      top: 0,
      left: 0,
      right: 100,
      bottom: 100,
    },
    closest: {
      borderBox: {
        top: 0,
        left: 0,
        right: 50,
        bottom: 50,
      },
      scrollSize: {
        scrollHeight: 100,
        scrollWidth: 100,
      },
      scroll: { x: 0, y: 0 },
      shouldClipSubject: true,
    },
  });
  const target: Position = { x: 60, y: 60 };
  const distance: Position = subtract(target, dragging.page.borderBox.center);

  const pageBorderBox: Rect = offsetRectByPosition(
    dragging.page.borderBox,
    distance,
  );

  const result: ?DroppableId = getDroppableOver({
    pageBorderBox,
    draggable: dragging,
    droppables: { [droppableId]: droppable },
  });

  expect(result).toBe(null);
})",snuts
/test/unit/state/get-droppable-over/is-not-visible.spec.js,SubOptimalAssert,"{'startLine':167,'endLine':167}","it('should not hit when outside subject and inside the frame (partially visible subject)', () => {
  const droppable: DroppableDimension = getDroppableDimension({
    descriptor: {
      id: droppableId,
      type,
      mode: 'standard',
    },
    borderBox: {
      top: 0,
      left: 0,
      right: 100,
      bottom: 100,
    },
    closest: {
      borderBox: {
        top: 0,
        left: 0,
        right: 200,
        bottom: 200,
      },
      scrollSize: {
        scrollHeight: 200,
        scrollWidth: 200,
      },
      scroll: { x: 0, y: 0 },
      shouldClipSubject: true,
    },
  });
  const target: Position = { x: 120, y: 120 };
  const distance: Position = subtract(target, dragging.page.borderBox.center);

  const pageBorderBox: Rect = offsetRectByPosition(
    dragging.page.borderBox,
    distance,
  );

  const result: ?DroppableId = getDroppableOver({
    pageBorderBox,
    draggable: dragging,
    droppables: { [droppableId]: droppable },
  });

  expect(result).toBe(null);
})",snuts
/test/unit/state/get-droppable-over/is-not-visible.spec.js,SubOptimalAssert,"{'startLine':212,'endLine':212}","it('should not hit when outside subject and inside the frame (invisible subject)', () => {
  const droppable: DroppableDimension = getDroppableDimension({
    descriptor: {
      id: droppableId,
      type,
      mode: 'standard',
    },
    borderBox: {
      top: 0,
      left: 0,
      right: 100,
      bottom: 100,
    },
    closest: {
      borderBox: {
        top: 0,
        left: 0,
        right: 200,
        bottom: 200,
      },
      scrollSize: {
        scrollHeight: 250,
        scrollWidth: 250,
      },
      scroll: { x: 200, y: 200 },
      shouldClipSubject: true,
    },
  });
  const target: Position = { x: 250, y: 250 };
  const distance: Position = subtract(target, dragging.page.borderBox.center);

  const pageBorderBox: Rect = offsetRectByPosition(
    dragging.page.borderBox,
    distance,
  );

  const result: ?DroppableId = getDroppableOver({
    pageBorderBox,
    draggable: dragging,
    droppables: { [droppableId]: droppable },
  });

  expect(result).toBe(null);
})",snuts
/test/unit/state/get-droppable-over/is-disabled.spec.js,SubOptimalAssert,"{'startLine':26,'endLine':26}","it('should not consider lists that are disabled', () => {
  const withDisabled: DroppableDimensionMap = {
    ...preset.droppables,
    [preset.home.descriptor.id]: disableDroppable(preset.home),
  };

  const whileEnabled: ?DroppableId = getDroppableOver({
    pageBorderBox: preset.inHome1.page.borderBox,
    draggable: preset.inHome1,
    droppables: preset.droppables,
  });
  const whileDisabled: ?DroppableId = getDroppableOver({
    pageBorderBox: preset.inHome1.page.borderBox,
    draggable: preset.inHome1,
    droppables: withDisabled,
  });

  expect(whileEnabled).toBe(preset.home.descriptor.id);
  expect(whileDisabled).toBe(null);
})",snuts
/test/unit/state/get-droppable-over/center-is-over.spec.js,SubOptimalAssert,"{'startLine':68,'endLine':68}","it('should not return a match when the center is not over a list (and no other candidate conditions are met)', () => {
      const outside: Position[] = getCorners(
        // getting corners of a slightly bigger active
        // which would be outside the current active
        expandByPosition(active, patch(axis.line, 1)),
      );

      outside.forEach((corner: Position) => {
        const pageOffset: Position = subtract(
          corner,
          draggable.page.borderBox.center,
        );
        const pageBorderBox: Rect = offsetRectByPosition(
          draggable.page.borderBox,
          pageOffset,
        );
        const result: ?DroppableId = getDroppableOver({
          pageBorderBox,
          draggable,
          droppables: preset.droppables,
        });

        expect(result).toBe(null);
      });
    })",snuts
/test/unit/state/droppable/with-placeholder.spec.js,OvercommentedTest,"{'startLine':315,'endLine':359}","it('should always grow the subject required', () => {
        const inHome: DraggableDimension = getHomeDraggable(gap - 5);
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          inHome.displaceBy,
        );
        // increasing by the whole amount, not just the gap
        // for virtual lists we cannot count the size of existing items
        // as they all might not be there
        const increasedBy: Position = patch(axis.line, displacedBy.value);

        const result: DroppableDimension = addPlaceholder(
          virtual,
          inHome,
          withHomeDraggable(inHome),
        );

        const active: ?Rect = virtual.subject.active;
        invariant(active);
        const expected: DroppableSubject = {
          // unchanged
          page: virtual.subject.page,
          // increased
          active: getRect({
            ...active,
            [axis.end]: active[axis.end] + displacedBy.value,
          }),
          // added
          withPlaceholder: {
            increasedBy,
            oldFrameMaxScroll: originalFrame.scroll.max,
            placeholderSize: getPlaceholderSize(inHome),
          },
        };
        expect(result.subject).toEqual(expected);
        // max scroll change
        const newFrame: ?Scrollable = result.frame;
        invariant(newFrame);
        expect(originalFrame.scroll.max).not.toEqual(newFrame.scroll.max);
        expect(newFrame.scroll.max).toEqual(
          add(originalFrame.scroll.max, increasedBy),
        );
        // no client change
        expect(newFrame.frameClient).toEqual(newFrame.frameClient);
      })",snuts
/test/unit/state/droppable/with-placeholder.spec.js,IdenticalTestDescription,"{'startLine':207,'endLine':234}","it('should not grow the subject if not required', () => {
        const inHome: DraggableDimension = getHomeDraggable(gap - 5);

        const result: DroppableDimension = addPlaceholder(
          withFrame,
          inHome,
          withHomeDraggable(inHome),
        );

        const expected: DroppableSubject = {
          // unchanged
          page: withFrame.subject.page,
          active: withFrame.subject.active,
          // added
          withPlaceholder: {
            increasedBy: null,
            // holding onto old max regardless
            oldFrameMaxScroll: originalFrame.scroll.max,
            placeholderSize: getPlaceholderSize(inHome),
          },
        };
        expect(result.subject).toEqual(expected);
        // no change in frame or scroll
        const newFrame: ?Scrollable = result.frame;
        invariant(newFrame);
        expect(originalFrame.scroll.max).toEqual(newFrame.scroll.max);
        expect(originalFrame).toEqual(newFrame);
      })",snuts
/test/unit/state/droppable/with-placeholder.spec.js,IdenticalTestDescription,"{'startLine':236,'endLine':274}","it('should grow the subject if required', () => {
        const excess: number = 20;
        const inHome: DraggableDimension = getHomeDraggable(gap + excess);

        const result: DroppableDimension = addPlaceholder(
          withFrame,
          inHome,
          withHomeDraggable(inHome),
        );

        const increasedBy: Position = patch(axis.line, excess);
        const active: ?Rect = withFrame.subject.active;
        invariant(active);
        const expected: DroppableSubject = {
          // unchanged
          page: withFrame.subject.page,
          // increased
          active: getRect({
            ...active,
            [axis.end]: active[axis.end] + excess,
          }),
          // added
          withPlaceholder: {
            increasedBy,
            oldFrameMaxScroll: originalFrame.scroll.max,
            placeholderSize: getPlaceholderSize(inHome),
          },
        };
        expect(result.subject).toEqual(expected);
        // max scroll change
        const newFrame: ?Scrollable = result.frame;
        invariant(newFrame);
        expect(originalFrame.scroll.max).not.toEqual(newFrame.scroll.max);
        expect(newFrame.scroll.max).toEqual(
          add(originalFrame.scroll.max, increasedBy),
        );
        // no client change
        expect(newFrame.frameClient).toEqual(newFrame.frameClient);
      })",snuts
/test/unit/state/droppable/with-placeholder.spec.js,IdenticalTestDescription,"{'startLine':361,'endLine':373}","it('should restore the original frame when placeholder is no longer needed', () => {
        const excess: number = 20;
        const inHome: DraggableDimension = getHomeDraggable(gap + excess);

        const added: DroppableDimension = addPlaceholder(
          virtual,
          inHome,
          withHomeDraggable(inHome),
        );
        const removed: DroppableDimension = removePlaceholder(added);

        expect(removed).toEqual(virtual);
      })",snuts
/test/unit/state/droppable/scroll-droppable.spec.js,OvercommentedTest,"{'startLine':27,'endLine':118}","it('should update the frame scroll and the subject', () => {
  const scrollSize: ScrollSize = {
    scrollHeight: 500,
    scrollWidth: 100,
  };
  const customClient: BoxModel = createBox({
    borderBox: {
      // 500 px high
      top: 0,
      left: 0,
      bottom: scrollSize.scrollHeight,
      right: scrollSize.scrollWidth,
    },
  });
  const customPage: BoxModel = customClient;
  const frameClient: BoxModel = createBox({
    borderBox: {
      // only viewing top 100px
      bottom: 100,
      // unchanged
      top: 0,
      right: scrollSize.scrollWidth,
      left: 0,
    },
  });
  const framePage: BoxModel = frameClient;
  const originalFrameScroll: Position = { x: 0, y: 0 };
  const droppable: DroppableDimension = getDroppable({
    descriptor,
    client: customClient,
    page: customPage,
    direction: 'vertical',
    isEnabled: true,
    isCombineEnabled: false,
    isFixedOnPage: false,
    closest: {
      client: frameClient,
      page: framePage,
      scrollSize,
      scroll: originalFrameScroll,
      shouldClipSubject: true,
    },
  });

  const originalFrame: ?Scrollable = droppable.frame;
  invariant(originalFrame);
  // original frame
  expect(originalFrame.pageMarginBox).toEqual(framePage.marginBox);
  // subject is currently clipped by the frame
  expect(droppable.subject.active).toEqual(framePage.marginBox);

  // scrolling down
  const newScroll: Position = { x: 0, y: 100 };
  const updated: DroppableDimension = scrollDroppable(droppable, newScroll);
  const updatedFrame: ?Scrollable = updated.frame;
  invariant(updatedFrame);

  // unchanged frame client
  expect(updatedFrame.frameClient).toEqual(originalFrame.frameClient);
  expect(updatedFrame.pageMarginBox).toEqual(framePage.marginBox);

  // updated scroll info
  {
    const expected: ScrollDetails = {
      initial: originalFrameScroll,
      current: newScroll,
      diff: {
        value: newScroll,
        displacement: negate(newScroll),
      },
      max: getMaxScroll({
        scrollWidth: scrollSize.scrollWidth,
        scrollHeight: scrollSize.scrollHeight,
        width: frameClient.paddingBox.width,
        height: frameClient.paddingBox.height,
      }),
    };
    expect(updatedFrame.scroll).toEqual(expected);
  }

  // updated clipped
  // can now see the bottom half of the subject
  expect(updated.subject.active).toEqual(
    getRect({
      top: 0,
      bottom: 100,
      // unchanged
      right: 100,
      left: 0,
    }),
  );
})",snuts
/test/unit/state/droppable/scroll-droppable.spec.js,VerboseStatement,"{'startLine':27,'endLine':118}","it('should update the frame scroll and the subject', () => {
  const scrollSize: ScrollSize = {
    scrollHeight: 500,
    scrollWidth: 100,
  };
  const customClient: BoxModel = createBox({
    borderBox: {
      // 500 px high
      top: 0,
      left: 0,
      bottom: scrollSize.scrollHeight,
      right: scrollSize.scrollWidth,
    },
  });
  const customPage: BoxModel = customClient;
  const frameClient: BoxModel = createBox({
    borderBox: {
      // only viewing top 100px
      bottom: 100,
      // unchanged
      top: 0,
      right: scrollSize.scrollWidth,
      left: 0,
    },
  });
  const framePage: BoxModel = frameClient;
  const originalFrameScroll: Position = { x: 0, y: 0 };
  const droppable: DroppableDimension = getDroppable({
    descriptor,
    client: customClient,
    page: customPage,
    direction: 'vertical',
    isEnabled: true,
    isCombineEnabled: false,
    isFixedOnPage: false,
    closest: {
      client: frameClient,
      page: framePage,
      scrollSize,
      scroll: originalFrameScroll,
      shouldClipSubject: true,
    },
  });

  const originalFrame: ?Scrollable = droppable.frame;
  invariant(originalFrame);
  // original frame
  expect(originalFrame.pageMarginBox).toEqual(framePage.marginBox);
  // subject is currently clipped by the frame
  expect(droppable.subject.active).toEqual(framePage.marginBox);

  // scrolling down
  const newScroll: Position = { x: 0, y: 100 };
  const updated: DroppableDimension = scrollDroppable(droppable, newScroll);
  const updatedFrame: ?Scrollable = updated.frame;
  invariant(updatedFrame);

  // unchanged frame client
  expect(updatedFrame.frameClient).toEqual(originalFrame.frameClient);
  expect(updatedFrame.pageMarginBox).toEqual(framePage.marginBox);

  // updated scroll info
  {
    const expected: ScrollDetails = {
      initial: originalFrameScroll,
      current: newScroll,
      diff: {
        value: newScroll,
        displacement: negate(newScroll),
      },
      max: getMaxScroll({
        scrollWidth: scrollSize.scrollWidth,
        scrollHeight: scrollSize.scrollHeight,
        width: frameClient.paddingBox.width,
        height: frameClient.paddingBox.height,
      }),
    };
    expect(updatedFrame.scroll).toEqual(expected);
  }

  // updated clipped
  // can now see the bottom half of the subject
  expect(updated.subject.active).toEqual(
    getRect({
      top: 0,
      bottom: 100,
      // unchanged
      right: 100,
      left: 0,
    }),
  );
})",snuts
/test/unit/state/droppable/get-droppable.spec.js,SubOptimalAssert,"{'startLine':84,'endLine':84}","it('should not have a closest scrollable if there is no closest scrollable', () => {
      const dimension: DroppableDimension = getDroppableDimension({
        descriptor,
        isEnabled: true,
        isCombineEnabled: false,
        isFixedOnPage: false,
        client,
        page,
        direction: 'vertical',
        closest: null,
      });

      expect(dimension.frame).toBe(null);
    })",snuts
/test/unit/state/auto-scroll/jump-scroller.spec.js,IdenticalTestDescription,"{'startLine':138,'endLine':156}","it('should manually move the item if the window is unable to scroll', () => {
          // unable to scroll backwards to start with
          const request: Position = patch(axis.line, -1);
          const existing: DraggingState = state.scrollJumpRequest(
            request,
            unscrollableViewport,
          );
          const expected: Position = add(
            existing.current.client.selection,
            request,
          );

          jumpScroll(existing);

          expect(mocks.move).toHaveBeenCalledWith({
            client: expected,
          });
          expect(mocks.scrollWindow).not.toHaveBeenCalled();
        })",snuts
/test/unit/state/auto-scroll/jump-scroller.spec.js,IdenticalTestDescription,"{'startLine':158,'endLine':169}","it('should scroll the window if can absorb all of the movement', () => {
          const scrolled: Viewport = scrollViewport(
            scrollableViewport,
            patch(axis.line, 1),
          );
          const request: Position = patch(axis.line, -1);

          jumpScroll(state.scrollJumpRequest(request, scrolled));

          expect(mocks.scrollWindow).toHaveBeenCalledWith(request);
          expect(mocks.move).not.toHaveBeenCalled();
        })",snuts
/test/unit/state/auto-scroll/jump-scroller.spec.js,IdenticalTestDescription,"{'startLine':171,'endLine':198}","it('should manually move the item any distance that the window is unable to scroll', () => {
          // only allowing scrolling by 1 px
          const windowScroll: Position = patch(axis.line, 1);
          const scrolled: Viewport = scrollViewport(
            scrollableViewport,
            windowScroll,
          );
          // more than the 1 pixel allowed
          const request: Position = patch(axis.line, -3);
          const existing: DraggingState = state.scrollJumpRequest(
            request,
            scrolled,
          );
          const expected: Position = add(
            existing.current.client.selection,
            // the two pixels that could not be done by the window
            patch(axis.line, -2),
          );

          jumpScroll(existing);

          // can scroll with what we have
          expect(mocks.scrollWindow).toHaveBeenCalledWith(patch(axis.line, -1));
          // remainder to be done by movement
          expect(mocks.move).toHaveBeenCalledWith({
            client: expected,
          });
        })",snuts
/test/unit/state/auto-scroll/jump-scroller.spec.js,IdenticalTestDescription,"{'startLine':436,'endLine':457}","it('should only scroll the droppable', () => {
            // move forward slightly to allow us to move forwards
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              patch(axis.line, 1),
            );
            const request: Position = patch(axis.line, -1);

            jumpScroll(
              addDroppable(
                state.scrollJumpRequest(request, scrollableViewport),
                scrolled,
              ),
            );

            expect(mocks.scrollDroppable).toHaveBeenCalledWith(
              scrolled.descriptor.id,
              request,
            );
            expect(mocks.scrollWindow).not.toHaveBeenCalled();
            expect(mocks.move).not.toHaveBeenCalled();
          })",snuts
/test/unit/state/auto-scroll/jump-scroller.spec.js,IdenticalTestDescription,"{'startLine':461,'endLine':479}","it('should manually move the entire request if it is unable to be partially completed by the window or the droppable', () => {
            const request: Position = patch(axis.line, -1);
            const existing: DraggingState = state.scrollJumpRequest(
              request,
              unscrollableViewport,
            );
            const expected: Position = add(
              existing.current.client.selection,
              request,
            );

            jumpScroll(addDroppable(existing, scrollable));

            expect(mocks.scrollWindow).not.toHaveBeenCalled();
            expect(mocks.scrollDroppable).not.toHaveBeenCalled();
            expect(mocks.move).toHaveBeenCalledWith({
              client: expected,
            });
          })",snuts
/test/unit/state/auto-scroll/jump-scroller.spec.js,IdenticalTestDescription,"{'startLine':482,'endLine':511}","it('should scroll the droppable what it can and move the rest', () => {
              // able to scroll 1 pixel forward
              const scrolled: DroppableDimension = scrollDroppable(
                scrollable,
                patch(axis.line, 1),
              );
              // want to move backwards 3 pixels
              const request: Position = patch(axis.line, -3);
              const existing: DraggingState = state.scrollJumpRequest(
                request,
                unscrollableViewport,
              );
              // manual move will take what the droppable cannot
              const expectedManualMove: Position = add(
                existing.current.client.selection,
                patch(axis.line, -2),
              );

              jumpScroll(addDroppable(existing, scrolled));

              expect(mocks.scrollWindow).not.toHaveBeenCalled();
              expect(mocks.scrollDroppable).toHaveBeenCalledWith(
                preset.home.descriptor.id,
                // can only scroll backwards what it has!
                patch(axis.line, -1),
              );
              expect(mocks.move).toHaveBeenCalledWith({
                client: expectedManualMove,
              });
            })",snuts
/test/unit/state/auto-scroll/jump-scroller.spec.js,IdenticalTestDescription,"{'startLine':515,'endLine':543}","it('should scroll the entire overlap if it can', () => {
              // let the window scroll be enough to move back into
              const scrolledViewport: Viewport = scrollViewport(
                scrollableViewport,
                patch(axis.line, 100),
              );
              const scrolledDroppable: DroppableDimension = scrollDroppable(
                scrollable,
                patch(axis.line, 1),
              );
              // want to move 3 pixels backwards
              const request: Position = patch(axis.line, -3);

              jumpScroll(
                addDroppable(
                  state.scrollJumpRequest(request, scrolledViewport),
                  scrolledDroppable,
                ),
              );

              expect(mocks.scrollDroppable).toHaveBeenCalledWith(
                scrolledDroppable.descriptor.id,
                patch(axis.line, -1),
              );
              expect(mocks.scrollWindow).toHaveBeenCalledWith(
                patch(axis.line, -2),
              );
              expect(mocks.move).not.toHaveBeenCalled();
            })",snuts
/test/unit/state/auto-scroll/jump-scroller.spec.js,IdenticalTestDescription,"{'startLine':545,'endLine':583}","it('should scroll the droppable and window by what it can, and manually move the rest', () => {
              // Setting the window scroll so it has a small amount of available space
              const windowScroll: Position = patch(axis.line, 2);
              const scrolledViewport: Viewport = scrollViewport(
                scrollableViewport,
                windowScroll,
              );
              // Setting the droppable scroll so it has a small amount of available space
              const droppableScroll: Position = patch(axis.line, 1);
              const scrolled: DroppableDimension = scrollDroppable(
                scrollable,
                droppableScroll,
              );
              // How much we want to scroll
              const request: Position = patch(axis.line, -5);
              // How much we will not be able to absorb with droppable and window scroll
              const remainder: Position = patch(axis.line, -2);
              const existing: DraggingState = addDroppable(
                state.scrollJumpRequest(request, scrolledViewport),
                scrolled,
              );
              const expectedManualMove: Position = add(
                existing.current.client.selection,
                remainder,
              );

              jumpScroll(existing);

              expect(mocks.scrollDroppable).toHaveBeenCalledWith(
                scrolled.descriptor.id,
                negate(droppableScroll),
              );
              expect(mocks.scrollWindow).toHaveBeenCalledWith(
                negate(windowScroll),
              );
              expect(mocks.move).toHaveBeenCalledWith({
                client: expectedManualMove,
              });
            })",snuts
/test/unit/state/auto-scroll/jump-scroller.spec.js,VerboseStatement,"{'startLine':373,'endLine':429}","it('should scroll the droppable and window by what it can, and manually move the rest', () => {
              // Setting the window scroll so it has a small amount of available space
              const availableWindowScroll: Position = patch(axis.line, 2);
              const maxWindowScroll: Position = getMaxScroll({
                scrollHeight: windowScrollSize.scrollHeight,
                scrollWidth: windowScrollSize.scrollWidth,
                height: scrollableViewport.frame.height,
                width: scrollableViewport.frame.width,
              });
              const windowScroll: Position = subtract(
                maxWindowScroll,
                availableWindowScroll,
              );
              // setWindowScroll(windowScroll);
              const scrolledViewport: Viewport = scrollViewport(
                scrollableViewport,
                windowScroll,
              );
              // Setting the droppable scroll so it has a small amount of available space
              const availableDroppableScroll: Position = patch(axis.line, 1);
              const droppableScroll: Position = subtract(
                maxDroppableScroll,
                availableDroppableScroll,
              );
              const scrolled: DroppableDimension = scrollDroppable(
                scrollable,
                droppableScroll,
              );
              // How much we want to scroll
              const request: Position = patch(axis.line, 5);
              // How much we will not be able to absorb with droppable and window scroll
              const remainder: Position = subtract(
                subtract(request, availableDroppableScroll),
                availableWindowScroll,
              );
              const existing: DraggingState = addDroppable(
                state.scrollJumpRequest(request, scrolledViewport),
                scrolled,
              );
              const expectedManualMove: Position = add(
                existing.current.client.selection,
                remainder,
              );

              jumpScroll(existing);

              expect(mocks.scrollDroppable).toHaveBeenCalledWith(
                scrolled.descriptor.id,
                availableDroppableScroll,
              );
              expect(mocks.scrollWindow).toHaveBeenCalledWith(
                availableWindowScroll,
              );
              expect(mocks.move).toHaveBeenCalledWith({
                client: expectedManualMove,
              });
            })",snuts
/test/unit/state/auto-scroll/can-scroll.spec.js,OvercommentedTest,"{'startLine':392,'endLine':433}","it('should trim values that can be scrolled', () => {
      const items: Item[] = [
        // too far back: top
        {
          // x can be scrolled entirely
          // y can be partially scrolled
          change: { x: -20, y: -70 },
          expected: { x: 0, y: -20 },
        },
        // too far back: left
        {
          // x can be partially scrolled
          // y can be scrolled entirely
          change: { x: -70, y: -40 },
          expected: { x: -20, y: 0 },
        },
        // too far forward: right
        {
          // x can be partially scrolled
          // y can be scrolled entirely
          change: { x: 70, y: 40 },
          expected: { x: 20, y: 0 },
        },
        // too far forward: bottom
        {
          // x can be scrolled entirely
          // y can be partially scrolled
          change: { x: 20, y: 70 },
          expected: { x: 0, y: 20 },
        },
      ];

      items.forEach((item: Item) => {
        const result: ?Position = getOverlap({
          current,
          max,
          change: item.change,
        });

        expect(result).toEqual(item.expected);
      });
    })",snuts
/test/unit/state/auto-scroll/can-scroll.spec.js,IdenticalTestDescription,"{'startLine':564,'endLine':595}","it('should return the overlap', () => {
    const viewport: Viewport = createViewport({
      frame: customViewport.frame,
      scrollHeight: 200,
      scrollWidth: 200,
      scroll: {
        x: 50,
        y: 50,
      },
    });

    // little validation
    const maxScroll: Position = getMaxScroll({
      scrollHeight: 200,
      scrollWidth: 200,
      height: viewport.frame.height,
      width: viewport.frame.width,
    });
    expect(maxScroll).toEqual({ x: 100, y: 100 });

    const availableScrollSpace: Position = {
      x: 50,
      y: 50,
    };
    // cannot be absorbed in the current scroll plane
    const bigChange: Position = { x: 300, y: 300 };
    const expectedOverlap: Position = subtract(bigChange, availableScrollSpace);

    const result: ?Position = getWindowOverlap(viewport, bigChange);

    expect(result).toEqual(expectedOverlap);
  })",snuts
/test/unit/state/auto-scroll/can-scroll.spec.js,IdenticalTestDescription,"{'startLine':597,'endLine':608}","it('should return null if there is no overlap', () => {
    const viewport: Viewport = createViewport({
      frame: customViewport.frame,
      scrollHeight: 200,
      scrollWidth: 200,
      scroll: origin,
    });

    const result: ?Position = getWindowOverlap(viewport, { x: 10, y: 10 });

    expect(result).toBe(null);
  })",snuts
/test/unit/state/auto-scroll/can-scroll.spec.js,SubOptimalAssert,"{'startLine':496,'endLine':496}","it('should return null if there is no scroll container', () => {
    const result: ?Position = getDroppableOverlap(preset.home, {
      x: 1,
      y: 1,
    });

    expect(result).toBe(null);
  })",snuts
/test/unit/state/auto-scroll/can-scroll.spec.js,SubOptimalAssert,"{'startLine':508,'endLine':508}","it('should return null if the droppable cannot be scrolled', () => {
    // end of the scrollable area
    const scroll: Position = {
      x: 0,
      y: 200,
    };
    const scrolled: DroppableDimension = scrollDroppable(scrollable, scroll);
    const result: ?Position = getDroppableOverlap(scrolled, { x: 0, y: 1 });

    expect(result).toBe(null);
  })",snuts
/test/unit/state/auto-scroll/can-scroll.spec.js,SubOptimalAssert,"{'startLine':560,'endLine':560}","it('should return null if the window cannot be scrolled', () => {
    const viewport: Viewport = createViewport({
      frame: customViewport.frame,
      scrollHeight: 200,
      scrollWidth: 100,
      // already at the max scroll
      scroll: {
        x: 0,
        y: 200,
      },
    });

    const result: ?Position = getWindowOverlap(viewport, { x: 0, y: 1 });

    expect(result).toBe(null);
  })",snuts
/test/unit/state/auto-scroll/can-scroll.spec.js,SubOptimalAssert,"{'startLine':607,'endLine':607}","it('should return null if there is no overlap', () => {
    const viewport: Viewport = createViewport({
      frame: customViewport.frame,
      scrollHeight: 200,
      scrollWidth: 200,
      scroll: origin,
    });

    const result: ?Position = getWindowOverlap(viewport, { x: 10, y: 10 });

    expect(result).toBe(null);
  })",snuts
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,OvercommentedTest,"{'startLine':36,'endLine':65}","it('should not start dragging if finished before a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.advanceTimersByTime(timeForLongPress - 1);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  const touchEnd: Event = createEvent.touchEnd(handle);
  fireEvent(handle, touchEnd);

  // not a direct cancel
  expect(touchEnd.defaultPrevented).toBe(false);

  // flushing any timers
  jest.runOnlyPendingTimers();

  expect(isDragging(handle)).toBe(false);
})",snuts
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,VerboseStatement,"{'startLine':16,'endLine':41}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",snuts
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,VerboseStatement,"{'startLine':11,'endLine':36}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",snuts
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,NonFunctionalStatement,"{'startLine':24,'endLine':24}","beforeEach(() => {
    // react will log a warning if using upper case
    jest.spyOn(console, 'error').mockImplementation(() => {});
  })",snuts
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,NonFunctionalStatement,"{'startLine':15,'endLine':15}","beforeEach(() => {
    // using content editable in particular ways causes react logging
    jest.spyOn(console, 'error').mockImplementation(() => {});
  })",snuts
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,SubOptimalAssert,"{'startLine':118,'endLine':118}","it('should abort a drag if an a non-invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText, queryByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              throw new Error('Raw error throw');
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    expect(() => {
      thrower.execute();
    }).toThrow();

    // handle is gone
    expect(queryByText('item: 0')).toBe(null);

    // strange - but firing events on old handle
    expect(() => {
      control.move(handle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",snuts
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,NonFunctionalStatement,"{'startLine':14,'endLine':14}",Unknown,snuts
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,VerboseStatement,"{'startLine':22,'endLine':57}","it('should not allow pre drag actions when in a dragging phase', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  // it is currently active
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();

  // pre drag now outdated
  expect(preDrag.isActive()).toBe(false);
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );

  // drag is active - not aborted by preDrag
  expect(drag.isActive()).toBe(true);

  // ending drag
  warn.mockClear();
  act(() => drag.drop());
  expect(warn).not.toHaveBeenCalled();

  // preDrag is still out of date
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,VerboseStatement,"{'startLine':59,'endLine':84}","it('should not allow drag actions after a drop', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();
  expect(drag.isActive()).toBe(true);

  act(() => drag.cancel());

  // no longer active
  expect(drag.isActive()).toBe(false);
  expect(warn).not.toHaveBeenCalled();

  drag.moveUp();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,OvercommentedTest,"{'startLine':69,'endLine':103}","it('should not allow a sensor to obtain a on a dropping item, but can claim one on something else while dragging', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');

  // drag not started yet
  expect(isDragging(handle)).toBe(false);
  // start a drag
  const actions: FluidDragActions = preDrag.fluidLift({ x: 0, y: 0 });
  expect(isDragging(handle)).toBe(true);

  // release the movement
  actions.move({ x: 100, y: 100 });
  requestAnimationFrame.flush();

  actions.drop();
  expect(isDropAnimating(handle)).toBe(true);

  // lock is no longer active
  expect(actions.isActive()).toBe(false);
  expect(preDrag.isActive()).toBe(false);

  // cannot get a new lock while still dropping
  expect(api.tryGetLock('0', noop)).toBe(null);

  // can get a lock on a handle that is not dropping - while the other is dropping
  expect(api.tryGetLock('1', noop)).toBeTruthy();
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,NonFunctionalStatement,"{'startLine':15,'endLine':15}",Unknown,snuts
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,SubOptimalAssert,"{'startLine':36,'endLine':36}","it('should allow an exclusive lock for drag actions', () => {
  let first: SensorAPI;
  let second: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(<App sensors={[a, b]} />);
  invariant(first, 'expected first to be set');
  invariant(second, 'expected second to be set');

  // first can get a lock
  expect(first.tryGetLock('0')).toBeTruthy();

  // second cannot get a lock
  expect(second.tryGetLock('0')).toBe(null);

  // first cannot get another lock on the same element
  expect(first.tryGetLock('0')).toBe(null);

  // nothing cannot get lock on a different element
  expect(first.tryGetLock('1')).toBe(null);
  expect(second.tryGetLock('1')).toBe(null);
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,SubOptimalAssert,"{'startLine':39,'endLine':39}","it('should allow an exclusive lock for drag actions', () => {
  let first: SensorAPI;
  let second: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(<App sensors={[a, b]} />);
  invariant(first, 'expected first to be set');
  invariant(second, 'expected second to be set');

  // first can get a lock
  expect(first.tryGetLock('0')).toBeTruthy();

  // second cannot get a lock
  expect(second.tryGetLock('0')).toBe(null);

  // first cannot get another lock on the same element
  expect(first.tryGetLock('0')).toBe(null);

  // nothing cannot get lock on a different element
  expect(first.tryGetLock('1')).toBe(null);
  expect(second.tryGetLock('1')).toBe(null);
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,SubOptimalAssert,"{'startLine':42,'endLine':42}","it('should allow an exclusive lock for drag actions', () => {
  let first: SensorAPI;
  let second: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(<App sensors={[a, b]} />);
  invariant(first, 'expected first to be set');
  invariant(second, 'expected second to be set');

  // first can get a lock
  expect(first.tryGetLock('0')).toBeTruthy();

  // second cannot get a lock
  expect(second.tryGetLock('0')).toBe(null);

  // first cannot get another lock on the same element
  expect(first.tryGetLock('0')).toBe(null);

  // nothing cannot get lock on a different element
  expect(first.tryGetLock('1')).toBe(null);
  expect(second.tryGetLock('1')).toBe(null);
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,SubOptimalAssert,"{'startLine':43,'endLine':43}","it('should allow an exclusive lock for drag actions', () => {
  let first: SensorAPI;
  let second: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(<App sensors={[a, b]} />);
  invariant(first, 'expected first to be set');
  invariant(second, 'expected second to be set');

  // first can get a lock
  expect(first.tryGetLock('0')).toBeTruthy();

  // second cannot get a lock
  expect(second.tryGetLock('0')).toBe(null);

  // first cannot get another lock on the same element
  expect(first.tryGetLock('0')).toBe(null);

  // nothing cannot get lock on a different element
  expect(first.tryGetLock('1')).toBe(null);
  expect(second.tryGetLock('1')).toBe(null);
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,SubOptimalAssert,"{'startLine':62,'endLine':62}","it('should allow a lock to be released', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };

  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  Array.from({ length: 4 }).forEach(() => {
    // get the lock
    const lock: ?PreDragActions = api.tryGetLock('0', noop);
    expect(lock).toBeTruthy();
    invariant(lock, 'Expected lock to be set');

    // cannot get another lock
    expect(api.tryGetLock('0')).toBe(null);

    // release the lock
    lock.abort();
  });
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,SubOptimalAssert,"{'startLine':99,'endLine':99}","it('should not allow a sensor to obtain a on a dropping item, but can claim one on something else while dragging', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');

  // drag not started yet
  expect(isDragging(handle)).toBe(false);
  // start a drag
  const actions: FluidDragActions = preDrag.fluidLift({ x: 0, y: 0 });
  expect(isDragging(handle)).toBe(true);

  // release the movement
  actions.move({ x: 100, y: 100 });
  requestAnimationFrame.flush();

  actions.drop();
  expect(isDropAnimating(handle)).toBe(true);

  // lock is no longer active
  expect(actions.isActive()).toBe(false);
  expect(preDrag.isActive()).toBe(false);

  // cannot get a new lock while still dropping
  expect(api.tryGetLock('0', noop)).toBe(null);

  // can get a lock on a handle that is not dropping - while the other is dropping
  expect(api.tryGetLock('1', noop)).toBeTruthy();
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,SubOptimalAssert,"{'startLine':147,'endLine':147}","it('should release a lock when cancelling or dropping a drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  ['cancel', 'drop'].forEach((property: string) => {
    const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
    invariant(preDrag, 'Expected to get lock');
    expect(preDrag.isActive()).toBe(true);

    const drag: SnapDragActions = preDrag.snapLift();
    expect(drag.isActive()).toBe(true);

    // cannot get another lock
    const second: ?PreDragActions = api.tryGetLock('1', noop);
    expect(second).toBe(null);

    // calling cancel or drop
    act(() => {
      drag[property]();
    });

    // can now get another lock
    const third: ?PreDragActions = api.tryGetLock('1', noop);
    expect(third).toBeTruthy();
    // need to try to release it
    invariant(third);
    third.abort();
  });
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,VerboseStatement,"{'startLine':69,'endLine':103}","it('should not allow a sensor to obtain a on a dropping item, but can claim one on something else while dragging', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');

  // drag not started yet
  expect(isDragging(handle)).toBe(false);
  // start a drag
  const actions: FluidDragActions = preDrag.fluidLift({ x: 0, y: 0 });
  expect(isDragging(handle)).toBe(true);

  // release the movement
  actions.move({ x: 100, y: 100 });
  requestAnimationFrame.flush();

  actions.drop();
  expect(isDropAnimating(handle)).toBe(true);

  // lock is no longer active
  expect(actions.isActive()).toBe(false);
  expect(preDrag.isActive()).toBe(false);

  // cannot get a new lock while still dropping
  expect(api.tryGetLock('0', noop)).toBe(null);

  // can get a lock on a handle that is not dropping - while the other is dropping
  expect(api.tryGetLock('1', noop)).toBeTruthy();
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,VerboseStatement,"{'startLine':105,'endLine':127}","it('should release a lock when aborting a pre drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');
  expect(preDrag.isActive()).toBe(true);
  // should release the lock
  preDrag.abort();
  expect(preDrag.isActive()).toBe(false);

  // can get another lock
  const second: ?PreDragActions = api.tryGetLock('1', noop);
  expect(second).toBeTruthy();
  invariant(second);
  // need to release this one :)
  second.abort();
  expect(second.isActive()).toBe(false);
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}",Unknown,snuts
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,VerboseStatement,"{'startLine':18,'endLine':46}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,VerboseStatement,"{'startLine':48,'endLine':75}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/force-releasing-locks.spec.js,VerboseStatement,"{'startLine':12,'endLine':39}","it('should correctly state whether a lock is claimed', () => {
  let first: SensorAPI;
  let second: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };
  const onForceStop = jest.fn();

  render(
    <React.Fragment>
      <App sensors={[a, b]} />
    </React.Fragment>,
  );
  invariant(first);
  invariant(second);

  const preDrag: ?PreDragActions = first.tryGetLock('0', onForceStop);
  expect(preDrag).toBeTruthy();
  expect(second.isLockClaimed()).toBe(true);

  second.tryReleaseLock();
  expect(onForceStop).toHaveBeenCalled();
  // lock is gone
  expect(second.isLockClaimed()).toBe(false);
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/click-blocking.spec.js,VerboseStatement,"{'startLine':14,'endLine':43}","it('should block a single click if requested', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };

  const { getByText } = render(
    <React.Fragment>
      <App sensors={[sensor]} />
    </React.Fragment>,
  );
  const handle: HTMLElement = getByText('item: 0');
  invariant(api);

  // trigger a drop
  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  const drag: SnapDragActions = preDrag.snapLift();
  act(() => drag.drop({ shouldBlockNextClick: true }));

  // fire click
  const first: MouseEvent = createEvent.click(handle);
  const second: MouseEvent = createEvent.click(handle);
  fireEvent(handle, first);
  fireEvent(handle, second);

  // only first click is prevented
  expect(first.defaultPrevented).toBe(true);
  expect(second.defaultPrevented).toBe(false);
})",snuts
/test/unit/integration/drag-handle/sensor-marshal/click-blocking.spec.js,VerboseStatement,"{'startLine':74,'endLine':106}","it('should not block any clicks after a timeout', () => {
  jest.useFakeTimers();

  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };

  const { getByText } = render(
    <React.Fragment>
      <App sensors={[sensor]} />
    </React.Fragment>,
  );
  const handle: HTMLElement = getByText('item: 0');
  invariant(api);

  // trigger a drop
  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  const drag: SnapDragActions = preDrag.snapLift();
  act(() => drag.drop({ shouldBlockNextClick: true }));

  jest.runTimersToTime(1);

  // fire click
  const first: MouseEvent = createEvent.click(handle);
  fireEvent(handle, first);

  // click not prevented
  expect(first.defaultPrevented).toBe(false);

  jest.useRealTimers();
})",snuts
/test/unit/integration/drag-drop-context/on-before-capture/removals.spec.js,OvercommentedTest,"{'startLine':19,'endLine':104}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['first', 'second']);
    function onBeforeCapture() {
      // removing the first item
      setItems(['second']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const second: HTMLElement = getByTestId('second');

  // initially it had an index of 1
  expect(getIndex(second)).toBe(1);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(getByTestId('second'), { x: 0, y: 0 });
  });

  // act(() => rerender());
  // first item has been removed
  expect(queryByTestId('first')).toBe(null);
  // second is now dragging
  expect(isDragging(second)).toBe(true);
  // second index accounts for removal
  expect(getIndex(second)).toBe(0);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'second',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 0,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",snuts
/test/unit/integration/drag-drop-context/on-before-capture/removals.spec.js,SubOptimalAssert,"{'startLine':82,'endLine':82}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['first', 'second']);
    function onBeforeCapture() {
      // removing the first item
      setItems(['second']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const second: HTMLElement = getByTestId('second');

  // initially it had an index of 1
  expect(getIndex(second)).toBe(1);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(getByTestId('second'), { x: 0, y: 0 });
  });

  // act(() => rerender());
  // first item has been removed
  expect(queryByTestId('first')).toBe(null);
  // second is now dragging
  expect(isDragging(second)).toBe(true);
  // second index accounts for removal
  expect(getIndex(second)).toBe(0);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'second',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 0,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",snuts
/test/unit/integration/drag-drop-context/on-before-capture/removals.spec.js,VerboseStatement,"{'startLine':19,'endLine':104}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['first', 'second']);
    function onBeforeCapture() {
      // removing the first item
      setItems(['second']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const second: HTMLElement = getByTestId('second');

  // initially it had an index of 1
  expect(getIndex(second)).toBe(1);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(getByTestId('second'), { x: 0, y: 0 });
  });

  // act(() => rerender());
  // first item has been removed
  expect(queryByTestId('first')).toBe(null);
  // second is now dragging
  expect(isDragging(second)).toBe(true);
  // second index accounts for removal
  expect(getIndex(second)).toBe(0);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'second',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 0,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",snuts
/test/unit/integration/drag-drop-context/on-before-capture/additions.spec.js,OvercommentedTest,"{'startLine':74,'endLine':160}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['initial']);
    function onBeforeCapture() {
      // adding the first item
      setItems(['first', 'initial']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const initial: HTMLElement = getByTestId('initial');

  // initially it had an index of 1
  expect(getIndex(initial)).toBe(0);
  // first item does not exist yet
  expect(queryByTestId('first')).toBe(null);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(initial, { x: 0, y: 0 });
  });

  // first item has been added
  expect(queryByTestId('first')).toBeTruthy();
  // initial is now dragging
  expect(isDragging(initial)).toBe(true);
  // initial index accounts for addition
  expect(getIndex(initial)).toBe(1);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'initial',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 1,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",snuts
/test/unit/integration/drag-drop-context/on-before-capture/additions.spec.js,SubOptimalAssert,"{'startLine':129,'endLine':129}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['initial']);
    function onBeforeCapture() {
      // adding the first item
      setItems(['first', 'initial']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const initial: HTMLElement = getByTestId('initial');

  // initially it had an index of 1
  expect(getIndex(initial)).toBe(0);
  // first item does not exist yet
  expect(queryByTestId('first')).toBe(null);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(initial, { x: 0, y: 0 });
  });

  // first item has been added
  expect(queryByTestId('first')).toBeTruthy();
  // initial is now dragging
  expect(isDragging(initial)).toBe(true);
  // initial index accounts for addition
  expect(getIndex(initial)).toBe(1);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'initial',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 1,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",snuts
/test/unit/integration/drag-drop-context/on-before-capture/additions.spec.js,VerboseStatement,"{'startLine':74,'endLine':160}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['initial']);
    function onBeforeCapture() {
      // adding the first item
      setItems(['first', 'initial']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const initial: HTMLElement = getByTestId('initial');

  // initially it had an index of 1
  expect(getIndex(initial)).toBe(0);
  // first item does not exist yet
  expect(queryByTestId('first')).toBe(null);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(initial, { x: 0, y: 0 });
  });

  // first item has been added
  expect(queryByTestId('first')).toBeTruthy();
  // initial is now dragging
  expect(isDragging(initial)).toBe(true);
  // initial index accounts for addition
  expect(getIndex(initial)).toBe(1);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'initial',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 1,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",snuts
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,ConditionalTestLogic,"{'startLine':13,'endLine':16}","it('should recover from rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      invariant(false, 'throwing');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    rerender(<App anotherChild={<CanThrow shouldThrow />} />);
  });

  expect(isDragging(getByTestId('0'))).toBe(false);
})",snuts
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,ConditionalTestLogic,"{'startLine':37,'endLine':40}","it('should not recover from non-rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      throw new Error('Boom');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",snuts
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,ConditionalTestLogic,"{'startLine':61,'endLine':65}","it('should not recover from runtime errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      // Boom: TypeError
      window.foo();
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",snuts
/test/unit/state/move-in-direction/move-cross-axis/no-visible-targets-in-list.spec.js,SubOptimalAssert,"{'startLine':80,'endLine':80}","it('should return null if there are draggables in a destination list but none are visible', () => {
  const custom: DroppableDimension = getDroppableDimension({
    descriptor: {
      id: 'custom',
      type: 'TYPE',
      mode: 'standard',
    },
    borderBox: {
      left: preset.home.client.borderBox.left + 1,
      right: preset.home.client.borderBox.left + 10,
      top: 0,
      bottom: viewport.frame.bottom + 200,
    },
  });
  const notVisible: DraggableDimension = getDraggableDimension({
    descriptor: {
      id: 'not-visible',
      droppableId: custom.descriptor.id,
      type: custom.descriptor.type,
      index: 0,
    },
    borderBox: {
      left: preset.home.client.borderBox.left + 1,
      right: preset.home.client.borderBox.left + 10,
      // outside of the viewport
      top: viewport.frame.bottom + 1,
      bottom: viewport.frame.bottom + 10,
    },
  });
  const draggables: DraggableDimensionMap = {
    ...preset.draggables,
    [notVisible.descriptor.id]: notVisible,
  };
  const droppables: DroppableDimensionMap = {
    [preset.home.descriptor.id]: preset.home,
    [custom.descriptor.id]: custom,
  };
  const { afterCritical } = getLiftEffect({
    draggable: preset.inHome1,
    draggables,
    home: preset.home,
    viewport: preset.viewport,
  });

  const result: ?PublicResult = moveCrossAxis({
    isMovingForward: true,
    previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
    draggable: preset.inHome1,
    isOver: preset.home,
    draggables,
    droppables,
    viewport,
    afterCritical,
  });

  expect(result).toBe(null);
})",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,IdenticalTestDescription,"{'startLine':467,'endLine':510}","it('should return the first droppable on the cross axis when moving forward', () => {
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 0,
          right: 20,
          bottom: 20,
        },
      });
      const forward = getDroppableDimension({
        descriptor: {
          id: 'forward',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 20,
          left: 0,
          right: 20,
          bottom: 30,
        },
      });
      const droppables: DroppableDimensionMap = {
        [source.descriptor.id]: source,
        [forward.descriptor.id]: forward,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });

      expect(result).toBe(forward);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,IdenticalTestDescription,"{'startLine':512,'endLine':556}","it('should return the first droppable on the cross axis when moving backward', () => {
      const behind = getDroppableDimension({
        descriptor: {
          id: 'behind',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 0,
          right: 20,
          bottom: 10,
        },
      });
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 10,
          left: 0,
          right: 20,
          bottom: 20,
        },
      });
      const droppables: DroppableDimensionMap = {
        [behind.descriptor.id]: behind,
        [source.descriptor.id]: source,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        // moving backwards
        isMovingForward: false,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        viewport,
        droppables,
      });

      expect(result).toBe(behind);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,IdenticalTestDescription,"{'startLine':558,'endLine':611}","it('should exclude options that are not in the desired direction', () => {
      const behind = getDroppableDimension({
        descriptor: {
          id: 'behind',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 0,
          right: 20,
          bottom: 10,
        },
      });
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 10,
          left: 0,
          right: 20,
          bottom: 20,
        },
      });
      const droppables: DroppableDimensionMap = {
        [behind.descriptor.id]: behind,
        [source.descriptor.id]: source,
      };

      // now moving in the other direction
      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });
      expect(result).toBe(null);

      // Ensuring that normally it would be returned if moving in the right direction
      const result2: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: false,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });
      expect(result2).toBe(behind);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,IdenticalTestDescription,"{'startLine':613,'endLine':657}","it('should exclude options that are not enabled', () => {
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 20,
          right: 30,
          bottom: 10,
        },
      });
      const disabled = getDroppableDimension({
        descriptor: {
          id: 'disabled',
          type: 'TYPE',
          mode: 'standard',
        },
        isEnabled: false,
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 30,
          right: 40,
          bottom: 10,
        },
      });
      const droppables: DroppableDimensionMap = {
        [source.descriptor.id]: source,
        [disabled.descriptor.id]: disabled,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,IdenticalTestDescription,"{'startLine':722,'endLine':765}","it('should exclude options that are not in the viewport', () => {
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          bottom: 10,
          left: 20,
          right: 30,
        },
      });
      const notInViewport = getDroppableDimension({
        descriptor: {
          id: 'notInViewport',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          bottom: 10,
          left: viewport.frame.right + 1,
          right: viewport.frame.right + 10,
        },
      });
      const droppables: DroppableDimensionMap = {
        [source.descriptor.id]: source,
        [notInViewport.descriptor.id]: notInViewport,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,IdenticalTestDescription,"{'startLine':767,'endLine':813}","it('should exclude options that do not overlap on the main axis', () => {
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 0,
          right: 20,
          bottom: 10,
        },
      });
      const noOverlap = getDroppableDimension({
        descriptor: {
          id: 'noOverlap',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          // comes after the source
          top: 10,
          // but its left value is > the rigt of the source
          left: 30,
          right: 40,
          bottom: 20,
        },
      });

      const droppables: DroppableDimensionMap = {
        [source.descriptor.id]: source,
        [noOverlap.descriptor.id]: noOverlap,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,IdenticalTestDescription,"{'startLine':869,'endLine':885}","it('should return a droppable where the center position (axis.line) of the draggable draggable sits within the size of a droppable', () => {
        // sitting inside source - but within the size of sibling2 on the main axis
        const center: Position = {
          y: 5,
          x: 50,
        };

        const result: ?DroppableDimension = getBestCrossAxisDroppable({
          isMovingForward: true,
          pageBorderBoxCenter: center,
          source,
          droppables,
          viewport,
        });

        expect(result).toBe(sibling2);
      })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,IdenticalTestDescription,"{'startLine':888,'endLine':906}","it('should return the droppable that has the closest corner', () => {
          // Choosing a point that is before the first sibling
          const center: Position = {
            // above sibling 1
            y: 5,
            // before the left value of sibling 1
            x: 10,
          };

          const result: ?DroppableDimension = getBestCrossAxisDroppable({
            isMovingForward: true,
            pageBorderBoxCenter: center,
            source,
            droppables,
            viewport,
          });

          expect(result).toBe(sibling1);
        })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,IdenticalTestDescription,"{'startLine':908,'endLine':938}","it('should choose the droppable that is furthest back (closest to {x: 0, y: 0} on the screen) in the event of a tie', () => {
          // Choosing a point that is above the first sibling
          const center: Position = {
            y: 5,
            // this line is shared between sibling1 and sibling2
            x: 40,
          };

          const result: ?DroppableDimension = getBestCrossAxisDroppable({
            isMovingForward: true,
            pageBorderBoxCenter: center,
            source,
            droppables,
            viewport,
          });

          expect(result).toBe(sibling1);

          // checking that center point is correct

          const center2: Position = add(center, { y: 0, x: 1 });
          const result2: ?DroppableDimension = getBestCrossAxisDroppable({
            isMovingForward: true,
            pageBorderBoxCenter: center2,
            source,
            droppables,
            viewport,
          });

          expect(result2).toBe(sibling2);
        })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,IdenticalTestDescription,"{'startLine':1125,'endLine':1164}","it('should not allow movement when the droppables are on top of each other', () => {
        const box: Spacing = {
          top: 0,
          left: 20,
          right: 30,
          bottom: 10,
        };
        const source = getDroppableDimension({
          descriptor: {
            id: 'source',
            type: 'TYPE',
            mode: 'standard',
          },
          direction: axis.direction,
          borderBox: box,
        });
        const backward = getDroppableDimension({
          descriptor: {
            id: 'forward',
            type: 'TYPE',
            mode: 'standard',
          },
          direction: axis.direction,
          borderBox: box,
        });
        const droppables: DroppableDimensionMap = {
          [source.descriptor.id]: source,
          [backward.descriptor.id]: backward,
        };

        const result: ?DroppableDimension = getBestCrossAxisDroppable({
          isMovingForward: false,
          pageBorderBoxCenter: source.page.borderBox.center,
          source,
          droppables,
          viewport,
        });

        expect(result).toBe(null);
      })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':153,'endLine':153}","it('should exclude options that are not in the desired direction', () => {
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 20,
          right: 30,
          bottom: 10,
        },
      });
      const behind = getDroppableDimension({
        descriptor: {
          id: 'behind',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 0,
          right: 10,
          bottom: 10,
        },
      });
      const droppables: DroppableDimensionMap = {
        [behind.descriptor.id]: behind,
        [source.descriptor.id]: source,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });
      expect(result).toBe(null);

      // checking that it would have been returned if was moving in the other direction
      const result2: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: false,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });
      expect(result2).toBe(behind);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':209,'endLine':209}","it('should exclude options that are not enabled', () => {
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 20,
          right: 30,
          bottom: 10,
        },
      });
      const disabled = getDroppableDimension({
        descriptor: {
          id: 'disabled',
          type: 'TYPE',
          mode: 'standard',
        },
        isEnabled: false,
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 30,
          right: 40,
          bottom: 10,
        },
      });
      const droppables: DroppableDimensionMap = {
        [source.descriptor.id]: source,
        [disabled.descriptor.id]: disabled,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':254,'endLine':254}","it('should exclude options that are not in the viewport', () => {
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 20,
          right: 30,
          bottom: 10,
        },
      });
      const outsideViewport = getDroppableDimension({
        descriptor: {
          id: 'outsideViewport',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          left: 30,
          right: 40,
          top: viewport.frame.bottom + 1,
          bottom: viewport.frame.bottom + 10,
        },
      });
      const droppables: DroppableDimensionMap = {
        [source.descriptor.id]: source,
        [outsideViewport.descriptor.id]: outsideViewport,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':301,'endLine':301}","it('should exclude options that do not overlap on the main axis', () => {
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 20,
          right: 30,
          bottom: 10,
        },
      });
      const noOverlap = getDroppableDimension({
        descriptor: {
          id: 'noOverlap',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          // top is below where the source ended
          top: 11,
          left: 30,
          right: 40,
          bottom: 20,
        },
      });

      const droppables: DroppableDimensionMap = {
        [source.descriptor.id]: source,
        [noOverlap.descriptor.id]: noOverlap,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':600,'endLine':600}","it('should exclude options that are not in the desired direction', () => {
      const behind = getDroppableDimension({
        descriptor: {
          id: 'behind',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 0,
          right: 20,
          bottom: 10,
        },
      });
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 10,
          left: 0,
          right: 20,
          bottom: 20,
        },
      });
      const droppables: DroppableDimensionMap = {
        [behind.descriptor.id]: behind,
        [source.descriptor.id]: source,
      };

      // now moving in the other direction
      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });
      expect(result).toBe(null);

      // Ensuring that normally it would be returned if moving in the right direction
      const result2: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: false,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });
      expect(result2).toBe(behind);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':656,'endLine':656}","it('should exclude options that are not enabled', () => {
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 20,
          right: 30,
          bottom: 10,
        },
      });
      const disabled = getDroppableDimension({
        descriptor: {
          id: 'disabled',
          type: 'TYPE',
          mode: 'standard',
        },
        isEnabled: false,
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 30,
          right: 40,
          bottom: 10,
        },
      });
      const droppables: DroppableDimensionMap = {
        [source.descriptor.id]: source,
        [disabled.descriptor.id]: disabled,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':719,'endLine':719}","it('should exclude options that are not visible in their frame', () => {
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          [axis.start]: 0,
          [axis.end]: 100,
          [axis.crossAxisStart]: 0,
          [axis.crossAxisEnd]: 100,
        },
      });
      const subjectNotVisibleThroughFrame = getDroppableDimension({
        descriptor: {
          id: 'notInViewport',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        // totally hidden by frame
        borderBox: {
          [axis.start]: 0,
          [axis.end]: 100,
          // would normally be a good candidate
          [axis.crossAxisStart]: 200,
          [axis.crossAxisEnd]: 300,
        },
        closest: {
          borderBox: {
            [axis.start]: 0,
            [axis.end]: 100,
            // frame hides subject
            [axis.crossAxisStart]: 400,
            [axis.crossAxisEnd]: 500,
          },
          scroll: { x: 0, y: 0 },
          scrollSize: {
            scrollWidth: 100,
            scrollHeight: 100,
          },
          shouldClipSubject: true,
        },
      });
      const droppables: DroppableDimensionMap = {
        [source.descriptor.id]: source,
        [subjectNotVisibleThroughFrame.descriptor
          .id]: subjectNotVisibleThroughFrame,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':764,'endLine':764}","it('should exclude options that are not in the viewport', () => {
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          bottom: 10,
          left: 20,
          right: 30,
        },
      });
      const notInViewport = getDroppableDimension({
        descriptor: {
          id: 'notInViewport',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          bottom: 10,
          left: viewport.frame.right + 1,
          right: viewport.frame.right + 10,
        },
      });
      const droppables: DroppableDimensionMap = {
        [source.descriptor.id]: source,
        [notInViewport.descriptor.id]: notInViewport,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':812,'endLine':812}","it('should exclude options that do not overlap on the main axis', () => {
      const source = getDroppableDimension({
        descriptor: {
          id: 'source',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          top: 0,
          left: 0,
          right: 20,
          bottom: 10,
        },
      });
      const noOverlap = getDroppableDimension({
        descriptor: {
          id: 'noOverlap',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          // comes after the source
          top: 10,
          // but its left value is > the rigt of the source
          left: 30,
          right: 40,
          bottom: 20,
        },
      });

      const droppables: DroppableDimensionMap = {
        [source.descriptor.id]: source,
        [noOverlap.descriptor.id]: noOverlap,
      };

      const result: ?DroppableDimension = getBestCrossAxisDroppable({
        isMovingForward: true,
        pageBorderBoxCenter: source.page.borderBox.center,
        source,
        droppables,
        viewport,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':1029,'endLine':1029}","it('should not allow movement when the droppables are on top of each other', () => {
        const box: Spacing = {
          top: 0,
          left: 20,
          right: 30,
          bottom: 10,
        };
        const source = getDroppableDimension({
          descriptor: {
            id: 'source',
            type: 'TYPE',
            mode: 'standard',
          },
          direction: axis.direction,
          borderBox: box,
        });
        const forward = getDroppableDimension({
          descriptor: {
            id: 'forward',
            type: 'TYPE',
            mode: 'standard',
          },
          direction: axis.direction,
          borderBox: box,
        });
        const droppables: DroppableDimensionMap = {
          [source.descriptor.id]: source,
          [forward.descriptor.id]: forward,
        };

        const result: ?DroppableDimension = getBestCrossAxisDroppable({
          isMovingForward: true,
          pageBorderBoxCenter: source.page.borderBox.center,
          source,
          droppables,
          viewport,
        });

        expect(result).toBe(null);
      })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':1076,'endLine':1076}","it('should not allow movement the right edge of the source is not greater than the right edge of the target', () => {
        const box: Spacing = {
          top: 0,
          left: 20,
          right: 30,
          bottom: 10,
        };
        const source = getDroppableDimension({
          descriptor: {
            id: 'source',
            type: 'TYPE',
            mode: 'standard',
          },
          direction: axis.direction,
          borderBox: box,
        });
        const forward = getDroppableDimension({
          descriptor: {
            id: 'forward',
            type: 'TYPE',
            mode: 'standard',
          },
          direction: axis.direction,
          borderBox: {
            ...box,
            // forward a little bit
            left: box.left + 1,
            // not far enough
            right: box.right - 1,
          },
        });
        const droppables: DroppableDimensionMap = {
          [source.descriptor.id]: source,
          [forward.descriptor.id]: forward,
        };

        const result: ?DroppableDimension = getBestCrossAxisDroppable({
          isMovingForward: true,
          pageBorderBoxCenter: source.page.borderBox.center,
          source,
          droppables,
          viewport,
        });

        expect(result).toBe(null);
      })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':1163,'endLine':1163}","it('should not allow movement when the droppables are on top of each other', () => {
        const box: Spacing = {
          top: 0,
          left: 20,
          right: 30,
          bottom: 10,
        };
        const source = getDroppableDimension({
          descriptor: {
            id: 'source',
            type: 'TYPE',
            mode: 'standard',
          },
          direction: axis.direction,
          borderBox: box,
        });
        const backward = getDroppableDimension({
          descriptor: {
            id: 'forward',
            type: 'TYPE',
            mode: 'standard',
          },
          direction: axis.direction,
          borderBox: box,
        });
        const droppables: DroppableDimensionMap = {
          [source.descriptor.id]: source,
          [backward.descriptor.id]: backward,
        };

        const result: ?DroppableDimension = getBestCrossAxisDroppable({
          isMovingForward: false,
          pageBorderBoxCenter: source.page.borderBox.center,
          source,
          droppables,
          viewport,
        });

        expect(result).toBe(null);
      })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-best-cross-axis-droppable.spec.js,SubOptimalAssert,"{'startLine':1210,'endLine':1210}","it('should not allow movement left edge of the source is not greater than the left edge of the target', () => {
        const box: Spacing = {
          top: 0,
          left: 20,
          right: 30,
          bottom: 10,
        };
        const source = getDroppableDimension({
          descriptor: {
            id: 'source',
            type: 'TYPE',
            mode: 'standard',
          },
          direction: axis.direction,
          borderBox: box,
        });
        const backward = getDroppableDimension({
          descriptor: {
            id: 'forward',
            type: 'TYPE',
            mode: 'standard',
          },
          direction: axis.direction,
          borderBox: {
            ...box,
            // backward a little bit
            right: box.right - 1,
            // not far enough
            left: box.left,
          },
        });
        const droppables: DroppableDimensionMap = {
          [source.descriptor.id]: source,
          [backward.descriptor.id]: backward,
        };

        const result: ?DroppableDimension = getBestCrossAxisDroppable({
          isMovingForward: true,
          pageBorderBoxCenter: source.page.borderBox.center,
          source,
          droppables,
          viewport,
        });

        expect(result).toBe(null);
      })",snuts
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,SubOptimalAssert,"{'startLine':37,'endLine':37}","it('should clear any destination from a final impact if not dropping on a droppable', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination !== null);

  // no destination
  store.dispatch(move({ client: { x: 10000, y: 10000 } }));
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
  }

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",snuts
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,SubOptimalAssert,"{'startLine':52,'endLine':52}","it('should clear any destination from a final impact if not dropping on a droppable', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination !== null);

  // no destination
  store.dispatch(move({ client: { x: 10000, y: 10000 } }));
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
  }

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",snuts
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,SubOptimalAssert,"{'startLine':77,'endLine':77}","it('should clear any destination from a final impact canceling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // cancel
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",snuts
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,SubOptimalAssert,"{'startLine':104,'endLine':104}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",snuts
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,SubOptimalAssert,"{'startLine':116,'endLine':116}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",snuts
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,SubOptimalAssert,"{'startLine':122,'endLine':122}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",snuts
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,VerboseStatement,"{'startLine':22,'endLine':53}","it('should clear any destination from a final impact if not dropping on a droppable', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination !== null);

  // no destination
  store.dispatch(move({ client: { x: 10000, y: 10000 } }));
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
  }

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",snuts
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,VerboseStatement,"{'startLine':80,'endLine':123}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",snuts
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,OvercommentedTest,"{'startLine':118,'endLine':203}","it('should fire an animate drop action if combining', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      const inSnapMode: InitialPublishArgs = {
        ...initialPublishArgs,
        movementMode: 'SNAP',
      };
      store.dispatch(initialPublish(inSnapMode));
      store.dispatch(
        updateDroppableIsCombineEnabled({
          id: inSnapMode.critical.droppable.id,
          isCombineEnabled: true,
        }),
      );
      {
        const current: State = store.getState();
        invariant(current.phase === 'DRAGGING');
        invariant(current.movementMode === 'SNAP');
        invariant(
          current.dimensions.droppables[inSnapMode.critical.droppable.id]
            .isCombineEnabled,
        );
      }
      // combine
      store.dispatch(moveDown());
      // move past and shift item up
      store.dispatch(moveDown());
      // move backwards onto the displaced item
      store.dispatch(moveUp());
      mock.mockReset();

      const current: State = store.getState();
      invariant(current.isDragging);

      // if (reason === 'DROP') {
      const combine: ?Combine = tryGetCombine(current.impact);
      invariant(combine);
      // moved forwards past in home2, and then backwards onto it
      expect(combine).toEqual({
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      });

      store.dispatch(drop({ reason }));

      const combineDropImpact: DragImpact = getDropImpact({
        reason,
        draggables: preset.draggables,
        lastImpact: current.impact,
        home: preset.home,
        viewport: preset.viewport,
        onLiftImpact: homeImpact,
        afterCritical,
      }).impact;

      const completed: CompletedDrag = {
        critical,
        impact: combineDropImpact,
        afterCritical,
        result: {
          ...getDragStart(),
          // we are using snap movements
          mode: 'SNAP',
          destination: null,
          combine: reason === 'DROP' ? combine : null,
          reason,
        },
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: getNewHomeClientOffset({
          impact: combineDropImpact,
          draggable: preset.inHome1,
          dimensions: preset.dimensions,
          viewport: preset.viewport,
          afterCritical,
        }),
        // $ExpectError - wrong type
        dropDuration: expect.any(Number),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",snuts
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,VerboseStatement,"{'startLine':68,'endLine':116}","it('should fire an animate drop action if a drop animation movement is required', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      store.dispatch(initialPublish(initialPublishArgs));
      expect(store.getState().phase).toBe('DRAGGING');

      // moving a little bit so that a drop animation will be needed
      const shift: Position = { x: 1, y: 1 };
      store.dispatch(
        move({
          client: add(initialPublishArgs.clientSelection, shift),
        }),
      );
      const current: State = store.getState();
      invariant(current.isDragging);
      // impact is cleared when cancelling
      const destination: ?DraggableLocation =
        reason === 'DROP' ? getDragStart().source : null;

      mock.mockReset();
      store.dispatch(drop({ reason }));

      const result: DropResult = {
        ...getDragStart(),
        destination,
        reason,
        combine: null,
      };
      const completed: CompletedDrag = {
        result,
        impact: getDropImpactForReason(reason),
        critical,
        afterCritical,
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: origin,
        dropDuration: getDropDuration({
          current: shift,
          destination: origin,
          reason,
        }),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",snuts
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,VerboseStatement,"{'startLine':118,'endLine':203}","it('should fire an animate drop action if combining', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      const inSnapMode: InitialPublishArgs = {
        ...initialPublishArgs,
        movementMode: 'SNAP',
      };
      store.dispatch(initialPublish(inSnapMode));
      store.dispatch(
        updateDroppableIsCombineEnabled({
          id: inSnapMode.critical.droppable.id,
          isCombineEnabled: true,
        }),
      );
      {
        const current: State = store.getState();
        invariant(current.phase === 'DRAGGING');
        invariant(current.movementMode === 'SNAP');
        invariant(
          current.dimensions.droppables[inSnapMode.critical.droppable.id]
            .isCombineEnabled,
        );
      }
      // combine
      store.dispatch(moveDown());
      // move past and shift item up
      store.dispatch(moveDown());
      // move backwards onto the displaced item
      store.dispatch(moveUp());
      mock.mockReset();

      const current: State = store.getState();
      invariant(current.isDragging);

      // if (reason === 'DROP') {
      const combine: ?Combine = tryGetCombine(current.impact);
      invariant(combine);
      // moved forwards past in home2, and then backwards onto it
      expect(combine).toEqual({
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      });

      store.dispatch(drop({ reason }));

      const combineDropImpact: DragImpact = getDropImpact({
        reason,
        draggables: preset.draggables,
        lastImpact: current.impact,
        home: preset.home,
        viewport: preset.viewport,
        onLiftImpact: homeImpact,
        afterCritical,
      }).impact;

      const completed: CompletedDrag = {
        critical,
        impact: combineDropImpact,
        afterCritical,
        result: {
          ...getDragStart(),
          // we are using snap movements
          mode: 'SNAP',
          destination: null,
          combine: reason === 'DROP' ? combine : null,
          reason,
        },
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: getNewHomeClientOffset({
          impact: combineDropImpact,
          draggable: preset.inHome1,
          dimensions: preset.dimensions,
          viewport: preset.viewport,
          afterCritical,
        }),
        // $ExpectError - wrong type
        dropDuration: expect.any(Number),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",snuts
/test/unit/state/middleware/responders/update.spec.js,OvercommentedTest,"{'startLine':56,'endLine':98}","it('should not call onDragUpdate if there is no movement from the last update', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);

  // onDragUpdate not called yet
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // A movement to the same index is not causing an update
  const moveArgs: MoveArgs = {
    // tiny change
    client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
  };
  store.dispatch(move(moveArgs));

  // update not called after flushing
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Triggering an actual movement
  store.dispatch(moveDown());
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

  const state: State = store.getState();
  invariant(
    state.phase === 'DRAGGING',
    'Expecting state to be in dragging phase',
  );

  // A small movement that should not trigger any index changes
  store.dispatch(
    move({
      client: add(state.current.client.selection, { x: -1, y: -1 }),
    }),
  );

  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",snuts
/test/unit/state/middleware/responders/update.spec.js,VerboseStatement,"{'startLine':56,'endLine':98}","it('should not call onDragUpdate if there is no movement from the last update', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);

  // onDragUpdate not called yet
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // A movement to the same index is not causing an update
  const moveArgs: MoveArgs = {
    // tiny change
    client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
  };
  store.dispatch(move(moveArgs));

  // update not called after flushing
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Triggering an actual movement
  store.dispatch(moveDown());
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

  const state: State = store.getState();
  invariant(
    state.phase === 'DRAGGING',
    'Expecting state to be in dragging phase',
  );

  // A small movement that should not trigger any index changes
  store.dispatch(
    move({
      client: add(state.current.client.selection, { x: -1, y: -1 }),
    }),
  );

  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",snuts
/test/unit/state/middleware/responders/start.spec.js,VerboseStatement,"{'startLine':37,'endLine':71}","it('should call the onBeforeDragState and onDragStart in the correct order', () => {
  let mockCalled: ?number = null;
  let onBeforeDragStartCalled: ?number = null;
  let onDragStartCalled: ?number = null;
  const mock = jest.fn().mockImplementation(() => {
    mockCalled = performance.now();
  });
  const responders: Responders = getRespondersStub();
  // $FlowFixMe - no property mockImplementation
  responders.onBeforeDragStart.mockImplementation(() => {
    onBeforeDragStartCalled = performance.now();
  });
  // $FlowFixMe - no property mockImplementation
  responders.onDragStart.mockImplementation(() => {
    onDragStartCalled = performance.now();
  });
  const store: Store = createStore(
    middleware(() => responders, getAnnounce()),
    passThrough(mock),
  );

  // first initial publish
  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onBeforeDragStart).toHaveBeenCalledWith(getDragStart());
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking the order
  invariant(onBeforeDragStartCalled);
  invariant(mockCalled);
  invariant(onDragStartCalled);
  expect(mock).toHaveBeenCalledTimes(1);
  expect(onBeforeDragStartCalled).toBeLessThan(mockCalled);
  expect(mockCalled).toBeLessThan(onDragStartCalled);
})",snuts
/test/unit/state/middleware/responders/repeated-use.spec.js,OvercommentedTest,"{'startLine':25,'endLine':81}","it('should behave correctly across multiple drags', () => {
  const responders: Responders = createResponders();
  const store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    // start
    store.dispatch(initialPublish(initialPublishArgs));
    jest.runOnlyPendingTimers();
    expect(responders.onDragStart).toHaveBeenCalledWith(
      getDragStart(),
      expect.any(Object),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);

    // update
    const update: DragUpdate = {
      ...getDragStart(),
      destination: {
        droppableId: initialPublishArgs.critical.droppable.id,
        index: initialPublishArgs.critical.draggable.index + 1,
      },
      combine: null,
    };
    store.dispatch(moveDown());
    // flush responder call
    jest.runOnlyPendingTimers();
    expect(responders.onDragUpdate).toHaveBeenCalledWith(
      update,
      expect.any(Object),
    );
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

    // drop
    const result: DropResult = {
      ...update,
      reason: 'DROP',
    };
    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );
    expect(responders.onDragEnd).toHaveBeenCalledTimes(1);

    // cleanup
    store.dispatch(flush());
    // $ExpectError - unknown mock reset property
    responders.onDragStart.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragUpdate.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragEnd.mockReset();
  });
})",snuts
/test/unit/state/middleware/responders/flushing.spec.js,VerboseStatement,"{'startLine':59,'endLine':83}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",snuts
/test/unit/state/middleware/responders/announcements.spec.js,ConditionalTestLogic,"{'startLine':143,'endLine':146}","it('should announce with the default message if no responder is provided', () => {
      // This test is not relevant for onDragEnd as it must always be provided
      if (current.responder === 'onDragEnd') {
        expect(true).toBe(true);
        return;
      }
      // unsetting responder
      responders[current.responder] = undefined;
      current.execute(store);
      expect(announce).toHaveBeenCalledWith(current.defaultMessage);
    })",snuts
/test/unit/state/middleware/responders/announcements.spec.js,NonFunctionalStatement,"{'startLine':173,'endLine':173}","it('should prevent async announcements', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
        },
      );

      current.execute(store);

      // We did not announce so it would have been called with the default message
      expect(announce).toHaveBeenCalledWith(current.defaultMessage);
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform an async message
      setTimeout(() => provided.announce('async message'));
      jest.runOnlyPendingTimers();

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      // cleanup
      warn.mockRestore();
    })",snuts
/test/unit/state/middleware/responders/announcements.spec.js,NonFunctionalStatement,"{'startLine':203,'endLine':203}","it('should prevent multiple announcement calls from a consumer', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
          provided.announce('hello');
        },
      );

      current.execute(store);

      expect(announce).toHaveBeenCalledWith('hello');
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform another announcement
      invariant(provided, 'provided is not set');
      provided.announce('another one');

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      warn.mockRestore();
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,IdenticalTestDescription,"{'startLine':254,'endLine':269}","it('should not scroll if before the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = add(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: scrolledViewport,
          state,
        }),
      );

      requestAnimationFrame.flush();
      expect(mocks.scrollWindow).not.toHaveBeenCalled();
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,IdenticalTestDescription,"{'startLine':271,'endLine':286}","it('should scroll if on the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: scrolledViewport,
          state,
        }),
      );

      expect(mocks.scrollWindow).not.toHaveBeenCalled();
      requestAnimationFrame.flush();
      expect(mocks.scrollWindow).toHaveBeenCalled();
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,IdenticalTestDescription,"{'startLine':288,'endLine':309}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = subtract(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: scrolledViewport,
          state,
        }),
      );

      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalled();
      // moving forwards
      const request: Position = mocks.scrollWindow.mock.calls[0][0];
      expect(request[axis.line]).toBeLessThan(0);
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,IdenticalTestDescription,"{'startLine':311,'endLine':349}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,IdenticalTestDescription,"{'startLine':351,'endLine':367}","it('should have the top speed at the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: onMaxBoundary,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        negate(patch(axis.line, config.maxPixelScroll)),
      );
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,IdenticalTestDescription,"{'startLine':369,'endLine':386}","it('should have the top speed when moving beyond the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = subtract(onMaxBoundary, patch(axis.line, 1));

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: target,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        negate(patch(axis.line, config.maxPixelScroll)),
      );
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,IdenticalTestDescription,"{'startLine':388,'endLine':415}","it('should throttle multiple scrolls into a single animation frame', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target1: Position = subtract(onStartBoundary, patch(axis.line, 1));
      const target2: Position = add(onMaxBoundary, patch(axis.line, 1));

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: target1,
          viewport: scrolledViewport,
          state,
        }),
      );
      scroller.scroll(
        dragTo({
          selection: target2,
          viewport: scrolledViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        negate(patch(axis.line, config.maxPixelScroll)),
      );
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,VerboseStatement,"{'startLine':113,'endLine':154}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = subtract(
        onMaxBoundary,
        patch(axis.line, 1),
      );

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrollableViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrollableViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeLessThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,VerboseStatement,"{'startLine':311,'endLine':349}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,OvercommentedTest,"{'startLine':124,'endLine':232}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",snuts
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,VerboseStatement,"{'startLine':124,'endLine':232}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",snuts
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,IdenticalTestDescription,"{'startLine':273,'endLine':289}","it('should not scroll if before the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = add(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );

      requestAnimationFrame.flush();
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,IdenticalTestDescription,"{'startLine':291,'endLine':307}","it('should scroll if on the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();
      requestAnimationFrame.flush();
      expect(mocks.scrollDroppable).toHaveBeenCalled();
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,IdenticalTestDescription,"{'startLine':309,'endLine':331}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = subtract(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalled();
      // moving forwards
      const request: Position = mocks.scrollDroppable.mock.calls[0][1];
      expect(request[axis.line]).toBeLessThan(0);
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,IdenticalTestDescription,"{'startLine':333,'endLine':373}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,IdenticalTestDescription,"{'startLine':375,'endLine':393}","it('should have the top speed at the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: onMaxBoundary,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledWith(
        scrolled.descriptor.id,
        negate(patch(axis.line, config.maxPixelScroll)),
      );
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,IdenticalTestDescription,"{'startLine':395,'endLine':414}","it('should have the top speed when moving beyond the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = subtract(onMaxBoundary, patch(axis.line, 1));

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: target,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledWith(
        scrolled.descriptor.id,
        negate(patch(axis.line, config.maxPixelScroll)),
      );
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,IdenticalTestDescription,"{'startLine':416,'endLine':446}","it('should throttle multiple scrolls into a single animation frame', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target1: Position = subtract(onStartBoundary, patch(axis.line, 1));
      const target2: Position = add(onMaxBoundary, patch(axis.line, 1));

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: target1,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      scroller.scroll(
        dragTo({
          selection: target2,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      expect(mocks.scrollDroppable).toHaveBeenCalledWith(
        scrolled.descriptor.id,
        negate(patch(axis.line, config.maxPixelScroll)),
      );
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,VerboseStatement,"{'startLine':122,'endLine':165}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = subtract(
        onMaxBoundary,
        patch(axis.line, 1),
      );

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeLessThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,VerboseStatement,"{'startLine':333,'endLine':373}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/big-draggables.spec.js,IdenticalTestDescription,"{'startLine':146,'endLine':175}","it('should allow scrolling on the cross axis if too big on the main axis', () => {
      const mocks: PublicArgs = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const biggerOnMainAxis: Spacing = expandByPosition(
        frameClient.borderBox,
        patch(axis.line, 1),
      );
      const tooBigOnMainAxis: DraggableDimension = getDraggableDimension({
        descriptor: preset.inHome1.descriptor,
        borderBox: biggerOnMainAxis,
      });
      const first: DraggingState = addDraggable(
        dragTo({
          viewport: unscrollableViewport,
          selection: onMaxBoundaryOfBoth,
          state,
          droppable: scrollable,
        }),
        tooBigOnMainAxis,
      );

      scroller.start(first);
      requestAnimationFrame.step();

      expect(mocks.scrollDroppable).toHaveBeenCalledWith(
        scrollable.descriptor.id,
        // $FlowFixMe - using expect.any
        patch(axis.crossAxisLine, expect.any(Number)),
      );
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/big-draggables.spec.js,IdenticalTestDescription,"{'startLine':177,'endLine':206}","it('should allow scrolling on the main axis if too big on the cross axis', () => {
      const mocks: PublicArgs = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const biggerOnCrossAxis: Spacing = expandByPosition(
        frameClient.borderBox,
        patch(axis.crossAxisLine, 1),
      );
      const tooBigOnCrossAxis: DraggableDimension = getDraggableDimension({
        descriptor: preset.inHome1.descriptor,
        borderBox: biggerOnCrossAxis,
      });
      const first: DraggingState = addDraggable(
        dragTo({
          viewport: unscrollableViewport,
          selection: onMaxBoundaryOfBoth,
          droppable: scrollable,
          state,
        }),
        tooBigOnCrossAxis,
      );

      scroller.start(first);
      requestAnimationFrame.step();

      expect(mocks.scrollDroppable).toHaveBeenCalledWith(
        scrollable.descriptor.id,
        // $FlowFixMe - using expect.any
        patch(axis.line, expect.any(Number)),
      );
    })",snuts
/test/unit/state/auto-scroll/fluid-scroller/big-draggables.spec.js,IdenticalTestDescription,"{'startLine':208,'endLine':233}","it('should not allow scrolling on any axis if too big on both axis', () => {
      const mocks: PublicArgs = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const biggerOnBothAxis: Spacing = expandByPosition(
        frameClient.borderBox,
        patch(axis.line, 1, 1),
      );
      const tooBig: DraggableDimension = getDraggableDimension({
        descriptor: preset.inHome1.descriptor,
        borderBox: biggerOnBothAxis,
      });
      const first: DraggingState = addDraggable(
        dragTo({
          viewport: unscrollableViewport,
          selection: onMaxBoundaryOfBoth,
          droppable: scrollable,
          state,
        }),
        tooBig,
      );

      scroller.start(first);
      requestAnimationFrame.flush();

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();
    })",snuts
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-viewport.spec.js,OvercommentedTest,"{'startLine':252,'endLine':333}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        // after non-displaced inForeign
        const previousImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy: getDisplacedBy(axis, inHome.displaceBy),
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        const previousPageBorderBoxCenter: Position = getPageBorderBoxCenter({
          impact: previousImpact,
          afterCritical,
          draggable: inHome,
          droppable: foreign,
          draggables,
        });
        const previousClientSelection: Position = getClientFromPageBorderBoxCenter(
          {
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: inHome,
            viewport: scrolled,
          },
        );
        // const previousPageBorderBoxCenter: Position =
        //   initiallyOutsideViewport.page.borderBox.center;
        // const previousClientSelection: Position =
        //   initiallyOutsideViewport.client.borderBox.center;

        // figure out where we would have been if it was visible

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: false,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport: scrolled,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: getForcedDisplacement({
            // Even though the item started in an invisible place we force
            // the displacement to be visible.
            visible: [{ dimension: inForeign, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // moving into place of inForeign
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",snuts
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-viewport.spec.js,IdenticalTestDescription,"{'startLine':216,'endLine':250}","it('should be setup correctly', () => {
        // verify visibility is as expected
        expect(
          isTotallyVisible({
            target: inForeign.page.borderBox,
            viewport: scrolled.frame,
            withDroppableDisplacement: true,
            destination: foreign,
          }),
        ).toBe(false);
        // going further - ensure it is not partially visible
        expect(
          isPartiallyVisible({
            target: inForeign.page.borderBox,
            viewport: scrolled.frame,
            withDroppableDisplacement: true,
            destination: foreign,
          }),
        ).toBe(false);

        // checking that if displaced then inForeign would be visible
        // using raw .displacedBy as we are scolling on
        const displaced: BoxModel = offset(
          inForeign.client,
          getDisplacedBy(axis, inHome.displaceBy).point,
        );
        expect(
          isPartiallyVisible({
            target: displaced.borderBox,
            viewport: scrolled.frame,
            withDroppableDisplacement: true,
            destination: foreign,
          }),
        ).toBe(true);
      })",snuts
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-viewport.spec.js,IdenticalTestDescription,"{'startLine':252,'endLine':333}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        // after non-displaced inForeign
        const previousImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy: getDisplacedBy(axis, inHome.displaceBy),
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        const previousPageBorderBoxCenter: Position = getPageBorderBoxCenter({
          impact: previousImpact,
          afterCritical,
          draggable: inHome,
          droppable: foreign,
          draggables,
        });
        const previousClientSelection: Position = getClientFromPageBorderBoxCenter(
          {
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: inHome,
            viewport: scrolled,
          },
        );
        // const previousPageBorderBoxCenter: Position =
        //   initiallyOutsideViewport.page.borderBox.center;
        // const previousClientSelection: Position =
        //   initiallyOutsideViewport.client.borderBox.center;

        // figure out where we would have been if it was visible

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: false,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport: scrolled,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: getForcedDisplacement({
            // Even though the item started in an invisible place we force
            // the displacement to be visible.
            visible: [{ dimension: inForeign, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // moving into place of inForeign
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",snuts
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-droppable.spec.js,OvercommentedTest,"{'startLine':273,'endLine':350}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        // after non-displaced inForeign
        const previousImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy: getDisplacedBy(axis, inHome.displaceBy),
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        const previousPageBorderBoxCenter: Position = getPageBorderBoxCenter({
          impact: previousImpact,
          afterCritical,
          draggable: inHome,
          droppable: scrolled,
          draggables,
        });
        const previousClientSelection: Position = getClientFromPageBorderBoxCenter(
          {
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: inHome,
            viewport,
          },
        );

        // figure out where we would have been if it was visible

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: false,
          draggable: inHome,
          destination: scrolled,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: getForcedDisplacement({
            // Even though the item started in an invisible place we force
            // the displacement to be visible.
            visible: [{ dimension: inForeign, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // moving into place of inForeign
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: scrolled,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",snuts
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-droppable.spec.js,IdenticalTestDescription,"{'startLine':237,'endLine':271}","it('should be setup correctly', () => {
        // verify visibility is as expected
        expect(
          isTotallyVisible({
            target: inForeign.page.borderBox,
            viewport: viewport.frame,
            withDroppableDisplacement: true,
            destination: scrolled,
          }),
        ).toBe(false);
        // going further - ensure it is not partially visible
        expect(
          isPartiallyVisible({
            target: inForeign.page.borderBox,
            viewport: viewport.frame,
            withDroppableDisplacement: true,
            destination: scrolled,
          }),
        ).toBe(false);

        // checking that if displaced then inForeign would be visible
        // using raw .displacedBy as we are scolling on
        const displaced: BoxModel = offset(
          inForeign.client,
          getDisplacedBy(axis, inHome.displaceBy).point,
        );
        expect(
          isPartiallyVisible({
            target: displaced.borderBox,
            viewport: viewport.frame,
            withDroppableDisplacement: true,
            destination: scrolled,
          }),
        ).toBe(true);
      })",snuts
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-droppable.spec.js,IdenticalTestDescription,"{'startLine':273,'endLine':350}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        // after non-displaced inForeign
        const previousImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy: getDisplacedBy(axis, inHome.displaceBy),
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        const previousPageBorderBoxCenter: Position = getPageBorderBoxCenter({
          impact: previousImpact,
          afterCritical,
          draggable: inHome,
          droppable: scrolled,
          draggables,
        });
        const previousClientSelection: Position = getClientFromPageBorderBoxCenter(
          {
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: inHome,
            viewport,
          },
        );

        // figure out where we would have been if it was visible

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: false,
          draggable: inHome,
          destination: scrolled,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: getForcedDisplacement({
            // Even though the item started in an invisible place we force
            // the displacement to be visible.
            visible: [{ dimension: inForeign, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // moving into place of inForeign
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: scrolled,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",snuts
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,SubOptimalAssert,"{'startLine':181,'endLine':181}","it('should not allow combining with anything before the first item', () => {
      const { impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: false,
        draggable: preset.inHome1,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,SubOptimalAssert,"{'startLine':200,'endLine':200}","it('should not allow combining with anything after the last item', () => {
      const { impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome4,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: true,
        draggable: preset.inHome1,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-home-list.spec.js,SubOptimalAssert,"{'startLine':33,'endLine':44}","it('should not to anything if there is not target (can happen if invisible)', () => {
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      expect(
        moveToNewDroppable({
          previousPageBorderBoxCenter: dontCare,
          destination: preset.home,
          insideDestination: preset.inHomeList,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          moveRelativeTo: null,
          viewport,
          afterCritical,
        }),
      ).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,IdenticalTestDescription,"{'startLine':334,'endLine':379}","it('should move the target and everything below it forward', () => {
        // moving inHome3 relative to inForeign1 (will go after inForeign1)
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome1,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome3.displaceBy,
        );
        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
          draggable: preset.inHome3,
          draggables: preset.draggables,
          // moving relative to inForeign1
          // will actually go after it
          moveRelativeTo: preset.inForeign1,
          destination: preset.foreign,
          insideDestination: preset.inForeignList,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // everything after inForeign1
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(result).toEqual(expected);
      })",snuts
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,SubOptimalAssert,"{'startLine':168,'endLine':168}","it('should not move into the start of list if the position is not visible due to droppable scroll', () => {
          const whatNewCenterWouldBeWithoutScroll: Position = goIntoStart({
            axis,
            moveInto: preset.emptyForeign.page,
            isMoving: preset.inHome1.page,
          });
          const totalShift: Position = subtract(
            whatNewCenterWouldBeWithoutScroll,
            preset.inHome1.page.borderBox.center,
          );
          const shiftedInHome1Page: Spacing = offsetByPosition(
            preset.inHome1.page.borderBox,
            totalShift,
          );
          invariant(preset.emptyForeign.subject.active);
          const maxAllowableScroll: Position = negate(
            subtract(
              patch(axis.line, preset.emptyForeign.subject.active[axis.start]),
              patch(axis.line, shiftedInHome1Page[axis.start]),
            ),
          );
          const pastMaxAllowableScroll: Position = add(
            maxAllowableScroll,
            patch(axis.line, 1),
          );

          // validation: no scrolled droppable
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }

          // center on visible edge = can move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.foreign,
              maxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              maxAllowableScroll,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }
          // center past visible edge = cannot move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.emptyForeign,
              pastMaxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              pastMaxAllowableScroll,
            );
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",snuts
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,SubOptimalAssert,"{'startLine':242,'endLine':242}","it('should not move into the start of list if the position is not visible due to page scroll', () => {
          const emptyForeignPageBox: BoxModel = preset.emptyForeign.page;

          // How far to the start of the droppable content box?
          const distanceToStartOfDroppableContextBox: number =
            emptyForeignPageBox.marginBox[axis.start] +
            distanceToContentBoxStart(emptyForeignPageBox);

          const onVisibleStartEdge: Position = patch(
            axis.line,
            distanceToStartOfDroppableContextBox +
              preset.inHome1.page.margin[axis.start],
          );
          const pastVisibleStartEdge: Position = add(
            onVisibleStartEdge,
            patch(axis.line, 1),
          );
          // validate with no scroll
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              destination: preset.emptyForeign,
              moveRelativeTo: null,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBeTruthy();
          }
          // center on visible edge = can move
          {
            const scrolled: Viewport = scrollViewport(
              viewport,
              onVisibleStartEdge,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              destination: preset.emptyForeign,
              moveRelativeTo: null,
              insideDestination: [],
              viewport: scrolled,
              afterCritical,
            });

            expect(result).toBeTruthy();
          }
          // start is no longer visible = cannot move
          {
            const scrolled: Viewport = scrollViewport(
              viewport,
              pastVisibleStartEdge,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport: scrolled,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",snuts
/test/unit/state/get-drag-impact/reorder/over-home-list/started-before-critical.spec.js,OvercommentedTest,"{'startLine':55,'endLine':115}","it('should displace items forward when the start edge of the dragging item goes backwards past the items center', () => {
      // after center of inHome1
      {
        const startOnInHome1Center: DragImpact = getDragImpact({
          pageOffset: offsetForStartOnInHome1Center,
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest to current location
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // inHome3 is not displaced as it is the dragging item
              // inHome4 would have been displaced on lift so it won't be animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inHome2
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(startOnInHome1Center).toEqual(expected);
      }
      // on center of inHome1
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest to current location
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome2 },
              // inHome3 is not displaced as it is the dragging item
              // inHome4 would have been displaced on lift so it won't be animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inHome1
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(startBeforeInHome1Center).toEqual(expected);
      }
    })",snuts
/test/unit/state/get-drag-impact/reorder/over-home-list/displacement-visibility.spec.js,OvercommentedTest,"{'startLine':36,'endLine':187}","it('should indicate when a displacement is not visible due to being outside of the droppable frame', () => {
      const droppable: DroppableDimension = getDroppableDimension({
        descriptor: {
          id: 'my-custom-droppable',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          [axis.start]: 0,
          // will be cut by the frame
          [axis.end]: 200,
        },
        closest: {
          borderBox: {
            [axis.crossAxisStart]: crossAxisStart,
            [axis.crossAxisEnd]: crossAxisEnd,
            [axis.start]: 0,
            // will cut the subject,
            [axis.end]: 100,
          },
          scrollSize: {
            scrollWidth: 100,
            scrollHeight: 100,
          },
          scroll: { x: 0, y: 0 },
          shouldClipSubject: true,
        },
      });
      const visible: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'visible',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 0,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          [axis.start]: 0,
          [axis.end]: 90,
        },
      });
      const partialVisible: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'partial-visible',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 1,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          // partially in frame
          [axis.start]: 90,
          [axis.end]: 120,
        },
      });
      const notVisible1: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'not-visible-1',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 2,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          // inside the frame, but not in the visible area
          [axis.start]: 130,
          [axis.end]: 140,
        },
      });
      const notVisible2: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'not-visible-2',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 3,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          // inside the frame, but not in the visible area
          [axis.start]: 150,
          [axis.end]: 170,
        },
      });
      const customDraggables: DraggableDimensionMap = {
        [visible.descriptor.id]: visible,
        [partialVisible.descriptor.id]: partialVisible,
        [notVisible1.descriptor.id]: notVisible1,
        [notVisible2.descriptor.id]: notVisible2,
      };
      const customDroppables: DroppableDimensionMap = {
        [droppable.descriptor.id]: droppable,
      };
      // dragging notVisible2 backwards into first position
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        notVisible2.displaceBy,
      );
      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            {
              dimension: visible,
              shouldAnimate: true,
            },
            {
              dimension: partialVisible,
              shouldAnimate: true,
            },
          ],
          invisible: [notVisible1],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: droppable.descriptor.id,
            index: 0,
          },
        },
      };

      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: notVisible2,
        home: droppable,
        draggables: customDraggables,
        viewport,
      });
      // moving backwards to near the start of the droppable
      const destination: Position = { x: 1, y: 1 };
      const offset: Position = subtract(
        destination,
        notVisible2.page.borderBox.center,
      );
      const impact: DragImpact = getDragImpact({
        pageOffset: offset,
        draggable: notVisible2,
        draggables: customDraggables,
        droppables: customDroppables,
        previousImpact: homeImpact,
        viewport,
        afterCritical,
      });

      expect(impact).toEqual(expected);
    })",snuts
/test/unit/state/get-drag-impact/reorder/over-home-list/displacement-visibility.spec.js,VerboseStatement,"{'startLine':36,'endLine':187}","it('should indicate when a displacement is not visible due to being outside of the droppable frame', () => {
      const droppable: DroppableDimension = getDroppableDimension({
        descriptor: {
          id: 'my-custom-droppable',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          [axis.start]: 0,
          // will be cut by the frame
          [axis.end]: 200,
        },
        closest: {
          borderBox: {
            [axis.crossAxisStart]: crossAxisStart,
            [axis.crossAxisEnd]: crossAxisEnd,
            [axis.start]: 0,
            // will cut the subject,
            [axis.end]: 100,
          },
          scrollSize: {
            scrollWidth: 100,
            scrollHeight: 100,
          },
          scroll: { x: 0, y: 0 },
          shouldClipSubject: true,
        },
      });
      const visible: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'visible',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 0,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          [axis.start]: 0,
          [axis.end]: 90,
        },
      });
      const partialVisible: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'partial-visible',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 1,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          // partially in frame
          [axis.start]: 90,
          [axis.end]: 120,
        },
      });
      const notVisible1: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'not-visible-1',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 2,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          // inside the frame, but not in the visible area
          [axis.start]: 130,
          [axis.end]: 140,
        },
      });
      const notVisible2: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'not-visible-2',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 3,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          // inside the frame, but not in the visible area
          [axis.start]: 150,
          [axis.end]: 170,
        },
      });
      const customDraggables: DraggableDimensionMap = {
        [visible.descriptor.id]: visible,
        [partialVisible.descriptor.id]: partialVisible,
        [notVisible1.descriptor.id]: notVisible1,
        [notVisible2.descriptor.id]: notVisible2,
      };
      const customDroppables: DroppableDimensionMap = {
        [droppable.descriptor.id]: droppable,
      };
      // dragging notVisible2 backwards into first position
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        notVisible2.displaceBy,
      );
      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            {
              dimension: visible,
              shouldAnimate: true,
            },
            {
              dimension: partialVisible,
              shouldAnimate: true,
            },
          ],
          invisible: [notVisible1],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: droppable.descriptor.id,
            index: 0,
          },
        },
      };

      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: notVisible2,
        home: droppable,
        draggables: customDraggables,
        viewport,
      });
      // moving backwards to near the start of the droppable
      const destination: Position = { x: 1, y: 1 };
      const offset: Position = subtract(
        destination,
        notVisible2.page.borderBox.center,
      );
      const impact: DragImpact = getDragImpact({
        pageOffset: offset,
        draggable: notVisible2,
        draggables: customDraggables,
        droppables: customDroppables,
        previousImpact: homeImpact,
        viewport,
        afterCritical,
      });

      expect(impact).toEqual(expected);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-closest-draggable/without-starting-displacement.spec.js,SubOptimalAssert,"{'startLine':220,'endLine':220}","it('should return null if there are no draggables in the droppable', () => {
      const center: Position = {
        x: 100,
        y: 100,
      };

      const result: ?DraggableDimension = getClosestDraggable({
        pageBorderBoxCenter: center,
        destination: droppable,
        insideDestination: [],
        viewport,
        afterCritical: noAfterCritical,
      });

      expect(result).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-cross-axis/get-closest-draggable/without-starting-displacement.spec.js,SubOptimalAssert,"{'startLine':379,'endLine':379}","it('should return null if there are no visible targets', () => {
        const notVisible: DraggableDimension[] = [
          hiddenBackwards,
          hiddenForwards,
          outOfViewport,
        ];
        const center: Position = {
          x: 0,
          y: 0,
        };

        const result: ?DraggableDimension = getClosestDraggable({
          pageBorderBoxCenter: center,
          destination: droppable,
          insideDestination: notVisible,
          viewport,
          afterCritical: noAfterCritical,
        });

        expect(result).toBe(null);
      })",snuts
/test/unit/state/get-center-from-impact/get-page-border-box-center/reorder/nothing-displaced.spec.js,IdenticalTestDescription,"{'startLine':86,'endLine':123}","it('should go after the item in its current non-displaced location', () => {
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome1,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome1.displaceBy,
        );
        const impact: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            // currently after inForeign4
            destination: {
              index: preset.inForeign4.descriptor.index + 1,
              droppableId: preset.inForeign4.descriptor.id,
            },
          },
        };
        const result: Position = getPageBorderBoxCenter({
          impact,
          afterCritical,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppable: preset.foreign,
        });

        const expected: Position = goAfter({
          axis,
          moveRelativeTo: preset.inForeign4.page,
          isMoving: preset.inHome1.page,
        });
        expect(result).toEqual(expected);
      })",snuts
/test/unit/state/get-center-from-impact/get-page-border-box-center/combine/when-combining.spec.js,IdenticalTestDescription,"{'startLine':154,'endLine':190}","it('should move onto a non-displaced center', () => {
        // moving inHome2 backwards onto inHome1
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            // inHome2 not displaced as it is the dragging item
            visible: [
              {
                dimension: preset.inHome3,
                shouldAnimate: false,
              },
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'COMBINE',
            // combining with not displaced inHome1
            combine: {
              draggableId: preset.inHome1.descriptor.id,
              droppableId: preset.inHome1.descriptor.droppableId,
            },
          },
        };

        const result: Position = getPageBorderBoxCenter({
          impact,
          afterCritical,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppable: withCombineEnabled,
        });

        expect(result).toEqual(preset.inHome1.page.borderBox.center);
      })",snuts
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,VerboseStatement,"{'startLine':19,'endLine':179}","it('should update the impact when moving with items that started displaced', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome2.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const forwardsPastInHome3: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(forwardsPastInHome3);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome3).toEqual(expected);
      }
      const forwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome3,
        afterCritical,
      });
      invariant(forwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome4.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome4).toEqual(expected);
      }

      const backwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastInHome4).toEqual(expected);
      }

      const backwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome2.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsToHome).toEqual(expected);
      }

      const backwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsToHome,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome1.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastHome).toEqual(expected);
      }
    })",snuts
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,VerboseStatement,"{'startLine':181,'endLine':366}","it('should update the impact when moving with items that did not start displaced', () => {
      // dragging inHome3 backwards away from the start
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome3.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const backwardsPastInHome2: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
      });
      invariant(backwardsPastInHome2);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // initial displacement not animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome2).toEqual(expected);
      }

      // move backwards again
      const backwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome2,
        afterCritical,
      });
      invariant(backwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest displaced
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome1).toEqual(expected);
      }

      // move forwards
      const forwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(forwardsPastInHome1).toEqual(expected);
      }

      const forwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome3.descriptor.index,
            },
          },
        };
        expect(forwardsToHome).toEqual(expected);
      }
      const forwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsToHome,
        afterCritical,
      });
      invariant(forwardsPastHome);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(forwardsPastHome).toEqual(expected);
      }
    })",snuts
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,OvercommentedTest,"{'startLine':32,'endLine':186}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",snuts
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,OvercommentedTest,"{'startLine':188,'endLine':348}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",snuts
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,SubOptimalAssert,"{'startLine':384,'endLine':384}","it('should not allow displaced before the start of the list', () => {
      // cross axis move inHome1 before inForeign1
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign1.descriptor.index,
          },
        },
      };

      // cannot move backwards

      const impact: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });

      expect(impact).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,SubOptimalAssert,"{'startLine':461,'endLine':461}","it('should not allow displaced after it is already after the last item in a list', () => {
      const impact: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: atEndOfForeignList,
        afterCritical,
        viewport: preset.viewport,
      });

      expect(impact).toBe(null);
    })",snuts
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,OvercommentedTest,"{'startLine':136,'endLine':202}","it('should move forward off combining with a non-displaced item', () => {
      // Setup
      // - inHome1 past inForeign1
      // - inHome1 moves backwards onto inForeign1
      // - inHome1 moves forwards off inForeign1
      // Expected
      // - inHome1 moves before inForeign1
      // - inForeign1 becomes displaced
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          // inForeign1 is not displaced
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        // moved backward onto inForeign1
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign1.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: combining,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inForeign1 still not displaced
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      expect(result).toEqual(expected);
    })",snuts
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,OvercommentedTest,"{'startLine':204,'endLine':270}","it('should move backward off combining with a non-displaced item', () => {
      // Setup
      // - inHome1 past inForeign1
      // - inHome1 moves backwards onto inForeign1
      // - inHome1 moves backwards off inForeign1
      // Expected
      // - inHome1 moves forward off inForeign1
      // - no displacement changes
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            // inForeign1 not displaced
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          // moved backward onto inForeign1
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign1.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: combining,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inForeign1 now displaced
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign1.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",snuts
/test/test-flow-types.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/test/test-flow-types.js,NonFunctionalStatement,"{'startLine':14,'endLine':14}",Unknown,snuts
/test/unit/integration/util/controls.js,NonFunctionalStatement,"{'startLine':61,'endLine':61}",Unknown,snuts
/test/unit/view/droppable/util/get-stubber.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/test/unit/view/droppable/util/get-props.js,NonFunctionalStatement,"{'startLine':108,'endLine':108}",Unknown,snuts
/test/unit/dev-warning.spec.js,Duplicate Assert,"{'line': 23, 'column': 2, 'index': 467}","it('should not log a warning if warnings are disabled', () => {
  window['__react-beautiful-dnd-disable-dev-warnings'] = true;

  warning('hey');
  warning('sup');
  warning('hi');

  expect(warn).not.toHaveBeenCalled();

  // re-enable

  window['__react-beautiful-dnd-disable-dev-warnings'] = false;

  warning('hey');

  expect(warn).toHaveBeenCalled();
})",steel
/test/unit/dev-warning.spec.js,Duplicate Assert,"{'line': 31, 'column': 2, 'index': 607}","it('should not log a warning if warnings are disabled', () => {
  window['__react-beautiful-dnd-disable-dev-warnings'] = true;

  warning('hey');
  warning('sup');
  warning('hi');

  expect(warn).not.toHaveBeenCalled();

  // re-enable

  window['__react-beautiful-dnd-disable-dev-warnings'] = false;

  warning('hey');

  expect(warn).toHaveBeenCalled();
})",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 100, 'column': 4, 'index': 2698}","it('should register itself when mounting', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    mount(<Item registry={registry} />);

    const expected: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 101, 'column': 4, 'index': 2748}","it('should register itself when mounting', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    mount(<Item registry={registry} />);

    const expected: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 119, 'column': 4, 'index': 3360}","it('should unregister itself when unmounting', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expected: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    expect(unregisterSpy).not.toHaveBeenCalled();
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expected);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expected);

    wrapper.unmount();
    expect(unregisterSpy).toHaveBeenCalledTimes(1);
    expect(unregisterSpy.mock.calls[0][0]).toBe(entry);
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 120, 'column': 4, 'index': 3410}","it('should unregister itself when unmounting', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expected: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    expect(unregisterSpy).not.toHaveBeenCalled();
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expected);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expected);

    wrapper.unmount();
    expect(unregisterSpy).toHaveBeenCalledTimes(1);
    expect(unregisterSpy.mock.calls[0][0]).toBe(entry);
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 121, 'column': 4, 'index': 3460}","it('should unregister itself when unmounting', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expected: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    expect(unregisterSpy).not.toHaveBeenCalled();
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expected);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expected);

    wrapper.unmount();
    expect(unregisterSpy).toHaveBeenCalledTimes(1);
    expect(unregisterSpy.mock.calls[0][0]).toBe(entry);
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 126, 'column': 4, 'index': 3625}","it('should unregister itself when unmounting', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expected: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    expect(unregisterSpy).not.toHaveBeenCalled();
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expected);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expected);

    wrapper.unmount();
    expect(unregisterSpy).toHaveBeenCalledTimes(1);
    expect(unregisterSpy.mock.calls[0][0]).toBe(entry);
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 147, 'column': 4, 'index': 4428}","it('should update its registration when a descriptor property changes', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const updateSpy = jest.spyOn(registry.draggable, 'update');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expectedInitial: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    // asserting shape of original publish
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expectedInitial);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expectedInitial);

    expect(updateSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();

    registerSpy.mockReset();

    // updating the index
    wrapper.setProps({
      index: 1000,
    });

    // Descriptor updated
    const expectedUpdate: DraggableEntry = {
      uniqueId: entry.uniqueId,
      descriptor: {
        ...preset.inHome1.descriptor,
        index: 1000,
      },
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(updateSpy).toHaveBeenCalledTimes(1);
    // new descriptor
    expect(updateSpy.mock.calls[0][0]).toEqual(expectedUpdate);
    // late reference: same reference
    expect(updateSpy.mock.calls[0][1]).toBe(entry);

    // Nothing else changed
    expect(registerSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 148, 'column': 4, 'index': 4478}","it('should update its registration when a descriptor property changes', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const updateSpy = jest.spyOn(registry.draggable, 'update');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expectedInitial: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    // asserting shape of original publish
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expectedInitial);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expectedInitial);

    expect(updateSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();

    registerSpy.mockReset();

    // updating the index
    wrapper.setProps({
      index: 1000,
    });

    // Descriptor updated
    const expectedUpdate: DraggableEntry = {
      uniqueId: entry.uniqueId,
      descriptor: {
        ...preset.inHome1.descriptor,
        index: 1000,
      },
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(updateSpy).toHaveBeenCalledTimes(1);
    // new descriptor
    expect(updateSpy.mock.calls[0][0]).toEqual(expectedUpdate);
    // late reference: same reference
    expect(updateSpy.mock.calls[0][1]).toBe(entry);

    // Nothing else changed
    expect(registerSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 152, 'column': 4, 'index': 4634}","it('should update its registration when a descriptor property changes', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const updateSpy = jest.spyOn(registry.draggable, 'update');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expectedInitial: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    // asserting shape of original publish
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expectedInitial);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expectedInitial);

    expect(updateSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();

    registerSpy.mockReset();

    // updating the index
    wrapper.setProps({
      index: 1000,
    });

    // Descriptor updated
    const expectedUpdate: DraggableEntry = {
      uniqueId: entry.uniqueId,
      descriptor: {
        ...preset.inHome1.descriptor,
        index: 1000,
      },
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(updateSpy).toHaveBeenCalledTimes(1);
    // new descriptor
    expect(updateSpy.mock.calls[0][0]).toEqual(expectedUpdate);
    // late reference: same reference
    expect(updateSpy.mock.calls[0][1]).toBe(entry);

    // Nothing else changed
    expect(registerSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 153, 'column': 4, 'index': 4680}","it('should update its registration when a descriptor property changes', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const updateSpy = jest.spyOn(registry.draggable, 'update');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expectedInitial: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    // asserting shape of original publish
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expectedInitial);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expectedInitial);

    expect(updateSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();

    registerSpy.mockReset();

    // updating the index
    wrapper.setProps({
      index: 1000,
    });

    // Descriptor updated
    const expectedUpdate: DraggableEntry = {
      uniqueId: entry.uniqueId,
      descriptor: {
        ...preset.inHome1.descriptor,
        index: 1000,
      },
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(updateSpy).toHaveBeenCalledTimes(1);
    // new descriptor
    expect(updateSpy.mock.calls[0][0]).toEqual(expectedUpdate);
    // late reference: same reference
    expect(updateSpy.mock.calls[0][1]).toBe(entry);

    // Nothing else changed
    expect(registerSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 153, 'column': 4, 'index': 4680}","it('should update its registration when a descriptor property changes', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const updateSpy = jest.spyOn(registry.draggable, 'update');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expectedInitial: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    // asserting shape of original publish
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expectedInitial);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expectedInitial);

    expect(updateSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();

    registerSpy.mockReset();

    // updating the index
    wrapper.setProps({
      index: 1000,
    });

    // Descriptor updated
    const expectedUpdate: DraggableEntry = {
      uniqueId: entry.uniqueId,
      descriptor: {
        ...preset.inHome1.descriptor,
        index: 1000,
      },
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(updateSpy).toHaveBeenCalledTimes(1);
    // new descriptor
    expect(updateSpy.mock.calls[0][0]).toEqual(expectedUpdate);
    // late reference: same reference
    expect(updateSpy.mock.calls[0][1]).toBe(entry);

    // Nothing else changed
    expect(registerSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 173, 'column': 4, 'index': 5131}","it('should update its registration when a descriptor property changes', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const updateSpy = jest.spyOn(registry.draggable, 'update');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expectedInitial: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    // asserting shape of original publish
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expectedInitial);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expectedInitial);

    expect(updateSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();

    registerSpy.mockReset();

    // updating the index
    wrapper.setProps({
      index: 1000,
    });

    // Descriptor updated
    const expectedUpdate: DraggableEntry = {
      uniqueId: entry.uniqueId,
      descriptor: {
        ...preset.inHome1.descriptor,
        index: 1000,
      },
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(updateSpy).toHaveBeenCalledTimes(1);
    // new descriptor
    expect(updateSpy.mock.calls[0][0]).toEqual(expectedUpdate);
    // late reference: same reference
    expect(updateSpy.mock.calls[0][1]).toBe(entry);

    // Nothing else changed
    expect(registerSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 180, 'column': 4, 'index': 5384}","it('should update its registration when a descriptor property changes', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const updateSpy = jest.spyOn(registry.draggable, 'update');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expectedInitial: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    // asserting shape of original publish
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expectedInitial);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expectedInitial);

    expect(updateSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();

    registerSpy.mockReset();

    // updating the index
    wrapper.setProps({
      index: 1000,
    });

    // Descriptor updated
    const expectedUpdate: DraggableEntry = {
      uniqueId: entry.uniqueId,
      descriptor: {
        ...preset.inHome1.descriptor,
        index: 1000,
      },
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(updateSpy).toHaveBeenCalledTimes(1);
    // new descriptor
    expect(updateSpy.mock.calls[0][0]).toEqual(expectedUpdate);
    // late reference: same reference
    expect(updateSpy.mock.calls[0][1]).toBe(entry);

    // Nothing else changed
    expect(registerSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 181, 'column': 4, 'index': 5432}","it('should update its registration when a descriptor property changes', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const updateSpy = jest.spyOn(registry.draggable, 'update');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expectedInitial: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    // asserting shape of original publish
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expectedInitial);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expectedInitial);

    expect(updateSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();

    registerSpy.mockReset();

    // updating the index
    wrapper.setProps({
      index: 1000,
    });

    // Descriptor updated
    const expectedUpdate: DraggableEntry = {
      uniqueId: entry.uniqueId,
      descriptor: {
        ...preset.inHome1.descriptor,
        index: 1000,
      },
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(updateSpy).toHaveBeenCalledTimes(1);
    // new descriptor
    expect(updateSpy.mock.calls[0][0]).toEqual(expectedUpdate);
    // late reference: same reference
    expect(updateSpy.mock.calls[0][1]).toBe(entry);

    // Nothing else changed
    expect(registerSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-draggable-publisher.spec.js,Duplicate Assert,"{'line': 181, 'column': 4, 'index': 5432}","it('should update its registration when a descriptor property changes', () => {
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.draggable, 'register');
    const updateSpy = jest.spyOn(registry.draggable, 'update');
    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
    const wrapper = mount(<Item registry={registry} />);

    const expectedInitial: DraggableEntry = {
      // $ExpectError
      uniqueId: expect.any(String),
      descriptor: preset.inHome1.descriptor,
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };

    // asserting shape of original publish
    expect(registerSpy).toHaveBeenCalledTimes(1);
    expect(registerSpy).toHaveBeenCalledWith(expectedInitial);
    const entry = registerSpy.mock.calls[0][0];
    expect(entry).toEqual(expectedInitial);

    expect(updateSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();

    registerSpy.mockReset();

    // updating the index
    wrapper.setProps({
      index: 1000,
    });

    // Descriptor updated
    const expectedUpdate: DraggableEntry = {
      uniqueId: entry.uniqueId,
      descriptor: {
        ...preset.inHome1.descriptor,
        index: 1000,
      },
      options: defaultOptions,
      // $ExpectError
      getDimension: expect.any(Function),
    };
    expect(updateSpy).toHaveBeenCalledTimes(1);
    // new descriptor
    expect(updateSpy.mock.calls[0][0]).toEqual(expectedUpdate);
    // late reference: same reference
    expect(updateSpy.mock.calls[0][1]).toBe(entry);

    // Nothing else changed
    expect(registerSpy).not.toHaveBeenCalled();
    expect(unregisterSpy).not.toHaveBeenCalled();
  })",steel
/test/unit/view/announcer.spec.js,Duplicate Assert,"{'line': 56, 'column': 2, 'index': 1805}","it('should remove the element when unmounting after a timeout', () => {
  const { unmount } = render(
    <WithAnnouncer contextId=""5"">{getMock()}</WithAnnouncer>,
  );

  unmount();
  // not unmounted straight away
  expect(getElement('5')).toBeTruthy();

  jest.runOnlyPendingTimers();
  expect(getElement('5')).not.toBeTruthy();
})",steel
/test/unit/view/announcer.spec.js,Duplicate Assert,"{'line': 59, 'column': 2, 'index': 1877}","it('should remove the element when unmounting after a timeout', () => {
  const { unmount } = render(
    <WithAnnouncer contextId=""5"">{getMock()}</WithAnnouncer>,
  );

  unmount();
  // not unmounted straight away
  expect(getElement('5')).toBeTruthy();

  jest.runOnlyPendingTimers();
  expect(getElement('5')).not.toBeTruthy();
})",steel
/test/unit/view/announcer.spec.js,Lazy Test,"{'line': 40, 'column': 2, 'index': 1310}","it('should apply the appropriate aria attributes and non visibility styles', () => {
  render(<WithAnnouncer contextId=""5"">{getMock()}</WithAnnouncer>);

  const el: ?HTMLElement = getElement('5');
  invariant(el, 'Cannot find node');

  expect(el.getAttribute('aria-live')).toBe('assertive');
  expect(el.getAttribute('aria-atomic')).toBe('true');

  // not checking all the styles - just enough to know we are doing something
  expect(el.style.overflow).toBe('hidden');
})",steel
/test/unit/view/announcer.spec.js,Lazy Test,"{'line': 67, 'column': 2, 'index': 2142}","it('should set the text content of the announcement element', () => {
  // arrange
  const mock = getMock();
  render(<WithAnnouncer contextId=""6"">{mock}</WithAnnouncer>);
  const el: ?HTMLElement = getElement('6');
  invariant(el, 'Could not find announcer');

  // act
  const announce: Announce = getAnnounce(mock);
  announce('test');

  // assert
  expect(el.textContent).toBe('test');
})",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 82, 'column': 4, 'index': 2885}","it('should not fire a scroll if the value has not changed since the previous call', () => {
    // this can happen if you scroll backward and forward super quick
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

    // first event
    scroll(container, { x: 500, y: 1000 });
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1000 },
    );
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event - scroll to same spot
    scroll(container, { x: 500, y: 1000 });
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();

    // third event - new value
    scroll(container, { x: 500, y: 1001 });
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1001 },
    );
  })",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 83, 'column': 4, 'index': 2953}","it('should not fire a scroll if the value has not changed since the previous call', () => {
    // this can happen if you scroll backward and forward super quick
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

    // first event
    scroll(container, { x: 500, y: 1000 });
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1000 },
    );
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event - scroll to same spot
    scroll(container, { x: 500, y: 1000 });
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();

    // third event - new value
    scroll(container, { x: 500, y: 1001 });
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1001 },
    );
  })",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 92, 'column': 4, 'index': 3238}","it('should not fire a scroll if the value has not changed since the previous call', () => {
    // this can happen if you scroll backward and forward super quick
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

    // first event
    scroll(container, { x: 500, y: 1000 });
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1000 },
    );
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event - scroll to same spot
    scroll(container, { x: 500, y: 1000 });
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();

    // third event - new value
    scroll(container, { x: 500, y: 1001 });
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1001 },
    );
  })",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 96, 'column': 4, 'index': 3380}","it('should not fire a scroll if the value has not changed since the previous call', () => {
    // this can happen if you scroll backward and forward super quick
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

    // first event
    scroll(container, { x: 500, y: 1000 });
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1000 },
    );
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event - scroll to same spot
    scroll(container, { x: 500, y: 1000 });
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();

    // third event - new value
    scroll(container, { x: 500, y: 1001 });
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1001 },
    );
  })",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 162, 'column': 4, 'index': 5658}","it('should throttle multiple scrolls into a animation frame', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    // second event in same frame
    scroll(container, { x: 200, y: 800 });

    // release the update animation frame
    requestAnimationFrame.step();

    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 200, y: 800 },
    );

    // also checking that no loose frames are stored up
    requestAnimationFrame.flush();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 163, 'column': 4, 'index': 5726}","it('should throttle multiple scrolls into a animation frame', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    // second event in same frame
    scroll(container, { x: 200, y: 800 });

    // release the update animation frame
    requestAnimationFrame.step();

    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 200, y: 800 },
    );

    // also checking that no loose frames are stored up
    requestAnimationFrame.flush();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 170, 'column': 4, 'index': 5948}","it('should throttle multiple scrolls into a animation frame', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    // second event in same frame
    scroll(container, { x: 200, y: 800 });

    // release the update animation frame
    requestAnimationFrame.step();

    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 200, y: 800 },
    );

    // also checking that no loose frames are stored up
    requestAnimationFrame.flush();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 198, 'column': 4, 'index': 7040}","it('should not fire a scroll if the value has not changed since the previous frame', () => {
    // this can happen if you scroll backward and forward super quick
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    // release the frame
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1000 },
    );
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event
    scroll(container, { x: 501, y: 1001 });
    // no frame to release change yet

    // third event - back to original value
    scroll(container, { x: 500, y: 1000 });
    // release the frame
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 199, 'column': 4, 'index': 7108}","it('should not fire a scroll if the value has not changed since the previous frame', () => {
    // this can happen if you scroll backward and forward super quick
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    // release the frame
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1000 },
    );
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event
    scroll(container, { x: 501, y: 1001 });
    // no frame to release change yet

    // third event - back to original value
    scroll(container, { x: 500, y: 1000 });
    // release the frame
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 214, 'column': 4, 'index': 7557}","it('should not fire a scroll if the value has not changed since the previous frame', () => {
    // this can happen if you scroll backward and forward super quick
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    // release the frame
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
      preset.home.descriptor.id,
      { x: 500, y: 1000 },
    );
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event
    scroll(container, { x: 501, y: 1001 });
    // no frame to release change yet

    // third event - back to original value
    scroll(container, { x: 500, y: 1000 });
    // release the frame
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 240, 'column': 4, 'index': 8576}","it('should not publish a scroll update after requested not to update while an animation frame is occurring', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event
    scroll(container, { x: 400, y: 100 });
    // no animation frame to release event fired yet

    // unwatching before frame fired
    callbacks.dragStopped();

    // flushing any frames
    requestAnimationFrame.flush();
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 253, 'column': 4, 'index': 8958}","it('should not publish a scroll update after requested not to update while an animation frame is occurring', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;

    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    // first event
    scroll(container, { x: 500, y: 1000 });
    requestAnimationFrame.step();
    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
    // $ExpectError
    marshal.updateDroppableScroll.mockReset();

    // second event
    scroll(container, { x: 400, y: 100 });
    // no animation frame to release event fired yet

    // unwatching before frame fired
    callbacks.dragStopped();

    // flushing any frames
    requestAnimationFrame.flush();
    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 279, 'column': 2, 'index': 9929}","it('should stop watching scroll when no longer required to publish', () => {
  // this can happen if you scroll backward and forward super quick
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

  // first event
  scroll(container, { x: 500, y: 1000 });
  expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
  // $ExpectError
  marshal.updateDroppableScroll.mockReset();

  callbacks.dragStopped();

  // scroll event after no longer watching
  scroll(container, { x: 190, y: 400 });
  expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 287, 'column': 2, 'index': 10171}","it('should stop watching scroll when no longer required to publish', () => {
  // this can happen if you scroll backward and forward super quick
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

  // first event
  scroll(container, { x: 500, y: 1000 });
  expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
  // $ExpectError
  marshal.updateDroppableScroll.mockReset();

  callbacks.dragStopped();

  // scroll event after no longer watching
  scroll(container, { x: 190, y: 400 });
  expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 373, 'column': 2, 'index': 13178}","it('should add and remove events with the same event options', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  jest.spyOn(container, 'addEventListener');
  jest.spyOn(container, 'removeEventListener');

  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // assertion
  const expectedOptions = {
    passive: true,
  };
  expect(container.addEventListener).toHaveBeenCalledWith(
    'scroll',
    expect.any(Function),
    expectedOptions,
  );
  expect(container.removeEventListener).not.toHaveBeenCalled();
  container.addEventListener.mockReset();

  // unwatching scroll
  callbacks.dragStopped();

  // assertion
  expect(container.removeEventListener).toHaveBeenCalledWith(
    'scroll',
    expect.any(Function),
    expectedOptions,
  );
  expect(container.removeEventListener).toHaveBeenCalledTimes(1);
  expect(container.addEventListener).not.toHaveBeenCalled();

  // cleanup
  container.addEventListener.mockRestore();
  container.removeEventListener.mockRestore();
})",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 378, 'column': 2, 'index': 13303}","it('should add and remove events with the same event options', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  jest.spyOn(container, 'addEventListener');
  jest.spyOn(container, 'removeEventListener');

  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // assertion
  const expectedOptions = {
    passive: true,
  };
  expect(container.addEventListener).toHaveBeenCalledWith(
    'scroll',
    expect.any(Function),
    expectedOptions,
  );
  expect(container.removeEventListener).not.toHaveBeenCalled();
  container.addEventListener.mockReset();

  // unwatching scroll
  callbacks.dragStopped();

  // assertion
  expect(container.removeEventListener).toHaveBeenCalledWith(
    'scroll',
    expect.any(Function),
    expectedOptions,
  );
  expect(container.removeEventListener).toHaveBeenCalledTimes(1);
  expect(container.addEventListener).not.toHaveBeenCalled();

  // cleanup
  container.addEventListener.mockRestore();
  container.removeEventListener.mockRestore();
})",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 385, 'column': 2, 'index': 13476}","it('should add and remove events with the same event options', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  jest.spyOn(container, 'addEventListener');
  jest.spyOn(container, 'removeEventListener');

  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // assertion
  const expectedOptions = {
    passive: true,
  };
  expect(container.addEventListener).toHaveBeenCalledWith(
    'scroll',
    expect.any(Function),
    expectedOptions,
  );
  expect(container.removeEventListener).not.toHaveBeenCalled();
  container.addEventListener.mockReset();

  // unwatching scroll
  callbacks.dragStopped();

  // assertion
  expect(container.removeEventListener).toHaveBeenCalledWith(
    'scroll',
    expect.any(Function),
    expectedOptions,
  );
  expect(container.removeEventListener).toHaveBeenCalledTimes(1);
  expect(container.addEventListener).not.toHaveBeenCalled();

  // cleanup
  container.addEventListener.mockRestore();
  container.removeEventListener.mockRestore();
})",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 390, 'column': 2, 'index': 13604}","it('should add and remove events with the same event options', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  jest.spyOn(container, 'addEventListener');
  jest.spyOn(container, 'removeEventListener');

  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // assertion
  const expectedOptions = {
    passive: true,
  };
  expect(container.addEventListener).toHaveBeenCalledWith(
    'scroll',
    expect.any(Function),
    expectedOptions,
  );
  expect(container.removeEventListener).not.toHaveBeenCalled();
  container.addEventListener.mockReset();

  // unwatching scroll
  callbacks.dragStopped();

  // assertion
  expect(container.removeEventListener).toHaveBeenCalledWith(
    'scroll',
    expect.any(Function),
    expectedOptions,
  );
  expect(container.removeEventListener).toHaveBeenCalledTimes(1);
  expect(container.addEventListener).not.toHaveBeenCalled();

  // cleanup
  container.addEventListener.mockRestore();
  container.removeEventListener.mockRestore();
})",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Duplicate Assert,"{'line': 391, 'column': 2, 'index': 13670}","it('should add and remove events with the same event options', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  jest.spyOn(container, 'addEventListener');
  jest.spyOn(container, 'removeEventListener');

  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // assertion
  const expectedOptions = {
    passive: true,
  };
  expect(container.addEventListener).toHaveBeenCalledWith(
    'scroll',
    expect.any(Function),
    expectedOptions,
  );
  expect(container.removeEventListener).not.toHaveBeenCalled();
  container.addEventListener.mockReset();

  // unwatching scroll
  callbacks.dragStopped();

  // assertion
  expect(container.removeEventListener).toHaveBeenCalledWith(
    'scroll',
    expect.any(Function),
    expectedOptions,
  );
  expect(container.removeEventListener).toHaveBeenCalledTimes(1);
  expect(container.addEventListener).not.toHaveBeenCalled();

  // cleanup
  container.addEventListener.mockRestore();
  container.removeEventListener.mockRestore();
})",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Redundant Print,"{'line': 316, 'column': 9, 'index': 11282}","it('should stop watching for scroll events when the component is unmounted', () => {
  jest.spyOn(console, 'warn').mockImplementation(() => {});
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

  wrapper.unmount();

  // second event - will not fire any updates
  scroll(container, { x: 100, y: 300 });
  expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  // also logs a warning
  expect(console.warn).toHaveBeenCalled();

  // cleanup
  // $ExpectError
  console.warn.mockRestore();
})",steel
/test/unit/view/use-droppable-publisher/scroll-watching.spec.js,Redundant Print,"{'line': 320, 'column': 2, 'index': 11350}","it('should stop watching for scroll events when the component is unmounted', () => {
  jest.spyOn(console, 'warn').mockImplementation(() => {});
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  const container: ?HTMLElement = wrapper
    .find('.scroll-container')
    .getDOMNode();
  invariant(container);
  // tell the droppable to watch for scrolling
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

  // watch scroll will only be called after the dimension is requested
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

  wrapper.unmount();

  // second event - will not fire any updates
  scroll(container, { x: 100, y: 300 });
  expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
  // also logs a warning
  expect(console.warn).toHaveBeenCalled();

  // cleanup
  // $ExpectError
  console.warn.mockRestore();
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 28, 'column': 2, 'index': 900}","it('should register itself when mounting', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');

  mount(
    <WithAppContext registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );

  expect(registerSpy).toHaveBeenCalledTimes(1);

  // $ExpectError: using awesome matchers
  const expected: DroppableEntry = {
    uniqueId: expect.any(String),
    descriptor: preset.home.descriptor,
    callbacks: expect.any(Object),
  };

  expect(registerSpy).toHaveBeenCalledWith(expected);
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 37, 'column': 2, 'index': 1143}","it('should register itself when mounting', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');

  mount(
    <WithAppContext registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );

  expect(registerSpy).toHaveBeenCalledTimes(1);

  // $ExpectError: using awesome matchers
  const expected: DroppableEntry = {
    uniqueId: expect.any(String),
    descriptor: preset.home.descriptor,
    callbacks: expect.any(Object),
  };

  expect(registerSpy).toHaveBeenCalledWith(expected);
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 51, 'column': 2, 'index': 1602}","it('should unregister itself when unmounting', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const unregisterSpy = jest.spyOn(registry.droppable, 'unregister');

  const wrapper = mount(
    <WithAppContext registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  expect(registerSpy).toHaveBeenCalled();
  expect(unregisterSpy).not.toHaveBeenCalled();

  const entry = registerSpy.mock.calls[0][0];

  wrapper.unmount();
  expect(unregisterSpy).toHaveBeenCalledTimes(1);
  expect(unregisterSpy).toHaveBeenCalledWith(entry);
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 56, 'column': 2, 'index': 1719}","it('should unregister itself when unmounting', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const unregisterSpy = jest.spyOn(registry.droppable, 'unregister');

  const wrapper = mount(
    <WithAppContext registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  expect(registerSpy).toHaveBeenCalled();
  expect(unregisterSpy).not.toHaveBeenCalled();

  const entry = registerSpy.mock.calls[0][0];

  wrapper.unmount();
  expect(unregisterSpy).toHaveBeenCalledTimes(1);
  expect(unregisterSpy).toHaveBeenCalledWith(entry);
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 57, 'column': 2, 'index': 1769}","it('should unregister itself when unmounting', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const unregisterSpy = jest.spyOn(registry.droppable, 'unregister');

  const wrapper = mount(
    <WithAppContext registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  expect(registerSpy).toHaveBeenCalled();
  expect(unregisterSpy).not.toHaveBeenCalled();

  const entry = registerSpy.mock.calls[0][0];

  wrapper.unmount();
  expect(unregisterSpy).toHaveBeenCalledTimes(1);
  expect(unregisterSpy).toHaveBeenCalledWith(entry);
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 98, 'column': 2, 'index': 2877}","it('should update its registration when a descriptor property changes', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const unregisterSpy = jest.spyOn(registry.droppable, 'unregister');

  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext registry={registry}>
          <ScrollableItem {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // $ExpectError: using awesome matchers
  const expectedFirst: DroppableEntry = {
    uniqueId: expect.any(String),
    descriptor: preset.home.descriptor,
    callbacks: expect.any(Object),
  };

  // asserting shape of original publish
  const first = registerSpy.mock.calls[0][0];
  expect(first).toEqual(expectedFirst);

  registerSpy.mockClear();

  // updating the index
  wrapper.setProps({
    droppableId: 'some-new-id',
  });
  const updated: DroppableDescriptor = {
    ...preset.home.descriptor,
    id: 'some-new-id',
  };

  // old descriptor removed
  expect(unregisterSpy).toHaveBeenCalledTimes(1);
  expect(unregisterSpy).toHaveBeenCalledWith(first);

  // new descriptor added
  // $ExpectError: using awesome matchers
  const expectedSecond: DroppableEntry = {
    uniqueId: first.uniqueId,
    descriptor: updated,
    callbacks: expect.any(Object),
  };
  expect(registerSpy.mock.calls[0][0]).toEqual(expectedSecond);
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 99, 'column': 2, 'index': 2927}","it('should update its registration when a descriptor property changes', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const unregisterSpy = jest.spyOn(registry.droppable, 'unregister');

  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext registry={registry}>
          <ScrollableItem {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // $ExpectError: using awesome matchers
  const expectedFirst: DroppableEntry = {
    uniqueId: expect.any(String),
    descriptor: preset.home.descriptor,
    callbacks: expect.any(Object),
  };

  // asserting shape of original publish
  const first = registerSpy.mock.calls[0][0];
  expect(first).toEqual(expectedFirst);

  registerSpy.mockClear();

  // updating the index
  wrapper.setProps({
    droppableId: 'some-new-id',
  });
  const updated: DroppableDescriptor = {
    ...preset.home.descriptor,
    id: 'some-new-id',
  };

  // old descriptor removed
  expect(unregisterSpy).toHaveBeenCalledTimes(1);
  expect(unregisterSpy).toHaveBeenCalledWith(first);

  // new descriptor added
  // $ExpectError: using awesome matchers
  const expectedSecond: DroppableEntry = {
    uniqueId: first.uniqueId,
    descriptor: updated,
    callbacks: expect.any(Object),
  };
  expect(registerSpy.mock.calls[0][0]).toEqual(expectedSecond);
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 121, 'column': 2, 'index': 3664}","it('should not update its registration when a descriptor property does not change on an update', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const unregisterSpy = jest.spyOn(registry.droppable, 'unregister');

  const wrapper = mount(
    <WithAppContext registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  expect(registerSpy).toHaveBeenCalledTimes(1);
  expect(unregisterSpy).not.toHaveBeenCalled();
  registerSpy.mockClear();

  forceUpdate(wrapper);
  expect(unregisterSpy).not.toHaveBeenCalled();
  expect(registerSpy).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 122, 'column': 2, 'index': 3712}","it('should not update its registration when a descriptor property does not change on an update', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const unregisterSpy = jest.spyOn(registry.droppable, 'unregister');

  const wrapper = mount(
    <WithAppContext registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  expect(registerSpy).toHaveBeenCalledTimes(1);
  expect(unregisterSpy).not.toHaveBeenCalled();
  registerSpy.mockClear();

  forceUpdate(wrapper);
  expect(unregisterSpy).not.toHaveBeenCalled();
  expect(registerSpy).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 122, 'column': 2, 'index': 3712}","it('should not update its registration when a descriptor property does not change on an update', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const unregisterSpy = jest.spyOn(registry.droppable, 'unregister');

  const wrapper = mount(
    <WithAppContext registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  expect(registerSpy).toHaveBeenCalledTimes(1);
  expect(unregisterSpy).not.toHaveBeenCalled();
  registerSpy.mockClear();

  forceUpdate(wrapper);
  expect(unregisterSpy).not.toHaveBeenCalled();
  expect(registerSpy).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 126, 'column': 2, 'index': 3812}","it('should not update its registration when a descriptor property does not change on an update', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const unregisterSpy = jest.spyOn(registry.droppable, 'unregister');

  const wrapper = mount(
    <WithAppContext registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  expect(registerSpy).toHaveBeenCalledTimes(1);
  expect(unregisterSpy).not.toHaveBeenCalled();
  registerSpy.mockClear();

  forceUpdate(wrapper);
  expect(unregisterSpy).not.toHaveBeenCalled();
  expect(registerSpy).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 126, 'column': 2, 'index': 3812}","it('should not update its registration when a descriptor property does not change on an update', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const unregisterSpy = jest.spyOn(registry.droppable, 'unregister');

  const wrapper = mount(
    <WithAppContext registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  expect(registerSpy).toHaveBeenCalledTimes(1);
  expect(unregisterSpy).not.toHaveBeenCalled();
  registerSpy.mockClear();

  forceUpdate(wrapper);
  expect(unregisterSpy).not.toHaveBeenCalled();
  expect(registerSpy).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/registration.spec.js,Duplicate Assert,"{'line': 127, 'column': 2, 'index': 3860}","it('should not update its registration when a descriptor property does not change on an update', () => {
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const unregisterSpy = jest.spyOn(registry.droppable, 'unregister');

  const wrapper = mount(
    <WithAppContext registry={registry}>
      <ScrollableItem />
    </WithAppContext>,
  );
  expect(registerSpy).toHaveBeenCalledTimes(1);
  expect(unregisterSpy).not.toHaveBeenCalled();
  registerSpy.mockClear();

  forceUpdate(wrapper);
  expect(unregisterSpy).not.toHaveBeenCalled();
  expect(registerSpy).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/publishing.spec.js,Duplicate Assert,"{'line': 413, 'column': 4, 'index': 13396}","it('should log a warning as the use case is not supported', () => {
    jest.spyOn(console, 'warn').mockImplementation(() => {});
    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      borderBox: bigClient.borderBox,
      margin,
      padding,
      border,
      closest: {
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        scrollSize: {
          scrollWidth: bigClient.paddingBox.width,
          scrollHeight: bigClient.paddingBox.height,
        },
        scroll: { x: 0, y: 0 },
        shouldClipSubject: true,
      },
      windowScroll: preset.windowScroll,
    });
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App parentIsScrollable droppableIsScrollable />,
      </WithAppContext>,
    );
    const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(droppable);
    const parent: HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
    jest
      .spyOn(droppable, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    Object.defineProperty(droppable, 'scrollWidth', {
      value: bigClient.paddingBox.width,
    });
    Object.defineProperty(droppable, 'scrollHeight', {
      value: bigClient.paddingBox.height,
    });
    // should never be called!
    jest.spyOn(parent, 'getBoundingClientRect').mockImplementation(() => {
      throw new Error(
        'Should not be getting the boundingClientRect on the parent',
      );
    });

    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    expect(console.warn).not.toHaveBeenCalled();
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );
    expect(console.warn).toHaveBeenCalled();

    expect(result).toEqual(expected);
    // $FlowFixMe
    console.warn.mockRestore();
  })",steel
/test/unit/view/use-droppable-publisher/publishing.spec.js,Duplicate Assert,"{'line': 418, 'column': 4, 'index': 13573}","it('should log a warning as the use case is not supported', () => {
    jest.spyOn(console, 'warn').mockImplementation(() => {});
    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      borderBox: bigClient.borderBox,
      margin,
      padding,
      border,
      closest: {
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        scrollSize: {
          scrollWidth: bigClient.paddingBox.width,
          scrollHeight: bigClient.paddingBox.height,
        },
        scroll: { x: 0, y: 0 },
        shouldClipSubject: true,
      },
      windowScroll: preset.windowScroll,
    });
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App parentIsScrollable droppableIsScrollable />,
      </WithAppContext>,
    );
    const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(droppable);
    const parent: HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
    jest
      .spyOn(droppable, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    Object.defineProperty(droppable, 'scrollWidth', {
      value: bigClient.paddingBox.width,
    });
    Object.defineProperty(droppable, 'scrollHeight', {
      value: bigClient.paddingBox.height,
    });
    // should never be called!
    jest.spyOn(parent, 'getBoundingClientRect').mockImplementation(() => {
      throw new Error(
        'Should not be getting the boundingClientRect on the parent',
      );
    });

    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    expect(console.warn).not.toHaveBeenCalled();
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );
    expect(console.warn).toHaveBeenCalled();

    expect(result).toEqual(expected);
    // $FlowFixMe
    console.warn.mockRestore();
  })",steel
/test/unit/view/use-droppable-publisher/publishing.spec.js,Exception Handling,"{'line': 404, 'column': 6, 'index': 13117}","it('should log a warning as the use case is not supported', () => {
    jest.spyOn(console, 'warn').mockImplementation(() => {});
    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      borderBox: bigClient.borderBox,
      margin,
      padding,
      border,
      closest: {
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        scrollSize: {
          scrollWidth: bigClient.paddingBox.width,
          scrollHeight: bigClient.paddingBox.height,
        },
        scroll: { x: 0, y: 0 },
        shouldClipSubject: true,
      },
      windowScroll: preset.windowScroll,
    });
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App parentIsScrollable droppableIsScrollable />,
      </WithAppContext>,
    );
    const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(droppable);
    const parent: HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
    jest
      .spyOn(droppable, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    Object.defineProperty(droppable, 'scrollWidth', {
      value: bigClient.paddingBox.width,
    });
    Object.defineProperty(droppable, 'scrollHeight', {
      value: bigClient.paddingBox.height,
    });
    // should never be called!
    jest.spyOn(parent, 'getBoundingClientRect').mockImplementation(() => {
      throw new Error(
        'Should not be getting the boundingClientRect on the parent',
      );
    });

    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    expect(console.warn).not.toHaveBeenCalled();
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );
    expect(console.warn).toHaveBeenCalled();

    expect(result).toEqual(expected);
    // $FlowFixMe
    console.warn.mockRestore();
  })",steel
/test/unit/view/use-droppable-publisher/publishing.spec.js,Redundant Print,"{'line': 413, 'column': 11, 'index': 13403}","it('should log a warning as the use case is not supported', () => {
    jest.spyOn(console, 'warn').mockImplementation(() => {});
    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      borderBox: bigClient.borderBox,
      margin,
      padding,
      border,
      closest: {
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        scrollSize: {
          scrollWidth: bigClient.paddingBox.width,
          scrollHeight: bigClient.paddingBox.height,
        },
        scroll: { x: 0, y: 0 },
        shouldClipSubject: true,
      },
      windowScroll: preset.windowScroll,
    });
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App parentIsScrollable droppableIsScrollable />,
      </WithAppContext>,
    );
    const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(droppable);
    const parent: HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
    jest
      .spyOn(droppable, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    Object.defineProperty(droppable, 'scrollWidth', {
      value: bigClient.paddingBox.width,
    });
    Object.defineProperty(droppable, 'scrollHeight', {
      value: bigClient.paddingBox.height,
    });
    // should never be called!
    jest.spyOn(parent, 'getBoundingClientRect').mockImplementation(() => {
      throw new Error(
        'Should not be getting the boundingClientRect on the parent',
      );
    });

    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    expect(console.warn).not.toHaveBeenCalled();
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );
    expect(console.warn).toHaveBeenCalled();

    expect(result).toEqual(expected);
    // $FlowFixMe
    console.warn.mockRestore();
  })",steel
/test/unit/view/use-droppable-publisher/publishing.spec.js,Redundant Print,"{'line': 418, 'column': 11, 'index': 13580}","it('should log a warning as the use case is not supported', () => {
    jest.spyOn(console, 'warn').mockImplementation(() => {});
    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      borderBox: bigClient.borderBox,
      margin,
      padding,
      border,
      closest: {
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        scrollSize: {
          scrollWidth: bigClient.paddingBox.width,
          scrollHeight: bigClient.paddingBox.height,
        },
        scroll: { x: 0, y: 0 },
        shouldClipSubject: true,
      },
      windowScroll: preset.windowScroll,
    });
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App parentIsScrollable droppableIsScrollable />,
      </WithAppContext>,
    );
    const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(droppable);
    const parent: HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
    jest
      .spyOn(droppable, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    Object.defineProperty(droppable, 'scrollWidth', {
      value: bigClient.paddingBox.width,
    });
    Object.defineProperty(droppable, 'scrollHeight', {
      value: bigClient.paddingBox.height,
    });
    // should never be called!
    jest.spyOn(parent, 'getBoundingClientRect').mockImplementation(() => {
      throw new Error(
        'Should not be getting the boundingClientRect on the parent',
      );
    });

    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    expect(console.warn).not.toHaveBeenCalled();
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );
    expect(console.warn).toHaveBeenCalled();

    expect(result).toEqual(expected);
    // $FlowFixMe
    console.warn.mockRestore();
  })",steel
/test/unit/view/use-droppable-publisher/publishing.spec.js,Redundant Print,"{'line': 422, 'column': 4, 'index': 13675}","it('should log a warning as the use case is not supported', () => {
    jest.spyOn(console, 'warn').mockImplementation(() => {});
    const expected: DroppableDimension = getDroppableDimension({
      descriptor,
      borderBox: bigClient.borderBox,
      margin,
      padding,
      border,
      closest: {
        borderBox: smallFrameClient.borderBox,
        margin,
        padding,
        border,
        scrollSize: {
          scrollWidth: bigClient.paddingBox.width,
          scrollHeight: bigClient.paddingBox.height,
        },
        scroll: { x: 0, y: 0 },
        shouldClipSubject: true,
      },
      windowScroll: preset.windowScroll,
    });
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext registry={registry}>
        <App parentIsScrollable droppableIsScrollable />,
      </WithAppContext>,
    );
    const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
    invariant(droppable);
    const parent: HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
    jest
      .spyOn(droppable, 'getBoundingClientRect')
      .mockImplementation(() => smallFrameClient.borderBox);
    Object.defineProperty(droppable, 'scrollWidth', {
      value: bigClient.paddingBox.width,
    });
    Object.defineProperty(droppable, 'scrollHeight', {
      value: bigClient.paddingBox.height,
    });
    // should never be called!
    jest.spyOn(parent, 'getBoundingClientRect').mockImplementation(() => {
      throw new Error(
        'Should not be getting the boundingClientRect on the parent',
      );
    });

    // pull the get dimension function out
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // execute it to get the dimension
    expect(console.warn).not.toHaveBeenCalled();
    const result: DroppableDimension = callbacks.getDimensionAndWatchScroll(
      preset.windowScroll,
      immediate,
    );
    expect(console.warn).toHaveBeenCalled();

    expect(result).toEqual(expected);
    // $FlowFixMe
    console.warn.mockRestore();
  })",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 37, 'column': 2, 'index': 1237}","it('should publish updates to the enabled state when dragging', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );
  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  const isDropDisabled: boolean = true;
  wrapper.setProps({
    isDropDisabled,
  });

  expect(marshal.updateDroppableIsEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    !isDropDisabled,
  );
})",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 47, 'column': 2, 'index': 1546}","it('should publish updates to the enabled state when dragging', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );
  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  const isDropDisabled: boolean = true;
  wrapper.setProps({
    isDropDisabled,
  });

  expect(marshal.updateDroppableIsEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    !isDropDisabled,
  );
})",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 48, 'column': 2, 'index': 1615}","it('should publish updates to the enabled state when dragging', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );
  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  const isDropDisabled: boolean = true;
  wrapper.setProps({
    isDropDisabled,
  });

  expect(marshal.updateDroppableIsEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    !isDropDisabled,
  );
})",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 68, 'column': 2, 'index': 2207}","it('should not publish updates to the enabled state when there is no drag', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();

  // no yet dragging

  wrapper.setProps({
    isDropDisabled: true,
  });

  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 68, 'column': 2, 'index': 2207}","it('should not publish updates to the enabled state when there is no drag', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();

  // no yet dragging

  wrapper.setProps({
    isDropDisabled: true,
  });

  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 76, 'column': 2, 'index': 2351}","it('should not publish updates to the enabled state when there is no drag', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();

  // no yet dragging

  wrapper.setProps({
    isDropDisabled: true,
  });

  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 76, 'column': 2, 'index': 2351}","it('should not publish updates to the enabled state when there is no drag', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();

  // no yet dragging

  wrapper.setProps({
    isDropDisabled: true,
  });

  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 94, 'column': 2, 'index': 2935}","it('should not publish updates when there is no change', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // no change
  wrapper.setProps({
    isDropDisabled: false,
  });

  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
  // $ExpectError
  marshal.updateDroppableIsEnabled.mockReset();

  forceUpdate(wrapper);
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 94, 'column': 2, 'index': 2935}","it('should not publish updates when there is no change', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // no change
  wrapper.setProps({
    isDropDisabled: false,
  });

  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
  // $ExpectError
  marshal.updateDroppableIsEnabled.mockReset();

  forceUpdate(wrapper);
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 103, 'column': 2, 'index': 3225}","it('should not publish updates when there is no change', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // no change
  wrapper.setProps({
    isDropDisabled: false,
  });

  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
  // $ExpectError
  marshal.updateDroppableIsEnabled.mockReset();

  forceUpdate(wrapper);
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 103, 'column': 2, 'index': 3225}","it('should not publish updates when there is no change', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // no change
  wrapper.setProps({
    isDropDisabled: false,
  });

  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
  // $ExpectError
  marshal.updateDroppableIsEnabled.mockReset();

  forceUpdate(wrapper);
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 108, 'column': 2, 'index': 3383}","it('should not publish updates when there is no change', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // no change
  wrapper.setProps({
    isDropDisabled: false,
  });

  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
  // $ExpectError
  marshal.updateDroppableIsEnabled.mockReset();

  forceUpdate(wrapper);
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-enabled-change.spec.js,Duplicate Assert,"{'line': 108, 'column': 2, 'index': 3383}","it('should not publish updates when there is no change', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isDropDisabled={false} {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // no change
  wrapper.setProps({
    isDropDisabled: false,
  });

  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
  // $ExpectError
  marshal.updateDroppableIsEnabled.mockReset();

  forceUpdate(wrapper);
  expect(marshal.updateDroppableIsEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js,Conditional Test Logic,"{'line': 6, 'column': 29, 'index': 282}","it('should return true if an element has overflow:auto or overflow:scroll', () => {
  ['overflowY', 'overflowX'].forEach((overflow: string) => {
    ['auto', 'scroll'].forEach((value: string) => {
      const el: HTMLElement = document.createElement('div');
      // $ExpectError - flow being mean
      el.style[overflow] = value;
      expect(getClosestScrollable(el)).toBe(el);
    });
  });
})",steel
/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js,Conditional Test Logic,"{'line': 7, 'column': 23, 'index': 337}","it('should return true if an element has overflow:auto or overflow:scroll', () => {
  ['overflowY', 'overflowX'].forEach((overflow: string) => {
    ['auto', 'scroll'].forEach((value: string) => {
      const el: HTMLElement = document.createElement('div');
      // $ExpectError - flow being mean
      el.style[overflow] = value;
      expect(getClosestScrollable(el)).toBe(el);
    });
  });
})",steel
/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js,Conditional Test Logic,"{'line': 17, 'column': 29, 'index': 667}","it('should return false if an element has overflow:visible', () => {
  ['overflowY', 'overflowX'].forEach((overflow: string) => {
    const el: HTMLElement = document.createElement('div');
    // $ExpectError - flow being mean
    el.style[overflow] = 'visible';
    expect(getClosestScrollable(el)).toBe(null);
  });
})",steel
/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js,Redundant Print,"{'line': 65, 'column': 11, 'index': 2067}","it('should warn if the body might be a scroll container', () => {
    body.style.overflowX = 'auto';
    html.style.overflowY = 'auto';

    expect(getClosestScrollable(body)).toBe(null);
    expect(console.warn).toHaveBeenCalled();
  })",steel
/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js,Redundant Print,"{'line': 71, 'column': 11, 'index': 2308}","it('should not mark the body as a scroll container if it does not have any overflow set', () => {
    body.style.overflowX = 'visible';
    expect(getClosestScrollable(body)).toBe(null);
    expect(console.warn).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js,Redundant Print,"{'line': 78, 'column': 11, 'index': 2592}","it('should not mark the body as a scroll container if the html element has visible overflow', () => {
    body.style.overflowX = 'auto';
    html.style.overflowY = 'visible';
    expect(getClosestScrollable(body)).toBe(null);
    expect(console.warn).not.toHaveBeenCalled();
  })",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 37, 'column': 2, 'index': 1231}","it('should publish updates to the enabled state when dragging', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );
  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // changing to false
  wrapper.setProps({
    isCombineEnabled: false,
  });
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    false,
  );
  // $FlowFixMe
  marshal.updateDroppableIsCombineEnabled.mockClear();

  // now setting to true
  wrapper.setProps({
    isCombineEnabled: true,
  });
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    true,
  );
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 46, 'column': 2, 'index': 1538}","it('should publish updates to the enabled state when dragging', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );
  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // changing to false
  wrapper.setProps({
    isCombineEnabled: false,
  });
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    false,
  );
  // $FlowFixMe
  marshal.updateDroppableIsCombineEnabled.mockClear();

  // now setting to true
  wrapper.setProps({
    isCombineEnabled: true,
  });
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    true,
  );
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 47, 'column': 2, 'index': 1614}","it('should publish updates to the enabled state when dragging', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );
  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // changing to false
  wrapper.setProps({
    isCombineEnabled: false,
  });
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    false,
  );
  // $FlowFixMe
  marshal.updateDroppableIsCombineEnabled.mockClear();

  // now setting to true
  wrapper.setProps({
    isCombineEnabled: true,
  });
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    true,
  );
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 58, 'column': 2, 'index': 1885}","it('should publish updates to the enabled state when dragging', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );
  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // changing to false
  wrapper.setProps({
    isCombineEnabled: false,
  });
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    false,
  );
  // $FlowFixMe
  marshal.updateDroppableIsCombineEnabled.mockClear();

  // now setting to true
  wrapper.setProps({
    isCombineEnabled: true,
  });
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    true,
  );
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 59, 'column': 2, 'index': 1961}","it('should publish updates to the enabled state when dragging', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />
        </WithAppContext>
      )}
    </PassThroughProps>,
  );
  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // changing to false
  wrapper.setProps({
    isCombineEnabled: false,
  });
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    false,
  );
  // $FlowFixMe
  marshal.updateDroppableIsCombineEnabled.mockClear();

  // now setting to true
  wrapper.setProps({
    isCombineEnabled: true,
  });
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledTimes(1);
  expect(marshal.updateDroppableIsCombineEnabled).toHaveBeenCalledWith(
    preset.home.descriptor.id,
    true,
  );
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 79, 'column': 2, 'index': 2544}","it('should not publish updates to the enabled state when there is no drag', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />,
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();

  // no yet dragging

  wrapper.setProps({
    isCombineEnabled: false,
  });

  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 79, 'column': 2, 'index': 2544}","it('should not publish updates to the enabled state when there is no drag', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />,
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();

  // no yet dragging

  wrapper.setProps({
    isCombineEnabled: false,
  });

  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 87, 'column': 2, 'index': 2698}","it('should not publish updates to the enabled state when there is no drag', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />,
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();

  // no yet dragging

  wrapper.setProps({
    isCombineEnabled: false,
  });

  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 87, 'column': 2, 'index': 2698}","it('should not publish updates to the enabled state when there is no drag', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />,
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();

  // no yet dragging

  wrapper.setProps({
    isCombineEnabled: false,
  });

  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 105, 'column': 2, 'index': 3284}","it('should not publish updates when there is no change', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />,
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // no change
  wrapper.setProps({
    isCombineEnabled: true,
  });

  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
  // $FlowFixMe
  marshal.updateDroppableIsCombineEnabled.mockReset();

  forceUpdate(wrapper);
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 105, 'column': 2, 'index': 3284}","it('should not publish updates when there is no change', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />,
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // no change
  wrapper.setProps({
    isCombineEnabled: true,
  });

  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
  // $FlowFixMe
  marshal.updateDroppableIsCombineEnabled.mockReset();

  forceUpdate(wrapper);
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 114, 'column': 2, 'index': 3582}","it('should not publish updates when there is no change', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />,
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // no change
  wrapper.setProps({
    isCombineEnabled: true,
  });

  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
  // $FlowFixMe
  marshal.updateDroppableIsCombineEnabled.mockReset();

  forceUpdate(wrapper);
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 114, 'column': 2, 'index': 3582}","it('should not publish updates when there is no change', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />,
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // no change
  wrapper.setProps({
    isCombineEnabled: true,
  });

  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
  // $FlowFixMe
  marshal.updateDroppableIsCombineEnabled.mockReset();

  forceUpdate(wrapper);
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 119, 'column': 2, 'index': 3752}","it('should not publish updates when there is no change', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />,
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // no change
  wrapper.setProps({
    isCombineEnabled: true,
  });

  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
  // $FlowFixMe
  marshal.updateDroppableIsCombineEnabled.mockReset();

  forceUpdate(wrapper);
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/is-combined-enabled-change.spec.js,Duplicate Assert,"{'line': 119, 'column': 2, 'index': 3752}","it('should not publish updates when there is no change', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  const wrapper = mount(
    <PassThroughProps>
      {(extra) => (
        <WithAppContext marshal={marshal} registry={registry}>
          <ScrollableItem isCombineEnabled {...extra} />,
        </WithAppContext>
      )}
    </PassThroughProps>,
  );

  // not called yet
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // no change
  wrapper.setProps({
    isCombineEnabled: true,
  });

  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
  // $FlowFixMe
  marshal.updateDroppableIsCombineEnabled.mockReset();

  forceUpdate(wrapper);
  expect(marshal.updateDroppableIsCombineEnabled).not.toHaveBeenCalled();
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 53, 'column': 2, 'index': 1727}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 53, 'column': 2, 'index': 1727}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 54, 'column': 2, 'index': 1763}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 54, 'column': 2, 'index': 1763}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 55, 'column': 2, 'index': 1800}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 55, 'column': 2, 'index': 1800}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 56, 'column': 2, 'index': 1839}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 56, 'column': 2, 'index': 1839}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 66, 'column': 2, 'index': 2200}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 66, 'column': 2, 'index': 2200}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 67, 'column': 2, 'index': 2236}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 67, 'column': 2, 'index': 2236}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 68, 'column': 2, 'index': 2273}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 68, 'column': 2, 'index': 2273}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 69, 'column': 2, 'index': 2312}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 69, 'column': 2, 'index': 2312}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 87, 'column': 4, 'index': 2921}","it('should update the scroll of the closest scrollable', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);

    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    callbacks.scroll({ x: 500, y: 1000 });

    expect(container.scrollLeft).toBe(500);
    expect(container.scrollTop).toBe(1000);
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 88, 'column': 4, 'index': 2962}","it('should update the scroll of the closest scrollable', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);

    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    callbacks.scroll({ x: 500, y: 1000 });

    expect(container.scrollLeft).toBe(500);
    expect(container.scrollTop).toBe(1000);
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 98, 'column': 4, 'index': 3334}","it('should update the scroll of the closest scrollable', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);

    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    callbacks.scroll({ x: 500, y: 1000 });

    expect(container.scrollLeft).toBe(500);
    expect(container.scrollTop).toBe(1000);
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 99, 'column': 4, 'index': 3378}","it('should update the scroll of the closest scrollable', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);

    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    callbacks.scroll({ x: 500, y: 1000 });

    expect(container.scrollLeft).toBe(500);
    expect(container.scrollTop).toBe(1000);
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 122, 'column': 4, 'index': 4171}","it('should throw if asked to scoll while scroll is not currently being watched', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );

    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // dimension not returned yet
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    expect(() => callbacks.scroll({ x: 500, y: 1000 })).toThrow();

    // now watching scroll
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

    // no longer watching scroll
    callbacks.dragStopped();
    expect(() => callbacks.scroll({ x: 500, y: 1000 })).toThrow();
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 122, 'column': 4, 'index': 4171}","it('should throw if asked to scoll while scroll is not currently being watched', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );

    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // dimension not returned yet
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    expect(() => callbacks.scroll({ x: 500, y: 1000 })).toThrow();

    // now watching scroll
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

    // no longer watching scroll
    callbacks.dragStopped();
    expect(() => callbacks.scroll({ x: 500, y: 1000 })).toThrow();
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 129, 'column': 4, 'index': 4403}","it('should throw if asked to scoll while scroll is not currently being watched', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );

    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // dimension not returned yet
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    expect(() => callbacks.scroll({ x: 500, y: 1000 })).toThrow();

    // now watching scroll
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

    // no longer watching scroll
    callbacks.dragStopped();
    expect(() => callbacks.scroll({ x: 500, y: 1000 })).toThrow();
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Duplicate Assert,"{'line': 129, 'column': 4, 'index': 4403}","it('should throw if asked to scoll while scroll is not currently being watched', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );

    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // dimension not returned yet
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    expect(() => callbacks.scroll({ x: 500, y: 1000 })).toThrow();

    // now watching scroll
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

    // no longer watching scroll
    callbacks.dragStopped();
    expect(() => callbacks.scroll({ x: 500, y: 1000 })).toThrow();
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 53, 'column': 32, 'index': 1757}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 54, 'column': 33, 'index': 1794}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 55, 'column': 35, 'index': 1833}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 56, 'column': 36, 'index': 1873}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 66, 'column': 32, 'index': 2230}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 67, 'column': 33, 'index': 2267}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 68, 'column': 35, 'index': 2306}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 69, 'column': 36, 'index': 2346}","it('should throw if the droppable has no closest scrollable', () => {
  const marshal: DimensionMarshal = getMarshalStub();
  const registry: Registry = createRegistry();
  const registerSpy = jest.spyOn(registry.droppable, 'register');
  // no scroll parent
  const wrapper = mount(
    <WithAppContext marshal={marshal} registry={registry}>
      <App parentIsScrollable={false} droppableIsScrollable={false} />,
    </WithAppContext>,
  );
  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
  invariant(droppable);
  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
  invariant(parent);
  jest
    .spyOn(droppable, 'getBoundingClientRect')
    .mockImplementation(() => smallFrameClient.borderBox);
  jest
    .spyOn(parent, 'getBoundingClientRect')
    .mockImplementation(() => bigClient.borderBox);

  // validating no initial scroll
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);

  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
  // request the droppable start listening for scrolling
  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

  // ask it to scroll
  expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

  // no scroll changes
  expect(parent.scrollTop).toBe(0);
  expect(parent.scrollLeft).toBe(0);
  expect(droppable.scrollTop).toBe(0);
  expect(droppable.scrollLeft).toBe(0);
})",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 87, 'column': 37, 'index': 2954}","it('should update the scroll of the closest scrollable', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);

    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    callbacks.scroll({ x: 500, y: 1000 });

    expect(container.scrollLeft).toBe(500);
    expect(container.scrollTop).toBe(1000);
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 88, 'column': 38, 'index': 2996}","it('should update the scroll of the closest scrollable', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);

    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    callbacks.scroll({ x: 500, y: 1000 });

    expect(container.scrollLeft).toBe(500);
    expect(container.scrollTop).toBe(1000);
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 98, 'column': 38, 'index': 3368}","it('should update the scroll of the closest scrollable', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);

    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    callbacks.scroll({ x: 500, y: 1000 });

    expect(container.scrollLeft).toBe(500);
    expect(container.scrollTop).toBe(1000);
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 99, 'column': 37, 'index': 3411}","it('should update the scroll of the closest scrollable', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );
    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);

    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // tell the droppable to watch for scrolling
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    // watch scroll will only be called after the dimension is requested
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

    callbacks.scroll({ x: 500, y: 1000 });

    expect(container.scrollLeft).toBe(500);
    expect(container.scrollTop).toBe(1000);
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 116, 'column': 37, 'index': 3998}","it('should throw if asked to scoll while scroll is not currently being watched', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );

    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // dimension not returned yet
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    expect(() => callbacks.scroll({ x: 500, y: 1000 })).toThrow();

    // now watching scroll
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

    // no longer watching scroll
    callbacks.dragStopped();
    expect(() => callbacks.scroll({ x: 500, y: 1000 })).toThrow();
  })",steel
/test/unit/view/use-droppable-publisher/forced-scroll.spec.js,Magic Number,"{'line': 117, 'column': 38, 'index': 4040}","it('should throw if asked to scoll while scroll is not currently being watched', () => {
    const marshal: DimensionMarshal = getMarshalStub();
    const registry: Registry = createRegistry();
    const registerSpy = jest.spyOn(registry.droppable, 'register');
    const wrapper = mount(
      <WithAppContext marshal={marshal} registry={registry}>
        <ScrollableItem />
      </WithAppContext>,
    );

    const container: ?HTMLElement = wrapper
      .find('.scroll-container')
      .getDOMNode();
    invariant(container);
    expect(container.scrollTop).toBe(0);
    expect(container.scrollLeft).toBe(0);

    // dimension not returned yet
    const callbacks: DroppableCallbacks =
      registerSpy.mock.calls[0][0].callbacks;
    expect(() => callbacks.scroll({ x: 500, y: 1000 })).toThrow();

    // now watching scroll
    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

    // no longer watching scroll
    callbacks.dragStopped();
    expect(() => callbacks.scroll({ x: 500, y: 1000 })).toThrow();
  })",steel
/test/unit/view/style-marshal/style-marshal.spec.js,Duplicate Assert,"{'line': 58, 'column': 2, 'index': 2061}","it('should not mount style tags until mounted', () => {
  const contextId: ContextId = '1';
  const dynamicSelector: string = getDynamicStyleTagSelector(contextId);
  const alwaysSelector: string = getAlwaysStyleTagSelector(contextId);

  // initially there is no style tag
  expect(document.querySelector(dynamicSelector)).toBeFalsy();
  expect(document.querySelector(alwaysSelector)).toBeFalsy();

  // now mounting
  const wrapper: ReactWrapper<*> = mount(
    <WithMarshal contextId={contextId}>{getMock()}</WithMarshal>,
  );

  // elements should now exist
  expect(document.querySelector(alwaysSelector)).toBeInstanceOf(
    HTMLStyleElement,
  );
  expect(document.querySelector(dynamicSelector)).toBeInstanceOf(
    HTMLStyleElement,
  );

  wrapper.unmount();
})",steel
/test/unit/view/style-marshal/style-marshal.spec.js,Duplicate Assert,"{'line': 59, 'column': 2, 'index': 2124}","it('should not mount style tags until mounted', () => {
  const contextId: ContextId = '1';
  const dynamicSelector: string = getDynamicStyleTagSelector(contextId);
  const alwaysSelector: string = getAlwaysStyleTagSelector(contextId);

  // initially there is no style tag
  expect(document.querySelector(dynamicSelector)).toBeFalsy();
  expect(document.querySelector(alwaysSelector)).toBeFalsy();

  // now mounting
  const wrapper: ReactWrapper<*> = mount(
    <WithMarshal contextId={contextId}>{getMock()}</WithMarshal>,
  );

  // elements should now exist
  expect(document.querySelector(alwaysSelector)).toBeInstanceOf(
    HTMLStyleElement,
  );
  expect(document.querySelector(dynamicSelector)).toBeInstanceOf(
    HTMLStyleElement,
  );

  wrapper.unmount();
})",steel
/test/unit/view/style-marshal/style-marshal.spec.js,Duplicate Assert,"{'line': 67, 'column': 2, 'index': 2350}","it('should not mount style tags until mounted', () => {
  const contextId: ContextId = '1';
  const dynamicSelector: string = getDynamicStyleTagSelector(contextId);
  const alwaysSelector: string = getAlwaysStyleTagSelector(contextId);

  // initially there is no style tag
  expect(document.querySelector(dynamicSelector)).toBeFalsy();
  expect(document.querySelector(alwaysSelector)).toBeFalsy();

  // now mounting
  const wrapper: ReactWrapper<*> = mount(
    <WithMarshal contextId={contextId}>{getMock()}</WithMarshal>,
  );

  // elements should now exist
  expect(document.querySelector(alwaysSelector)).toBeInstanceOf(
    HTMLStyleElement,
  );
  expect(document.querySelector(dynamicSelector)).toBeInstanceOf(
    HTMLStyleElement,
  );

  wrapper.unmount();
})",steel
/test/unit/view/style-marshal/style-marshal.spec.js,Duplicate Assert,"{'line': 70, 'column': 2, 'index': 2442}","it('should not mount style tags until mounted', () => {
  const contextId: ContextId = '1';
  const dynamicSelector: string = getDynamicStyleTagSelector(contextId);
  const alwaysSelector: string = getAlwaysStyleTagSelector(contextId);

  // initially there is no style tag
  expect(document.querySelector(dynamicSelector)).toBeFalsy();
  expect(document.querySelector(alwaysSelector)).toBeFalsy();

  // now mounting
  const wrapper: ReactWrapper<*> = mount(
    <WithMarshal contextId={contextId}>{getMock()}</WithMarshal>,
  );

  // elements should now exist
  expect(document.querySelector(alwaysSelector)).toBeInstanceOf(
    HTMLStyleElement,
  );
  expect(document.querySelector(dynamicSelector)).toBeInstanceOf(
    HTMLStyleElement,
  );

  wrapper.unmount();
})",steel
/test/unit/view/style-marshal/style-marshal.spec.js,Duplicate Assert,"{'line': 156, 'column': 2, 'index': 5047}","it('should remove the style tag from the head when unmounting', () => {
  const contextId: ContextId = '2';
  const wrapper: ReactWrapper<*> = mount(
    <WithMarshal contextId={contextId}>{getMock()}</WithMarshal>,
  );
  const selector1: string = getDynamicStyleTagSelector(contextId);
  const selector2: string = getAlwaysStyleTagSelector(contextId);

  // the style tag exists
  expect(document.querySelector(selector1)).toBeTruthy();
  expect(document.querySelector(selector2)).toBeTruthy();

  // now unmounted
  wrapper.unmount();

  expect(document.querySelector(selector1)).not.toBeTruthy();
  expect(document.querySelector(selector2)).not.toBeTruthy();
})",steel
/test/unit/view/style-marshal/style-marshal.spec.js,Duplicate Assert,"{'line': 157, 'column': 2, 'index': 5105}","it('should remove the style tag from the head when unmounting', () => {
  const contextId: ContextId = '2';
  const wrapper: ReactWrapper<*> = mount(
    <WithMarshal contextId={contextId}>{getMock()}</WithMarshal>,
  );
  const selector1: string = getDynamicStyleTagSelector(contextId);
  const selector2: string = getAlwaysStyleTagSelector(contextId);

  // the style tag exists
  expect(document.querySelector(selector1)).toBeTruthy();
  expect(document.querySelector(selector2)).toBeTruthy();

  // now unmounted
  wrapper.unmount();

  expect(document.querySelector(selector1)).not.toBeTruthy();
  expect(document.querySelector(selector2)).not.toBeTruthy();
})",steel
/test/unit/view/style-marshal/style-marshal.spec.js,Duplicate Assert,"{'line': 162, 'column': 2, 'index': 5205}","it('should remove the style tag from the head when unmounting', () => {
  const contextId: ContextId = '2';
  const wrapper: ReactWrapper<*> = mount(
    <WithMarshal contextId={contextId}>{getMock()}</WithMarshal>,
  );
  const selector1: string = getDynamicStyleTagSelector(contextId);
  const selector2: string = getAlwaysStyleTagSelector(contextId);

  // the style tag exists
  expect(document.querySelector(selector1)).toBeTruthy();
  expect(document.querySelector(selector2)).toBeTruthy();

  // now unmounted
  wrapper.unmount();

  expect(document.querySelector(selector1)).not.toBeTruthy();
  expect(document.querySelector(selector2)).not.toBeTruthy();
})",steel
/test/unit/view/style-marshal/style-marshal.spec.js,Duplicate Assert,"{'line': 163, 'column': 2, 'index': 5267}","it('should remove the style tag from the head when unmounting', () => {
  const contextId: ContextId = '2';
  const wrapper: ReactWrapper<*> = mount(
    <WithMarshal contextId={contextId}>{getMock()}</WithMarshal>,
  );
  const selector1: string = getDynamicStyleTagSelector(contextId);
  const selector2: string = getAlwaysStyleTagSelector(contextId);

  // the style tag exists
  expect(document.querySelector(selector1)).toBeTruthy();
  expect(document.querySelector(selector2)).toBeTruthy();

  // now unmounted
  wrapper.unmount();

  expect(document.querySelector(selector1)).not.toBeTruthy();
  expect(document.querySelector(selector2)).not.toBeTruthy();
})",steel
/test/unit/view/style-marshal/style-marshal.spec.js,Duplicate Assert,"{'line': 177, 'column': 4, 'index': 5723}","it('should allow subsequent updates', () => {
  const contextId: ContextId = '10';
  const styles: Styles = getStyles(`${contextId}`);
  const mock = getMock();
  const wrapper: ReactWrapper<*> = mount(
    <WithMarshal contextId={contextId}>{mock}</WithMarshal>,
  );
  const marshal: StyleMarshal = getMarshal(mock);

  Array.from({ length: 4 }).forEach(() => {
    marshal.resting();
    expect(getDynamicStyleFromTag(contextId)).toEqual(styles.resting);

    marshal.dragging();
    expect(getDynamicStyleFromTag(contextId)).toEqual(styles.dragging);

    marshal.dropping('DROP');
    expect(getDynamicStyleFromTag(contextId)).toEqual(styles.dropAnimating);
  });

  wrapper.unmount();
})",steel
/test/unit/view/style-marshal/style-marshal.spec.js,Duplicate Assert,"{'line': 180, 'column': 4, 'index': 5819}","it('should allow subsequent updates', () => {
  const contextId: ContextId = '10';
  const styles: Styles = getStyles(`${contextId}`);
  const mock = getMock();
  const wrapper: ReactWrapper<*> = mount(
    <WithMarshal contextId={contextId}>{mock}</WithMarshal>,
  );
  const marshal: StyleMarshal = getMarshal(mock);

  Array.from({ length: 4 }).forEach(() => {
    marshal.resting();
    expect(getDynamicStyleFromTag(contextId)).toEqual(styles.resting);

    marshal.dragging();
    expect(getDynamicStyleFromTag(contextId)).toEqual(styles.dragging);

    marshal.dropping('DROP');
    expect(getDynamicStyleFromTag(contextId)).toEqual(styles.dropAnimating);
  });

  wrapper.unmount();
})",steel
/test/unit/view/style-marshal/style-marshal.spec.js,Duplicate Assert,"{'line': 183, 'column': 4, 'index': 5922}","it('should allow subsequent updates', () => {
  const contextId: ContextId = '10';
  const styles: Styles = getStyles(`${contextId}`);
  const mock = getMock();
  const wrapper: ReactWrapper<*> = mount(
    <WithMarshal contextId={contextId}>{mock}</WithMarshal>,
  );
  const marshal: StyleMarshal = getMarshal(mock);

  Array.from({ length: 4 }).forEach(() => {
    marshal.resting();
    expect(getDynamicStyleFromTag(contextId)).toEqual(styles.resting);

    marshal.dragging();
    expect(getDynamicStyleFromTag(contextId)).toEqual(styles.dragging);

    marshal.dropping('DROP');
    expect(getDynamicStyleFromTag(contextId)).toEqual(styles.dropAnimating);
  });

  wrapper.unmount();
})",steel
/test/unit/view/placeholder/on-transition-end.spec.js,Duplicate Assert,"{'line': 40, 'column': 2, 'index': 1203}","it('should only fire a single transitionend event a single time when transitioning multiple properties', () => {
  const onTransitionEnd = jest.fn();
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={onTransitionEnd}
      contextId=""hey""
    />,
  );
  // finish the animate open timer
  act(() => {
    jest.runOnlyPendingTimers();
  });
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));

  // first event: a 'height' event will trigger the handler

  // $ExpectError - not a complete event
  const height: TransitionEvent = {
    propertyName: 'height',
  };
  wrapper.simulate('transitionend', height);
  expect(onTransitionEnd).toHaveBeenCalledTimes(1);
  onTransitionEnd.mockClear();

  // subsequent transition events will not trigger

  // $ExpectError - not a complete event
  const margin: TransitionEvent = {
    propertyName: 'margin',
  };
  // $ExpectError - not a complete event
  const width: TransitionEvent = {
    propertyName: 'width',
  };
  wrapper.simulate('transitionend', margin);
  wrapper.simulate('transitionend', width);
  expect(onTransitionEnd).not.toHaveBeenCalled();

  // another transition event of height would trigger the handler
  wrapper.simulate('transitionend', height);
  expect(onTransitionEnd).toHaveBeenCalledTimes(1);

  // validate: this should not have triggered any close events
  expect(onClose).not.toHaveBeenCalled();
})",steel
/test/unit/view/placeholder/on-transition-end.spec.js,Duplicate Assert,"{'line': 55, 'column': 2, 'index': 1646}","it('should only fire a single transitionend event a single time when transitioning multiple properties', () => {
  const onTransitionEnd = jest.fn();
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={onTransitionEnd}
      contextId=""hey""
    />,
  );
  // finish the animate open timer
  act(() => {
    jest.runOnlyPendingTimers();
  });
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));

  // first event: a 'height' event will trigger the handler

  // $ExpectError - not a complete event
  const height: TransitionEvent = {
    propertyName: 'height',
  };
  wrapper.simulate('transitionend', height);
  expect(onTransitionEnd).toHaveBeenCalledTimes(1);
  onTransitionEnd.mockClear();

  // subsequent transition events will not trigger

  // $ExpectError - not a complete event
  const margin: TransitionEvent = {
    propertyName: 'margin',
  };
  // $ExpectError - not a complete event
  const width: TransitionEvent = {
    propertyName: 'width',
  };
  wrapper.simulate('transitionend', margin);
  wrapper.simulate('transitionend', width);
  expect(onTransitionEnd).not.toHaveBeenCalled();

  // another transition event of height would trigger the handler
  wrapper.simulate('transitionend', height);
  expect(onTransitionEnd).toHaveBeenCalledTimes(1);

  // validate: this should not have triggered any close events
  expect(onClose).not.toHaveBeenCalled();
})",steel
/test/unit/view/placeholder/on-transition-end.spec.js,Duplicate Assert,"{'line': 59, 'column': 2, 'index': 1808}","it('should only fire a single transitionend event a single time when transitioning multiple properties', () => {
  const onTransitionEnd = jest.fn();
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={onTransitionEnd}
      contextId=""hey""
    />,
  );
  // finish the animate open timer
  act(() => {
    jest.runOnlyPendingTimers();
  });
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));

  // first event: a 'height' event will trigger the handler

  // $ExpectError - not a complete event
  const height: TransitionEvent = {
    propertyName: 'height',
  };
  wrapper.simulate('transitionend', height);
  expect(onTransitionEnd).toHaveBeenCalledTimes(1);
  onTransitionEnd.mockClear();

  // subsequent transition events will not trigger

  // $ExpectError - not a complete event
  const margin: TransitionEvent = {
    propertyName: 'margin',
  };
  // $ExpectError - not a complete event
  const width: TransitionEvent = {
    propertyName: 'width',
  };
  wrapper.simulate('transitionend', margin);
  wrapper.simulate('transitionend', width);
  expect(onTransitionEnd).not.toHaveBeenCalled();

  // another transition event of height would trigger the handler
  wrapper.simulate('transitionend', height);
  expect(onTransitionEnd).toHaveBeenCalledTimes(1);

  // validate: this should not have triggered any close events
  expect(onClose).not.toHaveBeenCalled();
})",steel
/test/unit/view/placeholder/on-close.spec.js,Assertion Roulette,"{'column': 2, 'line': 72}","it('should not fire an onClose if not closing when a transitionend occurs', () => {
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""none""
      contextId=""1""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={jest.fn()}
    />,
  );
  const assert = () => {
    // $ExpectError - not a complete event
    const height: TransitionEvent = {
      propertyName: 'height',
    };
    wrapper.simulate('transitionend', height);
    expect(onClose).not.toHaveBeenCalled();
    onClose.mockClear();
  };
  expectIsFull(getPlaceholderStyle(wrapper));
  assert();

  wrapper.setProps({ animate: 'open' });
  assert();
})",steel
/test/unit/view/placeholder/on-close.spec.js,Assertion Roulette,"{'column': 2, 'line': 75}","it('should not fire an onClose if not closing when a transitionend occurs', () => {
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""none""
      contextId=""1""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={jest.fn()}
    />,
  );
  const assert = () => {
    // $ExpectError - not a complete event
    const height: TransitionEvent = {
      propertyName: 'height',
    };
    wrapper.simulate('transitionend', height);
    expect(onClose).not.toHaveBeenCalled();
    onClose.mockClear();
  };
  expectIsFull(getPlaceholderStyle(wrapper));
  assert();

  wrapper.setProps({ animate: 'open' });
  assert();
})",steel
/test/unit/view/placeholder/on-close.spec.js,Duplicate Assert,"{'line': 32, 'column': 2, 'index': 839}","it('should only fire a single onClose event', () => {
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      contextId=""1""
      animate=""none""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={jest.fn()}
    />,
  );
  expectIsFull(getPlaceholderStyle(wrapper));

  wrapper.setProps({
    animate: 'close',
  });

  // $ExpectError - not a complete event
  const height: TransitionEvent = {
    propertyName: 'height',
  };
  wrapper.simulate('transitionend', height);
  expect(onClose).toHaveBeenCalledTimes(1);
  onClose.mockClear();

  // transition events while animate=""closed"" of different properties will not trigger

  // $ExpectError - not a complete event
  const margin: TransitionEvent = {
    propertyName: 'margin',
  };
  // $ExpectError - not a complete event
  const width: TransitionEvent = {
    propertyName: 'width',
  };
  wrapper.simulate('transitionend', margin);
  wrapper.simulate('transitionend', width);
  expect(onClose).not.toHaveBeenCalled();
})",steel
/test/unit/view/placeholder/on-close.spec.js,Duplicate Assert,"{'line': 47, 'column': 2, 'index': 1302}","it('should only fire a single onClose event', () => {
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      contextId=""1""
      animate=""none""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={jest.fn()}
    />,
  );
  expectIsFull(getPlaceholderStyle(wrapper));

  wrapper.setProps({
    animate: 'close',
  });

  // $ExpectError - not a complete event
  const height: TransitionEvent = {
    propertyName: 'height',
  };
  wrapper.simulate('transitionend', height);
  expect(onClose).toHaveBeenCalledTimes(1);
  onClose.mockClear();

  // transition events while animate=""closed"" of different properties will not trigger

  // $ExpectError - not a complete event
  const margin: TransitionEvent = {
    propertyName: 'margin',
  };
  // $ExpectError - not a complete event
  const width: TransitionEvent = {
    propertyName: 'width',
  };
  wrapper.simulate('transitionend', margin);
  wrapper.simulate('transitionend', width);
  expect(onClose).not.toHaveBeenCalled();
})",steel
/test/unit/view/placeholder/on-close.spec.js,Duplicate Assert,"{'line': 72, 'column': 2, 'index': 1976}","it('should not fire an onClose if not closing when a transitionend occurs', () => {
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""none""
      contextId=""1""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={jest.fn()}
    />,
  );
  const assert = () => {
    // $ExpectError - not a complete event
    const height: TransitionEvent = {
      propertyName: 'height',
    };
    wrapper.simulate('transitionend', height);
    expect(onClose).not.toHaveBeenCalled();
    onClose.mockClear();
  };
  expectIsFull(getPlaceholderStyle(wrapper));
  assert();

  wrapper.setProps({ animate: 'open' });
  assert();
})",steel
/test/unit/view/placeholder/on-close.spec.js,Duplicate Assert,"{'line': 75, 'column': 2, 'index': 2030}","it('should not fire an onClose if not closing when a transitionend occurs', () => {
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""none""
      contextId=""1""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={jest.fn()}
    />,
  );
  const assert = () => {
    // $ExpectError - not a complete event
    const height: TransitionEvent = {
      propertyName: 'height',
    };
    wrapper.simulate('transitionend', height);
    expect(onClose).not.toHaveBeenCalled();
    onClose.mockClear();
  };
  expectIsFull(getPlaceholderStyle(wrapper));
  assert();

  wrapper.setProps({ animate: 'open' });
  assert();
})",steel
/test/unit/view/placeholder/on-close.spec.js,Redundant Assertion,"{'column': 2, 'line': 72}","it('should not fire an onClose if not closing when a transitionend occurs', () => {
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""none""
      contextId=""1""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={jest.fn()}
    />,
  );
  const assert = () => {
    // $ExpectError - not a complete event
    const height: TransitionEvent = {
      propertyName: 'height',
    };
    wrapper.simulate('transitionend', height);
    expect(onClose).not.toHaveBeenCalled();
    onClose.mockClear();
  };
  expectIsFull(getPlaceholderStyle(wrapper));
  assert();

  wrapper.setProps({ animate: 'open' });
  assert();
})",steel
/test/unit/view/placeholder/on-close.spec.js,Redundant Assertion,"{'column': 2, 'line': 75}","it('should not fire an onClose if not closing when a transitionend occurs', () => {
  const onClose = jest.fn();

  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""none""
      contextId=""1""
      placeholder={placeholder}
      onClose={onClose}
      onTransitionEnd={jest.fn()}
    />,
  );
  const assert = () => {
    // $ExpectError - not a complete event
    const height: TransitionEvent = {
      propertyName: 'height',
    };
    wrapper.simulate('transitionend', height);
    expect(onClose).not.toHaveBeenCalled();
    onClose.mockClear();
  };
  expectIsFull(getPlaceholderStyle(wrapper));
  assert();

  wrapper.setProps({ animate: 'open' });
  assert();
})",steel
/test/unit/view/placeholder/animated-mount.spec.js,Duplicate Assert,"{'line': 73, 'column': 2, 'index': 1923}","it('should not animate a mount if interrupted', () => {
  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      contextId={contextId}
      placeholder={placeholder}
      onClose={jest.fn()}
      onTransitionEnd={jest.fn()}
    />,
  );
  const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsEmpty(onMount);

  expect(getCreatePlaceholderCalls()).toHaveLength(1);

  // interrupting animation
  wrapper.setProps({
    animate: 'none',
  });

  // render 1: normal
  // render 2: useEffect calling setState
  // render 3: result of setState
  expect(getCreatePlaceholderCalls()).toHaveLength(3);

  // no timers are run
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();

  const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsFull(postMount);

  // validation - no further updates
  spy.mockClear();
  jest.runOnlyPendingTimers();
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));
  expect(getCreatePlaceholderCalls()).toHaveLength(0);
})",steel
/test/unit/view/placeholder/animated-mount.spec.js,Duplicate Assert,"{'line': 83, 'column': 2, 'index': 2154}","it('should not animate a mount if interrupted', () => {
  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      contextId={contextId}
      placeholder={placeholder}
      onClose={jest.fn()}
      onTransitionEnd={jest.fn()}
    />,
  );
  const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsEmpty(onMount);

  expect(getCreatePlaceholderCalls()).toHaveLength(1);

  // interrupting animation
  wrapper.setProps({
    animate: 'none',
  });

  // render 1: normal
  // render 2: useEffect calling setState
  // render 3: result of setState
  expect(getCreatePlaceholderCalls()).toHaveLength(3);

  // no timers are run
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();

  const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsFull(postMount);

  // validation - no further updates
  spy.mockClear();
  jest.runOnlyPendingTimers();
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));
  expect(getCreatePlaceholderCalls()).toHaveLength(0);
})",steel
/test/unit/view/placeholder/animated-mount.spec.js,Duplicate Assert,"{'line': 97, 'column': 2, 'index': 2577}","it('should not animate a mount if interrupted', () => {
  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      contextId={contextId}
      placeholder={placeholder}
      onClose={jest.fn()}
      onTransitionEnd={jest.fn()}
    />,
  );
  const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsEmpty(onMount);

  expect(getCreatePlaceholderCalls()).toHaveLength(1);

  // interrupting animation
  wrapper.setProps({
    animate: 'none',
  });

  // render 1: normal
  // render 2: useEffect calling setState
  // render 3: result of setState
  expect(getCreatePlaceholderCalls()).toHaveLength(3);

  // no timers are run
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();

  const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsFull(postMount);

  // validation - no further updates
  spy.mockClear();
  jest.runOnlyPendingTimers();
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));
  expect(getCreatePlaceholderCalls()).toHaveLength(0);
})",steel
/test/unit/view/placeholder/animated-mount.spec.js,Magic Number,"{'line': 42, 'column': 50, 'index': 1178}","it('should animate a mount', () => {
  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      contextId={contextId}
      animate=""open""
      placeholder={placeholder}
      onClose={jest.fn()}
      onTransitionEnd={jest.fn()}
    />,
  );

  expect(getCreatePlaceholderCalls().length).toBe(1);

  // first call had an empty size
  const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsEmpty(onMount);

  // Will trigger a .setState
  act(() => {
    jest.runOnlyPendingTimers();
  });

  // tell enzyme that something has changed
  wrapper.update();

  const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsFull(postMount);
})",steel
/test/unit/view/placeholder/animated-mount.spec.js,Magic Number,"{'line': 73, 'column': 51, 'index': 1972}","it('should not animate a mount if interrupted', () => {
  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      contextId={contextId}
      placeholder={placeholder}
      onClose={jest.fn()}
      onTransitionEnd={jest.fn()}
    />,
  );
  const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsEmpty(onMount);

  expect(getCreatePlaceholderCalls()).toHaveLength(1);

  // interrupting animation
  wrapper.setProps({
    animate: 'none',
  });

  // render 1: normal
  // render 2: useEffect calling setState
  // render 3: result of setState
  expect(getCreatePlaceholderCalls()).toHaveLength(3);

  // no timers are run
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();

  const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsFull(postMount);

  // validation - no further updates
  spy.mockClear();
  jest.runOnlyPendingTimers();
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));
  expect(getCreatePlaceholderCalls()).toHaveLength(0);
})",steel
/test/unit/view/placeholder/animated-mount.spec.js,Magic Number,"{'line': 83, 'column': 51, 'index': 2203}","it('should not animate a mount if interrupted', () => {
  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      contextId={contextId}
      placeholder={placeholder}
      onClose={jest.fn()}
      onTransitionEnd={jest.fn()}
    />,
  );
  const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsEmpty(onMount);

  expect(getCreatePlaceholderCalls()).toHaveLength(1);

  // interrupting animation
  wrapper.setProps({
    animate: 'none',
  });

  // render 1: normal
  // render 2: useEffect calling setState
  // render 3: result of setState
  expect(getCreatePlaceholderCalls()).toHaveLength(3);

  // no timers are run
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();

  const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsFull(postMount);

  // validation - no further updates
  spy.mockClear();
  jest.runOnlyPendingTimers();
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));
  expect(getCreatePlaceholderCalls()).toHaveLength(0);
})",steel
/test/unit/view/placeholder/animated-mount.spec.js,Magic Number,"{'line': 97, 'column': 51, 'index': 2626}","it('should not animate a mount if interrupted', () => {
  const wrapper: ReactWrapper<*> = mount(
    <Placeholder
      animate=""open""
      contextId={contextId}
      placeholder={placeholder}
      onClose={jest.fn()}
      onTransitionEnd={jest.fn()}
    />,
  );
  const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsEmpty(onMount);

  expect(getCreatePlaceholderCalls()).toHaveLength(1);

  // interrupting animation
  wrapper.setProps({
    animate: 'none',
  });

  // render 1: normal
  // render 2: useEffect calling setState
  // render 3: result of setState
  expect(getCreatePlaceholderCalls()).toHaveLength(3);

  // no timers are run
  // let enzyme know that the react tree has changed due to the set state
  wrapper.update();

  const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
  expectIsFull(postMount);

  // validation - no further updates
  spy.mockClear();
  jest.runOnlyPendingTimers();
  wrapper.update();
  expectIsFull(getPlaceholderStyle(wrapper));
  expect(getCreatePlaceholderCalls()).toHaveLength(0);
})",steel
/test/unit/view/is-type-of-element/is-element.spec.js,Conditional Test Logic,"{'line': 16, 'column': 32, 'index': 520}","it('should not let other types through', () => {
  [null, 1, true, {}, () => {}].forEach((value: mixed) =>
    expect(isElement(value)).toBe(false),
  );
})",steel
/test/unit/view/droppable/placeholder.spec.js,Magic Number,"{'line': 22, 'column': 51, 'index': 560}","it('should not render a placeholder when not dragging', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: homeOwnProps,
      mapProps: homeAtRest,
    });

    expect(wrapper.find(Placeholder)).toHaveLength(0);
  })",steel
/test/unit/view/droppable/placeholder.spec.js,Magic Number,"{'line': 31, 'column': 51, 'index': 797}","it('should render a placeholder when dragging over', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: homeOwnProps,
      mapProps: isOverHome,
    });

    expect(wrapper.find(Placeholder)).toHaveLength(1);
  })",steel
/test/unit/view/droppable/placeholder.spec.js,Magic Number,"{'line': 40, 'column': 51, 'index': 1045}","it('should render a placeholder when dragging over nothing', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: homeOwnProps,
      mapProps: isNotOverHome,
    });

    expect(wrapper.find(Placeholder)).toHaveLength(1);
  })",steel
/test/unit/view/droppable/placeholder.spec.js,Magic Number,"{'line': 49, 'column': 51, 'index': 1300}","it('should render a placeholder when dragging over a foreign list', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: homeOwnProps,
      mapProps: isOverForeign,
    });

    expect(wrapper.find(Placeholder)).toHaveLength(1);
  })",steel
/test/unit/view/droppable/placeholder.spec.js,Magic Number,"{'line': 60, 'column': 51, 'index': 1575}","it('should not render a placeholder when not dragging', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: homeAtRest,
    });

    expect(wrapper.find(Placeholder)).toHaveLength(0);
  })",steel
/test/unit/view/droppable/placeholder.spec.js,Magic Number,"{'line': 69, 'column': 51, 'index': 1818}","it('should render a placeholder when dragging over', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: isOverForeign,
    });

    expect(wrapper.find(Placeholder)).toHaveLength(1);
  })",steel
/test/unit/view/droppable/placeholder.spec.js,Magic Number,"{'line': 78, 'column': 51, 'index': 2067}","it('should not render a placeholder when over nothing', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: isNotOverForeign,
    });

    expect(wrapper.find(Placeholder)).toHaveLength(0);
  })",steel
/test/unit/view/droppable/placeholder-setup-warning.spec.js,Duplicate Assert,"{'line': 55, 'column': 4, 'index': 1265}","it('should log a warning when updating', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: homeAtRest,
      WrappedComponent: WithNoPlaceholder,
    });
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.setProps(isOverForeign);
    expect(console.warn).toHaveBeenCalled();

    wrapper.unmount();
  })",steel
/test/unit/view/droppable/placeholder-setup-warning.spec.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 1352}","it('should log a warning when updating', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: homeAtRest,
      WrappedComponent: WithNoPlaceholder,
    });
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.setProps(isOverForeign);
    expect(console.warn).toHaveBeenCalled();

    wrapper.unmount();
  })",steel
/test/unit/view/droppable/placeholder-setup-warning.spec.js,Duplicate Assert,"{'line': 83, 'column': 4, 'index': 1983}","it('should not log a warning when updating', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: homeAtRest,
      WrappedComponent: WithNoPlaceholder,
    });
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.setProps(isNotOverForeign);
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.unmount();
  })",steel
/test/unit/view/droppable/placeholder-setup-warning.spec.js,Duplicate Assert,"{'line': 83, 'column': 4, 'index': 1983}","it('should not log a warning when updating', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: homeAtRest,
      WrappedComponent: WithNoPlaceholder,
    });
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.setProps(isNotOverForeign);
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.unmount();
  })",steel
/test/unit/view/droppable/placeholder-setup-warning.spec.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 2073}","it('should not log a warning when updating', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: homeAtRest,
      WrappedComponent: WithNoPlaceholder,
    });
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.setProps(isNotOverForeign);
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.unmount();
  })",steel
/test/unit/view/droppable/placeholder-setup-warning.spec.js,Duplicate Assert,"{'line': 86, 'column': 4, 'index': 2073}","it('should not log a warning when updating', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: homeAtRest,
      WrappedComponent: WithNoPlaceholder,
    });
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.setProps(isNotOverForeign);
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.unmount();
  })",steel
/test/unit/view/droppable/placeholder-setup-warning.spec.js,Redundant Print,"{'line': 44, 'column': 11, 'index': 988}","it('should log a warning when mounting', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: isOverForeign,
      WrappedComponent: WithNoPlaceholder,
    });

    expect(console.warn).toHaveBeenCalled();

    wrapper.unmount();
  })",steel
/test/unit/view/droppable/placeholder-setup-warning.spec.js,Redundant Print,"{'line': 55, 'column': 11, 'index': 1272}","it('should log a warning when updating', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: homeAtRest,
      WrappedComponent: WithNoPlaceholder,
    });
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.setProps(isOverForeign);
    expect(console.warn).toHaveBeenCalled();

    wrapper.unmount();
  })",steel
/test/unit/view/droppable/placeholder-setup-warning.spec.js,Redundant Print,"{'line': 58, 'column': 11, 'index': 1359}","it('should log a warning when updating', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: homeAtRest,
      WrappedComponent: WithNoPlaceholder,
    });
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.setProps(isOverForeign);
    expect(console.warn).toHaveBeenCalled();

    wrapper.unmount();
  })",steel
/test/unit/view/droppable/placeholder-setup-warning.spec.js,Redundant Print,"{'line': 72, 'column': 11, 'index': 1698}","it('should not log a warning when mounting', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: isNotOverForeign,
      WrappedComponent: WithNoPlaceholder,
    });

    expect(console.warn).not.toHaveBeenCalled();

    wrapper.unmount();
  })",steel
/test/unit/view/droppable/placeholder-setup-warning.spec.js,Redundant Print,"{'line': 83, 'column': 11, 'index': 1990}","it('should not log a warning when updating', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: homeAtRest,
      WrappedComponent: WithNoPlaceholder,
    });
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.setProps(isNotOverForeign);
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.unmount();
  })",steel
/test/unit/view/droppable/placeholder-setup-warning.spec.js,Redundant Print,"{'line': 86, 'column': 11, 'index': 2080}","it('should not log a warning when updating', () => {
    const wrapper: ReactWrapper<*> = mount({
      ownProps: foreignOwnProps,
      mapProps: homeAtRest,
      WrappedComponent: WithNoPlaceholder,
    });
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.setProps(isNotOverForeign);
    expect(console.warn).not.toHaveBeenCalled();

    wrapper.unmount();
  })",steel
/test/unit/view/droppable/pass-through-snapshot.spec.js,Duplicate Assert,"{'line': 35, 'column': 2, 'index': 879}","it('should update snapshot as dragging over changes', () => {
  const myMock = jest.fn();

  const wrapper: ReactWrapper<*> = mount({
    mapProps: homeAtRest,
    WrappedComponent: getStubber(myMock),
  });
  expect(getLastSnapshot(myMock)).toBe(homeAtRest.snapshot);

  wrapper.setProps(isOverHome);
  expect(getLastSnapshot(myMock)).toBe(isOverHome.snapshot);

  // now over foreign list
  wrapper.setProps(isNotOverHome);
  expect(getLastSnapshot(myMock)).toBe(isNotOverHome.snapshot);

  // drag is now over
  wrapper.setProps(homeAtRest);
  expect(getLastSnapshot(myMock)).toBe(homeAtRest.snapshot);
})",steel
/test/unit/view/droppable/pass-through-snapshot.spec.js,Duplicate Assert,"{'line': 35, 'column': 2, 'index': 879}","it('should update snapshot as dragging over changes', () => {
  const myMock = jest.fn();

  const wrapper: ReactWrapper<*> = mount({
    mapProps: homeAtRest,
    WrappedComponent: getStubber(myMock),
  });
  expect(getLastSnapshot(myMock)).toBe(homeAtRest.snapshot);

  wrapper.setProps(isOverHome);
  expect(getLastSnapshot(myMock)).toBe(isOverHome.snapshot);

  // now over foreign list
  wrapper.setProps(isNotOverHome);
  expect(getLastSnapshot(myMock)).toBe(isNotOverHome.snapshot);

  // drag is now over
  wrapper.setProps(homeAtRest);
  expect(getLastSnapshot(myMock)).toBe(homeAtRest.snapshot);
})",steel
/test/unit/view/droppable/pass-through-snapshot.spec.js,Duplicate Assert,"{'line': 38, 'column': 2, 'index': 973}","it('should update snapshot as dragging over changes', () => {
  const myMock = jest.fn();

  const wrapper: ReactWrapper<*> = mount({
    mapProps: homeAtRest,
    WrappedComponent: getStubber(myMock),
  });
  expect(getLastSnapshot(myMock)).toBe(homeAtRest.snapshot);

  wrapper.setProps(isOverHome);
  expect(getLastSnapshot(myMock)).toBe(isOverHome.snapshot);

  // now over foreign list
  wrapper.setProps(isNotOverHome);
  expect(getLastSnapshot(myMock)).toBe(isNotOverHome.snapshot);

  // drag is now over
  wrapper.setProps(homeAtRest);
  expect(getLastSnapshot(myMock)).toBe(homeAtRest.snapshot);
})",steel
/test/unit/view/droppable/pass-through-snapshot.spec.js,Duplicate Assert,"{'line': 42, 'column': 2, 'index': 1097}","it('should update snapshot as dragging over changes', () => {
  const myMock = jest.fn();

  const wrapper: ReactWrapper<*> = mount({
    mapProps: homeAtRest,
    WrappedComponent: getStubber(myMock),
  });
  expect(getLastSnapshot(myMock)).toBe(homeAtRest.snapshot);

  wrapper.setProps(isOverHome);
  expect(getLastSnapshot(myMock)).toBe(isOverHome.snapshot);

  // now over foreign list
  wrapper.setProps(isNotOverHome);
  expect(getLastSnapshot(myMock)).toBe(isNotOverHome.snapshot);

  // drag is now over
  wrapper.setProps(homeAtRest);
  expect(getLastSnapshot(myMock)).toBe(homeAtRest.snapshot);
})",steel
/test/unit/view/droppable/pass-through-snapshot.spec.js,Duplicate Assert,"{'line': 46, 'column': 2, 'index': 1216}","it('should update snapshot as dragging over changes', () => {
  const myMock = jest.fn();

  const wrapper: ReactWrapper<*> = mount({
    mapProps: homeAtRest,
    WrappedComponent: getStubber(myMock),
  });
  expect(getLastSnapshot(myMock)).toBe(homeAtRest.snapshot);

  wrapper.setProps(isOverHome);
  expect(getLastSnapshot(myMock)).toBe(isOverHome.snapshot);

  // now over foreign list
  wrapper.setProps(isNotOverHome);
  expect(getLastSnapshot(myMock)).toBe(isNotOverHome.snapshot);

  // drag is now over
  wrapper.setProps(homeAtRest);
  expect(getLastSnapshot(myMock)).toBe(homeAtRest.snapshot);
})",steel
/test/unit/view/droppable/pass-through-snapshot.spec.js,Duplicate Assert,"{'line': 46, 'column': 2, 'index': 1216}","it('should update snapshot as dragging over changes', () => {
  const myMock = jest.fn();

  const wrapper: ReactWrapper<*> = mount({
    mapProps: homeAtRest,
    WrappedComponent: getStubber(myMock),
  });
  expect(getLastSnapshot(myMock)).toBe(homeAtRest.snapshot);

  wrapper.setProps(isOverHome);
  expect(getLastSnapshot(myMock)).toBe(isOverHome.snapshot);

  // now over foreign list
  wrapper.setProps(isNotOverHome);
  expect(getLastSnapshot(myMock)).toBe(isNotOverHome.snapshot);

  // drag is now over
  wrapper.setProps(homeAtRest);
  expect(getLastSnapshot(myMock)).toBe(homeAtRest.snapshot);
})",steel
/test/unit/view/droppable/own-props-validation.spec.js,Unknown Test,"{'column': 0, 'line': 16}","it('should throw if no droppableId is provided', () => {
  const ownProps: OwnProps = {
    ...defaultOwnProps,
  };

  withError(() => {
    // $ExpectError - not provided
    ownProps.droppableId = undefined;
    mount({ ownProps });
  });

  withError(() => {
    // $ExpectError - not a string
    ownProps.droppableId = null;
    mount({ ownProps });
  });

  withError(() => {
    // $ExpectError - using number
    ownProps.droppableId = 3;
    mount({ ownProps });
  });
})",steel
/test/unit/view/droppable/own-props-validation.spec.js,Unknown Test,"{'column': 0, 'line': 40}","it('should throw if isDropDisabled is set to null', () => {
  const ownProps: OwnProps = {
    ...defaultOwnProps,
  };
  withError(() => {
    // $ExpectError - null
    ownProps.isDropDisabled = null;
    mount({ ownProps });
  });
})",steel
/test/unit/view/droppable/own-props-validation.spec.js,Unknown Test,"{'column': 0, 'line': 51}","it('should throw if isCombineEnabled is set to null', () => {
  const ownProps: OwnProps = {
    ...defaultOwnProps,
  };
  withError(() => {
    // $ExpectError - null
    ownProps.isCombineEnabled = null;
    mount({ ownProps });
  });
})",steel
/test/unit/view/droppable/own-props-validation.spec.js,Unknown Test,"{'column': 0, 'line': 62}","it('should throw if ignoreContainerClipping is set to null', () => {
  const ownProps: OwnProps = {
    ...defaultOwnProps,
  };
  withError(() => {
    // $ExpectError - null
    ownProps.ignoreContainerClipping = null;
    mount({ ownProps });
  });
})",steel
/test/unit/view/droppable/inner-ref-validation.spec.js,Unknown Test,"{'column': 0, 'line': 7}","it('should warn a consumer if they have not provided a ref', () => {
  class NoRef extends React.Component<{ provided: Provided }> {
    render() {
      const provided: Provided = this.props.provided;

      return (
        <div {...provided.droppableProps}>
          Hello there
          {provided.placeholder}
        </div>
      );
    }
  }

  withError(() => {
    mount({ WrappedComponent: NoRef });
  });
})",steel
/test/unit/view/droppable/inner-ref-validation.spec.js,Unknown Test,"{'column': 0, 'line': 26}","it('should throw a consumer if they have provided an SVGElement', () => {
  class WithSVG extends React.Component<{ provided: Provided }> {
    render() {
      const provided: Provided = this.props.provided;

      return (
        // $FlowFixMe - flow is correctly stating this is not a HTMLElement
        <svg {...provided.droppableProps} ref={provided.innerRef}>
          Hello there
          {provided.placeholder}
        </svg>
      );
    }
  }

  withError(() => {
    mount({ WrappedComponent: WithSVG });
  });
})",steel
/test/unit/view/droppable/home-list-placeholder-cleanup.spec.js,Duplicate Assert,"{'line': 20, 'column': 2, 'index': 512}","it('should not display a placeholder after a flushed drag end in the home list', () => {
  // dropping
  const wrapper: ReactWrapper<*> = mount({
    ownProps: homeOwnProps,
    mapProps: isNotOverHome,
  });

  expect(wrapper.find(Placeholder)).toHaveLength(1);

  wrapper.setProps({
    ...homeAtRest,
  });
  wrapper.update();

  expect(wrapper.find(Placeholder)).toHaveLength(0);
})",steel
/test/unit/view/droppable/home-list-placeholder-cleanup.spec.js,Duplicate Assert,"{'line': 27, 'column': 2, 'index': 633}","it('should not display a placeholder after a flushed drag end in the home list', () => {
  // dropping
  const wrapper: ReactWrapper<*> = mount({
    ownProps: homeOwnProps,
    mapProps: isNotOverHome,
  });

  expect(wrapper.find(Placeholder)).toHaveLength(1);

  wrapper.setProps({
    ...homeAtRest,
  });
  wrapper.update();

  expect(wrapper.find(Placeholder)).toHaveLength(0);
})",steel
/test/unit/view/droppable/home-list-placeholder-cleanup.spec.js,Duplicate Assert,"{'line': 37, 'column': 2, 'index': 890}","it('should animate a placeholder closed in a home list after a drag', () => {
  // dropping
  const wrapper: ReactWrapper<*> = mount({
    ownProps: homeOwnProps,
    mapProps: isNotOverHome,
  });

  expect(wrapper.find(Placeholder)).toHaveLength(1);

  wrapper.setProps({
    ...homePostDropAnimation,
  });
  wrapper.update();

  expect(wrapper.find(Placeholder)).toHaveLength(1);
  expect(homePostDropAnimation.shouldAnimatePlaceholder).toBe(true);

  // finishing the animation
  act(() => {
    wrapper.find(Placeholder).props().onClose();
  });

  // let the wrapper know the react tree has changed
  wrapper.update();

  // placeholder is now gone
  expect(wrapper.find(Placeholder)).toHaveLength(0);
})",steel
/test/unit/view/droppable/home-list-placeholder-cleanup.spec.js,Duplicate Assert,"{'line': 37, 'column': 2, 'index': 890}","it('should animate a placeholder closed in a home list after a drag', () => {
  // dropping
  const wrapper: ReactWrapper<*> = mount({
    ownProps: homeOwnProps,
    mapProps: isNotOverHome,
  });

  expect(wrapper.find(Placeholder)).toHaveLength(1);

  wrapper.setProps({
    ...homePostDropAnimation,
  });
  wrapper.update();

  expect(wrapper.find(Placeholder)).toHaveLength(1);
  expect(homePostDropAnimation.shouldAnimatePlaceholder).toBe(true);

  // finishing the animation
  act(() => {
    wrapper.find(Placeholder).props().onClose();
  });

  // let the wrapper know the react tree has changed
  wrapper.update();

  // placeholder is now gone
  expect(wrapper.find(Placeholder)).toHaveLength(0);
})",steel
/test/unit/view/droppable/home-list-placeholder-cleanup.spec.js,Duplicate Assert,"{'line': 44, 'column': 2, 'index': 1022}","it('should animate a placeholder closed in a home list after a drag', () => {
  // dropping
  const wrapper: ReactWrapper<*> = mount({
    ownProps: homeOwnProps,
    mapProps: isNotOverHome,
  });

  expect(wrapper.find(Placeholder)).toHaveLength(1);

  wrapper.setProps({
    ...homePostDropAnimation,
  });
  wrapper.update();

  expect(wrapper.find(Placeholder)).toHaveLength(1);
  expect(homePostDropAnimation.shouldAnimatePlaceholder).toBe(true);

  // finishing the animation
  act(() => {
    wrapper.find(Placeholder).props().onClose();
  });

  // let the wrapper know the react tree has changed
  wrapper.update();

  // placeholder is now gone
  expect(wrapper.find(Placeholder)).toHaveLength(0);
})",steel
/test/unit/view/droppable/home-list-placeholder-cleanup.spec.js,Duplicate Assert,"{'line': 44, 'column': 2, 'index': 1022}","it('should animate a placeholder closed in a home list after a drag', () => {
  // dropping
  const wrapper: ReactWrapper<*> = mount({
    ownProps: homeOwnProps,
    mapProps: isNotOverHome,
  });

  expect(wrapper.find(Placeholder)).toHaveLength(1);

  wrapper.setProps({
    ...homePostDropAnimation,
  });
  wrapper.update();

  expect(wrapper.find(Placeholder)).toHaveLength(1);
  expect(homePostDropAnimation.shouldAnimatePlaceholder).toBe(true);

  // finishing the animation
  act(() => {
    wrapper.find(Placeholder).props().onClose();
  });

  // let the wrapper know the react tree has changed
  wrapper.update();

  // placeholder is now gone
  expect(wrapper.find(Placeholder)).toHaveLength(0);
})",steel
/test/unit/view/droppable/home-list-placeholder-cleanup.spec.js,Duplicate Assert,"{'line': 56, 'column': 2, 'index': 1347}","it('should animate a placeholder closed in a home list after a drag', () => {
  // dropping
  const wrapper: ReactWrapper<*> = mount({
    ownProps: homeOwnProps,
    mapProps: isNotOverHome,
  });

  expect(wrapper.find(Placeholder)).toHaveLength(1);

  wrapper.setProps({
    ...homePostDropAnimation,
  });
  wrapper.update();

  expect(wrapper.find(Placeholder)).toHaveLength(1);
  expect(homePostDropAnimation.shouldAnimatePlaceholder).toBe(true);

  // finishing the animation
  act(() => {
    wrapper.find(Placeholder).props().onClose();
  });

  // let the wrapper know the react tree has changed
  wrapper.update();

  // placeholder is now gone
  expect(wrapper.find(Placeholder)).toHaveLength(0);
})",steel
/test/unit/view/droppable/home-list-placeholder-cleanup.spec.js,Magic Number,"{'line': 20, 'column': 49, 'index': 559}","it('should not display a placeholder after a flushed drag end in the home list', () => {
  // dropping
  const wrapper: ReactWrapper<*> = mount({
    ownProps: homeOwnProps,
    mapProps: isNotOverHome,
  });

  expect(wrapper.find(Placeholder)).toHaveLength(1);

  wrapper.setProps({
    ...homeAtRest,
  });
  wrapper.update();

  expect(wrapper.find(Placeholder)).toHaveLength(0);
})",steel
/test/unit/view/droppable/home-list-placeholder-cleanup.spec.js,Magic Number,"{'line': 27, 'column': 49, 'index': 680}","it('should not display a placeholder after a flushed drag end in the home list', () => {
  // dropping
  const wrapper: ReactWrapper<*> = mount({
    ownProps: homeOwnProps,
    mapProps: isNotOverHome,
  });

  expect(wrapper.find(Placeholder)).toHaveLength(1);

  wrapper.setProps({
    ...homeAtRest,
  });
  wrapper.update();

  expect(wrapper.find(Placeholder)).toHaveLength(0);
})",steel
/test/unit/view/droppable/home-list-placeholder-cleanup.spec.js,Magic Number,"{'line': 37, 'column': 49, 'index': 937}","it('should animate a placeholder closed in a home list after a drag', () => {
  // dropping
  const wrapper: ReactWrapper<*> = mount({
    ownProps: homeOwnProps,
    mapProps: isNotOverHome,
  });

  expect(wrapper.find(Placeholder)).toHaveLength(1);

  wrapper.setProps({
    ...homePostDropAnimation,
  });
  wrapper.update();

  expect(wrapper.find(Placeholder)).toHaveLength(1);
  expect(homePostDropAnimation.shouldAnimatePlaceholder).toBe(true);

  // finishing the animation
  act(() => {
    wrapper.find(Placeholder).props().onClose();
  });

  // let the wrapper know the react tree has changed
  wrapper.update();

  // placeholder is now gone
  expect(wrapper.find(Placeholder)).toHaveLength(0);
})",steel
/test/unit/view/droppable/home-list-placeholder-cleanup.spec.js,Magic Number,"{'line': 44, 'column': 49, 'index': 1069}","it('should animate a placeholder closed in a home list after a drag', () => {
  // dropping
  const wrapper: ReactWrapper<*> = mount({
    ownProps: homeOwnProps,
    mapProps: isNotOverHome,
  });

  expect(wrapper.find(Placeholder)).toHaveLength(1);

  wrapper.setProps({
    ...homePostDropAnimation,
  });
  wrapper.update();

  expect(wrapper.find(Placeholder)).toHaveLength(1);
  expect(homePostDropAnimation.shouldAnimatePlaceholder).toBe(true);

  // finishing the animation
  act(() => {
    wrapper.find(Placeholder).props().onClose();
  });

  // let the wrapper know the react tree has changed
  wrapper.update();

  // placeholder is now gone
  expect(wrapper.find(Placeholder)).toHaveLength(0);
})",steel
/test/unit/view/droppable/home-list-placeholder-cleanup.spec.js,Magic Number,"{'line': 56, 'column': 49, 'index': 1394}","it('should animate a placeholder closed in a home list after a drag', () => {
  // dropping
  const wrapper: ReactWrapper<*> = mount({
    ownProps: homeOwnProps,
    mapProps: isNotOverHome,
  });

  expect(wrapper.find(Placeholder)).toHaveLength(1);

  wrapper.setProps({
    ...homePostDropAnimation,
  });
  wrapper.update();

  expect(wrapper.find(Placeholder)).toHaveLength(1);
  expect(homePostDropAnimation.shouldAnimatePlaceholder).toBe(true);

  // finishing the animation
  act(() => {
    wrapper.find(Placeholder).props().onClose();
  });

  // let the wrapper know the react tree has changed
  wrapper.update();

  // placeholder is now gone
  expect(wrapper.find(Placeholder)).toHaveLength(0);
})",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 139, 'column': 4, 'index': 3660}","it('should collect and publish the draggables', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'addition1',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const registry: Registry = createRegistry();
    const callbacks: Callbacks = getCallbacksStub();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 139, 'column': 4, 'index': 3660}","it('should collect and publish the draggables', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'addition1',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const registry: Registry = createRegistry();
    const callbacks: Callbacks = getCallbacksStub();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 148, 'column': 4, 'index': 3979}","it('should collect and publish the draggables', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'addition1',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const registry: Registry = createRegistry();
    const callbacks: Callbacks = getCallbacksStub();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 148, 'column': 4, 'index': 3979}","it('should collect and publish the draggables', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'addition1',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const registry: Registry = createRegistry();
    const callbacks: Callbacks = getCallbacksStub();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 157, 'column': 4, 'index': 4310}","it('should collect and publish the draggables', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'addition1',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const registry: Registry = createRegistry();
    const callbacks: Callbacks = getCallbacksStub();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 171, 'column': 4, 'index': 4834}","it('should not do anything if trying to add a draggable that does not have the same type as the dragging item', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();

    // Registering a new draggable (inserted before inHome1)

    registry.draggable.register(
      getDraggableEntry({ dimension: inAnotherType }),
    );
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 171, 'column': 4, 'index': 4834}","it('should not do anything if trying to add a draggable that does not have the same type as the dragging item', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();

    // Registering a new draggable (inserted before inHome1)

    registry.draggable.register(
      getDraggableEntry({ dimension: inAnotherType }),
    );
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 178, 'column': 4, 'index': 5057}","it('should not do anything if trying to add a draggable that does not have the same type as the dragging item', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();

    // Registering a new draggable (inserted before inHome1)

    registry.draggable.register(
      getDraggableEntry({ dimension: inAnotherType }),
    );
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 178, 'column': 4, 'index': 5057}","it('should not do anything if trying to add a draggable that does not have the same type as the dragging item', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();

    // Registering a new draggable (inserted before inHome1)

    registry.draggable.register(
      getDraggableEntry({ dimension: inAnotherType }),
    );
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 209, 'column': 4, 'index': 5930}","it('should order published draggables by their index', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'b',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        // if ordered by a key, this would be first
        id: 'a',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // publishing the higher index value first
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    // publishing the lower index value second
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      // we expect this to be ordered by index
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 209, 'column': 4, 'index': 5930}","it('should order published draggables by their index', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'b',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        // if ordered by a key, this would be first
        id: 'a',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // publishing the higher index value first
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    // publishing the lower index value second
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      // we expect this to be ordered by index
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 219, 'column': 4, 'index': 6282}","it('should order published draggables by their index', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'b',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        // if ordered by a key, this would be first
        id: 'a',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // publishing the higher index value first
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    // publishing the lower index value second
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      // we expect this to be ordered by index
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 219, 'column': 4, 'index': 6282}","it('should order published draggables by their index', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'b',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        // if ordered by a key, this would be first
        id: 'a',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // publishing the higher index value first
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    // publishing the lower index value second
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      // we expect this to be ordered by index
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 229, 'column': 4, 'index': 6660}","it('should order published draggables by their index', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'b',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        // if ordered by a key, this would be first
        id: 'a',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // publishing the higher index value first
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    // publishing the lower index value second
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      // we expect this to be ordered by index
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 251, 'column': 4, 'index': 7398}","it('should log a warning if trying to add or remove a draggable from a non-virtual list', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const notVirtual: DroppableDimension = {
      ...scrollableHome,
      descriptor: {
        ...scrollableHome.descriptor,
        mode: 'standard',
      },
    };
    const map: DimensionMap = patchDimensionMap(withScrollables, notVirtual);
    populate(registry, map);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();

    // additions log a warning
    withWarn(() => {
      const beforeInHome1: DraggableDimension = {
        ...preset.inHome1,
        descriptor: {
          ...preset.inHome1.descriptor,
          id: 'b',
          index: 0,
        },
      };
      registry.draggable.register(
        getDraggableEntry({ dimension: beforeInHome1 }),
      );
    });
    // removals log a warning
    withWarn(() => {
      registry.draggable.unregister(
        registry.draggable.getById(preset.inHome2.descriptor.id),
      );
    });

    // neither cause a collection to start
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 251, 'column': 4, 'index': 7398}","it('should log a warning if trying to add or remove a draggable from a non-virtual list', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const notVirtual: DroppableDimension = {
      ...scrollableHome,
      descriptor: {
        ...scrollableHome.descriptor,
        mode: 'standard',
      },
    };
    const map: DimensionMap = patchDimensionMap(withScrollables, notVirtual);
    populate(registry, map);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();

    // additions log a warning
    withWarn(() => {
      const beforeInHome1: DraggableDimension = {
        ...preset.inHome1,
        descriptor: {
          ...preset.inHome1.descriptor,
          id: 'b',
          index: 0,
        },
      };
      registry.draggable.register(
        getDraggableEntry({ dimension: beforeInHome1 }),
      );
    });
    // removals log a warning
    withWarn(() => {
      registry.draggable.unregister(
        registry.draggable.getById(preset.inHome2.descriptor.id),
      );
    });

    // neither cause a collection to start
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 275, 'column': 4, 'index': 8038}","it('should log a warning if trying to add or remove a draggable from a non-virtual list', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const notVirtual: DroppableDimension = {
      ...scrollableHome,
      descriptor: {
        ...scrollableHome.descriptor,
        mode: 'standard',
      },
    };
    const map: DimensionMap = patchDimensionMap(withScrollables, notVirtual);
    populate(registry, map);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();

    // additions log a warning
    withWarn(() => {
      const beforeInHome1: DraggableDimension = {
        ...preset.inHome1,
        descriptor: {
          ...preset.inHome1.descriptor,
          id: 'b',
          index: 0,
        },
      };
      registry.draggable.register(
        getDraggableEntry({ dimension: beforeInHome1 }),
      );
    });
    // removals log a warning
    withWarn(() => {
      registry.draggable.unregister(
        registry.draggable.getById(preset.inHome2.descriptor.id),
      );
    });

    // neither cause a collection to start
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 275, 'column': 4, 'index': 8038}","it('should log a warning if trying to add or remove a draggable from a non-virtual list', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const notVirtual: DroppableDimension = {
      ...scrollableHome,
      descriptor: {
        ...scrollableHome.descriptor,
        mode: 'standard',
      },
    };
    const map: DimensionMap = patchDimensionMap(withScrollables, notVirtual);
    populate(registry, map);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();

    // additions log a warning
    withWarn(() => {
      const beforeInHome1: DraggableDimension = {
        ...preset.inHome1,
        descriptor: {
          ...preset.inHome1.descriptor,
          id: 'b',
          index: 0,
        },
      };
      registry.draggable.register(
        getDraggableEntry({ dimension: beforeInHome1 }),
      );
    });
    // removals log a warning
    withWarn(() => {
      registry.draggable.unregister(
        registry.draggable.getById(preset.inHome2.descriptor.id),
      );
    });

    // neither cause a collection to start
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 291, 'column': 4, 'index': 8514}","it('should publish a removal', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome3.descriptor.id),
    );
    registry.draggable.unregister(
      registry.draggable.getById(preset.inForeign1.descriptor.id),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();
    const expected: Published = {
      additions: [],
      removals: [
        preset.inHome2.descriptor.id,
        preset.inHome3.descriptor.id,
        preset.inForeign1.descriptor.id,
      ],
      modified: [
        { droppableId: scrollableHome.descriptor.id, scroll: origin },
        { droppableId: scrollableForeign.descriptor.id, scroll: origin },
      ],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 291, 'column': 4, 'index': 8514}","it('should publish a removal', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome3.descriptor.id),
    );
    registry.draggable.unregister(
      registry.draggable.getById(preset.inForeign1.descriptor.id),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();
    const expected: Published = {
      additions: [],
      removals: [
        preset.inHome2.descriptor.id,
        preset.inHome3.descriptor.id,
        preset.inForeign1.descriptor.id,
      ],
      modified: [
        { droppableId: scrollableHome.descriptor.id, scroll: origin },
        { droppableId: scrollableForeign.descriptor.id, scroll: origin },
      ],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 302, 'column': 4, 'index': 8903}","it('should publish a removal', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome3.descriptor.id),
    );
    registry.draggable.unregister(
      registry.draggable.getById(preset.inForeign1.descriptor.id),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();
    const expected: Published = {
      additions: [],
      removals: [
        preset.inHome2.descriptor.id,
        preset.inHome3.descriptor.id,
        preset.inForeign1.descriptor.id,
      ],
      modified: [
        { droppableId: scrollableHome.descriptor.id, scroll: origin },
        { droppableId: scrollableForeign.descriptor.id, scroll: origin },
      ],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 302, 'column': 4, 'index': 8903}","it('should publish a removal', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome3.descriptor.id),
    );
    registry.draggable.unregister(
      registry.draggable.getById(preset.inForeign1.descriptor.id),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();
    const expected: Published = {
      additions: [],
      removals: [
        preset.inHome2.descriptor.id,
        preset.inHome3.descriptor.id,
        preset.inForeign1.descriptor.id,
      ],
      modified: [
        { droppableId: scrollableHome.descriptor.id, scroll: origin },
        { droppableId: scrollableForeign.descriptor.id, scroll: origin },
      ],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 318, 'column': 4, 'index': 9426}","it('should publish a removal', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome3.descriptor.id),
    );
    registry.draggable.unregister(
      registry.draggable.getById(preset.inForeign1.descriptor.id),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();
    const expected: Published = {
      additions: [],
      removals: [
        preset.inHome2.descriptor.id,
        preset.inHome3.descriptor.id,
        preset.inForeign1.descriptor.id,
      ],
      modified: [
        { droppableId: scrollableHome.descriptor.id, scroll: origin },
        { droppableId: scrollableForeign.descriptor.id, scroll: origin },
      ],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 429, 'column': 4, 'index': 12835}","it('should recollect the scroll from droppables that had draggable additions', () => {
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [beforeInHome2],
      removals: [],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 429, 'column': 4, 'index': 12835}","it('should recollect the scroll from droppables that had draggable additions', () => {
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [beforeInHome2],
      removals: [],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 435, 'column': 4, 'index': 13059}","it('should recollect the scroll from droppables that had draggable additions', () => {
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [beforeInHome2],
      removals: [],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 435, 'column': 4, 'index': 13059}","it('should recollect the scroll from droppables that had draggable additions', () => {
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [beforeInHome2],
      removals: [],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 436, 'column': 4, 'index': 13126}","it('should recollect the scroll from droppables that had draggable additions', () => {
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [beforeInHome2],
      removals: [],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 443, 'column': 4, 'index': 13326}","it('should recollect the scroll from droppables that had draggable additions', () => {
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [beforeInHome2],
      removals: [],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 453, 'column': 4, 'index': 13668}","it('should recollect the scroll from droppables that had draggable additions', () => {
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [beforeInHome2],
      removals: [],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 467, 'column': 4, 'index': 14192}","it('should recollect the scroll from droppables that had draggable removals', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [],
      removals: [preset.inHome2.descriptor.id],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 467, 'column': 4, 'index': 14192}","it('should recollect the scroll from droppables that had draggable removals', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [],
      removals: [preset.inHome2.descriptor.id],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 473, 'column': 4, 'index': 14427}","it('should recollect the scroll from droppables that had draggable removals', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [],
      removals: [preset.inHome2.descriptor.id],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 473, 'column': 4, 'index': 14427}","it('should recollect the scroll from droppables that had draggable removals', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [],
      removals: [preset.inHome2.descriptor.id],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 474, 'column': 4, 'index': 14494}","it('should recollect the scroll from droppables that had draggable removals', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [],
      removals: [preset.inHome2.descriptor.id],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 481, 'column': 4, 'index': 14694}","it('should recollect the scroll from droppables that had draggable removals', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [],
      removals: [preset.inHome2.descriptor.id],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 491, 'column': 4, 'index': 15051}","it('should recollect the scroll from droppables that had draggable removals', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.unregister(
      registry.draggable.getById(preset.inHome2.descriptor.id),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [],
      removals: [preset.inHome2.descriptor.id],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 521, 'column': 4, 'index': 15925}","it('should cancel any pending collections', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );

    populate(registry, justCritical);

    const result: StartPublishingResult = marshal.startPublishing(
      defaultRequest,
    );
    const expected: StartPublishingResult = {
      critical,
      dimensions: justCritical,
      viewport,
    };
    expect(result).toEqual(expected);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    // no request animation fired yet
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // marshal told to stop - which should cancel any pending publishes
    marshal.stopPublishing();

    // flushing any frames
    requestAnimationFrame.flush();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 521, 'column': 4, 'index': 15925}","it('should cancel any pending collections', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );

    populate(registry, justCritical);

    const result: StartPublishingResult = marshal.startPublishing(
      defaultRequest,
    );
    const expected: StartPublishingResult = {
      critical,
      dimensions: justCritical,
      viewport,
    };
    expect(result).toEqual(expected);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    // no request animation fired yet
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // marshal told to stop - which should cancel any pending publishes
    marshal.stopPublishing();

    // flushing any frames
    requestAnimationFrame.flush();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 528, 'column': 4, 'index': 16158}","it('should cancel any pending collections', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );

    populate(registry, justCritical);

    const result: StartPublishingResult = marshal.startPublishing(
      defaultRequest,
    );
    const expected: StartPublishingResult = {
      critical,
      dimensions: justCritical,
      viewport,
    };
    expect(result).toEqual(expected);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    // no request animation fired yet
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // marshal told to stop - which should cancel any pending publishes
    marshal.stopPublishing();

    // flushing any frames
    requestAnimationFrame.flush();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 528, 'column': 4, 'index': 16158}","it('should cancel any pending collections', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );

    populate(registry, justCritical);

    const result: StartPublishingResult = marshal.startPublishing(
      defaultRequest,
    );
    const expected: StartPublishingResult = {
      critical,
      dimensions: justCritical,
      viewport,
    };
    expect(result).toEqual(expected);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    // no request animation fired yet
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // marshal told to stop - which should cancel any pending publishes
    marshal.stopPublishing();

    // flushing any frames
    requestAnimationFrame.flush();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 548, 'column': 4, 'index': 16753}","it('should allow subsequent publishes in the same drag', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
    // $FlowFixMe
    callbacks.publishWhileDragging.mockReset();

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome3 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 556, 'column': 4, 'index': 17019}","it('should allow subsequent publishes in the same drag', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
    // $FlowFixMe
    callbacks.publishWhileDragging.mockReset();

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome3 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 574, 'column': 4, 'index': 17578}","it('should allow subsequent publishes between drags', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
    // $FlowFixMe
    callbacks.publishWhileDragging.mockReset();

    marshal.stopPublishing();

    // second drag
    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome3 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Duplicate Assert,"{'line': 587, 'column': 4, 'index': 17940}","it('should allow subsequent publishes between drags', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
    // $FlowFixMe
    callbacks.publishWhileDragging.mockReset();

    marshal.stopPublishing();

    // second drag
    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome3 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Eager Test,"{'line': 142, 'column': 6, 'index': 3763}","it('should collect and publish the draggables', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'addition1',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const registry: Registry = createRegistry();
    const callbacks: Callbacks = getCallbacksStub();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Eager Test,"{'line': 145, 'column': 6, 'index': 3858}","it('should collect and publish the draggables', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'addition1',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const registry: Registry = createRegistry();
    const callbacks: Callbacks = getCallbacksStub();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Eager Test,"{'line': 213, 'column': 6, 'index': 6080}","it('should order published draggables by their index', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'b',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        // if ordered by a key, this would be first
        id: 'a',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // publishing the higher index value first
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    // publishing the lower index value second
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      // we expect this to be ordered by index
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Eager Test,"{'line': 217, 'column': 6, 'index': 6222}","it('should order published draggables by their index', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'b',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        // if ordered by a key, this would be first
        id: 'a',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // publishing the higher index value first
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    // publishing the lower index value second
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      // we expect this to be ordered by index
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Eager Test,"{'line': 545, 'column': 6, 'index': 16658}","it('should allow subsequent publishes in the same drag', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
    // $FlowFixMe
    callbacks.publishWhileDragging.mockReset();

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome3 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Eager Test,"{'line': 553, 'column': 6, 'index': 16924}","it('should allow subsequent publishes in the same drag', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
    // $FlowFixMe
    callbacks.publishWhileDragging.mockReset();

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome3 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Eager Test,"{'line': 571, 'column': 6, 'index': 17483}","it('should allow subsequent publishes between drags', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
    // $FlowFixMe
    callbacks.publishWhileDragging.mockReset();

    marshal.stopPublishing();

    // second drag
    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome3 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Eager Test,"{'line': 584, 'column': 6, 'index': 17845}","it('should allow subsequent publishes between drags', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
    // $FlowFixMe
    callbacks.publishWhileDragging.mockReset();

    marshal.stopPublishing();

    // second drag
    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome3 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Lazy Test,"{'line': 142, 'column': 6, 'index': 3763}","it('should collect and publish the draggables', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'addition1',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const registry: Registry = createRegistry();
    const callbacks: Callbacks = getCallbacksStub();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Lazy Test,"{'line': 176, 'column': 6, 'index': 4997}","it('should not do anything if trying to add a draggable that does not have the same type as the dragging item', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();

    // Registering a new draggable (inserted before inHome1)

    registry.draggable.register(
      getDraggableEntry({ dimension: inAnotherType }),
    );
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Lazy Test,"{'line': 213, 'column': 6, 'index': 6080}","it('should order published draggables by their index', () => {
    const beforeInHome1: DraggableDimension = {
      ...preset.inHome1,
      descriptor: {
        ...preset.inHome1.descriptor,
        id: 'b',
        index: 0,
      },
    };
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        // if ordered by a key, this would be first
        id: 'a',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // publishing the higher index value first
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    // publishing the lower index value second
    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome1 }),
    );
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.step();
    const expected: Published = {
      ...empty,
      // we expect this to be ordered by index
      additions: [beforeInHome1, beforeInHome2],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Lazy Test,"{'line': 264, 'column': 8, 'index': 7753}","it('should log a warning if trying to add or remove a draggable from a non-virtual list', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const notVirtual: DroppableDimension = {
      ...scrollableHome,
      descriptor: {
        ...scrollableHome.descriptor,
        mode: 'standard',
      },
    };
    const map: DimensionMap = patchDimensionMap(withScrollables, notVirtual);
    populate(registry, map);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();

    // additions log a warning
    withWarn(() => {
      const beforeInHome1: DraggableDimension = {
        ...preset.inHome1,
        descriptor: {
          ...preset.inHome1.descriptor,
          id: 'b',
          index: 0,
        },
      };
      registry.draggable.register(
        getDraggableEntry({ dimension: beforeInHome1 }),
      );
    });
    // removals log a warning
    withWarn(() => {
      registry.draggable.unregister(
        registry.draggable.getById(preset.inHome2.descriptor.id),
      );
    });

    // neither cause a collection to start
    expect(callbacks.collectionStarting).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Lazy Test,"{'line': 432, 'column': 6, 'index': 12938}","it('should recollect the scroll from droppables that had draggable additions', () => {
    const beforeInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        id: 'addition2',
        index: 1,
      },
    };
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry, withScrollables);

    // A publish has started
    marshal.startPublishing(defaultRequest);
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    registry.draggable.register(
      getDraggableEntry({ dimension: beforeInHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
    expect(watcher.droppable.getScrollWhileDragging).not.toHaveBeenCalled();

    // Fire the collection / publish step
    requestAnimationFrame.flush();

    // not hiding placeholder in home list

    expect(watcher.droppable.getScrollWhileDragging).toHaveBeenCalledWith(
      scrollableHome.descriptor.id,
      getFrame(scrollableHome).scroll.current,
    );

    const expected: Published = {
      additions: [beforeInHome2],
      removals: [],
      modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
    };
    expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Lazy Test,"{'line': 517, 'column': 6, 'index': 15765}","it('should cancel any pending collections', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );

    populate(registry, justCritical);

    const result: StartPublishingResult = marshal.startPublishing(
      defaultRequest,
    );
    const expected: StartPublishingResult = {
      critical,
      dimensions: justCritical,
      viewport,
    };
    expect(result).toEqual(expected);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    expect(callbacks.collectionStarting).toHaveBeenCalled();
    // no request animation fired yet
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

    // marshal told to stop - which should cancel any pending publishes
    marshal.stopPublishing();

    // flushing any frames
    requestAnimationFrame.flush();
    expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Lazy Test,"{'line': 545, 'column': 6, 'index': 16658}","it('should allow subsequent publishes in the same drag', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
    // $FlowFixMe
    callbacks.publishWhileDragging.mockReset();

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome3 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/dimension-marshal/publish-while-dragging.spec.js,Lazy Test,"{'line': 571, 'column': 6, 'index': 17483}","it('should allow subsequent publishes between drags', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry, justCritical);

    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome2 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
    // $FlowFixMe
    callbacks.publishWhileDragging.mockReset();

    marshal.stopPublishing();

    // second drag
    marshal.startPublishing(defaultRequest);

    registry.draggable.register(
      getDraggableEntry({ dimension: preset.inHome3 }),
    );
    requestAnimationFrame.step();
    expect(callbacks.publishWhileDragging).toHaveBeenCalledTimes(1);
  })",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Duplicate Assert,"{'line': 165, 'column': 2, 'index': 4818}","it('should not publish dimensions that have been unregistered', () => {
  const registry: Registry = createRegistry();
  const marshal: DimensionMarshal = createDimensionMarshal(
    registry,
    getCallbacksStub(),
  );
  populate(registry, preset.dimensions);
  const expectedMap: DimensionMap = copy(preset.dimensions);

  // removing inHome2
  registry.draggable.unregister(
    registry.draggable.getById(preset.inHome2.descriptor.id),
  );
  delete expectedMap.draggables[preset.inHome2.descriptor.id];

  // removing foreign
  registry.droppable.unregister(
    registry.droppable.getById(preset.foreign.descriptor.id),
  );
  delete expectedMap.droppables[preset.foreign.descriptor.id];

  // Being a good citizen and also unregistering all of the foreign draggables
  preset.inForeignList.forEach((draggable: DraggableDimension) => {
    registry.draggable.unregister(
      registry.draggable.getById(draggable.descriptor.id),
    );
    delete expectedMap.draggables[draggable.descriptor.id];
  });

  const result: StartPublishingResult = marshal.startPublishing(defaultRequest);

  expect(result).toEqual({
    critical,
    dimensions: expectedMap,
    viewport,
  });
  expect(result).not.toEqual({
    critical,
    dimensions: preset.dimensions,
    viewport,
  });
})",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Duplicate Assert,"{'line': 170, 'column': 2, 'index': 4908}","it('should not publish dimensions that have been unregistered', () => {
  const registry: Registry = createRegistry();
  const marshal: DimensionMarshal = createDimensionMarshal(
    registry,
    getCallbacksStub(),
  );
  populate(registry, preset.dimensions);
  const expectedMap: DimensionMap = copy(preset.dimensions);

  // removing inHome2
  registry.draggable.unregister(
    registry.draggable.getById(preset.inHome2.descriptor.id),
  );
  delete expectedMap.draggables[preset.inHome2.descriptor.id];

  // removing foreign
  registry.droppable.unregister(
    registry.droppable.getById(preset.foreign.descriptor.id),
  );
  delete expectedMap.droppables[preset.foreign.descriptor.id];

  // Being a good citizen and also unregistering all of the foreign draggables
  preset.inForeignList.forEach((draggable: DraggableDimension) => {
    registry.draggable.unregister(
      registry.draggable.getById(draggable.descriptor.id),
    );
    delete expectedMap.draggables[draggable.descriptor.id];
  });

  const result: StartPublishingResult = marshal.startPublishing(defaultRequest);

  expect(result).toEqual({
    critical,
    dimensions: expectedMap,
    viewport,
  });
  expect(result).not.toEqual({
    critical,
    dimensions: preset.dimensions,
    viewport,
  });
})",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Duplicate Assert,"{'line': 289, 'column': 4, 'index': 8408}","it('should return dimensions a subsequent call', () => {
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      getCallbacksStub(),
    );
    populate(registry, preset.dimensions);
    const expected: StartPublishingResult = {
      critical,
      dimensions: preset.dimensions,
      viewport,
    };

    expect(start(marshal)).toEqual(expected);
    stop(marshal);
    expect(start(marshal)).toEqual(expected);
    stop(marshal);
    expect(start(marshal)).toEqual(expected);
    stop(marshal);
  })",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Duplicate Assert,"{'line': 289, 'column': 4, 'index': 8408}","it('should return dimensions a subsequent call', () => {
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      getCallbacksStub(),
    );
    populate(registry, preset.dimensions);
    const expected: StartPublishingResult = {
      critical,
      dimensions: preset.dimensions,
      viewport,
    };

    expect(start(marshal)).toEqual(expected);
    stop(marshal);
    expect(start(marshal)).toEqual(expected);
    stop(marshal);
    expect(start(marshal)).toEqual(expected);
    stop(marshal);
  })",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Duplicate Assert,"{'line': 291, 'column': 4, 'index': 8473}","it('should return dimensions a subsequent call', () => {
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      getCallbacksStub(),
    );
    populate(registry, preset.dimensions);
    const expected: StartPublishingResult = {
      critical,
      dimensions: preset.dimensions,
      viewport,
    };

    expect(start(marshal)).toEqual(expected);
    stop(marshal);
    expect(start(marshal)).toEqual(expected);
    stop(marshal);
    expect(start(marshal)).toEqual(expected);
    stop(marshal);
  })",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Duplicate Assert,"{'line': 291, 'column': 4, 'index': 8473}","it('should return dimensions a subsequent call', () => {
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      getCallbacksStub(),
    );
    populate(registry, preset.dimensions);
    const expected: StartPublishingResult = {
      critical,
      dimensions: preset.dimensions,
      viewport,
    };

    expect(start(marshal)).toEqual(expected);
    stop(marshal);
    expect(start(marshal)).toEqual(expected);
    stop(marshal);
    expect(start(marshal)).toEqual(expected);
    stop(marshal);
  })",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Duplicate Assert,"{'line': 293, 'column': 4, 'index': 8538}","it('should return dimensions a subsequent call', () => {
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      getCallbacksStub(),
    );
    populate(registry, preset.dimensions);
    const expected: StartPublishingResult = {
      critical,
      dimensions: preset.dimensions,
      viewport,
    };

    expect(start(marshal)).toEqual(expected);
    stop(marshal);
    expect(start(marshal)).toEqual(expected);
    stop(marshal);
    expect(start(marshal)).toEqual(expected);
    stop(marshal);
  })",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Duplicate Assert,"{'line': 293, 'column': 4, 'index': 8538}","it('should return dimensions a subsequent call', () => {
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      getCallbacksStub(),
    );
    populate(registry, preset.dimensions);
    const expected: StartPublishingResult = {
      critical,
      dimensions: preset.dimensions,
      viewport,
    };

    expect(start(marshal)).toEqual(expected);
    stop(marshal);
    expect(start(marshal)).toEqual(expected);
    stop(marshal);
    expect(start(marshal)).toEqual(expected);
    stop(marshal);
  })",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Eager Test,"{'line': 74, 'column': 30, 'index': 1977}","it('should publish the registered dimensions (simple)', () => {
  const registry: Registry = createRegistry();
  const marshal: DimensionMarshal = createDimensionMarshal(
    registry,
    getCallbacksStub(),
  );

  registry.draggable.register(getDraggableEntry({ dimension: preset.inHome1 }));
  registry.draggable.register(getDraggableEntry({ dimension: preset.inHome2 }));
  registry.droppable.register(getDroppableEntry({ dimension: preset.home }));

  const result: StartPublishingResult = marshal.startPublishing(defaultRequest);
  const expected: StartPublishingResult = {
    critical,
    viewport,
    dimensions: {
      draggables: {
        [preset.inHome1.descriptor.id]: preset.inHome1,
        [preset.inHome2.descriptor.id]: preset.inHome2,
      },
      droppables: {
        [preset.home.descriptor.id]: preset.home,
      },
    },
  };
  expect(expected).toEqual(result);
})",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Eager Test,"{'line': 75, 'column': 30, 'index': 2058}","it('should publish the registered dimensions (simple)', () => {
  const registry: Registry = createRegistry();
  const marshal: DimensionMarshal = createDimensionMarshal(
    registry,
    getCallbacksStub(),
  );

  registry.draggable.register(getDraggableEntry({ dimension: preset.inHome1 }));
  registry.draggable.register(getDraggableEntry({ dimension: preset.inHome2 }));
  registry.droppable.register(getDroppableEntry({ dimension: preset.home }));

  const result: StartPublishingResult = marshal.startPublishing(defaultRequest);
  const expected: StartPublishingResult = {
    critical,
    viewport,
    dimensions: {
      draggables: {
        [preset.inHome1.descriptor.id]: preset.inHome1,
        [preset.inHome2.descriptor.id]: preset.inHome2,
      },
      droppables: {
        [preset.home.descriptor.id]: preset.home,
      },
    },
  };
  expect(expected).toEqual(result);
})",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Eager Test,"{'line': 76, 'column': 30, 'index': 2139}","it('should publish the registered dimensions (simple)', () => {
  const registry: Registry = createRegistry();
  const marshal: DimensionMarshal = createDimensionMarshal(
    registry,
    getCallbacksStub(),
  );

  registry.draggable.register(getDraggableEntry({ dimension: preset.inHome1 }));
  registry.draggable.register(getDraggableEntry({ dimension: preset.inHome2 }));
  registry.droppable.register(getDroppableEntry({ dimension: preset.home }));

  const result: StartPublishingResult = marshal.startPublishing(defaultRequest);
  const expected: StartPublishingResult = {
    critical,
    viewport,
    dimensions: {
      draggables: {
        [preset.inHome1.descriptor.id]: preset.inHome1,
        [preset.inHome2.descriptor.id]: preset.inHome2,
      },
      droppables: {
        [preset.home.descriptor.id]: preset.home,
      },
    },
  };
  expect(expected).toEqual(result);
})",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Eager Test,"{'line': 231, 'column': 30, 'index': 6634}","it('should publish droppables that have been updated (id change)', () => {
  const registry: Registry = createRegistry();
  const marshal: DimensionMarshal = createDimensionMarshal(
    registry,
    getCallbacksStub(),
  );
  populate(registry, preset.dimensions);
  const expected: DimensionMap = copy(preset.dimensions);

  // changing the id of home
  const updatedHome: DroppableDimension = {
    ...preset.home,
    descriptor: {
      ...preset.home.descriptor,
      id: 'some new id',
    },
  };
  registry.droppable.unregister(
    registry.droppable.getById(preset.home.descriptor.id),
  );
  registry.droppable.register(getDroppableEntry({ dimension: updatedHome }));
  delete expected.droppables[preset.home.descriptor.id];
  expected.droppables[updatedHome.descriptor.id] = updatedHome;

  // changing the droppable id of all the draggables in home
  preset.inHomeList.forEach((draggable: DraggableDimension) => {
    const updated: DraggableDimension = {
      ...draggable,
      descriptor: {
        ...draggable.descriptor,
        droppableId: updatedHome.descriptor.id,
      },
    };
    const last: DraggableEntry = registry.draggable.getById(
      draggable.descriptor.id,
    );
    const fresh: DraggableEntry = getDraggableEntry({
      uniqueId: last.uniqueId,
      dimension: updated,
    });
    registry.draggable.update(fresh, last);
    expected.draggables[draggable.descriptor.id] = updated;
  });

  const result: StartPublishingResult = marshal.startPublishing(defaultRequest);

  const wanted: StartPublishingResult = {
    viewport,
    critical: {
      draggable: {
        ...critical.draggable,
        droppableId: updatedHome.descriptor.id,
      },
      droppable: updatedHome.descriptor,
    },
    dimensions: expected,
  };
  expect(result).toEqual(wanted);
})",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Eager Test,"{'line': 247, 'column': 34, 'index': 7242}","it('should publish droppables that have been updated (id change)', () => {
  const registry: Registry = createRegistry();
  const marshal: DimensionMarshal = createDimensionMarshal(
    registry,
    getCallbacksStub(),
  );
  populate(registry, preset.dimensions);
  const expected: DimensionMap = copy(preset.dimensions);

  // changing the id of home
  const updatedHome: DroppableDimension = {
    ...preset.home,
    descriptor: {
      ...preset.home.descriptor,
      id: 'some new id',
    },
  };
  registry.droppable.unregister(
    registry.droppable.getById(preset.home.descriptor.id),
  );
  registry.droppable.register(getDroppableEntry({ dimension: updatedHome }));
  delete expected.droppables[preset.home.descriptor.id];
  expected.droppables[updatedHome.descriptor.id] = updatedHome;

  // changing the droppable id of all the draggables in home
  preset.inHomeList.forEach((draggable: DraggableDimension) => {
    const updated: DraggableDimension = {
      ...draggable,
      descriptor: {
        ...draggable.descriptor,
        droppableId: updatedHome.descriptor.id,
      },
    };
    const last: DraggableEntry = registry.draggable.getById(
      draggable.descriptor.id,
    );
    const fresh: DraggableEntry = getDraggableEntry({
      uniqueId: last.uniqueId,
      dimension: updated,
    });
    registry.draggable.update(fresh, last);
    expected.draggables[draggable.descriptor.id] = updated;
  });

  const result: StartPublishingResult = marshal.startPublishing(defaultRequest);

  const wanted: StartPublishingResult = {
    viewport,
    critical: {
      draggable: {
        ...critical.draggable,
        droppableId: updatedHome.descriptor.id,
      },
      droppable: updatedHome.descriptor,
    },
    dimensions: expected,
  };
  expect(result).toEqual(wanted);
})",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Lazy Test,"{'line': 74, 'column': 30, 'index': 1977}","it('should publish the registered dimensions (simple)', () => {
  const registry: Registry = createRegistry();
  const marshal: DimensionMarshal = createDimensionMarshal(
    registry,
    getCallbacksStub(),
  );

  registry.draggable.register(getDraggableEntry({ dimension: preset.inHome1 }));
  registry.draggable.register(getDraggableEntry({ dimension: preset.inHome2 }));
  registry.droppable.register(getDroppableEntry({ dimension: preset.home }));

  const result: StartPublishingResult = marshal.startPublishing(defaultRequest);
  const expected: StartPublishingResult = {
    critical,
    viewport,
    dimensions: {
      draggables: {
        [preset.inHome1.descriptor.id]: preset.inHome1,
        [preset.inHome2.descriptor.id]: preset.inHome2,
      },
      droppables: {
        [preset.home.descriptor.id]: preset.home,
      },
    },
  };
  expect(expected).toEqual(result);
})",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Lazy Test,"{'line': 76, 'column': 30, 'index': 2139}","it('should publish the registered dimensions (simple)', () => {
  const registry: Registry = createRegistry();
  const marshal: DimensionMarshal = createDimensionMarshal(
    registry,
    getCallbacksStub(),
  );

  registry.draggable.register(getDraggableEntry({ dimension: preset.inHome1 }));
  registry.draggable.register(getDraggableEntry({ dimension: preset.inHome2 }));
  registry.droppable.register(getDroppableEntry({ dimension: preset.home }));

  const result: StartPublishingResult = marshal.startPublishing(defaultRequest);
  const expected: StartPublishingResult = {
    critical,
    viewport,
    dimensions: {
      draggables: {
        [preset.inHome1.descriptor.id]: preset.inHome1,
        [preset.inHome2.descriptor.id]: preset.inHome2,
      },
      droppables: {
        [preset.home.descriptor.id]: preset.home,
      },
    },
  };
  expect(expected).toEqual(result);
})",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Lazy Test,"{'line': 195, 'column': 34, 'index': 5569}","it('should publish draggables that have been updated (index change)', () => {
  const registry: Registry = createRegistry();
  const marshal: DimensionMarshal = createDimensionMarshal(
    registry,
    getCallbacksStub(),
  );
  populate(registry, preset.dimensions);

  const updatedInHome2: DraggableDimension = {
    ...preset.inHome2,
    descriptor: {
      ...preset.inHome2.descriptor,
      index: 10000,
    },
  };
  const last: DraggableEntry = registry.draggable.getById(
    preset.inHome2.descriptor.id,
  );
  const updated: DraggableEntry = getDraggableEntry({
    uniqueId: last.uniqueId,
    dimension: updatedInHome2,
  });
  registry.draggable.update(updated, last);

  const result: StartPublishingResult = marshal.startPublishing(defaultRequest);
  const expected: DimensionMap = copy(preset.dimensions);
  expected.draggables[preset.inHome2.descriptor.id] = updatedInHome2;
  expect(result).toEqual({
    critical,
    dimensions: expected,
    viewport,
  });
})",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Lazy Test,"{'line': 231, 'column': 30, 'index': 6634}","it('should publish droppables that have been updated (id change)', () => {
  const registry: Registry = createRegistry();
  const marshal: DimensionMarshal = createDimensionMarshal(
    registry,
    getCallbacksStub(),
  );
  populate(registry, preset.dimensions);
  const expected: DimensionMap = copy(preset.dimensions);

  // changing the id of home
  const updatedHome: DroppableDimension = {
    ...preset.home,
    descriptor: {
      ...preset.home.descriptor,
      id: 'some new id',
    },
  };
  registry.droppable.unregister(
    registry.droppable.getById(preset.home.descriptor.id),
  );
  registry.droppable.register(getDroppableEntry({ dimension: updatedHome }));
  delete expected.droppables[preset.home.descriptor.id];
  expected.droppables[updatedHome.descriptor.id] = updatedHome;

  // changing the droppable id of all the draggables in home
  preset.inHomeList.forEach((draggable: DraggableDimension) => {
    const updated: DraggableDimension = {
      ...draggable,
      descriptor: {
        ...draggable.descriptor,
        droppableId: updatedHome.descriptor.id,
      },
    };
    const last: DraggableEntry = registry.draggable.getById(
      draggable.descriptor.id,
    );
    const fresh: DraggableEntry = getDraggableEntry({
      uniqueId: last.uniqueId,
      dimension: updated,
    });
    registry.draggable.update(fresh, last);
    expected.draggables[draggable.descriptor.id] = updated;
  });

  const result: StartPublishingResult = marshal.startPublishing(defaultRequest);

  const wanted: StartPublishingResult = {
    viewport,
    critical: {
      draggable: {
        ...critical.draggable,
        droppableId: updatedHome.descriptor.id,
      },
      droppable: updatedHome.descriptor,
    },
    dimensions: expected,
  };
  expect(result).toEqual(wanted);
})",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Lazy Test,"{'line': 247, 'column': 34, 'index': 7242}","it('should publish droppables that have been updated (id change)', () => {
  const registry: Registry = createRegistry();
  const marshal: DimensionMarshal = createDimensionMarshal(
    registry,
    getCallbacksStub(),
  );
  populate(registry, preset.dimensions);
  const expected: DimensionMap = copy(preset.dimensions);

  // changing the id of home
  const updatedHome: DroppableDimension = {
    ...preset.home,
    descriptor: {
      ...preset.home.descriptor,
      id: 'some new id',
    },
  };
  registry.droppable.unregister(
    registry.droppable.getById(preset.home.descriptor.id),
  );
  registry.droppable.register(getDroppableEntry({ dimension: updatedHome }));
  delete expected.droppables[preset.home.descriptor.id];
  expected.droppables[updatedHome.descriptor.id] = updatedHome;

  // changing the droppable id of all the draggables in home
  preset.inHomeList.forEach((draggable: DraggableDimension) => {
    const updated: DraggableDimension = {
      ...draggable,
      descriptor: {
        ...draggable.descriptor,
        droppableId: updatedHome.descriptor.id,
      },
    };
    const last: DraggableEntry = registry.draggable.getById(
      draggable.descriptor.id,
    );
    const fresh: DraggableEntry = getDraggableEntry({
      uniqueId: last.uniqueId,
      dimension: updated,
    });
    registry.draggable.update(fresh, last);
    expected.draggables[draggable.descriptor.id] = updated;
  });

  const result: StartPublishingResult = marshal.startPublishing(defaultRequest);

  const wanted: StartPublishingResult = {
    viewport,
    critical: {
      draggable: {
        ...critical.draggable,
        droppableId: updatedHome.descriptor.id,
      },
      droppable: updatedHome.descriptor,
    },
    dimensions: expected,
  };
  expect(result).toEqual(wanted);
})",steel
/test/unit/view/dimension-marshal/initial-publish.spec.js,Lazy Test,"{'line': 337, 'column': 34, 'index': 9767}","it('should account for changes after the last call', () => {
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      getCallbacksStub(),
    );
    populate(registry, preset.dimensions);

    // Start first publish
    const result1: StartPublishingResult = start(marshal);
    expect(result1).toEqual({
      critical,
      dimensions: preset.dimensions,
      viewport,
    });

    // Update while first drag is occurring

    const updatedInHome2: DraggableDimension = {
      ...preset.inHome2,
      descriptor: {
        ...preset.inHome2.descriptor,
        index: 10000,
      },
    };
    const last: DraggableEntry = registry.draggable.getById(
      preset.inHome2.descriptor.id,
    );
    const fresh: DraggableEntry = getDraggableEntry({
      uniqueId: last.uniqueId,
      dimension: updatedInHome2,
    });
    registry.draggable.update(fresh, last);
    const expected: DimensionMap = copy(preset.dimensions);
    expected.draggables[updatedInHome2.descriptor.id] = updatedInHome2;

    // Stop the first publish
    stop(marshal);

    // Start the second publish
    const result2: StartPublishingResult = start(marshal);
    expect(result2).toEqual({
      critical,
      dimensions: expected,
      viewport,
    });
  })",steel
/test/unit/view/dimension-marshal/droppable-passthrough.spec.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 1096}","it('should scroll the droppable', () => {
    const registry: Registry = createRegistry();
    const callbacks: Callbacks = getCallbacksStub();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry);

    // initial lift
    marshal.startPublishing(defaultRequest);
    expect(watcher.droppable.scroll).not.toHaveBeenCalled();

    // scroll
    marshal.scrollDroppable(critical.droppable.id, { x: 10, y: 20 });
    expect(watcher.droppable.scroll).toHaveBeenCalledWith(
      critical.droppable.id,
      { x: 10, y: 20 },
    );
  })",steel
/test/unit/view/dimension-marshal/droppable-passthrough.spec.js,Duplicate Assert,"{'line': 32, 'column': 4, 'index': 1242}","it('should scroll the droppable', () => {
    const registry: Registry = createRegistry();
    const callbacks: Callbacks = getCallbacksStub();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    const watcher: DimensionWatcher = populate(registry);

    // initial lift
    marshal.startPublishing(defaultRequest);
    expect(watcher.droppable.scroll).not.toHaveBeenCalled();

    // scroll
    marshal.scrollDroppable(critical.droppable.id, { x: 10, y: 20 });
    expect(watcher.droppable.scroll).toHaveBeenCalledWith(
      critical.droppable.id,
      { x: 10, y: 20 },
    );
  })",steel
/test/unit/view/dimension-marshal/droppable-passthrough.spec.js,Duplicate Assert,"{'line': 140, 'column': 4, 'index': 4604}","it('should let consumers know', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry);

    // initial lift
    marshal.startPublishing(defaultRequest);
    expect(callbacks.updateDroppableIsEnabled).not.toHaveBeenCalled();

    marshal.updateDroppableIsEnabled(critical.droppable.id, false);
    expect(callbacks.updateDroppableIsEnabled).toHaveBeenCalledWith({
      id: critical.droppable.id,
      isEnabled: false,
    });
  })",steel
/test/unit/view/dimension-marshal/droppable-passthrough.spec.js,Duplicate Assert,"{'line': 143, 'column': 4, 'index': 4744}","it('should let consumers know', () => {
    const callbacks: Callbacks = getCallbacksStub();
    const registry: Registry = createRegistry();
    const marshal: DimensionMarshal = createDimensionMarshal(
      registry,
      callbacks,
    );
    populate(registry);

    // initial lift
    marshal.startPublishing(defaultRequest);
    expect(callbacks.updateDroppableIsEnabled).not.toHaveBeenCalled();

    marshal.updateDroppableIsEnabled(critical.droppable.id, false);
    expect(callbacks.updateDroppableIsEnabled).toHaveBeenCalledWith({
      id: critical.droppable.id,
      isEnabled: false,
    });
  })",steel
/test/unit/view/connected-droppable/post-drop.spec.js,Duplicate Assert,"{'line': 178, 'column': 4, 'index': 5124}","it('should cut an animation', () => {
    const ownProps: OwnProps = getOwnProps(preset.home);
    const selector: Selector = makeMapStateToProps();
    const atRest: MapProps = selector(state.idle, ownProps);

    // while dropping
    const combine: Combine = {
      draggableId: preset.inHome2.descriptor.id,
      droppableId: preset.inHome2.descriptor.droppableId,
    };
    const base: DropAnimatingState = state.dropAnimating();
    const combineImpact: DragImpact = {
      ...base.completed.impact,
      at: {
        type: 'COMBINE',
        combine,
      },
    };
    const dropping: DropAnimatingState = {
      ...base,
      completed: {
        ...base.completed,
        impact: combineImpact,
        result: {
          ...base.completed.result,
          destination: null,
          combine,
        },
      },
    };

    // drop complete
    const withFlush: IdleState = {
      phase: 'IDLE',
      completed: dropping.completed,
      shouldFlush: true,
    };
    const postDrop: MapProps = selector(withFlush, ownProps);
    const expected: MapProps = {
      ...atRest,
      shouldAnimatePlaceholder: false,
    };
    expect(postDrop).toBe(atRest);
    expect(postDrop).toEqual(expected);
  })",steel
/test/unit/view/connected-droppable/post-drop.spec.js,Duplicate Assert,"{'line': 179, 'column': 4, 'index': 5159}","it('should cut an animation', () => {
    const ownProps: OwnProps = getOwnProps(preset.home);
    const selector: Selector = makeMapStateToProps();
    const atRest: MapProps = selector(state.idle, ownProps);

    // while dropping
    const combine: Combine = {
      draggableId: preset.inHome2.descriptor.id,
      droppableId: preset.inHome2.descriptor.droppableId,
    };
    const base: DropAnimatingState = state.dropAnimating();
    const combineImpact: DragImpact = {
      ...base.completed.impact,
      at: {
        type: 'COMBINE',
        combine,
      },
    };
    const dropping: DropAnimatingState = {
      ...base,
      completed: {
        ...base.completed,
        impact: combineImpact,
        result: {
          ...base.completed.result,
          destination: null,
          combine,
        },
      },
    };

    // drop complete
    const withFlush: IdleState = {
      phase: 'IDLE',
      completed: dropping.completed,
      shouldFlush: true,
    };
    const postDrop: MapProps = selector(withFlush, ownProps);
    const expected: MapProps = {
      ...atRest,
      shouldAnimatePlaceholder: false,
    };
    expect(postDrop).toBe(atRest);
    expect(postDrop).toEqual(expected);
  })",steel
/test/unit/view/connected-droppable/post-drop.spec.js,Duplicate Assert,"{'line': 198, 'column': 4, 'index': 5769}","it('should cut animation in a list that was not animating', () => {
    const ownProps: OwnProps = getOwnProps(preset.foreign);
    const selector: Selector = makeMapStateToProps();
    const atRest: MapProps = selector(state.idle, ownProps);

    // drop complete
    const withFlush: IdleState = {
      phase: 'IDLE',
      completed: state.dropAnimating().completed,
      shouldFlush: true,
    };
    const postDrop: MapProps = selector(withFlush, ownProps);
    const expected: MapProps = {
      ...atRest,
      shouldAnimatePlaceholder: false,
    };
    expect(postDrop).toBe(atRest);
    expect(postDrop).toEqual(expected);
  })",steel
/test/unit/view/connected-droppable/post-drop.spec.js,Duplicate Assert,"{'line': 199, 'column': 4, 'index': 5804}","it('should cut animation in a list that was not animating', () => {
    const ownProps: OwnProps = getOwnProps(preset.foreign);
    const selector: Selector = makeMapStateToProps();
    const atRest: MapProps = selector(state.idle, ownProps);

    // drop complete
    const withFlush: IdleState = {
      phase: 'IDLE',
      completed: state.dropAnimating().completed,
      shouldFlush: true,
    };
    const postDrop: MapProps = selector(withFlush, ownProps);
    const expected: MapProps = {
      ...atRest,
      shouldAnimatePlaceholder: false,
    };
    expect(postDrop).toBe(atRest);
    expect(postDrop).toEqual(expected);
  })",steel
/test/unit/view/connected-droppable/dropping.spec.js,Duplicate Assert,"{'line': 44, 'column': 6, 'index': 1511}","it('should not break memoization from a reorder', () => {
      const ownProps: OwnProps = getOwnProps(preset.home);
      const selector: Selector = makeMapStateToProps();

      const whileDragging: MapProps = selector(state.dragging(), ownProps);
      const whileDropping: MapProps = selector(state.dropAnimating(), ownProps);

      expect(whileDragging).toEqual(isOverMapProps);
      // referential equality: memoization check
      expect(whileDragging).toBe(whileDropping);
    })",steel
/test/unit/view/connected-droppable/dropping.spec.js,Duplicate Assert,"{'line': 46, 'column': 6, 'index': 1613}","it('should not break memoization from a reorder', () => {
      const ownProps: OwnProps = getOwnProps(preset.home);
      const selector: Selector = makeMapStateToProps();

      const whileDragging: MapProps = selector(state.dragging(), ownProps);
      const whileDropping: MapProps = selector(state.dropAnimating(), ownProps);

      expect(whileDragging).toEqual(isOverMapProps);
      // referential equality: memoization check
      expect(whileDragging).toBe(whileDropping);
    })",steel
/test/unit/view/connected-droppable/dropping.spec.js,Duplicate Assert,"{'line': 77, 'column': 6, 'index': 2557}","it('should not break memoization from a combine', () => {
      const ownProps: OwnProps = getOwnProps(preset.home);
      const selector: Selector = makeMapStateToProps();
      const combine: DragImpact = {
        ...state.dragging().impact,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome2.descriptor.id,
            droppableId: preset.inHome2.descriptor.droppableId,
          },
        },
      };
      const base: DropAnimatingState = state.dropAnimating();
      const droppingState: DropAnimatingState = {
        ...base,
        completed: {
          ...base.completed,
          impact: combine,
        },
      };

      const whileDragging: MapProps = selector(
        withImpact(state.dragging(), combine),
        ownProps,
      );
      const whileDropping: MapProps = selector(droppingState, ownProps);

      expect(whileDragging).toEqual(isOverMapProps);
      // referential equality: memoization check
      expect(whileDragging).toBe(whileDropping);
    })",steel
/test/unit/view/connected-droppable/dropping.spec.js,Duplicate Assert,"{'line': 79, 'column': 6, 'index': 2659}","it('should not break memoization from a combine', () => {
      const ownProps: OwnProps = getOwnProps(preset.home);
      const selector: Selector = makeMapStateToProps();
      const combine: DragImpact = {
        ...state.dragging().impact,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome2.descriptor.id,
            droppableId: preset.inHome2.descriptor.droppableId,
          },
        },
      };
      const base: DropAnimatingState = state.dropAnimating();
      const droppingState: DropAnimatingState = {
        ...base,
        completed: {
          ...base.completed,
          impact: combine,
        },
      };

      const whileDragging: MapProps = selector(
        withImpact(state.dragging(), combine),
        ownProps,
      );
      const whileDropping: MapProps = selector(droppingState, ownProps);

      expect(whileDragging).toEqual(isOverMapProps);
      // referential equality: memoization check
      expect(whileDragging).toBe(whileDropping);
    })",steel
/test/unit/view/connected-droppable/dragging.spec.js,Duplicate Assert,"{'line': 132, 'column': 6, 'index': 4349}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isHomeButNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      const combine: Combine = {
        draggableId: preset.inForeign1.descriptor.id,
        droppableId: preset.foreign.descriptor.id,
      };
      const withCombine: IsDraggingState = withImpact(
        state.dragging(),
        withCombineImpact(state.dragging().impact, combine),
      );
      expect(selector(withCombine, ownProps)).toBe(first);
    })",steel
/test/unit/view/connected-droppable/dragging.spec.js,Duplicate Assert,"{'line': 132, 'column': 6, 'index': 4349}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isHomeButNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      const combine: Combine = {
        draggableId: preset.inForeign1.descriptor.id,
        droppableId: preset.foreign.descriptor.id,
      };
      const withCombine: IsDraggingState = withImpact(
        state.dragging(),
        withCombineImpact(state.dragging().impact, combine),
      );
      expect(selector(withCombine, ownProps)).toBe(first);
    })",steel
/test/unit/view/connected-droppable/dragging.spec.js,Duplicate Assert,"{'line': 135, 'column': 6, 'index': 4448}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isHomeButNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      const combine: Combine = {
        draggableId: preset.inForeign1.descriptor.id,
        droppableId: preset.foreign.descriptor.id,
      };
      const withCombine: IsDraggingState = withImpact(
        state.dragging(),
        withCombineImpact(state.dragging().impact, combine),
      );
      expect(selector(withCombine, ownProps)).toBe(first);
    })",steel
/test/unit/view/connected-droppable/dragging.spec.js,Duplicate Assert,"{'line': 135, 'column': 6, 'index': 4448}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isHomeButNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      const combine: Combine = {
        draggableId: preset.inForeign1.descriptor.id,
        droppableId: preset.foreign.descriptor.id,
      };
      const withCombine: IsDraggingState = withImpact(
        state.dragging(),
        withCombineImpact(state.dragging().impact, combine),
      );
      expect(selector(withCombine, ownProps)).toBe(first);
    })",steel
/test/unit/view/connected-droppable/dragging.spec.js,Duplicate Assert,"{'line': 138, 'column': 6, 'index': 4547}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isHomeButNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      const combine: Combine = {
        draggableId: preset.inForeign1.descriptor.id,
        droppableId: preset.foreign.descriptor.id,
      };
      const withCombine: IsDraggingState = withImpact(
        state.dragging(),
        withCombineImpact(state.dragging().impact, combine),
      );
      expect(selector(withCombine, ownProps)).toBe(first);
    })",steel
/test/unit/view/connected-droppable/dragging.spec.js,Duplicate Assert,"{'line': 138, 'column': 6, 'index': 4547}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isHomeButNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      const combine: Combine = {
        draggableId: preset.inForeign1.descriptor.id,
        droppableId: preset.foreign.descriptor.id,
      };
      const withCombine: IsDraggingState = withImpact(
        state.dragging(),
        withCombineImpact(state.dragging().impact, combine),
      );
      expect(selector(withCombine, ownProps)).toBe(first);
    })",steel
/test/unit/view/connected-droppable/dragging.spec.js,Duplicate Assert,"{'line': 257, 'column': 6, 'index': 8397}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
    })",steel
/test/unit/view/connected-droppable/dragging.spec.js,Duplicate Assert,"{'line': 257, 'column': 6, 'index': 8397}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
    })",steel
/test/unit/view/connected-droppable/dragging.spec.js,Duplicate Assert,"{'line': 260, 'column': 6, 'index': 8496}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
    })",steel
/test/unit/view/connected-droppable/dragging.spec.js,Duplicate Assert,"{'line': 260, 'column': 6, 'index': 8496}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
    })",steel
/test/unit/view/connected-droppable/dragging.spec.js,Duplicate Assert,"{'line': 263, 'column': 6, 'index': 8595}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
    })",steel
/test/unit/view/connected-droppable/dragging.spec.js,Duplicate Assert,"{'line': 263, 'column': 6, 'index': 8595}","it('should not break memoization between moves', () => {
      const selector: Selector = makeMapStateToProps();

      const first: MapProps = selector(getNoWhere(), ownProps);
      expect(first).toEqual(isNotOver);

      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
      expect(selector(move(getNoWhere(), { x: 1, y: 1 }), ownProps)).toBe(
        first,
      );
    })",steel
/test/unit/view/connected-droppable/disabled.spec.js,Duplicate Assert,"{'line': 56, 'column': 4, 'index': 1959}","it('should display a placeholder even when disabled', () => {
    const base: DraggingState = state.dragging(preset.inHome1.descriptor.id);
    const getNoWhere = (): DraggingState => ({
      ...base,
      dimensions: patchDimensionMap(
        base.dimensions,
        disableDroppable(preset.home),
      ),
      impact: cloneImpact(noImpact),
    });
    const isHomeButNotOver: MapProps = {
      placeholder: preset.inHome1.placeholder,
      shouldAnimatePlaceholder: false,
      snapshot: {
        isDraggingOver: false,
        draggingOverWith: null,
        draggingFromThisWith: preset.inHome1.descriptor.id,
        isUsingPlaceholder: true,
      },
      useClone: null,
    };

    const result: MapProps = selector(getNoWhere(), ownProps);
    expect(result).toEqual(isHomeButNotOver);

    // memoization
    expect(selector(getNoWhere(), ownProps)).toBe(result);
    expect(selector(getNoWhere(), ownProps)).toBe(result);
  })",steel
/test/unit/view/connected-droppable/disabled.spec.js,Duplicate Assert,"{'line': 56, 'column': 4, 'index': 1959}","it('should display a placeholder even when disabled', () => {
    const base: DraggingState = state.dragging(preset.inHome1.descriptor.id);
    const getNoWhere = (): DraggingState => ({
      ...base,
      dimensions: patchDimensionMap(
        base.dimensions,
        disableDroppable(preset.home),
      ),
      impact: cloneImpact(noImpact),
    });
    const isHomeButNotOver: MapProps = {
      placeholder: preset.inHome1.placeholder,
      shouldAnimatePlaceholder: false,
      snapshot: {
        isDraggingOver: false,
        draggingOverWith: null,
        draggingFromThisWith: preset.inHome1.descriptor.id,
        isUsingPlaceholder: true,
      },
      useClone: null,
    };

    const result: MapProps = selector(getNoWhere(), ownProps);
    expect(result).toEqual(isHomeButNotOver);

    // memoization
    expect(selector(getNoWhere(), ownProps)).toBe(result);
    expect(selector(getNoWhere(), ownProps)).toBe(result);
  })",steel
/test/unit/view/connected-droppable/disabled.spec.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 2018}","it('should display a placeholder even when disabled', () => {
    const base: DraggingState = state.dragging(preset.inHome1.descriptor.id);
    const getNoWhere = (): DraggingState => ({
      ...base,
      dimensions: patchDimensionMap(
        base.dimensions,
        disableDroppable(preset.home),
      ),
      impact: cloneImpact(noImpact),
    });
    const isHomeButNotOver: MapProps = {
      placeholder: preset.inHome1.placeholder,
      shouldAnimatePlaceholder: false,
      snapshot: {
        isDraggingOver: false,
        draggingOverWith: null,
        draggingFromThisWith: preset.inHome1.descriptor.id,
        isUsingPlaceholder: true,
      },
      useClone: null,
    };

    const result: MapProps = selector(getNoWhere(), ownProps);
    expect(result).toEqual(isHomeButNotOver);

    // memoization
    expect(selector(getNoWhere(), ownProps)).toBe(result);
    expect(selector(getNoWhere(), ownProps)).toBe(result);
  })",steel
/test/unit/view/connected-droppable/disabled.spec.js,Duplicate Assert,"{'line': 57, 'column': 4, 'index': 2018}","it('should display a placeholder even when disabled', () => {
    const base: DraggingState = state.dragging(preset.inHome1.descriptor.id);
    const getNoWhere = (): DraggingState => ({
      ...base,
      dimensions: patchDimensionMap(
        base.dimensions,
        disableDroppable(preset.home),
      ),
      impact: cloneImpact(noImpact),
    });
    const isHomeButNotOver: MapProps = {
      placeholder: preset.inHome1.placeholder,
      shouldAnimatePlaceholder: false,
      snapshot: {
        isDraggingOver: false,
        draggingOverWith: null,
        draggingFromThisWith: preset.inHome1.descriptor.id,
        isUsingPlaceholder: true,
      },
      useClone: null,
    };

    const result: MapProps = selector(getNoWhere(), ownProps);
    expect(result).toEqual(isHomeButNotOver);

    // memoization
    expect(selector(getNoWhere(), ownProps)).toBe(result);
    expect(selector(getNoWhere(), ownProps)).toBe(result);
  })",steel
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,Duplicate Assert,"{'line': 193, 'column': 8, 'index': 6328}","it('should not break memoization on multiple calls', () => {
        const selector: Selector = makeMapStateToProps();
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              { dimension: preset.inHome3, shouldAnimate: true },
              { dimension: preset.inHome4, shouldAnimate: true },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: inHome1Location,
          },
        };
        const first: MapProps = selector(withImpact(current, impact), ownProps);

        const expected: MapProps = {
          mapped: {
            type: 'SECONDARY',
            offset: displacedBy.point,
            shouldAnimateDisplacement: true,
            combineTargetFor: null,
            snapshot: getSecondarySnapshot({
              combineTargetFor: null,
            }),
          },
        };
        expect(first).toEqual(expected);

        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
      })",steel
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,Duplicate Assert,"{'line': 193, 'column': 8, 'index': 6328}","it('should not break memoization on multiple calls', () => {
        const selector: Selector = makeMapStateToProps();
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              { dimension: preset.inHome3, shouldAnimate: true },
              { dimension: preset.inHome4, shouldAnimate: true },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: inHome1Location,
          },
        };
        const first: MapProps = selector(withImpact(current, impact), ownProps);

        const expected: MapProps = {
          mapped: {
            type: 'SECONDARY',
            offset: displacedBy.point,
            shouldAnimateDisplacement: true,
            combineTargetFor: null,
            snapshot: getSecondarySnapshot({
              combineTargetFor: null,
            }),
          },
        };
        expect(first).toEqual(expected);

        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
      })",steel
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,Duplicate Assert,"{'line': 196, 'column': 8, 'index': 6439}","it('should not break memoization on multiple calls', () => {
        const selector: Selector = makeMapStateToProps();
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              { dimension: preset.inHome3, shouldAnimate: true },
              { dimension: preset.inHome4, shouldAnimate: true },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: inHome1Location,
          },
        };
        const first: MapProps = selector(withImpact(current, impact), ownProps);

        const expected: MapProps = {
          mapped: {
            type: 'SECONDARY',
            offset: displacedBy.point,
            shouldAnimateDisplacement: true,
            combineTargetFor: null,
            snapshot: getSecondarySnapshot({
              combineTargetFor: null,
            }),
          },
        };
        expect(first).toEqual(expected);

        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
      })",steel
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,Duplicate Assert,"{'line': 196, 'column': 8, 'index': 6439}","it('should not break memoization on multiple calls', () => {
        const selector: Selector = makeMapStateToProps();
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              { dimension: preset.inHome3, shouldAnimate: true },
              { dimension: preset.inHome4, shouldAnimate: true },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: inHome1Location,
          },
        };
        const first: MapProps = selector(withImpact(current, impact), ownProps);

        const expected: MapProps = {
          mapped: {
            type: 'SECONDARY',
            offset: displacedBy.point,
            shouldAnimateDisplacement: true,
            combineTargetFor: null,
            snapshot: getSecondarySnapshot({
              combineTargetFor: null,
            }),
          },
        };
        expect(first).toEqual(expected);

        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
      })",steel
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,Duplicate Assert,"{'line': 199, 'column': 8, 'index': 6550}","it('should not break memoization on multiple calls', () => {
        const selector: Selector = makeMapStateToProps();
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              { dimension: preset.inHome3, shouldAnimate: true },
              { dimension: preset.inHome4, shouldAnimate: true },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: inHome1Location,
          },
        };
        const first: MapProps = selector(withImpact(current, impact), ownProps);

        const expected: MapProps = {
          mapped: {
            type: 'SECONDARY',
            offset: displacedBy.point,
            shouldAnimateDisplacement: true,
            combineTargetFor: null,
            snapshot: getSecondarySnapshot({
              combineTargetFor: null,
            }),
          },
        };
        expect(first).toEqual(expected);

        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
      })",steel
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,Duplicate Assert,"{'line': 199, 'column': 8, 'index': 6550}","it('should not break memoization on multiple calls', () => {
        const selector: Selector = makeMapStateToProps();
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              { dimension: preset.inHome3, shouldAnimate: true },
              { dimension: preset.inHome4, shouldAnimate: true },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: inHome1Location,
          },
        };
        const first: MapProps = selector(withImpact(current, impact), ownProps);

        const expected: MapProps = {
          mapped: {
            type: 'SECONDARY',
            offset: displacedBy.point,
            shouldAnimateDisplacement: true,
            combineTargetFor: null,
            snapshot: getSecondarySnapshot({
              combineTargetFor: null,
            }),
          },
        };
        expect(first).toEqual(expected);

        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
      })",steel
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,Lazy Test,"{'line': 81, 'column': 21, 'index': 2571}","it('should move out of the way (no animation)', () => {
        const selector: Selector = makeMapStateToProps();
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: false },
              { dimension: preset.inHome3, shouldAnimate: false },
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: inHome1Location,
          },
        };
        const impacted: IsDraggingState = withImpact(current, impact);

        const expected: MapProps = {
          mapped: {
            type: 'SECONDARY',
            shouldAnimateDisplacement: false,
            offset: displacedBy.point,
            combineTargetFor: null,
            snapshot: getSecondarySnapshot({
              combineTargetFor: null,
            }),
          },
        };
        expect(selector(impacted, ownProps)).toEqual(expected);
      })",steel
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,Lazy Test,"{'line': 113, 'column': 21, 'index': 3641}","it('should move out of the way (with animation)', () => {
        const selector: Selector = makeMapStateToProps();
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              { dimension: preset.inHome3, shouldAnimate: true },
              { dimension: preset.inHome4, shouldAnimate: true },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: inHome1Location,
          },
        };
        const impacted: IsDraggingState = withImpact(current, impact);

        const expected: MapProps = {
          mapped: {
            type: 'SECONDARY',
            shouldAnimateDisplacement: true,
            offset: displacedBy.point,
            combineTargetFor: null,
            snapshot: getSecondarySnapshot({
              combineTargetFor: null,
            }),
          },
        };
        expect(selector(impacted, ownProps)).toEqual(expected);
      })",steel
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,Lazy Test,"{'line': 147, 'column': 21, 'index': 4812}","it('should not move if displacement is not visible, and not break memoization', () => {
        const selector: Selector = makeMapStateToProps();
        const defaultMapProps: MapProps = selector(state.idle, ownProps);

        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            invisible: [preset.inHome2, preset.inHome3, preset.inHome4],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: inHome1Location,
          },
        };
        const impacted: IsDraggingState = withImpact(current, impact);

        // testing value and also that memoization has not broken
        expect(selector(impacted, ownProps)).toBe(defaultMapProps);
      })",steel
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,Lazy Test,"{'line': 165, 'column': 21, 'index': 5457}","it('should not break memoization on multiple calls', () => {
        const selector: Selector = makeMapStateToProps();
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              { dimension: preset.inHome3, shouldAnimate: true },
              { dimension: preset.inHome4, shouldAnimate: true },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: inHome1Location,
          },
        };
        const first: MapProps = selector(withImpact(current, impact), ownProps);

        const expected: MapProps = {
          mapped: {
            type: 'SECONDARY',
            offset: displacedBy.point,
            shouldAnimateDisplacement: true,
            combineTargetFor: null,
            snapshot: getSecondarySnapshot({
              combineTargetFor: null,
            }),
          },
        };
        expect(first).toEqual(expected);

        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
        expect(
          selector(withImpact(current, cloneImpact(impact)), ownProps),
        ).toBe(first);
      })",steel
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,Lazy Test,"{'line': 207, 'column': 21, 'index': 6870}","it('should not break memoization moving between different dragging phases', () => {
        const selector: Selector = makeMapStateToProps();
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: false },
              { dimension: preset.inHome3, shouldAnimate: false },
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: inHome1Location,
          },
        };

        const first: MapProps = selector(
          withImpact(state.dragging(), cloneImpact(impact)),
          ownProps,
        );
        const second: MapProps = selector(
          withImpact(state.collecting(), cloneImpact(impact)),
          ownProps,
        );
        const third: MapProps = selector(
          withImpact(state.dropPending(), cloneImpact(impact)),
          ownProps,
        );

        expect(first).toBe(second);
        expect(second).toBe(third);
      })",steel
/test/unit/view/connected-draggable/something-else-is-dragging.spec.js,Lazy Test,"{'line': 259, 'column': 15, 'index': 8530}","it('should not break memoization moving between different dragging phases (something else impacted)', () => {
  const selector: Selector = makeMapStateToProps();
  const impact: DragImpact = {
    displaced: getForcedDisplacement({
      visible: [
        { dimension: preset.inHome2, shouldAnimate: false },
        { dimension: preset.inHome3, shouldAnimate: false },
        { dimension: preset.inHome4, shouldAnimate: false },
      ],
    }),
    displacedBy,
    at: {
      type: 'REORDER',
      destination: inHome1Location,
    },
  };
  // drag should have no impact on inForeign1
  const unrelatedToDrag: OwnProps = getOwnProps(preset.inForeign1);
  const unrelatedDefault: MapProps = selector(state.idle, unrelatedToDrag);

  const first: MapProps = selector(
    withImpact(state.dragging(), impact),
    unrelatedToDrag,
  );
  const second: MapProps = selector(
    withImpact(state.collecting(), impact),
    unrelatedToDrag,
  );
  const third: MapProps = selector(
    withImpact(state.dropPending(), impact),
    unrelatedToDrag,
  );

  expect(first).toBe(unrelatedDefault);
  expect(second).toBe(unrelatedDefault);
  expect(third).toBe(unrelatedDefault);
})",steel
/test/unit/view/connected-draggable/something-else-dragging-in-virtual.spec.js,Lazy Test,"{'line': 47, 'column': 17, 'index': 2081}","it('should stay in the original visual spot when displaced', () => {
    const selector: Selector = makeMapStateToProps();
    const defaultMapProps: MapProps = selector(state.idle, ownProps);
    const current: DraggingState = (withVirtuals(
      (state.dragging(preset.inHome1.descriptor.id): any),
    ): any);
    const impact: DragImpact = {
      displaced: getForcedDisplacement({
        visible: [
          { dimension: preset.inHome2, shouldAnimate: false },
          { dimension: preset.inHome3, shouldAnimate: false },
          { dimension: preset.inHome4, shouldAnimate: false },
        ],
      }),
      displacedBy: getDisplacedBy(preset.home.axis, preset.inHome1.displaceBy),
      at: {
        type: 'REORDER',
        destination: getHomeLocation(preset.inHome1.descriptor),
      },
    };
    const impacted: IsDraggingState = withImpact(current, impact);

    expect(selector(impacted, ownProps)).toBe(defaultMapProps);
  })",steel
/test/unit/view/connected-draggable/something-else-dragging-in-virtual.spec.js,Lazy Test,"{'line': 72, 'column': 17, 'index': 3038}","it('should return the resting props if currently invisible', () => {
    const selector: Selector = makeMapStateToProps();
    const defaultMapProps: MapProps = selector(state.idle, ownProps);
    const current: DraggingState = (withVirtuals(
      (state.dragging(preset.inHome1.descriptor.id): any),
    ): any);
    const impact: DragImpact = {
      displaced: getForcedDisplacement({
        visible: [
          { dimension: preset.inHome3, shouldAnimate: false },
          { dimension: preset.inHome4, shouldAnimate: false },
        ],
        invisible: [preset.inHome2],
      }),
      displacedBy: getDisplacedBy(preset.home.axis, preset.inHome1.displaceBy),
      at: {
        type: 'REORDER',
        destination: getHomeLocation(preset.inHome1.descriptor),
      },
    };
    const impacted: IsDraggingState = withImpact(current, impact);

    expect(selector(impacted, ownProps)).toBe(defaultMapProps);
  })",steel
/test/unit/view/connected-draggable/dragging.spec.js,Duplicate Assert,"{'line': 120, 'column': 6, 'index': 3715}","it('should not break memoization on multiple calls to the same offset', () => {
      const selector: Selector = makeMapStateToProps();

      const result1: MapProps = selector(
        move(current, { x: 100, y: 200 }),
        ownProps,
      );
      const result2: MapProps = selector(
        move(current, { x: 100, y: 200 }),
        ownProps,
      );

      expect(result1).toBe(result2);

      // also checking with new top level reference
      const newCurrent: IsDraggingState = ({ ...current }: any);
      const result3: MapProps = selector(
        move(newCurrent, { x: 100, y: 200 }),
        ownProps,
      );

      expect(result1).toBe(result3);
    })",steel
/test/unit/view/connected-draggable/dragging.spec.js,Duplicate Assert,"{'line': 129, 'column': 6, 'index': 3986}","it('should not break memoization on multiple calls to the same offset', () => {
      const selector: Selector = makeMapStateToProps();

      const result1: MapProps = selector(
        move(current, { x: 100, y: 200 }),
        ownProps,
      );
      const result2: MapProps = selector(
        move(current, { x: 100, y: 200 }),
        ownProps,
      );

      expect(result1).toBe(result2);

      // also checking with new top level reference
      const newCurrent: IsDraggingState = ({ ...current }: any);
      const result3: MapProps = selector(
        move(newCurrent, { x: 100, y: 200 }),
        ownProps,
      );

      expect(result1).toBe(result3);
    })",steel
/test/unit/view/connected-draggable/dragging.spec.js,Duplicate Assert,"{'line': 144, 'column': 6, 'index': 4401}","it('should break memoization on multiple calls if moving to a new offset', () => {
      const selector: Selector = makeMapStateToProps();

      const result1: MapProps = selector(
        move(current, { x: 100, y: 200 }),
        ownProps,
      );
      const result2: MapProps = selector(
        move(current, { x: 101, y: 200 }),
        ownProps,
      );

      expect(result1).not.toBe(result2);
      expect(result1).not.toEqual(result2);
    })",steel
/test/unit/view/connected-draggable/dragging.spec.js,Duplicate Assert,"{'line': 145, 'column': 6, 'index': 4442}","it('should break memoization on multiple calls if moving to a new offset', () => {
      const selector: Selector = makeMapStateToProps();

      const result1: MapProps = selector(
        move(current, { x: 100, y: 200 }),
        ownProps,
      );
      const result2: MapProps = selector(
        move(current, { x: 101, y: 200 }),
        ownProps,
      );

      expect(result1).not.toBe(result2);
      expect(result1).not.toEqual(result2);
    })",steel
/test/unit/view/connected-draggable/combine-with.spec.js,Duplicate Assert,"{'line': 107, 'column': 6, 'index': 3314}","it('should break memoization on multiple calls if changing combine', () => {
      const selector: Selector = makeMapStateToProps();

      const result1: MapProps = selector(withMerge, ownProps);
      const result2: MapProps = selector(withoutMerge, ownProps);

      expect(result1).not.toBe(result2);
      expect(result1).not.toEqual(result2);
    })",steel
/test/unit/view/connected-draggable/combine-with.spec.js,Duplicate Assert,"{'line': 108, 'column': 6, 'index': 3355}","it('should break memoization on multiple calls if changing combine', () => {
      const selector: Selector = makeMapStateToProps();

      const result1: MapProps = selector(withMerge, ownProps);
      const result2: MapProps = selector(withoutMerge, ownProps);

      expect(result1).not.toBe(result2);
      expect(result1).not.toEqual(result2);
    })",steel
/test/unit/view/connected-draggable/combine-target-for.spec.js,Duplicate Assert,"{'line': 83, 'column': 6, 'index': 2743}","it('should not break memoization on multiple calls with the same impact', () => {
      const selector: Selector = makeMapStateToProps();
      const expected: MapProps = {
        mapped: {
          type: 'SECONDARY',
          offset: impact.displacedBy.point,
          shouldAnimateDisplacement: false,
          combineTargetFor: preset.inHome1.descriptor.id,
          snapshot: getSecondarySnapshot({
            combineTargetFor: preset.inHome1.descriptor.id,
          }),
        },
      };

      const result1: MapProps = selector(withMerge, ownProps);
      const result2: MapProps = selector(
        JSON.parse(JSON.stringify(withMerge)),
        ownProps,
      );

      expect(result1).toEqual(expected);
      expect(result1).toBe(result2);
    })",steel
/test/unit/view/connected-draggable/combine-target-for.spec.js,Duplicate Assert,"{'line': 84, 'column': 6, 'index': 2784}","it('should not break memoization on multiple calls with the same impact', () => {
      const selector: Selector = makeMapStateToProps();
      const expected: MapProps = {
        mapped: {
          type: 'SECONDARY',
          offset: impact.displacedBy.point,
          shouldAnimateDisplacement: false,
          combineTargetFor: preset.inHome1.descriptor.id,
          snapshot: getSecondarySnapshot({
            combineTargetFor: preset.inHome1.descriptor.id,
          }),
        },
      };

      const result1: MapProps = selector(withMerge, ownProps);
      const result2: MapProps = selector(
        JSON.parse(JSON.stringify(withMerge)),
        ownProps,
      );

      expect(result1).toEqual(expected);
      expect(result1).toBe(result2);
    })",steel
/test/unit/view/connected-draggable/combine-target-for.spec.js,Duplicate Assert,"{'line': 93, 'column': 6, 'index': 3098}","it('should break memoization on multiple calls if changing combine', () => {
      const selector: Selector = makeMapStateToProps();

      const result1: MapProps = selector(withMerge, ownProps);
      const result2: MapProps = selector(withoutMerge, ownProps);

      expect(result1).not.toBe(result2);
      expect(result1).not.toEqual(result2);
    })",steel
/test/unit/view/connected-draggable/combine-target-for.spec.js,Duplicate Assert,"{'line': 94, 'column': 6, 'index': 3139}","it('should break memoization on multiple calls if changing combine', () => {
      const selector: Selector = makeMapStateToProps();

      const result1: MapProps = selector(withMerge, ownProps);
      const result2: MapProps = selector(withoutMerge, ownProps);

      expect(result1).not.toBe(result2);
      expect(result1).not.toEqual(result2);
    })",steel
/test/unit/view/connected-draggable/child-render-behaviour.spec.js,Duplicate Assert,"{'line': 70, 'column': 2, 'index': 2139}","it('should render the child function when the parent re-renders', () => {
  const child = getMock();
  // $FlowFixMe: not sure why flow is complaining about only this usage
  const { container, rerender } = render(<App currentUser=""Jake"">{child}</App>);
  expect(child).toHaveBeenCalledTimes(1);

  rerender(<App currentUser=""Jake"">{child}</App>);
  expect(child).toHaveBeenCalledTimes(2);

  expect(container.textContent).toBe('Jake');
})",steel
/test/unit/view/connected-draggable/child-render-behaviour.spec.js,Duplicate Assert,"{'line': 73, 'column': 2, 'index': 2233}","it('should render the child function when the parent re-renders', () => {
  const child = getMock();
  // $FlowFixMe: not sure why flow is complaining about only this usage
  const { container, rerender } = render(<App currentUser=""Jake"">{child}</App>);
  expect(child).toHaveBeenCalledTimes(1);

  rerender(<App currentUser=""Jake"">{child}</App>);
  expect(child).toHaveBeenCalledTimes(2);

  expect(container.textContent).toBe('Jake');
})",steel
/test/unit/view/connected-draggable/child-render-behaviour.spec.js,Duplicate Assert,"{'line': 81, 'column': 2, 'index': 2536}","it('should render the child function when the parents props changes that cause a re-render', () => {
  const child = getMock();
  const { container, rerender } = render(<App currentUser=""Jake"">{child}</App>);
  expect(child).toHaveBeenCalledTimes(1);

  rerender(<App currentUser=""Finn"">{child}</App>);
  expect(child).toHaveBeenCalledTimes(2);

  expect(container.textContent).toBe('Finn');
})",steel
/test/unit/view/connected-draggable/child-render-behaviour.spec.js,Duplicate Assert,"{'line': 84, 'column': 2, 'index': 2630}","it('should render the child function when the parents props changes that cause a re-render', () => {
  const child = getMock();
  const { container, rerender } = render(<App currentUser=""Jake"">{child}</App>);
  expect(child).toHaveBeenCalledTimes(1);

  rerender(<App currentUser=""Finn"">{child}</App>);
  expect(child).toHaveBeenCalledTimes(2);

  expect(container.textContent).toBe('Finn');
})",steel
/test/unit/view/animate-in-out/child-rendering.spec.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 900}","it('should allow children not to be rendered', () => {
  {
    const { unmount, container } = render(
      <AnimateInOut on={null} shouldAnimate={false}>
        {(provided: AnimateProvided) => <Child provided={provided} />}
      </AnimateInOut>,
    );

    expect(container.innerHTML).toEqual('');
    unmount();
  }
  // initial animation set to true
  {
    const { container, unmount } = render(
      <AnimateInOut on={null} shouldAnimate>
        {(provided: AnimateProvided) => <Child provided={provided} />}
      </AnimateInOut>,
    );

    expect(container.innerHTML).toEqual('');
    unmount();
  }
})",steel
/test/unit/view/animate-in-out/child-rendering.spec.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 900}","it('should allow children not to be rendered', () => {
  {
    const { unmount, container } = render(
      <AnimateInOut on={null} shouldAnimate={false}>
        {(provided: AnimateProvided) => <Child provided={provided} />}
      </AnimateInOut>,
    );

    expect(container.innerHTML).toEqual('');
    unmount();
  }
  // initial animation set to true
  {
    const { container, unmount } = render(
      <AnimateInOut on={null} shouldAnimate>
        {(provided: AnimateProvided) => <Child provided={provided} />}
      </AnimateInOut>,
    );

    expect(container.innerHTML).toEqual('');
    unmount();
  }
})",steel
/test/unit/view/animate-in-out/child-rendering.spec.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1193}","it('should allow children not to be rendered', () => {
  {
    const { unmount, container } = render(
      <AnimateInOut on={null} shouldAnimate={false}>
        {(provided: AnimateProvided) => <Child provided={provided} />}
      </AnimateInOut>,
    );

    expect(container.innerHTML).toEqual('');
    unmount();
  }
  // initial animation set to true
  {
    const { container, unmount } = render(
      <AnimateInOut on={null} shouldAnimate>
        {(provided: AnimateProvided) => <Child provided={provided} />}
      </AnimateInOut>,
    );

    expect(container.innerHTML).toEqual('');
    unmount();
  }
})",steel
/test/unit/view/animate-in-out/child-rendering.spec.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1193}","it('should allow children not to be rendered', () => {
  {
    const { unmount, container } = render(
      <AnimateInOut on={null} shouldAnimate={false}>
        {(provided: AnimateProvided) => <Child provided={provided} />}
      </AnimateInOut>,
    );

    expect(container.innerHTML).toEqual('');
    unmount();
  }
  // initial animation set to true
  {
    const { container, unmount } = render(
      <AnimateInOut on={null} shouldAnimate>
        {(provided: AnimateProvided) => <Child provided={provided} />}
      </AnimateInOut>,
    );

    expect(container.innerHTML).toEqual('');
    unmount();
  }
})",steel
/test/unit/view/animate-in-out/child-rendering.spec.js,Duplicate Assert,"{'line': 72, 'column': 2, 'index': 1824}","it('should allow children not to be rendered after a close animation', () => {
  const child = jest
    .fn()
    .mockImplementation((provided: AnimateProvided) => (
      <Child provided={provided} />
    ));

  type Props = {|
    on: ?mixed,
    shouldAnimate: boolean,
  |};
  function App({ on, shouldAnimate }: Props) {
    return (
      <AnimateInOut on={on} shouldAnimate={shouldAnimate}>
        {(provided: AnimateProvided) => child(provided)}
      </AnimateInOut>
    );
  }

  const { rerender, container } = render(<App on=""hey"" shouldAnimate />);
  expect(container.textContent).toEqual('open');

  // data is gone - will animate closed
  rerender(<App on={null} shouldAnimate />);
  expect(container.textContent).toEqual('close');

  // letting animate-in-out know that the animation is finished
  act(() => {
    child.mock.calls[child.mock.calls.length - 1][0].onClose();
  });

  expect(container.innerHTML).toEqual('');
})",steel
/test/unit/view/animate-in-out/child-rendering.spec.js,Duplicate Assert,"{'line': 76, 'column': 2, 'index': 1959}","it('should allow children not to be rendered after a close animation', () => {
  const child = jest
    .fn()
    .mockImplementation((provided: AnimateProvided) => (
      <Child provided={provided} />
    ));

  type Props = {|
    on: ?mixed,
    shouldAnimate: boolean,
  |};
  function App({ on, shouldAnimate }: Props) {
    return (
      <AnimateInOut on={on} shouldAnimate={shouldAnimate}>
        {(provided: AnimateProvided) => child(provided)}
      </AnimateInOut>
    );
  }

  const { rerender, container } = render(<App on=""hey"" shouldAnimate />);
  expect(container.textContent).toEqual('open');

  // data is gone - will animate closed
  rerender(<App on={null} shouldAnimate />);
  expect(container.textContent).toEqual('close');

  // letting animate-in-out know that the animation is finished
  act(() => {
    child.mock.calls[child.mock.calls.length - 1][0].onClose();
  });

  expect(container.innerHTML).toEqual('');
})",steel
/test/unit/view/animate-in-out/animate-in-out.spec.js,Duplicate Assert,"{'line': 110, 'column': 2, 'index': 2714}","it('should close instantly if required', () => {
  const child = jest.fn().mockReturnValue(<div>hi</div>);
  const data = { hello: 'world' };
  function App({ value }: { value: ?Object }) {
    return (
      <AnimateInOut on={value} shouldAnimate={false}>
        {child}
      </AnimateInOut>
    );
  }

  const { rerender, container } = render(<App value={data} />);

  const initial: AnimateProvided = {
    data,
    animate: 'none',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(initial);
  expect(container.innerHTML).toEqual('<div>hi</div>');
  child.mockClear();

  // start closing
  // data is gone! this should trigger a close
  rerender(<App value={null} />);
  expect(container.innerHTML).toEqual('');
  expect(child).not.toHaveBeenCalled();
})",steel
/test/unit/view/animate-in-out/animate-in-out.spec.js,Duplicate Assert,"{'line': 111, 'column': 2, 'index': 2761}","it('should close instantly if required', () => {
  const child = jest.fn().mockReturnValue(<div>hi</div>);
  const data = { hello: 'world' };
  function App({ value }: { value: ?Object }) {
    return (
      <AnimateInOut on={value} shouldAnimate={false}>
        {child}
      </AnimateInOut>
    );
  }

  const { rerender, container } = render(<App value={data} />);

  const initial: AnimateProvided = {
    data,
    animate: 'none',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(initial);
  expect(container.innerHTML).toEqual('<div>hi</div>');
  child.mockClear();

  // start closing
  // data is gone! this should trigger a close
  rerender(<App value={null} />);
  expect(container.innerHTML).toEqual('');
  expect(child).not.toHaveBeenCalled();
})",steel
/test/unit/view/animate-in-out/animate-in-out.spec.js,Duplicate Assert,"{'line': 117, 'column': 2, 'index': 2939}","it('should close instantly if required', () => {
  const child = jest.fn().mockReturnValue(<div>hi</div>);
  const data = { hello: 'world' };
  function App({ value }: { value: ?Object }) {
    return (
      <AnimateInOut on={value} shouldAnimate={false}>
        {child}
      </AnimateInOut>
    );
  }

  const { rerender, container } = render(<App value={data} />);

  const initial: AnimateProvided = {
    data,
    animate: 'none',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(initial);
  expect(container.innerHTML).toEqual('<div>hi</div>');
  child.mockClear();

  // start closing
  // data is gone! this should trigger a close
  rerender(<App value={null} />);
  expect(container.innerHTML).toEqual('');
  expect(child).not.toHaveBeenCalled();
})",steel
/test/unit/view/animate-in-out/animate-in-out.spec.js,Duplicate Assert,"{'line': 118, 'column': 2, 'index': 2982}","it('should close instantly if required', () => {
  const child = jest.fn().mockReturnValue(<div>hi</div>);
  const data = { hello: 'world' };
  function App({ value }: { value: ?Object }) {
    return (
      <AnimateInOut on={value} shouldAnimate={false}>
        {child}
      </AnimateInOut>
    );
  }

  const { rerender, container } = render(<App value={data} />);

  const initial: AnimateProvided = {
    data,
    animate: 'none',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(initial);
  expect(container.innerHTML).toEqual('<div>hi</div>');
  child.mockClear();

  // start closing
  // data is gone! this should trigger a close
  rerender(<App value={null} />);
  expect(container.innerHTML).toEqual('');
  expect(child).not.toHaveBeenCalled();
})",steel
/test/unit/view/animate-in-out/animate-in-out.spec.js,Duplicate Assert,"{'line': 148, 'column': 2, 'index': 3654}","it('should animate closed if required', () => {
  const child = jest.fn().mockReturnValue(<div>hi</div>);
  const data = { hello: 'world' };

  type Props = {|
    value: ?Object,
    shouldAnimate: boolean,
  |};

  function App({ value, shouldAnimate }: Props) {
    return (
      <AnimateInOut on={value} shouldAnimate={shouldAnimate}>
        {child}
      </AnimateInOut>
    );
  }

  const { container, rerender } = render(
    <App value={data} shouldAnimate={false} />,
  );

  const initial: AnimateProvided = {
    data,
    animate: 'none',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(initial);
  expect(child).toHaveBeenCalledTimes(1);
  expect(container.innerHTML).toEqual('<div>hi</div>');
  child.mockClear();

  // start closing
  // data is gone! this should trigger a close
  rerender(<App value={null} shouldAnimate />);

  const second: AnimateProvided = {
    // data is still provided to child for final render
    data,
    // still visible while animating
    animate: 'close',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(second);

  // telling AnimateInOut that the animation is finished
  const provided: AnimateProvided = child.mock.calls[0][0];
  child.mockClear();
  // this will trigger a setState that will stop rendering the child
  provided.onClose();

  expect(container.innerHTML).toEqual('');
  expect(child).not.toHaveBeenCalled();
})",steel
/test/unit/view/animate-in-out/animate-in-out.spec.js,Duplicate Assert,"{'line': 149, 'column': 2, 'index': 3701}","it('should animate closed if required', () => {
  const child = jest.fn().mockReturnValue(<div>hi</div>);
  const data = { hello: 'world' };

  type Props = {|
    value: ?Object,
    shouldAnimate: boolean,
  |};

  function App({ value, shouldAnimate }: Props) {
    return (
      <AnimateInOut on={value} shouldAnimate={shouldAnimate}>
        {child}
      </AnimateInOut>
    );
  }

  const { container, rerender } = render(
    <App value={data} shouldAnimate={false} />,
  );

  const initial: AnimateProvided = {
    data,
    animate: 'none',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(initial);
  expect(child).toHaveBeenCalledTimes(1);
  expect(container.innerHTML).toEqual('<div>hi</div>');
  child.mockClear();

  // start closing
  // data is gone! this should trigger a close
  rerender(<App value={null} shouldAnimate />);

  const second: AnimateProvided = {
    // data is still provided to child for final render
    data,
    // still visible while animating
    animate: 'close',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(second);

  // telling AnimateInOut that the animation is finished
  const provided: AnimateProvided = child.mock.calls[0][0];
  child.mockClear();
  // this will trigger a setState that will stop rendering the child
  provided.onClose();

  expect(container.innerHTML).toEqual('');
  expect(child).not.toHaveBeenCalled();
})",steel
/test/unit/view/animate-in-out/animate-in-out.spec.js,Duplicate Assert,"{'line': 150, 'column': 2, 'index': 3743}","it('should animate closed if required', () => {
  const child = jest.fn().mockReturnValue(<div>hi</div>);
  const data = { hello: 'world' };

  type Props = {|
    value: ?Object,
    shouldAnimate: boolean,
  |};

  function App({ value, shouldAnimate }: Props) {
    return (
      <AnimateInOut on={value} shouldAnimate={shouldAnimate}>
        {child}
      </AnimateInOut>
    );
  }

  const { container, rerender } = render(
    <App value={data} shouldAnimate={false} />,
  );

  const initial: AnimateProvided = {
    data,
    animate: 'none',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(initial);
  expect(child).toHaveBeenCalledTimes(1);
  expect(container.innerHTML).toEqual('<div>hi</div>');
  child.mockClear();

  // start closing
  // data is gone! this should trigger a close
  rerender(<App value={null} shouldAnimate />);

  const second: AnimateProvided = {
    // data is still provided to child for final render
    data,
    // still visible while animating
    animate: 'close',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(second);

  // telling AnimateInOut that the animation is finished
  const provided: AnimateProvided = child.mock.calls[0][0];
  child.mockClear();
  // this will trigger a setState that will stop rendering the child
  provided.onClose();

  expect(container.innerHTML).toEqual('');
  expect(child).not.toHaveBeenCalled();
})",steel
/test/unit/view/animate-in-out/animate-in-out.spec.js,Duplicate Assert,"{'line': 165, 'column': 2, 'index': 4170}","it('should animate closed if required', () => {
  const child = jest.fn().mockReturnValue(<div>hi</div>);
  const data = { hello: 'world' };

  type Props = {|
    value: ?Object,
    shouldAnimate: boolean,
  |};

  function App({ value, shouldAnimate }: Props) {
    return (
      <AnimateInOut on={value} shouldAnimate={shouldAnimate}>
        {child}
      </AnimateInOut>
    );
  }

  const { container, rerender } = render(
    <App value={data} shouldAnimate={false} />,
  );

  const initial: AnimateProvided = {
    data,
    animate: 'none',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(initial);
  expect(child).toHaveBeenCalledTimes(1);
  expect(container.innerHTML).toEqual('<div>hi</div>');
  child.mockClear();

  // start closing
  // data is gone! this should trigger a close
  rerender(<App value={null} shouldAnimate />);

  const second: AnimateProvided = {
    // data is still provided to child for final render
    data,
    // still visible while animating
    animate: 'close',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(second);

  // telling AnimateInOut that the animation is finished
  const provided: AnimateProvided = child.mock.calls[0][0];
  child.mockClear();
  // this will trigger a setState that will stop rendering the child
  provided.onClose();

  expect(container.innerHTML).toEqual('');
  expect(child).not.toHaveBeenCalled();
})",steel
/test/unit/view/animate-in-out/animate-in-out.spec.js,Duplicate Assert,"{'line': 173, 'column': 2, 'index': 4447}","it('should animate closed if required', () => {
  const child = jest.fn().mockReturnValue(<div>hi</div>);
  const data = { hello: 'world' };

  type Props = {|
    value: ?Object,
    shouldAnimate: boolean,
  |};

  function App({ value, shouldAnimate }: Props) {
    return (
      <AnimateInOut on={value} shouldAnimate={shouldAnimate}>
        {child}
      </AnimateInOut>
    );
  }

  const { container, rerender } = render(
    <App value={data} shouldAnimate={false} />,
  );

  const initial: AnimateProvided = {
    data,
    animate: 'none',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(initial);
  expect(child).toHaveBeenCalledTimes(1);
  expect(container.innerHTML).toEqual('<div>hi</div>');
  child.mockClear();

  // start closing
  // data is gone! this should trigger a close
  rerender(<App value={null} shouldAnimate />);

  const second: AnimateProvided = {
    // data is still provided to child for final render
    data,
    // still visible while animating
    animate: 'close',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(second);

  // telling AnimateInOut that the animation is finished
  const provided: AnimateProvided = child.mock.calls[0][0];
  child.mockClear();
  // this will trigger a setState that will stop rendering the child
  provided.onClose();

  expect(container.innerHTML).toEqual('');
  expect(child).not.toHaveBeenCalled();
})",steel
/test/unit/view/animate-in-out/animate-in-out.spec.js,Duplicate Assert,"{'line': 174, 'column': 2, 'index': 4490}","it('should animate closed if required', () => {
  const child = jest.fn().mockReturnValue(<div>hi</div>);
  const data = { hello: 'world' };

  type Props = {|
    value: ?Object,
    shouldAnimate: boolean,
  |};

  function App({ value, shouldAnimate }: Props) {
    return (
      <AnimateInOut on={value} shouldAnimate={shouldAnimate}>
        {child}
      </AnimateInOut>
    );
  }

  const { container, rerender } = render(
    <App value={data} shouldAnimate={false} />,
  );

  const initial: AnimateProvided = {
    data,
    animate: 'none',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(initial);
  expect(child).toHaveBeenCalledTimes(1);
  expect(container.innerHTML).toEqual('<div>hi</div>');
  child.mockClear();

  // start closing
  // data is gone! this should trigger a close
  rerender(<App value={null} shouldAnimate />);

  const second: AnimateProvided = {
    // data is still provided to child for final render
    data,
    // still visible while animating
    animate: 'close',
    // $ExpectError - wrong type
    onClose: expect.any(Function),
  };
  expect(child).toHaveBeenCalledWith(second);

  // telling AnimateInOut that the animation is finished
  const provided: AnimateProvided = child.mock.calls[0][0];
  child.mockClear();
  // this will trigger a setState that will stop rendering the child
  provided.onClose();

  expect(container.innerHTML).toEqual('');
  expect(child).not.toHaveBeenCalled();
})",steel
/test/unit/state/scroll-viewport.spec.js,Conditional Test Logic,"{'line': 80, 'column': 2, 'index': 1764}","it('should correctly update scroll across multiple movements (forwards)', () => {
  const original: Rect = getRect({
    top: 0,
    left: 0,
    right: 100,
    bottom: 100,
  });

  const max: Position = { x: 200, y: 200 };

  let lastViewport: Viewport = {
    frame: original,
    scroll: {
      initial: origin,
      current: origin,
      max,
      diff: {
        value: origin,
        displacement: origin,
      },
    },
  };

  let lastScroll: Position = origin;
  let runCount: number = 0;

  while (lastScroll.y < max.y && lastScroll.x < max.x) {
    const newScroll: Position = add(lastScroll, { x: 10, y: 20 });
    const updated: Viewport = scrollViewport(lastViewport, newScroll);

    const expected: Viewport = {
      frame: getRect(offsetByPosition(original, newScroll)),
      scroll: {
        initial: origin,
        current: newScroll,
        max,
        diff: {
          value: newScroll,
          displacement: negate(newScroll),
        },
      },
    };
    expect(updated).toEqual(expected);
    expect(updated.frame.top).toEqual(newScroll.y);
    expect(updated.frame.left).toEqual(newScroll.x);

    lastScroll = newScroll;
    lastViewport = updated;
    runCount++;
  }

  // Simply asserting our loop ran a few times
  expect(runCount).toBeGreaterThan(2);
})",steel
/test/unit/state/scroll-viewport.spec.js,Conditional Test Logic,"{'line': 134, 'column': 2, 'index': 3061}","it('should correctly update scroll across multiple movements (backwards)', () => {
  const original: Rect = getRect({
    top: 0,
    left: 0,
    right: 100,
    bottom: 100,
  });

  const max: Position = { x: 200, y: 200 };

  let lastViewport: Viewport = {
    frame: original,
    scroll: {
      initial: max,
      current: max,
      max,
      diff: {
        value: origin,
        displacement: origin,
      },
    },
  };

  let lastScroll: Position = max;
  let runCount: number = 0;
  while (lastScroll.y > 0 && lastScroll.x > 0) {
    const newScroll: Position = subtract(lastScroll, { x: 10, y: 20 });
    const updated: Viewport = scrollViewport(lastViewport, newScroll);

    const diff: Position = subtract(newScroll, lastViewport.scroll.initial);

    const expected: Viewport = {
      frame: getRect(offsetByPosition(original, newScroll)),
      scroll: {
        initial: max,
        current: newScroll,
        max,
        diff: {
          value: diff,
          displacement: negate(diff),
        },
      },
    };
    expect(updated).toEqual(expected);
    expect(updated.frame.top).toEqual(newScroll.y);
    expect(updated.frame.left).toEqual(newScroll.x);

    lastScroll = newScroll;
    lastViewport = updated;
    runCount++;
  }

  // Simply asserting our loop ran a few times
  expect(runCount).toBeGreaterThan(2);
})",steel
/test/unit/state/scroll-viewport.spec.js,Magic Number,"{'line': 106, 'column': 35, 'index': 2552}","it('should correctly update scroll across multiple movements (forwards)', () => {
  const original: Rect = getRect({
    top: 0,
    left: 0,
    right: 100,
    bottom: 100,
  });

  const max: Position = { x: 200, y: 200 };

  let lastViewport: Viewport = {
    frame: original,
    scroll: {
      initial: origin,
      current: origin,
      max,
      diff: {
        value: origin,
        displacement: origin,
      },
    },
  };

  let lastScroll: Position = origin;
  let runCount: number = 0;

  while (lastScroll.y < max.y && lastScroll.x < max.x) {
    const newScroll: Position = add(lastScroll, { x: 10, y: 20 });
    const updated: Viewport = scrollViewport(lastViewport, newScroll);

    const expected: Viewport = {
      frame: getRect(offsetByPosition(original, newScroll)),
      scroll: {
        initial: origin,
        current: newScroll,
        max,
        diff: {
          value: newScroll,
          displacement: negate(newScroll),
        },
      },
    };
    expect(updated).toEqual(expected);
    expect(updated.frame.top).toEqual(newScroll.y);
    expect(updated.frame.left).toEqual(newScroll.x);

    lastScroll = newScroll;
    lastViewport = updated;
    runCount++;
  }

  // Simply asserting our loop ran a few times
  expect(runCount).toBeGreaterThan(2);
})",steel
/test/unit/state/scroll-viewport.spec.js,Magic Number,"{'line': 162, 'column': 35, 'index': 3911}","it('should correctly update scroll across multiple movements (backwards)', () => {
  const original: Rect = getRect({
    top: 0,
    left: 0,
    right: 100,
    bottom: 100,
  });

  const max: Position = { x: 200, y: 200 };

  let lastViewport: Viewport = {
    frame: original,
    scroll: {
      initial: max,
      current: max,
      max,
      diff: {
        value: origin,
        displacement: origin,
      },
    },
  };

  let lastScroll: Position = max;
  let runCount: number = 0;
  while (lastScroll.y > 0 && lastScroll.x > 0) {
    const newScroll: Position = subtract(lastScroll, { x: 10, y: 20 });
    const updated: Viewport = scrollViewport(lastViewport, newScroll);

    const diff: Position = subtract(newScroll, lastViewport.scroll.initial);

    const expected: Viewport = {
      frame: getRect(offsetByPosition(original, newScroll)),
      scroll: {
        initial: max,
        current: newScroll,
        max,
        diff: {
          value: diff,
          displacement: negate(diff),
        },
      },
    };
    expect(updated).toEqual(expected);
    expect(updated.frame.top).toEqual(newScroll.y);
    expect(updated.frame.left).toEqual(newScroll.x);

    lastScroll = newScroll;
    lastViewport = updated;
    runCount++;
  }

  // Simply asserting our loop ran a few times
  expect(runCount).toBeGreaterThan(2);
})",steel
/test/unit/state/recompute-placeholders.spec.js,Conditional Test Logic,"{'line': 19, 'column': 23, 'index': 747}",Unknown,steel
/test/unit/state/recompute-placeholders.spec.js,Duplicate Assert,"{'line': 93, 'column': 6, 'index': 3108}","it('should add a placeholder if moving to a foreign list', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome1.displaceBy,
      );
      const overForeign: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign1.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const first: DroppableDimensionMap = recomputePlaceholders({
        draggables: preset.draggables,
        droppables: preset.droppables,
        previousImpact: homeImpact,
        impact: overForeign,
        draggable: preset.inHome1,
      });

      expect(first).not.toEqual(preset.droppables);
      const withPlaceholder: DroppableDimension = addPlaceholder(
        preset.foreign,
        preset.inHome1,
        preset.draggables,
      );
      expect(first).toEqual(
        patchDroppableMap(preset.droppables, withPlaceholder),
      );

      const overForeign2: DragImpact = {
        displaced: getForcedDisplacement({
          // now moving forward (should not add another placeholder)
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      const second: DroppableDimensionMap = recomputePlaceholders({
        draggable: preset.inHome1,
        draggables: preset.draggables,
        droppables: preset.droppables,
        previousImpact: overForeign,
        impact: overForeign2,
      });

      expect(second).toEqual(first);
    })",steel
/test/unit/state/recompute-placeholders.spec.js,Duplicate Assert,"{'line': 99, 'column': 6, 'index': 3310}","it('should add a placeholder if moving to a foreign list', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome1.displaceBy,
      );
      const overForeign: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign1.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const first: DroppableDimensionMap = recomputePlaceholders({
        draggables: preset.draggables,
        droppables: preset.droppables,
        previousImpact: homeImpact,
        impact: overForeign,
        draggable: preset.inHome1,
      });

      expect(first).not.toEqual(preset.droppables);
      const withPlaceholder: DroppableDimension = addPlaceholder(
        preset.foreign,
        preset.inHome1,
        preset.draggables,
      );
      expect(first).toEqual(
        patchDroppableMap(preset.droppables, withPlaceholder),
      );

      const overForeign2: DragImpact = {
        displaced: getForcedDisplacement({
          // now moving forward (should not add another placeholder)
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      const second: DroppableDimensionMap = recomputePlaceholders({
        draggable: preset.inHome1,
        draggables: preset.draggables,
        droppables: preset.droppables,
        previousImpact: overForeign,
        impact: overForeign2,
      });

      expect(second).toEqual(first);
    })",steel
/test/unit/state/recompute-placeholders.spec.js,Eager Test,"{'line': 67, 'column': 19, 'index': 2361}","it('should add a placeholder if moving to a foreign list', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome1.displaceBy,
      );
      const overForeign: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign1.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const first: DroppableDimensionMap = recomputePlaceholders({
        draggables: preset.draggables,
        droppables: preset.droppables,
        previousImpact: homeImpact,
        impact: overForeign,
        draggable: preset.inHome1,
      });

      expect(first).not.toEqual(preset.droppables);
      const withPlaceholder: DroppableDimension = addPlaceholder(
        preset.foreign,
        preset.inHome1,
        preset.draggables,
      );
      expect(first).toEqual(
        patchDroppableMap(preset.droppables, withPlaceholder),
      );

      const overForeign2: DragImpact = {
        displaced: getForcedDisplacement({
          // now moving forward (should not add another placeholder)
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      const second: DroppableDimensionMap = recomputePlaceholders({
        draggable: preset.inHome1,
        draggables: preset.draggables,
        droppables: preset.droppables,
        previousImpact: overForeign,
        impact: overForeign2,
      });

      expect(second).toEqual(first);
    })",steel
/test/unit/state/recompute-placeholders.spec.js,Eager Test,"{'line': 104, 'column': 19, 'index': 3466}","it('should add a placeholder if moving to a foreign list', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome1.displaceBy,
      );
      const overForeign: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign1.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const first: DroppableDimensionMap = recomputePlaceholders({
        draggables: preset.draggables,
        droppables: preset.droppables,
        previousImpact: homeImpact,
        impact: overForeign,
        draggable: preset.inHome1,
      });

      expect(first).not.toEqual(preset.droppables);
      const withPlaceholder: DroppableDimension = addPlaceholder(
        preset.foreign,
        preset.inHome1,
        preset.draggables,
      );
      expect(first).toEqual(
        patchDroppableMap(preset.droppables, withPlaceholder),
      );

      const overForeign2: DragImpact = {
        displaced: getForcedDisplacement({
          // now moving forward (should not add another placeholder)
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      const second: DroppableDimensionMap = recomputePlaceholders({
        draggable: preset.inHome1,
        draggables: preset.draggables,
        droppables: preset.droppables,
        previousImpact: overForeign,
        impact: overForeign2,
      });

      expect(second).toEqual(first);
    })",steel
/test/unit/state/recompute-placeholders.spec.js,Lazy Test,"{'line': 67, 'column': 19, 'index': 2361}","it('should add a placeholder if moving to a foreign list', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome1.displaceBy,
      );
      const overForeign: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign1.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const first: DroppableDimensionMap = recomputePlaceholders({
        draggables: preset.draggables,
        droppables: preset.droppables,
        previousImpact: homeImpact,
        impact: overForeign,
        draggable: preset.inHome1,
      });

      expect(first).not.toEqual(preset.droppables);
      const withPlaceholder: DroppableDimension = addPlaceholder(
        preset.foreign,
        preset.inHome1,
        preset.draggables,
      );
      expect(first).toEqual(
        patchDroppableMap(preset.droppables, withPlaceholder),
      );

      const overForeign2: DragImpact = {
        displaced: getForcedDisplacement({
          // now moving forward (should not add another placeholder)
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      const second: DroppableDimensionMap = recomputePlaceholders({
        draggable: preset.inHome1,
        draggables: preset.draggables,
        droppables: preset.droppables,
        previousImpact: overForeign,
        impact: overForeign2,
      });

      expect(second).toEqual(first);
    })",steel
/test/unit/state/recompute-placeholders.spec.js,Lazy Test,"{'line': 139, 'column': 19, 'index': 4572}","it('should remove a placeholder if moving from a foreign list', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome1.displaceBy,
      );
      const overForeign: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign1.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      // has a placeholder when moving over foreign
      {
        const toForeign: DroppableDimensionMap = recomputePlaceholders({
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          impact: overForeign,
          draggable: preset.inHome1,
        });

        expect(toForeign).not.toEqual(preset.droppables);
        expect(
          toForeign[preset.foreign.descriptor.id].subject.withPlaceholder,
        ).toBeTruthy();
      }
      // no placeholder when moving back over home
      {
        const toHome: DroppableDimensionMap = recomputePlaceholders({
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: overForeign,
          impact: homeImpact,
          draggable: preset.inHome1,
        });

        expect(toHome).toEqual(preset.droppables);
      }

      // no placeholder when moving over nothing
      {
        const toNoWhere: DroppableDimensionMap = recomputePlaceholders({
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: overForeign,
          impact: noImpact,
          draggable: preset.inHome1,
        });

        expect(toNoWhere).toEqual(preset.droppables);
      }
    })",steel
/test/unit/state/position.spec.js,Magic Number,"{'line': 92, 'column': 39, 'index': 2466}","it('should return the distance between two positive values', () => {
        const a = { x: 0, y: 2 };
        const b = { x: 0, y: 5 };
        expect(distance(a, b)).toEqual(3);
      })",steel
/test/unit/state/position.spec.js,Magic Number,"{'line': 98, 'column': 39, 'index': 2665}","it('should return the distance between two negative values', () => {
        const a = { x: 0, y: -2 };
        const b = { x: 0, y: -5 };
        expect(distance(a, b)).toEqual(3);
      })",steel
/test/unit/state/position.spec.js,Magic Number,"{'line': 104, 'column': 39, 'index': 2873}","it('should return the distance between a positive and negative value', () => {
        const a = { x: 0, y: -2 };
        const b = { x: 0, y: 3 };
        expect(distance(a, b)).toEqual(5);
      })",steel
/test/unit/state/position.spec.js,Magic Number,"{'line': 113, 'column': 49, 'index': 3166}","it('should account for a shift in plane', () => {
        // a '3, 4, 5' triangle
        // https://www.mathsisfun.com/pythagoras.html
        const target = { x: 3, y: 4 };
        expect(distance(origin, target)).toEqual(5);
      })",steel
/test/unit/state/position.spec.js,Magic Number,"{'line': 120, 'column': 55, 'index': 3454}","it('should account for a negative shift in plane', () => {
        // a reverse '3, 4, 5' triangle shifted down to (-1, -1)
        const customOrigin = { x: -1, y: -1 };
        const target = { x: -4, y: -5 };
        expect(distance(customOrigin, target)).toEqual(5);
      })",steel
/test/unit/state/visibility/is-totally-visible-on-axis.spec.js,Conditional Test Logic,"{'line': 26, 'column': 23, 'index': 735}",Unknown,steel
/test/unit/state/update-displacement-visibility/speculative-displacement.spec.js,Conditional Test Logic,"{'line': 30, 'column': 23, 'index': 1083}",Unknown,steel
/test/unit/state/update-displacement-visibility/speculative-displacement.spec.js,Eager Test,"{'line': 253, 'column': 19, 'index': 8033}","it('should increase the visible displacement in the window by the amount of the max scroll change', () => {
      const foreign: DroppableDimension = getDroppableDimension({
        descriptor: {
          id: foreignId,
          type: 'huge',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          [axis.crossAxisStart]: foreignCrossAxisStart,
          [axis.crossAxisEnd]: foreignCrossAxisEnd,
          [axis.start]: 0,
          [axis.end]: 10000,
        },
      });
      // Viewport is big enough to fit inForeign1 and inForeign2
      const sizeOfViewport: number = itemSize + itemSize - 1;

      const viewport: Viewport = createViewport({
        frame: getRect({
          [axis.crossAxisStart]: 0,
          [axis.crossAxisEnd]: 10000,
          [axis.start]: 0,
          [axis.end]: sizeOfViewport,
        }),
        scroll: origin,
        // some massive number
        scrollHeight: 20000,
        scrollWidth: 20000,
      });
      // visiblity validation
      // in the foreign list, these should be visible
      expect(
        isPartiallyVisible({
          target: inForeign1.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      expect(
        isPartiallyVisible({
          target: inForeign2.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      // the rest should be invisible
      expect(
        isPartiallyVisible({
          target: inForeign3.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign4.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign5.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);

      // inHome1 has moved into the foreign list below inForeign1
      const displacedBy: DisplacedBy = getDisplacedBy(axis, inHome1.displaceBy);

      const previousImpact: DragImpact = {
        displaced: getForcedDisplacement({
          // would normally be visible in viewport
          visible: [{ dimension: inForeign2 }],
          // normally not visible in viewport
          invisible: [inForeign3, inForeign4, inForeign5],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: foreign.descriptor.id,
            index: inForeign2.descriptor.index,
          },
        },
      };

      const result: DragImpact = speculativelyIncrease({
        impact: previousImpact,
        viewport,
        destination: foreign,
        draggables,
        maxScrollChange: patch(axis.line, itemSize),
      });

      const expected: DragImpact = {
        // unchanged locations
        ...previousImpact,
        displaced: getForcedDisplacement({
          visible: [
            // already visibly displaced: inside viewport
            { dimension: inForeign2, shouldAnimate: true },
            // speculatively increased. Forced to not animate
            { dimension: inForeign3, shouldAnimate: false },
            { dimension: inForeign4, shouldAnimate: false },
          ],
          // Bigger than 2x the size of the viewport - outside of the overscanning reach
          invisible: [inForeign5],
        }),
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/update-displacement-visibility/speculative-displacement.spec.js,Eager Test,"{'line': 280, 'column': 19, 'index': 8825}","it('should increase the visible displacement in the window by the amount of the max scroll change', () => {
      const foreign: DroppableDimension = getDroppableDimension({
        descriptor: {
          id: foreignId,
          type: 'huge',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          [axis.crossAxisStart]: foreignCrossAxisStart,
          [axis.crossAxisEnd]: foreignCrossAxisEnd,
          [axis.start]: 0,
          [axis.end]: 10000,
        },
      });
      // Viewport is big enough to fit inForeign1 and inForeign2
      const sizeOfViewport: number = itemSize + itemSize - 1;

      const viewport: Viewport = createViewport({
        frame: getRect({
          [axis.crossAxisStart]: 0,
          [axis.crossAxisEnd]: 10000,
          [axis.start]: 0,
          [axis.end]: sizeOfViewport,
        }),
        scroll: origin,
        // some massive number
        scrollHeight: 20000,
        scrollWidth: 20000,
      });
      // visiblity validation
      // in the foreign list, these should be visible
      expect(
        isPartiallyVisible({
          target: inForeign1.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      expect(
        isPartiallyVisible({
          target: inForeign2.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      // the rest should be invisible
      expect(
        isPartiallyVisible({
          target: inForeign3.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign4.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign5.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);

      // inHome1 has moved into the foreign list below inForeign1
      const displacedBy: DisplacedBy = getDisplacedBy(axis, inHome1.displaceBy);

      const previousImpact: DragImpact = {
        displaced: getForcedDisplacement({
          // would normally be visible in viewport
          visible: [{ dimension: inForeign2 }],
          // normally not visible in viewport
          invisible: [inForeign3, inForeign4, inForeign5],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: foreign.descriptor.id,
            index: inForeign2.descriptor.index,
          },
        },
      };

      const result: DragImpact = speculativelyIncrease({
        impact: previousImpact,
        viewport,
        destination: foreign,
        draggables,
        maxScrollChange: patch(axis.line, itemSize),
      });

      const expected: DragImpact = {
        // unchanged locations
        ...previousImpact,
        displaced: getForcedDisplacement({
          visible: [
            // already visibly displaced: inside viewport
            { dimension: inForeign2, shouldAnimate: true },
            // speculatively increased. Forced to not animate
            { dimension: inForeign3, shouldAnimate: false },
            { dimension: inForeign4, shouldAnimate: false },
          ],
          // Bigger than 2x the size of the viewport - outside of the overscanning reach
          invisible: [inForeign5],
        }),
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/update-displacement-visibility/speculative-displacement.spec.js,Eager Test,"{'line': 390, 'column': 19, 'index': 12452}","it('should increase the visible displacement in the droppable by the amount of the max scroll change', () => {
      // when moving into the foreign list there will be enough room for inHome1 and inForeign1
      // inHome1 and inForeign1 can be visible in the viewport at the same time
      const sizeOfDroppable: number = itemSize + itemSize - 1;

      const foreign: DroppableDimension = getDroppableDimension({
        descriptor: {
          id: foreignId,
          type: 'huge',
          mode: 'standard',
        },
        direction: axis.direction,
        // large subject
        borderBox: {
          [axis.crossAxisStart]: foreignCrossAxisStart,
          [axis.crossAxisEnd]: foreignCrossAxisEnd,
          [axis.start]: 0,
          [axis.end]: 10000,
        },
        // small frame (will clip subject)
        closest: {
          borderBox: {
            [axis.crossAxisStart]: foreignCrossAxisStart,
            [axis.crossAxisEnd]: foreignCrossAxisEnd,
            [axis.start]: 0,
            [axis.end]: sizeOfDroppable,
          },
          shouldClipSubject: true,
          scroll: origin,
          scrollSize: {
            scrollHeight: 10000,
            scrollWidth: 10000,
          },
        },
      });
      // huge viewport
      const viewport: Viewport = createViewport({
        frame: getRect({
          [axis.crossAxisStart]: 0,
          [axis.crossAxisEnd]: 10000,
          [axis.start]: 0,
          [axis.end]: 10000,
        }),
        scroll: origin,
        scrollHeight: 10000,
        scrollWidth: 10000,
      });
      // visiblity validation
      // in the foreign list, these should be visible
      expect(
        isPartiallyVisible({
          target: inForeign1.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      expect(
        isPartiallyVisible({
          target: inForeign2.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      // the rest should be invisible
      expect(
        isPartiallyVisible({
          target: inForeign3.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign4.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign5.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);

      // inHome1 has moved into the foreign list below inForeign1
      const displacedBy: DisplacedBy = getDisplacedBy(axis, inHome1.displaceBy);

      const previousImpact: DragImpact = {
        displaced: getForcedDisplacement({
          // would normally be visible in viewport
          visible: [{ dimension: inForeign2 }],
          // normally not visible in viewport
          invisible: [inForeign3, inForeign4, inForeign5],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: foreign.descriptor.id,
            index: inForeign2.descriptor.index,
          },
        },
      };

      const result: DragImpact = speculativelyIncrease({
        impact: previousImpact,
        viewport,
        destination: foreign,
        draggables,
        maxScrollChange: patch(axis.line, itemSize),
      });

      const expected: DragImpact = {
        // unchanged locations
        ...previousImpact,
        displaced: getForcedDisplacement({
          visible: [
            // already visibly displaced
            { dimension: inForeign2, shouldAnimate: true },
            // speculatively increased. Forced to not animate
            { dimension: inForeign3, shouldAnimate: false },
            { dimension: inForeign4, shouldAnimate: false },
          ],
          // not speculatively increased
          invisible: [inForeign5],
        }),
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/update-displacement-visibility/speculative-displacement.spec.js,Eager Test,"{'line': 417, 'column': 19, 'index': 13244}","it('should increase the visible displacement in the droppable by the amount of the max scroll change', () => {
      // when moving into the foreign list there will be enough room for inHome1 and inForeign1
      // inHome1 and inForeign1 can be visible in the viewport at the same time
      const sizeOfDroppable: number = itemSize + itemSize - 1;

      const foreign: DroppableDimension = getDroppableDimension({
        descriptor: {
          id: foreignId,
          type: 'huge',
          mode: 'standard',
        },
        direction: axis.direction,
        // large subject
        borderBox: {
          [axis.crossAxisStart]: foreignCrossAxisStart,
          [axis.crossAxisEnd]: foreignCrossAxisEnd,
          [axis.start]: 0,
          [axis.end]: 10000,
        },
        // small frame (will clip subject)
        closest: {
          borderBox: {
            [axis.crossAxisStart]: foreignCrossAxisStart,
            [axis.crossAxisEnd]: foreignCrossAxisEnd,
            [axis.start]: 0,
            [axis.end]: sizeOfDroppable,
          },
          shouldClipSubject: true,
          scroll: origin,
          scrollSize: {
            scrollHeight: 10000,
            scrollWidth: 10000,
          },
        },
      });
      // huge viewport
      const viewport: Viewport = createViewport({
        frame: getRect({
          [axis.crossAxisStart]: 0,
          [axis.crossAxisEnd]: 10000,
          [axis.start]: 0,
          [axis.end]: 10000,
        }),
        scroll: origin,
        scrollHeight: 10000,
        scrollWidth: 10000,
      });
      // visiblity validation
      // in the foreign list, these should be visible
      expect(
        isPartiallyVisible({
          target: inForeign1.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      expect(
        isPartiallyVisible({
          target: inForeign2.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      // the rest should be invisible
      expect(
        isPartiallyVisible({
          target: inForeign3.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign4.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign5.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);

      // inHome1 has moved into the foreign list below inForeign1
      const displacedBy: DisplacedBy = getDisplacedBy(axis, inHome1.displaceBy);

      const previousImpact: DragImpact = {
        displaced: getForcedDisplacement({
          // would normally be visible in viewport
          visible: [{ dimension: inForeign2 }],
          // normally not visible in viewport
          invisible: [inForeign3, inForeign4, inForeign5],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: foreign.descriptor.id,
            index: inForeign2.descriptor.index,
          },
        },
      };

      const result: DragImpact = speculativelyIncrease({
        impact: previousImpact,
        viewport,
        destination: foreign,
        draggables,
        maxScrollChange: patch(axis.line, itemSize),
      });

      const expected: DragImpact = {
        // unchanged locations
        ...previousImpact,
        displaced: getForcedDisplacement({
          visible: [
            // already visibly displaced
            { dimension: inForeign2, shouldAnimate: true },
            // speculatively increased. Forced to not animate
            { dimension: inForeign3, shouldAnimate: false },
            { dimension: inForeign4, shouldAnimate: false },
          ],
          // not speculatively increased
          invisible: [inForeign5],
        }),
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/update-displacement-visibility/speculative-displacement.spec.js,Lazy Test,"{'line': 253, 'column': 19, 'index': 8033}","it('should increase the visible displacement in the window by the amount of the max scroll change', () => {
      const foreign: DroppableDimension = getDroppableDimension({
        descriptor: {
          id: foreignId,
          type: 'huge',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          [axis.crossAxisStart]: foreignCrossAxisStart,
          [axis.crossAxisEnd]: foreignCrossAxisEnd,
          [axis.start]: 0,
          [axis.end]: 10000,
        },
      });
      // Viewport is big enough to fit inForeign1 and inForeign2
      const sizeOfViewport: number = itemSize + itemSize - 1;

      const viewport: Viewport = createViewport({
        frame: getRect({
          [axis.crossAxisStart]: 0,
          [axis.crossAxisEnd]: 10000,
          [axis.start]: 0,
          [axis.end]: sizeOfViewport,
        }),
        scroll: origin,
        // some massive number
        scrollHeight: 20000,
        scrollWidth: 20000,
      });
      // visiblity validation
      // in the foreign list, these should be visible
      expect(
        isPartiallyVisible({
          target: inForeign1.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      expect(
        isPartiallyVisible({
          target: inForeign2.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      // the rest should be invisible
      expect(
        isPartiallyVisible({
          target: inForeign3.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign4.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign5.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);

      // inHome1 has moved into the foreign list below inForeign1
      const displacedBy: DisplacedBy = getDisplacedBy(axis, inHome1.displaceBy);

      const previousImpact: DragImpact = {
        displaced: getForcedDisplacement({
          // would normally be visible in viewport
          visible: [{ dimension: inForeign2 }],
          // normally not visible in viewport
          invisible: [inForeign3, inForeign4, inForeign5],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: foreign.descriptor.id,
            index: inForeign2.descriptor.index,
          },
        },
      };

      const result: DragImpact = speculativelyIncrease({
        impact: previousImpact,
        viewport,
        destination: foreign,
        draggables,
        maxScrollChange: patch(axis.line, itemSize),
      });

      const expected: DragImpact = {
        // unchanged locations
        ...previousImpact,
        displaced: getForcedDisplacement({
          visible: [
            // already visibly displaced: inside viewport
            { dimension: inForeign2, shouldAnimate: true },
            // speculatively increased. Forced to not animate
            { dimension: inForeign3, shouldAnimate: false },
            { dimension: inForeign4, shouldAnimate: false },
          ],
          // Bigger than 2x the size of the viewport - outside of the overscanning reach
          invisible: [inForeign5],
        }),
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/update-displacement-visibility/speculative-displacement.spec.js,Lazy Test,"{'line': 390, 'column': 19, 'index': 12452}","it('should increase the visible displacement in the droppable by the amount of the max scroll change', () => {
      // when moving into the foreign list there will be enough room for inHome1 and inForeign1
      // inHome1 and inForeign1 can be visible in the viewport at the same time
      const sizeOfDroppable: number = itemSize + itemSize - 1;

      const foreign: DroppableDimension = getDroppableDimension({
        descriptor: {
          id: foreignId,
          type: 'huge',
          mode: 'standard',
        },
        direction: axis.direction,
        // large subject
        borderBox: {
          [axis.crossAxisStart]: foreignCrossAxisStart,
          [axis.crossAxisEnd]: foreignCrossAxisEnd,
          [axis.start]: 0,
          [axis.end]: 10000,
        },
        // small frame (will clip subject)
        closest: {
          borderBox: {
            [axis.crossAxisStart]: foreignCrossAxisStart,
            [axis.crossAxisEnd]: foreignCrossAxisEnd,
            [axis.start]: 0,
            [axis.end]: sizeOfDroppable,
          },
          shouldClipSubject: true,
          scroll: origin,
          scrollSize: {
            scrollHeight: 10000,
            scrollWidth: 10000,
          },
        },
      });
      // huge viewport
      const viewport: Viewport = createViewport({
        frame: getRect({
          [axis.crossAxisStart]: 0,
          [axis.crossAxisEnd]: 10000,
          [axis.start]: 0,
          [axis.end]: 10000,
        }),
        scroll: origin,
        scrollHeight: 10000,
        scrollWidth: 10000,
      });
      // visiblity validation
      // in the foreign list, these should be visible
      expect(
        isPartiallyVisible({
          target: inForeign1.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      expect(
        isPartiallyVisible({
          target: inForeign2.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(true);
      // the rest should be invisible
      expect(
        isPartiallyVisible({
          target: inForeign3.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign4.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);
      expect(
        isPartiallyVisible({
          target: inForeign5.page.borderBox,
          destination: foreign,
          viewport: viewport.frame,
          withDroppableDisplacement: true,
        }),
      ).toBe(false);

      // inHome1 has moved into the foreign list below inForeign1
      const displacedBy: DisplacedBy = getDisplacedBy(axis, inHome1.displaceBy);

      const previousImpact: DragImpact = {
        displaced: getForcedDisplacement({
          // would normally be visible in viewport
          visible: [{ dimension: inForeign2 }],
          // normally not visible in viewport
          invisible: [inForeign3, inForeign4, inForeign5],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: foreign.descriptor.id,
            index: inForeign2.descriptor.index,
          },
        },
      };

      const result: DragImpact = speculativelyIncrease({
        impact: previousImpact,
        viewport,
        destination: foreign,
        draggables,
        maxScrollChange: patch(axis.line, itemSize),
      });

      const expected: DragImpact = {
        // unchanged locations
        ...previousImpact,
        displaced: getForcedDisplacement({
          visible: [
            // already visibly displaced
            { dimension: inForeign2, shouldAnimate: true },
            // speculatively increased. Forced to not animate
            { dimension: inForeign3, shouldAnimate: false },
            { dimension: inForeign4, shouldAnimate: false },
          ],
          // not speculatively increased
          invisible: [inForeign5],
        }),
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/update-displacement-visibility/recompute.spec.js,Conditional Test Logic,"{'line': 9, 'column': 23, 'index': 448}",Unknown,steel
/test/unit/state/update-displacement-visibility/recompute.spec.js,Lazy Test,"{'line': 42, 'column': 19, 'index': 1422}","it('should recompute a displacement', () => {
      const recomputed: DragImpact = recompute({
        impact,
        viewport: preset.viewport,
        destination: preset.home,
        draggables: preset.draggables,
      });

      const expected: DragImpact = {
        ...impact,
        displaced: getForcedDisplacement({
          // visibility recalculated
          visible: [
            // not animated as previously invisible
            { dimension: preset.inHome2, shouldAnimate: false },
            { dimension: preset.inHome3, shouldAnimate: false },
          ],
        }),
      };
      expect(recomputed).toEqual(expected);
    })",steel
/test/unit/state/update-displacement-visibility/recompute.spec.js,Lazy Test,"{'line': 65, 'column': 19, 'index': 2137}","it('should allow the displacement animation to be forced', () => {
      const recomputed: DragImpact = recompute({
        impact,
        viewport: preset.viewport,
        destination: preset.home,
        draggables: preset.draggables,
        forceShouldAnimate: true,
      });

      const expected: DragImpact = {
        ...impact,
        displaced: getForcedDisplacement({
          // visibility recalculated
          visible: [
            // forced animation
            { dimension: preset.inHome2, shouldAnimate: true },
            { dimension: preset.inHome3, shouldAnimate: true },
          ],
        }),
      };
      expect(recomputed).toEqual(expected);
    })",steel
/test/unit/state/registry/use-registry.spec.js,Duplicate Assert,"{'line': 33, 'column': 2, 'index': 948}","it('should remove any registrations', () => {
  let registry: Registry;
  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const id: DraggableId = preset.inHome1.descriptor.id;
  function App() {
    registry = useRegistry();
    return null;
  }

  const { unmount } = render(<App />);
  invariant(registry);

  // initial registration
  registry.draggable.register(entry);
  expect(registry.draggable.exists(id)).toBe(true);

  // still available after a unmount
  unmount();
  expect(registry.draggable.exists(id)).toBe(true);

  // cleared after frame
  requestAnimationFrame.step();
  expect(registry.draggable.exists(id)).toBe(false);
})",steel
/test/unit/state/registry/use-registry.spec.js,Duplicate Assert,"{'line': 33, 'column': 2, 'index': 948}","it('should remove any registrations', () => {
  let registry: Registry;
  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const id: DraggableId = preset.inHome1.descriptor.id;
  function App() {
    registry = useRegistry();
    return null;
  }

  const { unmount } = render(<App />);
  invariant(registry);

  // initial registration
  registry.draggable.register(entry);
  expect(registry.draggable.exists(id)).toBe(true);

  // still available after a unmount
  unmount();
  expect(registry.draggable.exists(id)).toBe(true);

  // cleared after frame
  requestAnimationFrame.step();
  expect(registry.draggable.exists(id)).toBe(false);
})",steel
/test/unit/state/registry/use-registry.spec.js,Duplicate Assert,"{'line': 37, 'column': 2, 'index': 1051}","it('should remove any registrations', () => {
  let registry: Registry;
  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const id: DraggableId = preset.inHome1.descriptor.id;
  function App() {
    registry = useRegistry();
    return null;
  }

  const { unmount } = render(<App />);
  invariant(registry);

  // initial registration
  registry.draggable.register(entry);
  expect(registry.draggable.exists(id)).toBe(true);

  // still available after a unmount
  unmount();
  expect(registry.draggable.exists(id)).toBe(true);

  // cleared after frame
  requestAnimationFrame.step();
  expect(registry.draggable.exists(id)).toBe(false);
})",steel
/test/unit/state/registry/use-registry.spec.js,Duplicate Assert,"{'line': 37, 'column': 2, 'index': 1051}","it('should remove any registrations', () => {
  let registry: Registry;
  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const id: DraggableId = preset.inHome1.descriptor.id;
  function App() {
    registry = useRegistry();
    return null;
  }

  const { unmount } = render(<App />);
  invariant(registry);

  // initial registration
  registry.draggable.register(entry);
  expect(registry.draggable.exists(id)).toBe(true);

  // still available after a unmount
  unmount();
  expect(registry.draggable.exists(id)).toBe(true);

  // cleared after frame
  requestAnimationFrame.step();
  expect(registry.draggable.exists(id)).toBe(false);
})",steel
/test/unit/state/registry/use-registry.spec.js,Duplicate Assert,"{'line': 41, 'column': 2, 'index': 1161}","it('should remove any registrations', () => {
  let registry: Registry;
  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const id: DraggableId = preset.inHome1.descriptor.id;
  function App() {
    registry = useRegistry();
    return null;
  }

  const { unmount } = render(<App />);
  invariant(registry);

  // initial registration
  registry.draggable.register(entry);
  expect(registry.draggable.exists(id)).toBe(true);

  // still available after a unmount
  unmount();
  expect(registry.draggable.exists(id)).toBe(true);

  // cleared after frame
  requestAnimationFrame.step();
  expect(registry.draggable.exists(id)).toBe(false);
})",steel
/test/unit/state/registry/use-registry.spec.js,Eager Test,"{'line': 18, 'column': 32, 'index': 616}","it('should remove any registrations', () => {
  let registry: Registry;
  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const id: DraggableId = preset.inHome1.descriptor.id;
  function App() {
    registry = useRegistry();
    return null;
  }

  const { unmount } = render(<App />);
  invariant(registry);

  // initial registration
  registry.draggable.register(entry);
  expect(registry.draggable.exists(id)).toBe(true);

  // still available after a unmount
  unmount();
  expect(registry.draggable.exists(id)).toBe(true);

  // cleared after frame
  requestAnimationFrame.step();
  expect(registry.draggable.exists(id)).toBe(false);
})",steel
/test/unit/state/registry/use-registry.spec.js,Eager Test,"{'line': 29, 'column': 2, 'index': 860}","it('should remove any registrations', () => {
  let registry: Registry;
  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const id: DraggableId = preset.inHome1.descriptor.id;
  function App() {
    registry = useRegistry();
    return null;
  }

  const { unmount } = render(<App />);
  invariant(registry);

  // initial registration
  registry.draggable.register(entry);
  expect(registry.draggable.exists(id)).toBe(true);

  // still available after a unmount
  unmount();
  expect(registry.draggable.exists(id)).toBe(true);

  // cleared after frame
  requestAnimationFrame.step();
  expect(registry.draggable.exists(id)).toBe(false);
})",steel
/test/unit/state/registry/queries.spec.js,Conditional Test Logic,"{'line': 35, 'column': 36, 'index': 992}","describe('draggable', () => {
  const registry: Registry = createRegistry();
  const inHome1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const inHome2: DraggableEntry = getDraggableEntry({
    uniqueId: '2',
    dimension: preset.inHome2,
  });
  const ofAnotherType: DraggableEntry = getDraggableEntry({
    uniqueId: '3',
    dimension: {
      ...preset.inHome3,
      descriptor: {
        id: 'of another type',
        type: 'some other type',
        index: 1,
        droppableId: 'some other droppable id',
      },
    },
  });
  [inHome1, inHome2, ofAnotherType].forEach((entry: DraggableEntry) => {
    registry.draggable.register(entry);
  });

  describe('getById', () => {
    it('should return an item', () => {
      expect(registry.draggable.getById(preset.inHome1.descriptor.id)).toBe(
        inHome1,
      );
    });
    it('should throw if no item exists', () => {
      expect(() => registry.draggable.getById('some unknown id')).toThrow();
    });
  });
  describe('findById', () => {
    it('should return an item if it exists', () => {
      expect(registry.draggable.findById(preset.inHome1.descriptor.id)).toBe(
        inHome1,
      );
    });
    it('should return null if an item does not exist', () => {
      expect(registry.draggable.findById('unknown id')).toBe(null);
    });
  });
  describe('exists', () => {
    it('should return true if an item exists', () => {
      expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(
        true,
      );
    });
    it('should return null if an item does not exist', () => {
      expect(registry.draggable.exists('unknown id')).toBe(false);
    });
  });
  describe('getAllByType', () => {
    it('should only return items of the correct type', () => {
      expect(
        registry.draggable.getAllByType(preset.inHome1.descriptor.type),
      ).toEqual([inHome1, inHome2]);
    });
  });
})",steel
/test/unit/state/registry/queries.spec.js,Conditional Test Logic,"{'line': 99, 'column': 33, 'index': 2891}","describe('droppable', () => {
  const registry: Registry = createRegistry();
  const home: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });
  const foreign: DroppableEntry = getDroppableEntry({
    uniqueId: '2',
    dimension: preset.foreign,
  });
  const ofAnotherType: DroppableEntry = getDroppableEntry({
    uniqueId: '3',
    dimension: {
      ...preset.foreign,
      descriptor: {
        id: 'of another type',
        type: 'some other type',
        mode: 'standard',
      },
    },
  });
  [home, foreign, ofAnotherType].forEach((entry: DroppableEntry) => {
    registry.droppable.register(entry);
  });

  describe('getById', () => {
    it('should return an item', () => {
      expect(registry.droppable.getById(preset.home.descriptor.id)).toBe(home);
    });
    it('should throw if no item exists', () => {
      expect(() => registry.droppable.getById('some unknown id')).toThrow();
    });
  });
  describe('findById', () => {
    it('should return an item if it exists', () => {
      expect(registry.droppable.findById(preset.home.descriptor.id)).toBe(home);
    });
    it('should return null if an item does not exist', () => {
      expect(registry.droppable.findById('unknown id')).toBe(null);
    });
  });
  describe('exists', () => {
    it('should return true if an item exists', () => {
      expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(true);
    });
    it('should return null if an item does not exist', () => {
      expect(registry.droppable.exists('unknown id')).toBe(false);
    });
  });
  describe('getAllByType', () => {
    it('should only return items of the correct type', () => {
      expect(
        registry.droppable.getAllByType(preset.home.descriptor.type),
      ).toEqual([home, foreign]);
    });
  });
})",steel
/test/unit/state/registry/event-listeners.spec.js,Lazy Test,"{'line': 20, 'column': 32, 'index': 588}","it('should allow adding event listeners', () => {
  const listener1 = jest.fn();
  const listener2 = jest.fn();
  const registry: Registry = createRegistry();

  registry.subscribe(listener1);
  registry.subscribe(listener2);

  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  registry.draggable.register(entry);

  expect(listener1).toHaveBeenCalledWith({ type: 'ADDITION', value: entry });
  expect(listener2).toHaveBeenCalledWith({ type: 'ADDITION', value: entry });
})",steel
/test/unit/state/registry/event-listeners.spec.js,Lazy Test,"{'line': 40, 'column': 32, 'index': 1169}","it('should allow removing event listeners', () => {
  const toBeRemoved = jest.fn();
  const persistent = jest.fn();
  const registry: Registry = createRegistry();

  const unsubscribe = registry.subscribe(toBeRemoved);
  registry.subscribe(persistent);

  unsubscribe();

  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  registry.draggable.register(entry);

  expect(toBeRemoved).not.toHaveBeenCalled();
  expect(persistent).toHaveBeenCalledWith({ type: 'ADDITION', value: entry });
})",steel
/test/unit/state/registry/event-listeners.spec.js,Lazy Test,"{'line': 62, 'column': 32, 'index': 1756}","it('should not error on a double unsubscribe', () => {
  const toBeRemoved = jest.fn();
  const persistent = jest.fn();
  const registry: Registry = createRegistry();

  const unsubscribe = registry.subscribe(toBeRemoved);
  registry.subscribe(persistent);

  unsubscribe();
  unsubscribe();
  unsubscribe();

  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  registry.draggable.register(entry);

  // not called
  expect(toBeRemoved).not.toHaveBeenCalled();
  // unaffected
  expect(persistent).toHaveBeenCalledWith({ type: 'ADDITION', value: entry });
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Duplicate Assert,"{'line': 71, 'column': 2, 'index': 1952}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });
  const entry2: DroppableEntry = getDroppableEntry({
    uniqueId: '2',
    dimension: preset.home,
  });

  registry.droppable.register(entry1);
  // will overwrite with an updated uniqueId
  registry.droppable.register(entry2);

  // overwritten entry1
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry1 is now outdated, so entry2 won't be removed
  registry.droppable.unregister(entry1);
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Duplicate Assert,"{'line': 71, 'column': 2, 'index': 1952}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });
  const entry2: DroppableEntry = getDroppableEntry({
    uniqueId: '2',
    dimension: preset.home,
  });

  registry.droppable.register(entry1);
  // will overwrite with an updated uniqueId
  registry.droppable.register(entry2);

  // overwritten entry1
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry1 is now outdated, so entry2 won't be removed
  registry.droppable.unregister(entry1);
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Duplicate Assert,"{'line': 75, 'column': 2, 'index': 2124}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });
  const entry2: DroppableEntry = getDroppableEntry({
    uniqueId: '2',
    dimension: preset.home,
  });

  registry.droppable.register(entry1);
  // will overwrite with an updated uniqueId
  registry.droppable.register(entry2);

  // overwritten entry1
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry1 is now outdated, so entry2 won't be removed
  registry.droppable.unregister(entry1);
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Duplicate Assert,"{'line': 75, 'column': 2, 'index': 2124}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });
  const entry2: DroppableEntry = getDroppableEntry({
    uniqueId: '2',
    dimension: preset.home,
  });

  registry.droppable.register(entry1);
  // will overwrite with an updated uniqueId
  registry.droppable.register(entry2);

  // overwritten entry1
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry1 is now outdated, so entry2 won't be removed
  registry.droppable.unregister(entry1);
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Eager Test,"{'line': 39, 'column': 33, 'index': 1117}","it('should allow for entry overwriting', () => {
  const registry: Registry = createRegistry();
  const entry1: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });
  const entry2: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });

  registry.droppable.register(entry1);
  registry.droppable.register(entry2);

  // overwritten entry 2
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Eager Test,"{'line': 43, 'column': 33, 'index': 1223}","it('should allow for entry overwriting', () => {
  const registry: Registry = createRegistry();
  const entry1: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });
  const entry2: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });

  registry.droppable.register(entry1);
  registry.droppable.register(entry2);

  // overwritten entry 2
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Eager Test,"{'line': 57, 'column': 33, 'index': 1622}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });
  const entry2: DroppableEntry = getDroppableEntry({
    uniqueId: '2',
    dimension: preset.home,
  });

  registry.droppable.register(entry1);
  // will overwrite with an updated uniqueId
  registry.droppable.register(entry2);

  // overwritten entry1
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry1 is now outdated, so entry2 won't be removed
  registry.droppable.unregister(entry1);
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Eager Test,"{'line': 61, 'column': 33, 'index': 1728}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });
  const entry2: DroppableEntry = getDroppableEntry({
    uniqueId: '2',
    dimension: preset.home,
  });

  registry.droppable.register(entry1);
  // will overwrite with an updated uniqueId
  registry.droppable.register(entry2);

  // overwritten entry1
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry1 is now outdated, so entry2 won't be removed
  registry.droppable.unregister(entry1);
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Lazy Test,"{'line': 14, 'column': 32, 'index': 448}","it('should allow registration', () => {
  const registry: Registry = createRegistry();
  const entry: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });

  registry.droppable.register(entry);

  expect(registry.droppable.findById(entry.descriptor.id)).toBe(entry);
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Lazy Test,"{'line': 26, 'column': 32, 'index': 759}","it('should allow unregistration', () => {
  const registry: Registry = createRegistry();
  const entry: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });

  registry.droppable.register(entry);
  registry.droppable.unregister(entry);

  expect(registry.droppable.findById(entry.descriptor.id)).toBe(null);
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Lazy Test,"{'line': 39, 'column': 33, 'index': 1117}","it('should allow for entry overwriting', () => {
  const registry: Registry = createRegistry();
  const entry1: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });
  const entry2: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });

  registry.droppable.register(entry1);
  registry.droppable.register(entry2);

  // overwritten entry 2
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Lazy Test,"{'line': 57, 'column': 33, 'index': 1622}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });
  const entry2: DroppableEntry = getDroppableEntry({
    uniqueId: '2',
    dimension: preset.home,
  });

  registry.droppable.register(entry1);
  // will overwrite with an updated uniqueId
  registry.droppable.register(entry2);

  // overwritten entry1
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry1 is now outdated, so entry2 won't be removed
  registry.droppable.unregister(entry1);
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/droppable-registration.spec.js,Lazy Test,"{'line': 80, 'column': 33, 'index': 2347}","it('should allow unregistrations when there is no entry', () => {
  const registry: Registry = createRegistry();
  const entry1: DroppableEntry = getDroppableEntry({
    uniqueId: '1',
    dimension: preset.home,
  });

  // no registration
  expect(registry.droppable.findById(entry1.descriptor.id)).toBe(null);

  expect(() => {
    registry.droppable.unregister(entry1);
  }).not.toThrow();
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Duplicate Assert,"{'line': 120, 'column': 2, 'index': 3303}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const entry2: DraggableEntry = getDraggableEntry({
    uniqueId: '2',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry1);
  registry.draggable.register(entry2);

  // overwritten entry 1

  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry 1 is now outdated, so this won't be removed
  registry.draggable.unregister(entry1);
  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Duplicate Assert,"{'line': 120, 'column': 2, 'index': 3303}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const entry2: DraggableEntry = getDraggableEntry({
    uniqueId: '2',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry1);
  registry.draggable.register(entry2);

  // overwritten entry 1

  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry 1 is now outdated, so this won't be removed
  registry.draggable.unregister(entry1);
  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Duplicate Assert,"{'line': 124, 'column': 2, 'index': 3474}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const entry2: DraggableEntry = getDraggableEntry({
    uniqueId: '2',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry1);
  registry.draggable.register(entry2);

  // overwritten entry 1

  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry 1 is now outdated, so this won't be removed
  registry.draggable.unregister(entry1);
  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Duplicate Assert,"{'line': 124, 'column': 2, 'index': 3474}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const entry2: DraggableEntry = getDraggableEntry({
    uniqueId: '2',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry1);
  registry.draggable.register(entry2);

  // overwritten entry 1

  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry 1 is now outdated, so this won't be removed
  registry.draggable.unregister(entry1);
  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Eager Test,"{'line': 88, 'column': 33, 'index': 2499}","it('should allow for entry overwriting', () => {
  const registry: Registry = createRegistry();
  const entry1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const entry2: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry1);
  registry.draggable.register(entry2);

  // overwritten entry 2
  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Eager Test,"{'line': 92, 'column': 33, 'index': 2608}","it('should allow for entry overwriting', () => {
  const registry: Registry = createRegistry();
  const entry1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const entry2: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry1);
  registry.draggable.register(entry2);

  // overwritten entry 2
  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Eager Test,"{'line': 106, 'column': 33, 'index': 3010}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const entry2: DraggableEntry = getDraggableEntry({
    uniqueId: '2',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry1);
  registry.draggable.register(entry2);

  // overwritten entry 1

  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry 1 is now outdated, so this won't be removed
  registry.draggable.unregister(entry1);
  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Eager Test,"{'line': 110, 'column': 33, 'index': 3119}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const entry2: DraggableEntry = getDraggableEntry({
    uniqueId: '2',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry1);
  registry.draggable.register(entry2);

  // overwritten entry 1

  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry 1 is now outdated, so this won't be removed
  registry.draggable.unregister(entry1);
  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Lazy Test,"{'line': 14, 'column': 32, 'index': 448}","it('should allow registration', () => {
  const registry: Registry = createRegistry();
  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry);

  expect(registry.draggable.findById(entry.descriptor.id)).toBe(entry);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Lazy Test,"{'line': 26, 'column': 32, 'index': 762}","it('should allow unregistration', () => {
  const registry: Registry = createRegistry();
  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry);
  registry.draggable.unregister(entry);

  expect(registry.draggable.findById(entry.descriptor.id)).toBe(null);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Lazy Test,"{'line': 39, 'column': 34, 'index': 1132}","it('should allow for updating existing entries', () => {
  const registry: Registry = createRegistry();
  const initial: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const updated: DraggableEntry = {
    uniqueId: initial.uniqueId,
    descriptor: preset.inHome1.descriptor,
    options: {
      canDragInteractiveElements: true,
      // updated
      shouldRespectForcePress: true,
      isEnabled: true,
    },
    getDimension: () => preset.inHome1,
  };

  registry.draggable.register(initial);
  registry.draggable.update(updated, initial);

  expect(registry.draggable.findById(updated.descriptor.id)).toBe(updated);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Lazy Test,"{'line': 63, 'column': 34, 'index': 1822}","it('should throw away updates if the uniqueId is outdated', () => {
  const registry: Registry = createRegistry();
  const initial: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const updated: DraggableEntry = {
    // new uniqueId
    uniqueId: '2',
    descriptor: preset.inHome1.descriptor,
    options: {
      canDragInteractiveElements: true,
      // updated
      shouldRespectForcePress: true,
      isEnabled: true,
    },
    getDimension: () => preset.inHome1,
  };

  registry.draggable.register(initial);
  registry.draggable.update(updated, initial);

  expect(registry.draggable.findById(updated.descriptor.id)).toBe(initial);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Lazy Test,"{'line': 88, 'column': 33, 'index': 2499}","it('should allow for entry overwriting', () => {
  const registry: Registry = createRegistry();
  const entry1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const entry2: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry1);
  registry.draggable.register(entry2);

  // overwritten entry 2
  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Lazy Test,"{'line': 106, 'column': 33, 'index': 3010}","it('should not unregister with an outdated uniqueId', () => {
  const registry: Registry = createRegistry();
  const entry1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  const entry2: DraggableEntry = getDraggableEntry({
    uniqueId: '2',
    dimension: preset.inHome1,
  });

  registry.draggable.register(entry1);
  registry.draggable.register(entry2);

  // overwritten entry 1

  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);

  // entry 1 is now outdated, so this won't be removed
  registry.draggable.unregister(entry1);
  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(entry2);
})",steel
/test/unit/state/registry/draggable-registration.spec.js,Lazy Test,"{'line': 130, 'column': 33, 'index': 3761}","it('should allow unregistrations when there is no entry', () => {
  // this can happen if an unregistration occurs after a .clean
  const registry: Registry = createRegistry();
  const entry1: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });

  // no registration
  expect(registry.draggable.findById(entry1.descriptor.id)).toBe(null);

  expect(() => {
    registry.draggable.unregister(entry1);
  }).not.toThrow();
})",steel
/test/unit/state/registry/cleanup.spec.js,Duplicate Assert,"{'line': 21, 'column': 2, 'index': 651}","it('should remove any registrations', () => {
  const registry: Registry = createRegistry();

  registry.draggable.register(
    getDraggableEntry({ uniqueId: '1', dimension: preset.inHome1 }),
  );
  registry.droppable.register(
    getDroppableEntry({ uniqueId: '1', dimension: preset.home }),
  );
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(true);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(true);

  registry.clean();

  // now cannot find entries
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(false);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(false);
})",steel
/test/unit/state/registry/cleanup.spec.js,Duplicate Assert,"{'line': 22, 'column': 2, 'index': 729}","it('should remove any registrations', () => {
  const registry: Registry = createRegistry();

  registry.draggable.register(
    getDraggableEntry({ uniqueId: '1', dimension: preset.inHome1 }),
  );
  registry.droppable.register(
    getDroppableEntry({ uniqueId: '1', dimension: preset.home }),
  );
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(true);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(true);

  registry.clean();

  // now cannot find entries
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(false);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(false);
})",steel
/test/unit/state/registry/cleanup.spec.js,Duplicate Assert,"{'line': 27, 'column': 2, 'index': 855}","it('should remove any registrations', () => {
  const registry: Registry = createRegistry();

  registry.draggable.register(
    getDraggableEntry({ uniqueId: '1', dimension: preset.inHome1 }),
  );
  registry.droppable.register(
    getDroppableEntry({ uniqueId: '1', dimension: preset.home }),
  );
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(true);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(true);

  registry.clean();

  // now cannot find entries
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(false);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(false);
})",steel
/test/unit/state/registry/cleanup.spec.js,Duplicate Assert,"{'line': 28, 'column': 2, 'index': 934}","it('should remove any registrations', () => {
  const registry: Registry = createRegistry();

  registry.draggable.register(
    getDraggableEntry({ uniqueId: '1', dimension: preset.inHome1 }),
  );
  registry.droppable.register(
    getDroppableEntry({ uniqueId: '1', dimension: preset.home }),
  );
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(true);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(true);

  registry.clean();

  // now cannot find entries
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(false);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(false);
})",steel
/test/unit/state/registry/cleanup.spec.js,Eager Test,"{'line': 16, 'column': 4, 'index': 477}","it('should remove any registrations', () => {
  const registry: Registry = createRegistry();

  registry.draggable.register(
    getDraggableEntry({ uniqueId: '1', dimension: preset.inHome1 }),
  );
  registry.droppable.register(
    getDroppableEntry({ uniqueId: '1', dimension: preset.home }),
  );
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(true);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(true);

  registry.clean();

  // now cannot find entries
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(false);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(false);
})",steel
/test/unit/state/registry/cleanup.spec.js,Eager Test,"{'line': 19, 'column': 4, 'index': 582}","it('should remove any registrations', () => {
  const registry: Registry = createRegistry();

  registry.draggable.register(
    getDraggableEntry({ uniqueId: '1', dimension: preset.inHome1 }),
  );
  registry.droppable.register(
    getDroppableEntry({ uniqueId: '1', dimension: preset.home }),
  );
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(true);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(true);

  registry.clean();

  // now cannot find entries
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(false);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(false);
})",steel
/test/unit/state/registry/cleanup.spec.js,Lazy Test,"{'line': 16, 'column': 4, 'index': 477}","it('should remove any registrations', () => {
  const registry: Registry = createRegistry();

  registry.draggable.register(
    getDraggableEntry({ uniqueId: '1', dimension: preset.inHome1 }),
  );
  registry.droppable.register(
    getDroppableEntry({ uniqueId: '1', dimension: preset.home }),
  );
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(true);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(true);

  registry.clean();

  // now cannot find entries
  expect(registry.draggable.exists(preset.inHome1.descriptor.id)).toBe(false);
  expect(registry.droppable.exists(preset.home.descriptor.id)).toBe(false);
})",steel
/test/unit/state/registry/cleanup.spec.js,Lazy Test,"{'line': 41, 'column': 32, 'index': 1345}","it('should remove unsubscribe any event listeners', () => {
  const listener1 = jest.fn();
  const listener2 = jest.fn();
  const registry: Registry = createRegistry();

  const unsubscribe1 = registry.subscribe(listener1);
  const unsubscribe2 = registry.subscribe(listener2);

  registry.clean();

  const entry: DraggableEntry = getDraggableEntry({
    uniqueId: '1',
    dimension: preset.inHome1,
  });
  registry.draggable.register(entry);

  expect(listener1).not.toHaveBeenCalled();
  expect(listener2).not.toHaveBeenCalled();

  // manually unsubscribing does nothing and does not throw
  expect(() => {
    unsubscribe1();
    unsubscribe2();
  }).not.toThrow();
})",steel
/test/unit/state/publish-while-dragging/recompute-after-critical.spec.js,Eager Test,"{'line': 51, 'column': 2, 'index': 1530}","it('should recalculate after critical (something added)', () => {
  const displacedBy: DisplacedBy = getDisplacedBy(
    vertical,
    preset.inHome1.displaceBy,
  );
  const added: DraggableDimension = {
    ...preset.inHome4,
    descriptor: {
      ...preset.inHome4.descriptor,
      index: preset.inHome4.descriptor.index + 1,
      id: 'added',
    },
  };
  const published: Published = {
    ...empty,
    additions: [added],
    modified: [{ droppableId: virtualHome.descriptor.id, scroll: origin }],
  };

  const original: CollectingState = withVirtuals(state.collecting());
  const result: DraggingState | DropPendingState = publish({
    state: original,
    published,
  });

  invariant(result.phase === 'DRAGGING');

  {
    const expected: LiftEffect = {
      inVirtualList: true,
      effected: {
        // part of the original onLift
        [preset.inHome2.descriptor.id]: true,
        [preset.inHome3.descriptor.id]: true,
        [preset.inHome4.descriptor.id]: true,
        // added
        [added.descriptor.id]: true,
      },
      displacedBy,
    };

    expect(result.afterCritical).toEqual(expected);
  }

  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        { dimension: preset.inHome2, shouldAnimate: false },
        { dimension: preset.inHome3, shouldAnimate: false },
        { dimension: preset.inHome4, shouldAnimate: false },
        { dimension: added, shouldAnimate: false },
      ],
    });
    const expected: DragImpact = {
      displacedBy,
      displaced,
      at: original.onLiftImpact.at,
    };
    expect(result.onLiftImpact).toEqual(expected);
  }
})",steel
/test/unit/state/publish-while-dragging/recompute-after-critical.spec.js,Eager Test,"{'line': 71, 'column': 42, 'index': 2025}","it('should recalculate after critical (something added)', () => {
  const displacedBy: DisplacedBy = getDisplacedBy(
    vertical,
    preset.inHome1.displaceBy,
  );
  const added: DraggableDimension = {
    ...preset.inHome4,
    descriptor: {
      ...preset.inHome4.descriptor,
      index: preset.inHome4.descriptor.index + 1,
      id: 'added',
    },
  };
  const published: Published = {
    ...empty,
    additions: [added],
    modified: [{ droppableId: virtualHome.descriptor.id, scroll: origin }],
  };

  const original: CollectingState = withVirtuals(state.collecting());
  const result: DraggingState | DropPendingState = publish({
    state: original,
    published,
  });

  invariant(result.phase === 'DRAGGING');

  {
    const expected: LiftEffect = {
      inVirtualList: true,
      effected: {
        // part of the original onLift
        [preset.inHome2.descriptor.id]: true,
        [preset.inHome3.descriptor.id]: true,
        [preset.inHome4.descriptor.id]: true,
        // added
        [added.descriptor.id]: true,
      },
      displacedBy,
    };

    expect(result.afterCritical).toEqual(expected);
  }

  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        { dimension: preset.inHome2, shouldAnimate: false },
        { dimension: preset.inHome3, shouldAnimate: false },
        { dimension: preset.inHome4, shouldAnimate: false },
        { dimension: added, shouldAnimate: false },
      ],
    });
    const expected: DragImpact = {
      displacedBy,
      displaced,
      at: original.onLiftImpact.at,
    };
    expect(result.onLiftImpact).toEqual(expected);
  }
})",steel
/test/unit/state/publish-while-dragging/recompute-after-critical.spec.js,Eager Test,"{'line': 105, 'column': 2, 'index': 3017}","it('should recalculate after critical (something removed)', () => {
  const displacedBy: DisplacedBy = getDisplacedBy(
    vertical,
    preset.inHome1.displaceBy,
  );
  const published: Published = {
    removals: [preset.inHome4.descriptor.id],
    additions: [],
    modified: [{ droppableId: virtualHome.descriptor.id, scroll: origin }],
  };

  const original: CollectingState = withVirtuals(state.collecting());
  const result: DraggingState | DropPendingState = publish({
    state: original,
    published,
  });

  invariant(result.phase === 'DRAGGING');

  {
    const expected: LiftEffect = {
      inVirtualList: true,
      effected: {
        [preset.inHome2.descriptor.id]: true,
        [preset.inHome3.descriptor.id]: true,
        // preset.inHome4 is gone
      },
      displacedBy,
    };

    expect(result.afterCritical).toEqual(expected);
  }

  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        { dimension: preset.inHome2, shouldAnimate: false },
        { dimension: preset.inHome3, shouldAnimate: false },
      ],
    });
    const expected: DragImpact = {
      displacedBy,
      displaced,
      at: original.onLiftImpact.at,
    };
    expect(result.onLiftImpact).toEqual(expected);
  }
})",steel
/test/unit/state/publish-while-dragging/recompute-after-critical.spec.js,Eager Test,"{'line': 122, 'column': 42, 'index': 3407}","it('should recalculate after critical (something removed)', () => {
  const displacedBy: DisplacedBy = getDisplacedBy(
    vertical,
    preset.inHome1.displaceBy,
  );
  const published: Published = {
    removals: [preset.inHome4.descriptor.id],
    additions: [],
    modified: [{ droppableId: virtualHome.descriptor.id, scroll: origin }],
  };

  const original: CollectingState = withVirtuals(state.collecting());
  const result: DraggingState | DropPendingState = publish({
    state: original,
    published,
  });

  invariant(result.phase === 'DRAGGING');

  {
    const expected: LiftEffect = {
      inVirtualList: true,
      effected: {
        [preset.inHome2.descriptor.id]: true,
        [preset.inHome3.descriptor.id]: true,
        // preset.inHome4 is gone
      },
      displacedBy,
    };

    expect(result.afterCritical).toEqual(expected);
  }

  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        { dimension: preset.inHome2, shouldAnimate: false },
        { dimension: preset.inHome3, shouldAnimate: false },
      ],
    });
    const expected: DragImpact = {
      displacedBy,
      displaced,
      at: original.onLiftImpact.at,
    };
    expect(result.onLiftImpact).toEqual(expected);
  }
})",steel
/test/unit/state/publish-while-dragging/recompute-after-critical.spec.js,Lazy Test,"{'line': 51, 'column': 2, 'index': 1530}","it('should recalculate after critical (something added)', () => {
  const displacedBy: DisplacedBy = getDisplacedBy(
    vertical,
    preset.inHome1.displaceBy,
  );
  const added: DraggableDimension = {
    ...preset.inHome4,
    descriptor: {
      ...preset.inHome4.descriptor,
      index: preset.inHome4.descriptor.index + 1,
      id: 'added',
    },
  };
  const published: Published = {
    ...empty,
    additions: [added],
    modified: [{ droppableId: virtualHome.descriptor.id, scroll: origin }],
  };

  const original: CollectingState = withVirtuals(state.collecting());
  const result: DraggingState | DropPendingState = publish({
    state: original,
    published,
  });

  invariant(result.phase === 'DRAGGING');

  {
    const expected: LiftEffect = {
      inVirtualList: true,
      effected: {
        // part of the original onLift
        [preset.inHome2.descriptor.id]: true,
        [preset.inHome3.descriptor.id]: true,
        [preset.inHome4.descriptor.id]: true,
        // added
        [added.descriptor.id]: true,
      },
      displacedBy,
    };

    expect(result.afterCritical).toEqual(expected);
  }

  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        { dimension: preset.inHome2, shouldAnimate: false },
        { dimension: preset.inHome3, shouldAnimate: false },
        { dimension: preset.inHome4, shouldAnimate: false },
        { dimension: added, shouldAnimate: false },
      ],
    });
    const expected: DragImpact = {
      displacedBy,
      displaced,
      at: original.onLiftImpact.at,
    };
    expect(result.onLiftImpact).toEqual(expected);
  }
})",steel
/test/unit/state/publish-while-dragging/recompute-after-critical.spec.js,Lazy Test,"{'line': 71, 'column': 42, 'index': 2025}","it('should recalculate after critical (something added)', () => {
  const displacedBy: DisplacedBy = getDisplacedBy(
    vertical,
    preset.inHome1.displaceBy,
  );
  const added: DraggableDimension = {
    ...preset.inHome4,
    descriptor: {
      ...preset.inHome4.descriptor,
      index: preset.inHome4.descriptor.index + 1,
      id: 'added',
    },
  };
  const published: Published = {
    ...empty,
    additions: [added],
    modified: [{ droppableId: virtualHome.descriptor.id, scroll: origin }],
  };

  const original: CollectingState = withVirtuals(state.collecting());
  const result: DraggingState | DropPendingState = publish({
    state: original,
    published,
  });

  invariant(result.phase === 'DRAGGING');

  {
    const expected: LiftEffect = {
      inVirtualList: true,
      effected: {
        // part of the original onLift
        [preset.inHome2.descriptor.id]: true,
        [preset.inHome3.descriptor.id]: true,
        [preset.inHome4.descriptor.id]: true,
        // added
        [added.descriptor.id]: true,
      },
      displacedBy,
    };

    expect(result.afterCritical).toEqual(expected);
  }

  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        { dimension: preset.inHome2, shouldAnimate: false },
        { dimension: preset.inHome3, shouldAnimate: false },
        { dimension: preset.inHome4, shouldAnimate: false },
        { dimension: added, shouldAnimate: false },
      ],
    });
    const expected: DragImpact = {
      displacedBy,
      displaced,
      at: original.onLiftImpact.at,
    };
    expect(result.onLiftImpact).toEqual(expected);
  }
})",steel
/test/unit/state/publish-while-dragging/recompute-after-critical.spec.js,Lazy Test,"{'line': 105, 'column': 2, 'index': 3017}","it('should recalculate after critical (something removed)', () => {
  const displacedBy: DisplacedBy = getDisplacedBy(
    vertical,
    preset.inHome1.displaceBy,
  );
  const published: Published = {
    removals: [preset.inHome4.descriptor.id],
    additions: [],
    modified: [{ droppableId: virtualHome.descriptor.id, scroll: origin }],
  };

  const original: CollectingState = withVirtuals(state.collecting());
  const result: DraggingState | DropPendingState = publish({
    state: original,
    published,
  });

  invariant(result.phase === 'DRAGGING');

  {
    const expected: LiftEffect = {
      inVirtualList: true,
      effected: {
        [preset.inHome2.descriptor.id]: true,
        [preset.inHome3.descriptor.id]: true,
        // preset.inHome4 is gone
      },
      displacedBy,
    };

    expect(result.afterCritical).toEqual(expected);
  }

  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        { dimension: preset.inHome2, shouldAnimate: false },
        { dimension: preset.inHome3, shouldAnimate: false },
      ],
    });
    const expected: DragImpact = {
      displacedBy,
      displaced,
      at: original.onLiftImpact.at,
    };
    expect(result.onLiftImpact).toEqual(expected);
  }
})",steel
/test/unit/state/publish-while-dragging/recompute-after-critical.spec.js,Lazy Test,"{'line': 122, 'column': 42, 'index': 3407}","it('should recalculate after critical (something removed)', () => {
  const displacedBy: DisplacedBy = getDisplacedBy(
    vertical,
    preset.inHome1.displaceBy,
  );
  const published: Published = {
    removals: [preset.inHome4.descriptor.id],
    additions: [],
    modified: [{ droppableId: virtualHome.descriptor.id, scroll: origin }],
  };

  const original: CollectingState = withVirtuals(state.collecting());
  const result: DraggingState | DropPendingState = publish({
    state: original,
    published,
  });

  invariant(result.phase === 'DRAGGING');

  {
    const expected: LiftEffect = {
      inVirtualList: true,
      effected: {
        [preset.inHome2.descriptor.id]: true,
        [preset.inHome3.descriptor.id]: true,
        // preset.inHome4 is gone
      },
      displacedBy,
    };

    expect(result.afterCritical).toEqual(expected);
  }

  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        { dimension: preset.inHome2, shouldAnimate: false },
        { dimension: preset.inHome3, shouldAnimate: false },
      ],
    });
    const expected: DragImpact = {
      displacedBy,
      displaced,
      at: original.onLiftImpact.at,
    };
    expect(result.onLiftImpact).toEqual(expected);
  }
})",steel
/test/unit/state/publish-while-dragging/displacement-animation.spec.js,Eager Test,"{'line': 40, 'column': 2, 'index': 1464}","it('should not animate any displacement', () => {
  // inHome1 currently in foreign
  // adding item to foreign list
  // we are ensuring this displacement is not animated

  const inHomeState: DraggingState = addDroppable(
    state.dragging(),
    virtualForeign,
  );
  const moveToForeign: ?PublicResult = moveInDirection({
    state: inHomeState,
    type: 'MOVE_RIGHT',
  });
  invariant(moveToForeign);
  const inForeignImpact: DragImpact = moveToForeign.impact;
  // validation
  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        // initial movement goes after inForeign1
        { dimension: preset.inForeign2, shouldAnimate: true },
        { dimension: preset.inForeign3, shouldAnimate: true },
        { dimension: preset.inForeign4, shouldAnimate: true },
      ],
    });
    const impact: DragImpact = {
      displaced,
      displacedBy: getDisplacedBy(vertical, preset.inHome1.displaceBy),
      at: {
        type: 'REORDER',
        destination: {
          index: preset.inForeign2.descriptor.index,
          droppableId: preset.foreign.descriptor.id,
        },
      },
    };
    expect(impact).toEqual(inForeignImpact);
  }
  // $ExpectError - casting as different state type
  const inForeignState: DraggingState = update({
    state: inHomeState,
    clientSelection: moveToForeign.clientSelection,
    impact: inForeignImpact,
  });

  // adding item after inHome4
  const added: DraggableDimension = {
    ...preset.inForeign4,
    descriptor: {
      ...preset.inForeign4.descriptor,
      index: preset.inForeign4.descriptor.index + 1,
      id: 'added',
    },
  };
  const collectingState: CollectingState = {
    phase: 'COLLECTING',
    ...inForeignState,
    // appeasing flow
    // eslint-disable-next-line
    phase: 'COLLECTING',
  };
  const published: Published = {
    ...empty,
    additions: [added],
    modified: [{ droppableId: virtualForeign.descriptor.id, scroll: origin }],
  };

  const result: DraggingState | DropPendingState = publish({
    state: collectingState,
    published,
  });
  invariant(result.phase === 'DRAGGING');

  const displaced: DisplacementGroups = getForcedDisplacement({
    visible: [
      // original animation unchanged
      { dimension: preset.inForeign2, shouldAnimate: true },
      { dimension: preset.inForeign3, shouldAnimate: true },
      { dimension: preset.inForeign4, shouldAnimate: true },
      // addition
      { dimension: added, shouldAnimate: true },
    ],
  });
  const expected: DragImpact = {
    // same destination
    ...inForeignImpact,
    displaced,
  };
  expect(result.impact).toEqual(expected);
})",steel
/test/unit/state/publish-while-dragging/displacement-animation.spec.js,Eager Test,"{'line': 44, 'column': 42, 'index': 1612}","it('should not animate any displacement', () => {
  // inHome1 currently in foreign
  // adding item to foreign list
  // we are ensuring this displacement is not animated

  const inHomeState: DraggingState = addDroppable(
    state.dragging(),
    virtualForeign,
  );
  const moveToForeign: ?PublicResult = moveInDirection({
    state: inHomeState,
    type: 'MOVE_RIGHT',
  });
  invariant(moveToForeign);
  const inForeignImpact: DragImpact = moveToForeign.impact;
  // validation
  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        // initial movement goes after inForeign1
        { dimension: preset.inForeign2, shouldAnimate: true },
        { dimension: preset.inForeign3, shouldAnimate: true },
        { dimension: preset.inForeign4, shouldAnimate: true },
      ],
    });
    const impact: DragImpact = {
      displaced,
      displacedBy: getDisplacedBy(vertical, preset.inHome1.displaceBy),
      at: {
        type: 'REORDER',
        destination: {
          index: preset.inForeign2.descriptor.index,
          droppableId: preset.foreign.descriptor.id,
        },
      },
    };
    expect(impact).toEqual(inForeignImpact);
  }
  // $ExpectError - casting as different state type
  const inForeignState: DraggingState = update({
    state: inHomeState,
    clientSelection: moveToForeign.clientSelection,
    impact: inForeignImpact,
  });

  // adding item after inHome4
  const added: DraggableDimension = {
    ...preset.inForeign4,
    descriptor: {
      ...preset.inForeign4.descriptor,
      index: preset.inForeign4.descriptor.index + 1,
      id: 'added',
    },
  };
  const collectingState: CollectingState = {
    phase: 'COLLECTING',
    ...inForeignState,
    // appeasing flow
    // eslint-disable-next-line
    phase: 'COLLECTING',
  };
  const published: Published = {
    ...empty,
    additions: [added],
    modified: [{ droppableId: virtualForeign.descriptor.id, scroll: origin }],
  };

  const result: DraggingState | DropPendingState = publish({
    state: collectingState,
    published,
  });
  invariant(result.phase === 'DRAGGING');

  const displaced: DisplacementGroups = getForcedDisplacement({
    visible: [
      // original animation unchanged
      { dimension: preset.inForeign2, shouldAnimate: true },
      { dimension: preset.inForeign3, shouldAnimate: true },
      { dimension: preset.inForeign4, shouldAnimate: true },
      // addition
      { dimension: added, shouldAnimate: true },
    ],
  });
  const expected: DragImpact = {
    // same destination
    ...inForeignImpact,
    displaced,
  };
  expect(result.impact).toEqual(expected);
})",steel
/test/unit/state/publish-while-dragging/displacement-animation.spec.js,Eager Test,"{'line': 98, 'column': 2, 'index': 3167}","it('should not animate any displacement', () => {
  // inHome1 currently in foreign
  // adding item to foreign list
  // we are ensuring this displacement is not animated

  const inHomeState: DraggingState = addDroppable(
    state.dragging(),
    virtualForeign,
  );
  const moveToForeign: ?PublicResult = moveInDirection({
    state: inHomeState,
    type: 'MOVE_RIGHT',
  });
  invariant(moveToForeign);
  const inForeignImpact: DragImpact = moveToForeign.impact;
  // validation
  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        // initial movement goes after inForeign1
        { dimension: preset.inForeign2, shouldAnimate: true },
        { dimension: preset.inForeign3, shouldAnimate: true },
        { dimension: preset.inForeign4, shouldAnimate: true },
      ],
    });
    const impact: DragImpact = {
      displaced,
      displacedBy: getDisplacedBy(vertical, preset.inHome1.displaceBy),
      at: {
        type: 'REORDER',
        destination: {
          index: preset.inForeign2.descriptor.index,
          droppableId: preset.foreign.descriptor.id,
        },
      },
    };
    expect(impact).toEqual(inForeignImpact);
  }
  // $ExpectError - casting as different state type
  const inForeignState: DraggingState = update({
    state: inHomeState,
    clientSelection: moveToForeign.clientSelection,
    impact: inForeignImpact,
  });

  // adding item after inHome4
  const added: DraggableDimension = {
    ...preset.inForeign4,
    descriptor: {
      ...preset.inForeign4.descriptor,
      index: preset.inForeign4.descriptor.index + 1,
      id: 'added',
    },
  };
  const collectingState: CollectingState = {
    phase: 'COLLECTING',
    ...inForeignState,
    // appeasing flow
    // eslint-disable-next-line
    phase: 'COLLECTING',
  };
  const published: Published = {
    ...empty,
    additions: [added],
    modified: [{ droppableId: virtualForeign.descriptor.id, scroll: origin }],
  };

  const result: DraggingState | DropPendingState = publish({
    state: collectingState,
    published,
  });
  invariant(result.phase === 'DRAGGING');

  const displaced: DisplacementGroups = getForcedDisplacement({
    visible: [
      // original animation unchanged
      { dimension: preset.inForeign2, shouldAnimate: true },
      { dimension: preset.inForeign3, shouldAnimate: true },
      { dimension: preset.inForeign4, shouldAnimate: true },
      // addition
      { dimension: added, shouldAnimate: true },
    ],
  });
  const expected: DragImpact = {
    // same destination
    ...inForeignImpact,
    displaced,
  };
  expect(result.impact).toEqual(expected);
})",steel
/test/unit/state/publish-while-dragging/displacement-animation.spec.js,Eager Test,"{'line': 100, 'column': 40, 'index': 3248}","it('should not animate any displacement', () => {
  // inHome1 currently in foreign
  // adding item to foreign list
  // we are ensuring this displacement is not animated

  const inHomeState: DraggingState = addDroppable(
    state.dragging(),
    virtualForeign,
  );
  const moveToForeign: ?PublicResult = moveInDirection({
    state: inHomeState,
    type: 'MOVE_RIGHT',
  });
  invariant(moveToForeign);
  const inForeignImpact: DragImpact = moveToForeign.impact;
  // validation
  {
    const displaced: DisplacementGroups = getForcedDisplacement({
      visible: [
        // initial movement goes after inForeign1
        { dimension: preset.inForeign2, shouldAnimate: true },
        { dimension: preset.inForeign3, shouldAnimate: true },
        { dimension: preset.inForeign4, shouldAnimate: true },
      ],
    });
    const impact: DragImpact = {
      displaced,
      displacedBy: getDisplacedBy(vertical, preset.inHome1.displaceBy),
      at: {
        type: 'REORDER',
        destination: {
          index: preset.inForeign2.descriptor.index,
          droppableId: preset.foreign.descriptor.id,
        },
      },
    };
    expect(impact).toEqual(inForeignImpact);
  }
  // $ExpectError - casting as different state type
  const inForeignState: DraggingState = update({
    state: inHomeState,
    clientSelection: moveToForeign.clientSelection,
    impact: inForeignImpact,
  });

  // adding item after inHome4
  const added: DraggableDimension = {
    ...preset.inForeign4,
    descriptor: {
      ...preset.inForeign4.descriptor,
      index: preset.inForeign4.descriptor.index + 1,
      id: 'added',
    },
  };
  const collectingState: CollectingState = {
    phase: 'COLLECTING',
    ...inForeignState,
    // appeasing flow
    // eslint-disable-next-line
    phase: 'COLLECTING',
  };
  const published: Published = {
    ...empty,
    additions: [added],
    modified: [{ droppableId: virtualForeign.descriptor.id, scroll: origin }],
  };

  const result: DraggingState | DropPendingState = publish({
    state: collectingState,
    published,
  });
  invariant(result.phase === 'DRAGGING');

  const displaced: DisplacementGroups = getForcedDisplacement({
    visible: [
      // original animation unchanged
      { dimension: preset.inForeign2, shouldAnimate: true },
      { dimension: preset.inForeign3, shouldAnimate: true },
      { dimension: preset.inForeign4, shouldAnimate: true },
      // addition
      { dimension: added, shouldAnimate: true },
    ],
  });
  const expected: DragImpact = {
    // same destination
    ...inForeignImpact,
    displaced,
  };
  expect(result.impact).toEqual(expected);
})",steel
/test/unit/state/publish-while-dragging/adjust-additions-for-scroll-change.spec.js,Lazy Test,"{'line': 72, 'column': 2, 'index': 2454}","it('should shift added draggables to account for change in page scroll since start of drag', () => {
  // change in scroll
  const scrollChange: Position = { x: 20, y: 40 };
  // the displacement caused to draggables as a result of the change
  const scrollDisplacement: Position = negate(scrollChange);
  const newScroll: Position = add(preset.viewport.scroll.initial, scrollChange);
  const scrolledViewport: Viewport = scrollViewport(preset.viewport, newScroll);
  // dimensions
  const added: DraggableDimension = getDraggableDimension({
    descriptor: {
      index: 0,
      id: 'added',
      droppableId: preset.home.descriptor.id,
      type: preset.home.descriptor.type,
    },
    // when collected this dimension would have been displaced by the scroll
    borderBox: offset(preset.inHome1.client, scrollDisplacement).borderBox,
    windowScroll: add(preset.windowScroll, scrollDisplacement),
  });
  const unshifted: DraggableDimension = getDraggableDimension({
    descriptor: added.descriptor,
    // unshifted
    borderBox: preset.inHome1.client.borderBox,
    windowScroll: preset.windowScroll,
  });
  const published: Published = {
    ...empty,
    additions: [added],
    modified: [{ droppableId: virtualHome.descriptor.id, scroll: origin }],
  };
  const original: CollectingState = withVirtuals(
    state.collecting(
      preset.inHome1.descriptor.id,
      preset.inHome1.client.borderBox.center,
      scrolledViewport,
    ),
  );

  const result: DraggingState | DropPendingState = publish({
    state: original,
    published,
  });

  invariant(result.phase === 'DRAGGING');
  expect(result.dimensions.draggables[added.descriptor.id]).toEqual(unshifted);
})",steel
/test/unit/state/publish-while-dragging/adjust-additions-for-scroll-change.spec.js,Lazy Test,"{'line': 123, 'column': 2, 'index': 4168}","it('should shift added draggables to account for change in droppable scroll since start of drag', () => {
  // Scroll droppable
  const scrollChange: Position = { x: 20, y: 40 };
  const scrollDisplacement: Position = negate(scrollChange);
  const newScroll: Position = add(
    getFrame(virtualHome).scroll.initial,
    scrollChange,
  );
  const scrolled: DroppableDimension = scrollDroppable(virtualHome, newScroll);
  // validation
  expect(getFrame(scrolled).scroll.current).toEqual(scrollChange);
  // dimensions
  const added: DraggableDimension = getDraggableDimension({
    descriptor: {
      index: 0,
      id: 'added',
      droppableId: preset.home.descriptor.id,
      type: preset.home.descriptor.type,
    },
    // when collected this dimension would have been displaced by the scroll
    borderBox: offset(preset.inHome1.client, scrollDisplacement).borderBox,
    windowScroll: preset.windowScroll,
  });
  const unshifted: DraggableDimension = getDraggableDimension({
    descriptor: added.descriptor,
    // unshifted
    borderBox: preset.inHome1.client.borderBox,
    windowScroll: preset.windowScroll,
  });
  const published: Published = {
    ...empty,
    additions: [added],
    modified: [{ droppableId: scrolled.descriptor.id, scroll: newScroll }],
  };
  const original: CollectingState = state.collecting(
    preset.inHome1.descriptor.id,
  );
  const withScrolled: CollectingState = (addDroppable(
    (original: any),
    scrolled,
  ): any);

  const result: DraggingState | DropPendingState = publish({
    state: withScrolled,
    published,
  });

  invariant(result.phase === 'DRAGGING');
  expect(result.dimensions.draggables[added.descriptor.id]).toEqual(unshifted);
})",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Conditional Test Logic,"{'line': 138, 'column': 23, 'index': 4243}",Unknown,steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 26, 'column': 4, 'index': 930}","it('should move forward on a MOVE_DOWN', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_DOWN',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 31, 'column': 11, 'index': 1092}","it('should move forward on a MOVE_DOWN', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_DOWN',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 40, 'column': 4, 'index': 1350}","it('should move backwards on a MOVE_UP', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inHome2.descriptor.id),
      type: 'MOVE_UP',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 45, 'column': 11, 'index': 1512}","it('should move backwards on a MOVE_UP', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inHome2.descriptor.id),
      type: 'MOVE_UP',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 54, 'column': 4, 'index': 1758}","it('should move cross axis forwards on a MOVE_RIGHT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_RIGHT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.foreign.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 59, 'column': 11, 'index': 1923}","it('should move cross axis forwards on a MOVE_RIGHT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_RIGHT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.foreign.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 68, 'column': 4, 'index': 2199}","it('should move cross axis backwards on a MOVE_LEFT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inForeign1.descriptor.id),
      type: 'MOVE_LEFT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 73, 'column': 11, 'index': 2361}","it('should move cross axis backwards on a MOVE_LEFT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inForeign1.descriptor.id),
      type: 'MOVE_LEFT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 87, 'column': 4, 'index': 2727}","it('should move forward on a MOVE_RIGHT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_RIGHT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 92, 'column': 11, 'index': 2889}","it('should move forward on a MOVE_RIGHT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_RIGHT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 101, 'column': 4, 'index': 3151}","it('should move backwards on a MOVE_LEFT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inHome2.descriptor.id),
      type: 'MOVE_LEFT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 106, 'column': 11, 'index': 3313}","it('should move backwards on a MOVE_LEFT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inHome2.descriptor.id),
      type: 'MOVE_LEFT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 115, 'column': 4, 'index': 3557}","it('should move cross axis forwards on a MOVE_DOWN', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_DOWN',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.foreign.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 120, 'column': 11, 'index': 3722}","it('should move cross axis forwards on a MOVE_DOWN', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_DOWN',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.foreign.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 129, 'column': 4, 'index': 3994}","it('should move cross axis backwards on a MOVE_UP', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inForeign1.descriptor.id),
      type: 'MOVE_UP',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 134, 'column': 11, 'index': 4156}","it('should move cross axis backwards on a MOVE_UP', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inForeign1.descriptor.id),
      type: 'MOVE_UP',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 180, 'column': 6, 'index': 5653}","it('should not allow movement on the main axis if lifting in a disabled droppable', () => {
      const custom: DraggingState = state.dragging();

      // no destination when lifting in disabled droppable
      custom.impact.at = null;
      // disabling the droppable for good measure
      const critical: DroppableDimension =
        custom.dimensions.droppables[custom.critical.droppable.id];
      custom.dimensions.droppables[
        custom.critical.droppable.id
      ] = disableDroppable(critical);

      // Main axis movement not allowed
      const forward = axis.direction === 'vertical' ? 'MOVE_DOWN' : 'MOVE_LEFT';
      const backward = axis.direction === 'vertical' ? 'MOVE_UP' : 'MOVE_RIGHT';
      expect(
        moveInDirection({
          state: custom,
          type: forward,
        }),
      ).toBe(null);
      expect(
        moveInDirection({
          state: custom,
          type: backward,
        }),
      ).toBe(null);

      // cross axis movement allowed
      const crossAxisForward =
        axis.direction === 'vertical' ? 'MOVE_RIGHT' : 'MOVE_DOWN';

      const result: ?PublicResult = moveInDirection({
        state: state.dragging(),
        type: crossAxisForward,
      });

      invariant(result, 'expected a result');
      const expected: DraggableLocation = {
        droppableId: preset.foreign.descriptor.id,
        index: 1,
      };
      expect(tryGetDestination(result.impact)).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Eager Test,"{'line': 185, 'column': 13, 'index': 5828}","it('should not allow movement on the main axis if lifting in a disabled droppable', () => {
      const custom: DraggingState = state.dragging();

      // no destination when lifting in disabled droppable
      custom.impact.at = null;
      // disabling the droppable for good measure
      const critical: DroppableDimension =
        custom.dimensions.droppables[custom.critical.droppable.id];
      custom.dimensions.droppables[
        custom.critical.droppable.id
      ] = disableDroppable(critical);

      // Main axis movement not allowed
      const forward = axis.direction === 'vertical' ? 'MOVE_DOWN' : 'MOVE_LEFT';
      const backward = axis.direction === 'vertical' ? 'MOVE_UP' : 'MOVE_RIGHT';
      expect(
        moveInDirection({
          state: custom,
          type: forward,
        }),
      ).toBe(null);
      expect(
        moveInDirection({
          state: custom,
          type: backward,
        }),
      ).toBe(null);

      // cross axis movement allowed
      const crossAxisForward =
        axis.direction === 'vertical' ? 'MOVE_RIGHT' : 'MOVE_DOWN';

      const result: ?PublicResult = moveInDirection({
        state: state.dragging(),
        type: crossAxisForward,
      });

      invariant(result, 'expected a result');
      const expected: DraggableLocation = {
        droppableId: preset.foreign.descriptor.id,
        index: 1,
      };
      expect(tryGetDestination(result.impact)).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 26, 'column': 4, 'index': 930}","it('should move forward on a MOVE_DOWN', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_DOWN',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 31, 'column': 11, 'index': 1092}","it('should move forward on a MOVE_DOWN', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_DOWN',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 40, 'column': 4, 'index': 1350}","it('should move backwards on a MOVE_UP', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inHome2.descriptor.id),
      type: 'MOVE_UP',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 45, 'column': 11, 'index': 1512}","it('should move backwards on a MOVE_UP', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inHome2.descriptor.id),
      type: 'MOVE_UP',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 54, 'column': 4, 'index': 1758}","it('should move cross axis forwards on a MOVE_RIGHT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_RIGHT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.foreign.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 59, 'column': 11, 'index': 1923}","it('should move cross axis forwards on a MOVE_RIGHT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_RIGHT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.foreign.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 68, 'column': 4, 'index': 2199}","it('should move cross axis backwards on a MOVE_LEFT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inForeign1.descriptor.id),
      type: 'MOVE_LEFT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 73, 'column': 11, 'index': 2361}","it('should move cross axis backwards on a MOVE_LEFT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inForeign1.descriptor.id),
      type: 'MOVE_LEFT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 87, 'column': 4, 'index': 2727}","it('should move forward on a MOVE_RIGHT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_RIGHT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 92, 'column': 11, 'index': 2889}","it('should move forward on a MOVE_RIGHT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_RIGHT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 101, 'column': 4, 'index': 3151}","it('should move backwards on a MOVE_LEFT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inHome2.descriptor.id),
      type: 'MOVE_LEFT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 106, 'column': 11, 'index': 3313}","it('should move backwards on a MOVE_LEFT', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inHome2.descriptor.id),
      type: 'MOVE_LEFT',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 115, 'column': 4, 'index': 3557}","it('should move cross axis forwards on a MOVE_DOWN', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_DOWN',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.foreign.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 120, 'column': 11, 'index': 3722}","it('should move cross axis forwards on a MOVE_DOWN', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(),
      type: 'MOVE_DOWN',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.foreign.descriptor.id,
      index: 1,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 129, 'column': 4, 'index': 3994}","it('should move cross axis backwards on a MOVE_UP', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inForeign1.descriptor.id),
      type: 'MOVE_UP',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 134, 'column': 11, 'index': 4156}","it('should move cross axis backwards on a MOVE_UP', () => {
    const result: ?PublicResult = moveInDirection({
      state: state.dragging(preset.inForeign1.descriptor.id),
      type: 'MOVE_UP',
    });

    invariant(result, 'expected a result');
    const expected: DraggableLocation = {
      droppableId: preset.home.descriptor.id,
      index: 0,
    };
    expect(tryGetDestination(result.impact)).toEqual(expected);
  })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 180, 'column': 6, 'index': 5653}","it('should not allow movement on the main axis if lifting in a disabled droppable', () => {
      const custom: DraggingState = state.dragging();

      // no destination when lifting in disabled droppable
      custom.impact.at = null;
      // disabling the droppable for good measure
      const critical: DroppableDimension =
        custom.dimensions.droppables[custom.critical.droppable.id];
      custom.dimensions.droppables[
        custom.critical.droppable.id
      ] = disableDroppable(critical);

      // Main axis movement not allowed
      const forward = axis.direction === 'vertical' ? 'MOVE_DOWN' : 'MOVE_LEFT';
      const backward = axis.direction === 'vertical' ? 'MOVE_UP' : 'MOVE_RIGHT';
      expect(
        moveInDirection({
          state: custom,
          type: forward,
        }),
      ).toBe(null);
      expect(
        moveInDirection({
          state: custom,
          type: backward,
        }),
      ).toBe(null);

      // cross axis movement allowed
      const crossAxisForward =
        axis.direction === 'vertical' ? 'MOVE_RIGHT' : 'MOVE_DOWN';

      const result: ?PublicResult = moveInDirection({
        state: state.dragging(),
        type: crossAxisForward,
      });

      invariant(result, 'expected a result');
      const expected: DraggableLocation = {
        droppableId: preset.foreign.descriptor.id,
        index: 1,
      };
      expect(tryGetDestination(result.impact)).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-in-direction.spec.js,Lazy Test,"{'line': 185, 'column': 13, 'index': 5828}","it('should not allow movement on the main axis if lifting in a disabled droppable', () => {
      const custom: DraggingState = state.dragging();

      // no destination when lifting in disabled droppable
      custom.impact.at = null;
      // disabling the droppable for good measure
      const critical: DroppableDimension =
        custom.dimensions.droppables[custom.critical.droppable.id];
      custom.dimensions.droppables[
        custom.critical.droppable.id
      ] = disableDroppable(critical);

      // Main axis movement not allowed
      const forward = axis.direction === 'vertical' ? 'MOVE_DOWN' : 'MOVE_LEFT';
      const backward = axis.direction === 'vertical' ? 'MOVE_UP' : 'MOVE_RIGHT';
      expect(
        moveInDirection({
          state: custom,
          type: forward,
        }),
      ).toBe(null);
      expect(
        moveInDirection({
          state: custom,
          type: backward,
        }),
      ).toBe(null);

      // cross axis movement allowed
      const crossAxisForward =
        axis.direction === 'vertical' ? 'MOVE_RIGHT' : 'MOVE_DOWN';

      const result: ?PublicResult = moveInDirection({
        state: state.dragging(),
        type: crossAxisForward,
      });

      invariant(result, 'expected a result');
      const expected: DraggableLocation = {
        droppableId: preset.foreign.descriptor.id,
        index: 1,
      };
      expect(tryGetDestination(result.impact)).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-viewport.spec.js,Conditional Test Logic,"{'line': 35, 'column': 23, 'index': 1697}",Unknown,steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-viewport.spec.js,Eager Test,"{'line': 150, 'column': 21, 'index': 4768}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        const previousPageBorderBoxCenter: Position =
          inHome.page.borderBox.center;
        const previousClientSelection: Position =
          inHome.client.borderBox.center;

        const previousImpact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: inForeign }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: true,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-viewport.spec.js,Eager Test,"{'line': 174, 'column': 8, 'index': 5426}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        const previousPageBorderBoxCenter: Position =
          inHome.page.borderBox.center;
        const previousClientSelection: Position =
          inHome.client.borderBox.center;

        const previousImpact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: inForeign }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: true,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-viewport.spec.js,Eager Test,"{'line': 297, 'column': 8, 'index': 9495}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        // after non-displaced inForeign
        const previousImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy: getDisplacedBy(axis, inHome.displaceBy),
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        const previousPageBorderBoxCenter: Position = getPageBorderBoxCenter({
          impact: previousImpact,
          afterCritical,
          draggable: inHome,
          droppable: foreign,
          draggables,
        });
        const previousClientSelection: Position = getClientFromPageBorderBoxCenter(
          {
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: inHome,
            viewport: scrolled,
          },
        );
        // const previousPageBorderBoxCenter: Position =
        //   initiallyOutsideViewport.page.borderBox.center;
        // const previousClientSelection: Position =
        //   initiallyOutsideViewport.client.borderBox.center;

        // figure out where we would have been if it was visible

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: false,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport: scrolled,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: getForcedDisplacement({
            // Even though the item started in an invisible place we force
            // the displacement to be visible.
            visible: [{ dimension: inForeign, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // moving into place of inForeign
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-viewport.spec.js,Eager Test,"{'line': 300, 'column': 21, 'index': 9581}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        // after non-displaced inForeign
        const previousImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy: getDisplacedBy(axis, inHome.displaceBy),
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        const previousPageBorderBoxCenter: Position = getPageBorderBoxCenter({
          impact: previousImpact,
          afterCritical,
          draggable: inHome,
          droppable: foreign,
          draggables,
        });
        const previousClientSelection: Position = getClientFromPageBorderBoxCenter(
          {
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: inHome,
            viewport: scrolled,
          },
        );
        // const previousPageBorderBoxCenter: Position =
        //   initiallyOutsideViewport.page.borderBox.center;
        // const previousClientSelection: Position =
        //   initiallyOutsideViewport.client.borderBox.center;

        // figure out where we would have been if it was visible

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: false,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport: scrolled,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: getForcedDisplacement({
            // Even though the item started in an invisible place we force
            // the displacement to be visible.
            visible: [{ dimension: inForeign, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // moving into place of inForeign
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-viewport.spec.js,Lazy Test,"{'line': 150, 'column': 21, 'index': 4768}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        const previousPageBorderBoxCenter: Position =
          inHome.page.borderBox.center;
        const previousClientSelection: Position =
          inHome.client.borderBox.center;

        const previousImpact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: inForeign }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: true,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-viewport.spec.js,Lazy Test,"{'line': 174, 'column': 8, 'index': 5426}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        const previousPageBorderBoxCenter: Position =
          inHome.page.borderBox.center;
        const previousClientSelection: Position =
          inHome.client.borderBox.center;

        const previousImpact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: inForeign }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: true,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-viewport.spec.js,Lazy Test,"{'line': 297, 'column': 8, 'index': 9495}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        // after non-displaced inForeign
        const previousImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy: getDisplacedBy(axis, inHome.displaceBy),
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        const previousPageBorderBoxCenter: Position = getPageBorderBoxCenter({
          impact: previousImpact,
          afterCritical,
          draggable: inHome,
          droppable: foreign,
          draggables,
        });
        const previousClientSelection: Position = getClientFromPageBorderBoxCenter(
          {
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: inHome,
            viewport: scrolled,
          },
        );
        // const previousPageBorderBoxCenter: Position =
        //   initiallyOutsideViewport.page.borderBox.center;
        // const previousClientSelection: Position =
        //   initiallyOutsideViewport.client.borderBox.center;

        // figure out where we would have been if it was visible

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: false,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport: scrolled,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: getForcedDisplacement({
            // Even though the item started in an invisible place we force
            // the displacement to be visible.
            visible: [{ dimension: inForeign, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // moving into place of inForeign
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-viewport.spec.js,Lazy Test,"{'line': 300, 'column': 21, 'index': 9581}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        // after non-displaced inForeign
        const previousImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy: getDisplacedBy(axis, inHome.displaceBy),
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        const previousPageBorderBoxCenter: Position = getPageBorderBoxCenter({
          impact: previousImpact,
          afterCritical,
          draggable: inHome,
          droppable: foreign,
          draggables,
        });
        const previousClientSelection: Position = getClientFromPageBorderBoxCenter(
          {
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: inHome,
            viewport: scrolled,
          },
        );
        // const previousPageBorderBoxCenter: Position =
        //   initiallyOutsideViewport.page.borderBox.center;
        // const previousClientSelection: Position =
        //   initiallyOutsideViewport.client.borderBox.center;

        // figure out where we would have been if it was visible

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: false,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport: scrolled,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: getForcedDisplacement({
            // Even though the item started in an invisible place we force
            // the displacement to be visible.
            visible: [{ dimension: inForeign, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // moving into place of inForeign
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-droppable.spec.js,Conditional Test Logic,"{'line': 42, 'column': 23, 'index': 1743}",Unknown,steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-droppable.spec.js,Eager Test,"{'line': 171, 'column': 21, 'index': 5202}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        const previousPageBorderBoxCenter: Position =
          inHome.page.borderBox.center;
        const previousClientSelection: Position =
          inHome.client.borderBox.center;
        const previousImpact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: inForeign }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: true,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-droppable.spec.js,Eager Test,"{'line': 195, 'column': 8, 'index': 5860}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        const previousPageBorderBoxCenter: Position =
          inHome.page.borderBox.center;
        const previousClientSelection: Position =
          inHome.client.borderBox.center;
        const previousImpact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: inForeign }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: true,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-droppable.spec.js,Eager Test,"{'line': 314, 'column': 8, 'index': 9690}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        // after non-displaced inForeign
        const previousImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy: getDisplacedBy(axis, inHome.displaceBy),
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        const previousPageBorderBoxCenter: Position = getPageBorderBoxCenter({
          impact: previousImpact,
          afterCritical,
          draggable: inHome,
          droppable: scrolled,
          draggables,
        });
        const previousClientSelection: Position = getClientFromPageBorderBoxCenter(
          {
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: inHome,
            viewport,
          },
        );

        // figure out where we would have been if it was visible

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: false,
          draggable: inHome,
          destination: scrolled,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: getForcedDisplacement({
            // Even though the item started in an invisible place we force
            // the displacement to be visible.
            visible: [{ dimension: inForeign, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // moving into place of inForeign
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: scrolled,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-droppable.spec.js,Eager Test,"{'line': 317, 'column': 21, 'index': 9776}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        // after non-displaced inForeign
        const previousImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy: getDisplacedBy(axis, inHome.displaceBy),
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        const previousPageBorderBoxCenter: Position = getPageBorderBoxCenter({
          impact: previousImpact,
          afterCritical,
          draggable: inHome,
          droppable: scrolled,
          draggables,
        });
        const previousClientSelection: Position = getClientFromPageBorderBoxCenter(
          {
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: inHome,
            viewport,
          },
        );

        // figure out where we would have been if it was visible

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: false,
          draggable: inHome,
          destination: scrolled,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: getForcedDisplacement({
            // Even though the item started in an invisible place we force
            // the displacement to be visible.
            visible: [{ dimension: inForeign, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // moving into place of inForeign
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: scrolled,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-droppable.spec.js,Lazy Test,"{'line': 171, 'column': 21, 'index': 5202}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        const previousPageBorderBoxCenter: Position =
          inHome.page.borderBox.center;
        const previousClientSelection: Position =
          inHome.client.borderBox.center;
        const previousImpact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: inForeign }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: true,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-droppable.spec.js,Lazy Test,"{'line': 195, 'column': 8, 'index': 5860}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        const previousPageBorderBoxCenter: Position =
          inHome.page.borderBox.center;
        const previousClientSelection: Position =
          inHome.client.borderBox.center;
        const previousImpact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: inForeign }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: true,
          draggable: inHome,
          destination: foreign,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: foreign,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-droppable.spec.js,Lazy Test,"{'line': 314, 'column': 8, 'index': 9690}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        // after non-displaced inForeign
        const previousImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy: getDisplacedBy(axis, inHome.displaceBy),
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        const previousPageBorderBoxCenter: Position = getPageBorderBoxCenter({
          impact: previousImpact,
          afterCritical,
          draggable: inHome,
          droppable: scrolled,
          draggables,
        });
        const previousClientSelection: Position = getClientFromPageBorderBoxCenter(
          {
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: inHome,
            viewport,
          },
        );

        // figure out where we would have been if it was visible

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: false,
          draggable: inHome,
          destination: scrolled,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: getForcedDisplacement({
            // Even though the item started in an invisible place we force
            // the displacement to be visible.
            visible: [{ dimension: inForeign, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // moving into place of inForeign
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: scrolled,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/moving-to-invisible-place/not-visible-in-droppable.spec.js,Lazy Test,"{'line': 317, 'column': 21, 'index': 9776}","it('should request a jump scroll for movement that is outside of the viewport', () => {
        // after non-displaced inForeign
        const previousImpact: DragImpact = {
          displaced: emptyGroups,
          displacedBy: getDisplacedBy(axis, inHome.displaceBy),
          at: {
            type: 'REORDER',
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index + 1,
            },
          },
        };
        const previousPageBorderBoxCenter: Position = getPageBorderBoxCenter({
          impact: previousImpact,
          afterCritical,
          draggable: inHome,
          droppable: scrolled,
          draggables,
        });
        const previousClientSelection: Position = getClientFromPageBorderBoxCenter(
          {
            pageBorderBoxCenter: previousPageBorderBoxCenter,
            draggable: inHome,
            viewport,
          },
        );

        // figure out where we would have been if it was visible

        const result: ?PublicResult = moveToNextPlace({
          isMovingForward: false,
          draggable: inHome,
          destination: scrolled,
          draggables,
          previousImpact,
          viewport,
          previousPageBorderBoxCenter,
          previousClientSelection,
          afterCritical,
        });
        invariant(result);

        const expectedImpact: DragImpact = {
          displaced: getForcedDisplacement({
            // Even though the item started in an invisible place we force
            // the displacement to be visible.
            visible: [{ dimension: inForeign, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // moving into place of inForeign
            destination: {
              droppableId: foreign.descriptor.id,
              index: inForeign.descriptor.index,
            },
          },
        };
        // if the item would have been visible - where would the center have been?
        const nonVisibleCenter = getPageBorderBoxCenter({
          impact: expectedImpact,
          draggable: inHome,
          droppable: scrolled,
          draggables,
          afterCritical,
        });
        const expectedScrollJump: Position = subtract(
          nonVisibleCenter,
          previousPageBorderBoxCenter,
        );
        const expected: PublicResult = {
          clientSelection: previousClientSelection,
          impact: expectedImpact,
          scrollJumpRequest: expectedScrollJump,
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Conditional Test Logic,"{'line': 16, 'column': 23, 'index': 742}",Unknown,steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 42, 'column': 6, 'index': 1655}","it('should update the impact when moving with items that started displaced', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome2.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const forwardsPastInHome3: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(forwardsPastInHome3);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome3).toEqual(expected);
      }
      const forwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome3,
        afterCritical,
      });
      invariant(forwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome4.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome4).toEqual(expected);
      }

      const backwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastInHome4).toEqual(expected);
      }

      const backwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome2.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsToHome).toEqual(expected);
      }

      const backwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsToHome,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome1.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 45, 'column': 21, 'index': 1755}","it('should update the impact when moving with items that started displaced', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome2.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const forwardsPastInHome3: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(forwardsPastInHome3);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome3).toEqual(expected);
      }
      const forwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome3,
        afterCritical,
      });
      invariant(forwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome4.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome4).toEqual(expected);
      }

      const backwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastInHome4).toEqual(expected);
      }

      const backwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome2.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsToHome).toEqual(expected);
      }

      const backwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsToHome,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome1.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 70, 'column': 6, 'index': 2571}","it('should update the impact when moving with items that started displaced', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome2.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const forwardsPastInHome3: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(forwardsPastInHome3);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome3).toEqual(expected);
      }
      const forwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome3,
        afterCritical,
      });
      invariant(forwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome4.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome4).toEqual(expected);
      }

      const backwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastInHome4).toEqual(expected);
      }

      const backwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome2.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsToHome).toEqual(expected);
      }

      const backwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsToHome,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome1.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 97, 'column': 6, 'index': 3389}","it('should update the impact when moving with items that started displaced', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome2.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const forwardsPastInHome3: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(forwardsPastInHome3);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome3).toEqual(expected);
      }
      const forwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome3,
        afterCritical,
      });
      invariant(forwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome4.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome4).toEqual(expected);
      }

      const backwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastInHome4).toEqual(expected);
      }

      const backwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome2.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsToHome).toEqual(expected);
      }

      const backwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsToHome,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome1.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 100, 'column': 21, 'index': 3490}","it('should update the impact when moving with items that started displaced', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome2.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const forwardsPastInHome3: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(forwardsPastInHome3);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome3).toEqual(expected);
      }
      const forwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome3,
        afterCritical,
      });
      invariant(forwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome4.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome4).toEqual(expected);
      }

      const backwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastInHome4).toEqual(expected);
      }

      const backwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome2.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsToHome).toEqual(expected);
      }

      const backwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsToHome,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome1.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 126, 'column': 6, 'index': 4284}","it('should update the impact when moving with items that started displaced', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome2.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const forwardsPastInHome3: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(forwardsPastInHome3);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome3).toEqual(expected);
      }
      const forwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome3,
        afterCritical,
      });
      invariant(forwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome4.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome4).toEqual(expected);
      }

      const backwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastInHome4).toEqual(expected);
      }

      const backwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome2.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsToHome).toEqual(expected);
      }

      const backwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsToHome,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome1.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 129, 'column': 21, 'index': 4380}","it('should update the impact when moving with items that started displaced', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome2.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const forwardsPastInHome3: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(forwardsPastInHome3);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome3).toEqual(expected);
      }
      const forwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome3,
        afterCritical,
      });
      invariant(forwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome4.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome4).toEqual(expected);
      }

      const backwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastInHome4).toEqual(expected);
      }

      const backwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome2.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsToHome).toEqual(expected);
      }

      const backwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsToHome,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome1.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 158, 'column': 6, 'index': 5240}","it('should update the impact when moving with items that started displaced', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome2.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const forwardsPastInHome3: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(forwardsPastInHome3);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome3).toEqual(expected);
      }
      const forwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome3,
        afterCritical,
      });
      invariant(forwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome4.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome4).toEqual(expected);
      }

      const backwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastInHome4).toEqual(expected);
      }

      const backwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome2.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsToHome).toEqual(expected);
      }

      const backwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsToHome,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome1.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 161, 'column': 21, 'index': 5336}","it('should update the impact when moving with items that started displaced', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome2.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const forwardsPastInHome3: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(forwardsPastInHome3);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome3).toEqual(expected);
      }
      const forwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome3,
        afterCritical,
      });
      invariant(forwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome4.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome4).toEqual(expected);
      }

      const backwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastInHome4).toEqual(expected);
      }

      const backwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome2.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsToHome).toEqual(expected);
      }

      const backwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsToHome,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome1.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 205, 'column': 6, 'index': 6728}","it('should update the impact when moving with items that did not start displaced', () => {
      // dragging inHome3 backwards away from the start
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome3.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const backwardsPastInHome2: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
      });
      invariant(backwardsPastInHome2);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // initial displacement not animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome2).toEqual(expected);
      }

      // move backwards again
      const backwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome2,
        afterCritical,
      });
      invariant(backwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest displaced
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome1).toEqual(expected);
      }

      // move forwards
      const forwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(forwardsPastInHome1).toEqual(expected);
      }

      const forwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome3.descriptor.index,
            },
          },
        };
        expect(forwardsToHome).toEqual(expected);
      }
      const forwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsToHome,
        afterCritical,
      });
      invariant(forwardsPastHome);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(forwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 208, 'column': 21, 'index': 6829}","it('should update the impact when moving with items that did not start displaced', () => {
      // dragging inHome3 backwards away from the start
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome3.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const backwardsPastInHome2: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
      });
      invariant(backwardsPastInHome2);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // initial displacement not animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome2).toEqual(expected);
      }

      // move backwards again
      const backwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome2,
        afterCritical,
      });
      invariant(backwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest displaced
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome1).toEqual(expected);
      }

      // move forwards
      const forwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(forwardsPastInHome1).toEqual(expected);
      }

      const forwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome3.descriptor.index,
            },
          },
        };
        expect(forwardsToHome).toEqual(expected);
      }
      const forwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsToHome,
        afterCritical,
      });
      invariant(forwardsPastHome);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(forwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 239, 'column': 6, 'index': 7826}","it('should update the impact when moving with items that did not start displaced', () => {
      // dragging inHome3 backwards away from the start
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome3.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const backwardsPastInHome2: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
      });
      invariant(backwardsPastInHome2);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // initial displacement not animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome2).toEqual(expected);
      }

      // move backwards again
      const backwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome2,
        afterCritical,
      });
      invariant(backwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest displaced
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome1).toEqual(expected);
      }

      // move forwards
      const forwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(forwardsPastInHome1).toEqual(expected);
      }

      const forwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome3.descriptor.index,
            },
          },
        };
        expect(forwardsToHome).toEqual(expected);
      }
      const forwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsToHome,
        afterCritical,
      });
      invariant(forwardsPastHome);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(forwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 242, 'column': 21, 'index': 7927}","it('should update the impact when moving with items that did not start displaced', () => {
      // dragging inHome3 backwards away from the start
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome3.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const backwardsPastInHome2: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
      });
      invariant(backwardsPastInHome2);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // initial displacement not animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome2).toEqual(expected);
      }

      // move backwards again
      const backwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome2,
        afterCritical,
      });
      invariant(backwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest displaced
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome1).toEqual(expected);
      }

      // move forwards
      const forwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(forwardsPastInHome1).toEqual(expected);
      }

      const forwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome3.descriptor.index,
            },
          },
        };
        expect(forwardsToHome).toEqual(expected);
      }
      const forwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsToHome,
        afterCritical,
      });
      invariant(forwardsPastHome);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(forwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 284, 'column': 6, 'index': 9168}","it('should update the impact when moving with items that did not start displaced', () => {
      // dragging inHome3 backwards away from the start
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome3.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const backwardsPastInHome2: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
      });
      invariant(backwardsPastInHome2);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // initial displacement not animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome2).toEqual(expected);
      }

      // move backwards again
      const backwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome2,
        afterCritical,
      });
      invariant(backwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest displaced
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome1).toEqual(expected);
      }

      // move forwards
      const forwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(forwardsPastInHome1).toEqual(expected);
      }

      const forwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome3.descriptor.index,
            },
          },
        };
        expect(forwardsToHome).toEqual(expected);
      }
      const forwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsToHome,
        afterCritical,
      });
      invariant(forwardsPastHome);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(forwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 287, 'column': 21, 'index': 9268}","it('should update the impact when moving with items that did not start displaced', () => {
      // dragging inHome3 backwards away from the start
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome3.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const backwardsPastInHome2: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
      });
      invariant(backwardsPastInHome2);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // initial displacement not animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome2).toEqual(expected);
      }

      // move backwards again
      const backwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome2,
        afterCritical,
      });
      invariant(backwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest displaced
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome1).toEqual(expected);
      }

      // move forwards
      const forwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(forwardsPastInHome1).toEqual(expected);
      }

      const forwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome3.descriptor.index,
            },
          },
        };
        expect(forwardsToHome).toEqual(expected);
      }
      const forwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsToHome,
        afterCritical,
      });
      invariant(forwardsPastHome);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(forwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 323, 'column': 6, 'index': 10322}","it('should update the impact when moving with items that did not start displaced', () => {
      // dragging inHome3 backwards away from the start
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome3.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const backwardsPastInHome2: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
      });
      invariant(backwardsPastInHome2);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // initial displacement not animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome2).toEqual(expected);
      }

      // move backwards again
      const backwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome2,
        afterCritical,
      });
      invariant(backwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest displaced
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome1).toEqual(expected);
      }

      // move forwards
      const forwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(forwardsPastInHome1).toEqual(expected);
      }

      const forwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome3.descriptor.index,
            },
          },
        };
        expect(forwardsToHome).toEqual(expected);
      }
      const forwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsToHome,
        afterCritical,
      });
      invariant(forwardsPastHome);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(forwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 326, 'column': 21, 'index': 10417}","it('should update the impact when moving with items that did not start displaced', () => {
      // dragging inHome3 backwards away from the start
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome3.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const backwardsPastInHome2: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
      });
      invariant(backwardsPastInHome2);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // initial displacement not animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome2).toEqual(expected);
      }

      // move backwards again
      const backwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome2,
        afterCritical,
      });
      invariant(backwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest displaced
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome1).toEqual(expected);
      }

      // move forwards
      const forwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(forwardsPastInHome1).toEqual(expected);
      }

      const forwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome3.descriptor.index,
            },
          },
        };
        expect(forwardsToHome).toEqual(expected);
      }
      const forwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsToHome,
        afterCritical,
      });
      invariant(forwardsPastHome);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(forwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Eager Test,"{'line': 351, 'column': 6, 'index': 11220}","it('should update the impact when moving with items that did not start displaced', () => {
      // dragging inHome3 backwards away from the start
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome3.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const backwardsPastInHome2: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
      });
      invariant(backwardsPastInHome2);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // initial displacement not animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome2).toEqual(expected);
      }

      // move backwards again
      const backwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome2,
        afterCritical,
      });
      invariant(backwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest displaced
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome1).toEqual(expected);
      }

      // move forwards
      const forwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(forwardsPastInHome1).toEqual(expected);
      }

      const forwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome3.descriptor.index,
            },
          },
        };
        expect(forwardsToHome).toEqual(expected);
      }
      const forwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsToHome,
        afterCritical,
      });
      invariant(forwardsPastHome);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(forwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Lazy Test,"{'line': 42, 'column': 6, 'index': 1655}","it('should update the impact when moving with items that started displaced', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome2.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const forwardsPastInHome3: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(forwardsPastInHome3);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome3).toEqual(expected);
      }
      const forwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome3,
        afterCritical,
      });
      invariant(forwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome4.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome4).toEqual(expected);
      }

      const backwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastInHome4).toEqual(expected);
      }

      const backwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome2.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsToHome).toEqual(expected);
      }

      const backwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsToHome,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome1.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Lazy Test,"{'line': 45, 'column': 21, 'index': 1755}","it('should update the impact when moving with items that started displaced', () => {
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome2.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const forwardsPastInHome3: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(forwardsPastInHome3);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome3).toEqual(expected);
      }
      const forwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome3,
        afterCritical,
      });
      invariant(forwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome4.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(forwardsPastInHome4).toEqual(expected);
      }

      const backwardsPastInHome4: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsPastInHome4);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastInHome4).toEqual(expected);
      }

      const backwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome4,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome2.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsToHome).toEqual(expected);
      }

      const backwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsToHome,
        afterCritical,
      });
      invariant(backwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome1.descriptor.index,
              droppableId: preset.home.descriptor.id,
            },
          },
        };
        expect(backwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Lazy Test,"{'line': 205, 'column': 6, 'index': 6728}","it('should update the impact when moving with items that did not start displaced', () => {
      // dragging inHome3 backwards away from the start
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome3.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const backwardsPastInHome2: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
      });
      invariant(backwardsPastInHome2);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // initial displacement not animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome2).toEqual(expected);
      }

      // move backwards again
      const backwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome2,
        afterCritical,
      });
      invariant(backwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest displaced
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome1).toEqual(expected);
      }

      // move forwards
      const forwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(forwardsPastInHome1).toEqual(expected);
      }

      const forwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome3.descriptor.index,
            },
          },
        };
        expect(forwardsToHome).toEqual(expected);
      }
      const forwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsToHome,
        afterCritical,
      });
      invariant(forwardsPastHome);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(forwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-home-list.spec.js,Lazy Test,"{'line': 208, 'column': 21, 'index': 6829}","it('should update the impact when moving with items that did not start displaced', () => {
      // dragging inHome3 backwards away from the start
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome3.displaceBy,
      );
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const backwardsPastInHome2: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
        afterCritical,
      });
      invariant(backwardsPastInHome2);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // initial displacement not animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome2).toEqual(expected);
      }

      // move backwards again
      const backwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome2,
        afterCritical,
      });
      invariant(backwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest displaced
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(backwardsPastInHome1).toEqual(expected);
      }

      // move forwards
      const forwardsPastInHome1: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: backwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsPastInHome1);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome2,
                shouldAnimate: true,
              },
              {
                // initial displacement not animated
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(forwardsPastInHome1).toEqual(expected);
      }

      const forwardsToHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsPastInHome1,
        afterCritical,
      });
      invariant(forwardsToHome);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome3.descriptor.index,
            },
          },
        };
        expect(forwardsToHome).toEqual(expected);
      }
      const forwardsPastHome: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome3,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inHomeList,
        previousImpact: forwardsToHome,
        afterCritical,
      });
      invariant(forwardsPastHome);
      {
        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(forwardsPastHome).toEqual(expected);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Conditional Test Logic,"{'line': 16, 'column': 23, 'index': 742}",Unknown,steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Duplicate Assert,"{'line': 182, 'column': 8, 'index': 5803}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Duplicate Assert,"{'line': 184, 'column': 8, 'index': 5887}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Duplicate Assert,"{'line': 344, 'column': 8, 'index': 10739}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Duplicate Assert,"{'line': 346, 'column': 8, 'index': 10823}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 36, 'column': 19, 'index': 1501}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 65, 'column': 6, 'index': 2348}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 68, 'column': 21, 'index': 2434}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 98, 'column': 6, 'index': 3311}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 101, 'column': 21, 'index': 3398}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 130, 'column': 6, 'index': 4272}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 133, 'column': 21, 'index': 4358}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 162, 'column': 6, 'index': 5206}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 165, 'column': 21, 'index': 5293}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 191, 'column': 19, 'index': 6186}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 219, 'column': 6, 'index': 6990}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 222, 'column': 21, 'index': 7076}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 253, 'column': 6, 'index': 8004}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 256, 'column': 21, 'index': 8091}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 290, 'column': 6, 'index': 9135}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 293, 'column': 21, 'index': 9221}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 325, 'column': 6, 'index': 10190}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 328, 'column': 21, 'index': 10277}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 390, 'column': 19, 'index': 12151}","it('should allow displaced into a spot after the last item in a list', () => {
      // cross axis move inHome1 before inForeign4
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inForeign4 }],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          // currently in the spot that inForeign4 initially occupied
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign4.descriptor.index,
          },
        },
      };

      // move forwards into spot after inForeign4

      const impact: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(impact);
      const expected: DragImpact = {
        // nothing is displaced at this point
        displaced: emptyGroups,
        displacedBy,
        at: {
          type: 'REORDER',
          // trying to move after spot after inForeign4
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign4.descriptor.index + 1,
          },
        },
      };
      expect(impact).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Eager Test,"{'line': 417, 'column': 6, 'index': 12979}","it('should allow displaced into a spot after the last item in a list', () => {
      // cross axis move inHome1 before inForeign4
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inForeign4 }],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          // currently in the spot that inForeign4 initially occupied
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign4.descriptor.index,
          },
        },
      };

      // move forwards into spot after inForeign4

      const impact: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(impact);
      const expected: DragImpact = {
        // nothing is displaced at this point
        displaced: emptyGroups,
        displacedBy,
        at: {
          type: 'REORDER',
          // trying to move after spot after inForeign4
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign4.descriptor.index + 1,
          },
        },
      };
      expect(impact).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Lazy Test,"{'line': 36, 'column': 19, 'index': 1501}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Lazy Test,"{'line': 65, 'column': 6, 'index': 2348}","it('should update the impact when moving after where we started in the foreign start', () => {
      // inHome1 has made its way into index #2 of foreign after a cross axis move

      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };

      // moving forward
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving forward again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inForeign4 }],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign4.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving backwards towards where we started in the foreign list

      // moving backwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Lazy Test,"{'line': 191, 'column': 19, 'index': 6186}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Lazy Test,"{'line': 219, 'column': 6, 'index': 6990}","it('should update the impact when moving before where we started in the foreign list', () => {
      // inHome1 has made its way into index #3 of foreign after a cross axis move
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign3.descriptor.index,
          },
        },
      };

      // moving backwards
      const first: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(first);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(first).toEqual(expected);
      }

      // moving backwards again
      const second: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: first,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(second);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inForeign1 },
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index,
            },
          },
        };
        expect(second).toEqual(expected);
      }

      // now moving forwards towards where we started in the foreign list

      // moving forwards
      const third: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: second,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(third);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(third).toEqual(expected);
      }

      // moving forwards again
      const fourth: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: third,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(fourth);
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(fourth).toEqual(expected);
        // also now back where we started
        expect(fourth).toEqual(crossAxisMove);
      }
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Lazy Test,"{'line': 353, 'column': 19, 'index': 11065}","it('should not allow displaced before the start of the list', () => {
      // cross axis move inHome1 before inForeign1
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign1.descriptor.index,
          },
        },
      };

      // cannot move backwards

      const impact: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.home,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });

      expect(impact).toBe(null);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Lazy Test,"{'line': 390, 'column': 19, 'index': 12151}","it('should allow displaced into a spot after the last item in a list', () => {
      // cross axis move inHome1 before inForeign4
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inForeign4 }],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          // currently in the spot that inForeign4 initially occupied
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign4.descriptor.index,
          },
        },
      };

      // move forwards into spot after inForeign4

      const impact: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(impact);
      const expected: DragImpact = {
        // nothing is displaced at this point
        displaced: emptyGroups,
        displacedBy,
        at: {
          type: 'REORDER',
          // trying to move after spot after inForeign4
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign4.descriptor.index + 1,
          },
        },
      };
      expect(impact).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Lazy Test,"{'line': 417, 'column': 6, 'index': 12979}","it('should allow displaced into a spot after the last item in a list', () => {
      // cross axis move inHome1 before inForeign4
      const crossAxisMove: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inForeign4 }],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          // currently in the spot that inForeign4 initially occupied
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign4.descriptor.index,
          },
        },
      };

      // move forwards into spot after inForeign4

      const impact: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: crossAxisMove,
        afterCritical,
        viewport: preset.viewport,
      });
      invariant(impact);
      const expected: DragImpact = {
        // nothing is displaced at this point
        displaced: emptyGroups,
        displacedBy,
        at: {
          type: 'REORDER',
          // trying to move after spot after inForeign4
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign4.descriptor.index + 1,
          },
        },
      };
      expect(impact).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-reorder/in-foreign-list.spec.js,Lazy Test,"{'line': 478, 'column': 19, 'index': 14861}","it('should allow displaced back from after the last item in a list', () => {
      const impact: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: preset.foreign,
        insideDestination: preset.inForeignList,
        previousImpact: atEndOfForeignList,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inForeign4 }],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          // now in position of inForeign4
          destination: {
            droppableId: preset.foreign.descriptor.id,
            index: preset.inForeign4.descriptor.index,
          },
        },
      };
      expect(impact).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/started-after-critical.spec.js,Conditional Test Logic,"{'line': 19, 'column': 23, 'index': 746}",Unknown,steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/started-after-critical.spec.js,Eager Test,"{'line': 113, 'column': 19, 'index': 3820}","it('should move backwards past combining with an item that started displaced - but now is not', () => {
      // inHome2 moved past inHome3 and then backwards onto it
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          // inHome3 now displaced
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: combining,
        afterCritical,
      });

      // backwards movement should displace inHome3
      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inHome3 now displaced
          visible: [
            { dimension: preset.inHome3, shouldAnimate: true },
            { dimension: preset.inHome4, shouldAnimate: false },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome2.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/started-after-critical.spec.js,Eager Test,"{'line': 141, 'column': 19, 'index': 4731}","it('should move backwards past combining with an item that started displaced - but now is not', () => {
      // inHome2 moved past inHome3 and then backwards onto it
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          // inHome3 now displaced
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: combining,
        afterCritical,
      });

      // backwards movement should displace inHome3
      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inHome3 now displaced
          visible: [
            { dimension: preset.inHome3, shouldAnimate: true },
            { dimension: preset.inHome4, shouldAnimate: false },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome2.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/started-after-critical.spec.js,Eager Test,"{'line': 170, 'column': 19, 'index': 5709}","it('should move forwards past combining with an item that started displaced - but now is not', () => {
      // inHome2 moved past inHome3 and then backwards onto it
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          // preset.inHome3 is no longer displaced
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: combining,
        afterCritical,
      });

      const expected: DragImpact = {
        // forwards movement off inHome3. It will leave inHome3 in the same spot and go after it
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome3.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/started-after-critical.spec.js,Eager Test,"{'line': 198, 'column': 19, 'index': 6680}","it('should move forwards past combining with an item that started displaced - but now is not', () => {
      // inHome2 moved past inHome3 and then backwards onto it
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          // preset.inHome3 is no longer displaced
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: combining,
        afterCritical,
      });

      const expected: DragImpact = {
        // forwards movement off inHome3. It will leave inHome3 in the same spot and go after it
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome3.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/started-after-critical.spec.js,Lazy Test,"{'line': 88, 'column': 19, 'index': 2931}","it('should move forward past a combining an item that is displaced', () => {
      // inHome2 combining with inHome3
      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        ...homeImpact,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: combining,
        afterCritical,
      });

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inHome3 now displaced
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome3.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/started-after-critical.spec.js,Lazy Test,"{'line': 113, 'column': 19, 'index': 3820}","it('should move backwards past combining with an item that started displaced - but now is not', () => {
      // inHome2 moved past inHome3 and then backwards onto it
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          // inHome3 now displaced
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: false,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: combining,
        afterCritical,
      });

      // backwards movement should displace inHome3
      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inHome3 now displaced
          visible: [
            { dimension: preset.inHome3, shouldAnimate: true },
            { dimension: preset.inHome4, shouldAnimate: false },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome2.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/started-after-critical.spec.js,Lazy Test,"{'line': 170, 'column': 19, 'index': 5709}","it('should move forwards past combining with an item that started displaced - but now is not', () => {
      // inHome2 moved past inHome3 and then backwards onto it
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome2,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });

      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          // preset.inHome3 is no longer displaced
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        viewport: preset.viewport,
        isMovingForward: true,
        isInHomeList: true,
        draggable: preset.inHome2,
        draggables: preset.draggables,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: combining,
        afterCritical,
      });

      const expected: DragImpact = {
        // forwards movement off inHome3. It will leave inHome3 in the same spot and go after it
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome3.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,Conditional Test Logic,"{'line': 19, 'column': 23, 'index': 746}",Unknown,steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,Eager Test,"{'line': 32, 'column': 19, 'index': 1345}","it('should move forward off combining with is displaced', () => {
      // Setup: inHome1 combining with inForeign1 and then moving forward past it
      // Expected: inHome1 moves after inForeign1 and inForeign1 is no longer displaced
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign1.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: combining,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        // inForeign1 no longer displaced
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,Eager Test,"{'line': 64, 'column': 19, 'index': 2367}","it('should move forward off combining with is displaced', () => {
      // Setup: inHome1 combining with inForeign1 and then moving forward past it
      // Expected: inHome1 moves after inForeign1 and inForeign1 is no longer displaced
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign1.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: combining,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        // inForeign1 no longer displaced
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,Eager Test,"{'line': 151, 'column': 19, 'index': 5214}","it('should move forward off combining with a non-displaced item', () => {
      // Setup
      // - inHome1 past inForeign1
      // - inHome1 moves backwards onto inForeign1
      // - inHome1 moves forwards off inForeign1
      // Expected
      // - inHome1 moves before inForeign1
      // - inForeign1 becomes displaced
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          // inForeign1 is not displaced
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        // moved backward onto inForeign1
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign1.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: combining,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inForeign1 still not displaced
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,Eager Test,"{'line': 183, 'column': 19, 'index': 6231}","it('should move forward off combining with a non-displaced item', () => {
      // Setup
      // - inHome1 past inForeign1
      // - inHome1 moves backwards onto inForeign1
      // - inHome1 moves forwards off inForeign1
      // Expected
      // - inHome1 moves before inForeign1
      // - inForeign1 becomes displaced
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          // inForeign1 is not displaced
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        // moved backward onto inForeign1
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign1.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: combining,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inForeign1 still not displaced
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,Eager Test,"{'line': 219, 'column': 19, 'index': 7394}","it('should move backward off combining with a non-displaced item', () => {
      // Setup
      // - inHome1 past inForeign1
      // - inHome1 moves backwards onto inForeign1
      // - inHome1 moves backwards off inForeign1
      // Expected
      // - inHome1 moves forward off inForeign1
      // - no displacement changes
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            // inForeign1 not displaced
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          // moved backward onto inForeign1
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign1.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: combining,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inForeign1 now displaced
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign1.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,Eager Test,"{'line': 251, 'column': 19, 'index': 8413}","it('should move backward off combining with a non-displaced item', () => {
      // Setup
      // - inHome1 past inForeign1
      // - inHome1 moves backwards onto inForeign1
      // - inHome1 moves backwards off inForeign1
      // Expected
      // - inHome1 moves forward off inForeign1
      // - no displacement changes
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            // inForeign1 not displaced
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          // moved backward onto inForeign1
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign1.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: combining,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inForeign1 now displaced
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign1.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,Lazy Test,"{'line': 32, 'column': 19, 'index': 1345}","it('should move forward off combining with is displaced', () => {
      // Setup: inHome1 combining with inForeign1 and then moving forward past it
      // Expected: inHome1 moves after inForeign1 and inForeign1 is no longer displaced
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign1.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: combining,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        // inForeign1 no longer displaced
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,Lazy Test,"{'line': 93, 'column': 19, 'index': 3392}","it('should move backward off combining with is displaced', () => {
      // Setup: inHome1 combining with inForeign1 and then moving backward before it
      // Expected: inHome1 goes before inForeign1 and displacement is not changed
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign1.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: combining,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        ...combining,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign1.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,Lazy Test,"{'line': 151, 'column': 19, 'index': 5214}","it('should move forward off combining with a non-displaced item', () => {
      // Setup
      // - inHome1 past inForeign1
      // - inHome1 moves backwards onto inForeign1
      // - inHome1 moves forwards off inForeign1
      // Expected
      // - inHome1 moves before inForeign1
      // - inForeign1 becomes displaced
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          // inForeign1 is not displaced
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        // moved backward onto inForeign1
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign1.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        isMovingForward: true,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: combining,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inForeign1 still not displaced
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-index/from-combine/did-not-start-after-critical.spec.js,Lazy Test,"{'line': 219, 'column': 19, 'index': 7394}","it('should move backward off combining with a non-displaced item', () => {
      // Setup
      // - inHome1 past inForeign1
      // - inHome1 moves backwards onto inForeign1
      // - inHome1 moves backwards off inForeign1
      // Expected
      // - inHome1 moves forward off inForeign1
      // - no displacement changes
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const combining: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            // inForeign1 not displaced
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          // moved backward onto inForeign1
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign1.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextIndex({
        isMovingForward: false,
        isInHomeList: false,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: combining,
        afterCritical,
        viewport: preset.viewport,
      });

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inForeign1 now displaced
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome1.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign1.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,Conditional Test Logic,"{'line': 20, 'column': 23, 'index': 790}",Unknown,steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,Eager Test,"{'line': 57, 'column': 19, 'index': 1982}","it('should move onto an item that started displaced - but now is not', () => {
      // inHome2 moved forward past inHome3 and now moving back onto inHome3

      const pastInHome3: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome3.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      const moveBackwardsOntoInHome3: ?DragImpact = moveToNextCombine({
        isMovingForward: false,
        draggable: preset.inHome2,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: pastInHome3,
      });
      invariant(moveBackwardsOntoInHome3);

      const expected: DragImpact = {
        ...pastInHome3,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(moveBackwardsOntoInHome3).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,Eager Test,"{'line': 76, 'column': 6, 'index': 2652}","it('should move onto an item that started displaced - but now is not', () => {
      // inHome2 moved forward past inHome3 and now moving back onto inHome3

      const pastInHome3: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome3.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      const moveBackwardsOntoInHome3: ?DragImpact = moveToNextCombine({
        isMovingForward: false,
        draggable: preset.inHome2,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: pastInHome3,
      });
      invariant(moveBackwardsOntoInHome3);

      const expected: DragImpact = {
        ...pastInHome3,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(moveBackwardsOntoInHome3).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,Eager Test,"{'line': 126, 'column': 19, 'index': 4163}","it('should move onto an item that did not start displaced but now is', () => {
      // inHome3 moved backward before inHome2 and now moving back onto inHome2

      const beforeInHome2: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inHome2 },
            // originally displaced
            { dimension: preset.inHome4, shouldAnimate: false },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome3.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome2.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const moveForwardsOntoInHome2: ?DragImpact = moveToNextCombine({
        isMovingForward: true,
        draggable: preset.inHome3,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: beforeInHome2,
      });
      invariant(moveForwardsOntoInHome2);

      const expected: DragImpact = {
        ...beforeInHome2,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome2.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(moveForwardsOntoInHome2).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,Eager Test,"{'line': 150, 'column': 6, 'index': 4938}","it('should move onto an item that did not start displaced but now is', () => {
      // inHome3 moved backward before inHome2 and now moving back onto inHome2

      const beforeInHome2: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inHome2 },
            // originally displaced
            { dimension: preset.inHome4, shouldAnimate: false },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome3.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome2.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const moveForwardsOntoInHome2: ?DragImpact = moveToNextCombine({
        isMovingForward: true,
        draggable: preset.inHome3,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: beforeInHome2,
      });
      invariant(moveForwardsOntoInHome2);

      const expected: DragImpact = {
        ...beforeInHome2,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome2.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(moveForwardsOntoInHome2).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,Lazy Test,"{'line': 38, 'column': 6, 'index': 1431}","it('should move onto an item that started displaced', () => {
      const { impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome2,
        draggables: preset.draggables,
        home: preset.home,
        viewport: preset.viewport,
      });

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: true,
        draggable: preset.inHome2,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
      });
      invariant(result);

      const expected: DragImpact = {
        ...homeImpact,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,Lazy Test,"{'line': 57, 'column': 19, 'index': 1982}","it('should move onto an item that started displaced - but now is not', () => {
      // inHome2 moved forward past inHome3 and now moving back onto inHome3

      const pastInHome3: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome3.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      const moveBackwardsOntoInHome3: ?DragImpact = moveToNextCombine({
        isMovingForward: false,
        draggable: preset.inHome2,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: pastInHome3,
      });
      invariant(moveBackwardsOntoInHome3);

      const expected: DragImpact = {
        ...pastInHome3,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(moveBackwardsOntoInHome3).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,Lazy Test,"{'line': 76, 'column': 6, 'index': 2652}","it('should move onto an item that started displaced - but now is not', () => {
      // inHome2 moved forward past inHome3 and now moving back onto inHome3

      const pastInHome3: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome3.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      const moveBackwardsOntoInHome3: ?DragImpact = moveToNextCombine({
        isMovingForward: false,
        draggable: preset.inHome2,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: pastInHome3,
      });
      invariant(moveBackwardsOntoInHome3);

      const expected: DragImpact = {
        ...pastInHome3,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(moveBackwardsOntoInHome3).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,Lazy Test,"{'line': 107, 'column': 6, 'index': 3607}","it('should move onto an item that did not start displaced', () => {
      // moving inHome3 backwards onto inHome2
      const { impact: homeImpact } = getLiftEffect({
        draggable: preset.inHome3,
        draggables: preset.draggables,
        home: preset.home,
        viewport: preset.viewport,
      });

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: false,
        draggable: preset.inHome3,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: homeImpact,
      });
      invariant(result);

      const expected: DragImpact = {
        ...homeImpact,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome2.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,Lazy Test,"{'line': 126, 'column': 19, 'index': 4163}","it('should move onto an item that did not start displaced but now is', () => {
      // inHome3 moved backward before inHome2 and now moving back onto inHome2

      const beforeInHome2: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inHome2 },
            // originally displaced
            { dimension: preset.inHome4, shouldAnimate: false },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome3.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome2.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const moveForwardsOntoInHome2: ?DragImpact = moveToNextCombine({
        isMovingForward: true,
        draggable: preset.inHome3,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: beforeInHome2,
      });
      invariant(moveForwardsOntoInHome2);

      const expected: DragImpact = {
        ...beforeInHome2,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome2.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(moveForwardsOntoInHome2).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-home-list.legacy.spec.js,Lazy Test,"{'line': 150, 'column': 6, 'index': 4938}","it('should move onto an item that did not start displaced but now is', () => {
      // inHome3 moved backward before inHome2 and now moving back onto inHome2

      const beforeInHome2: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inHome2 },
            // originally displaced
            { dimension: preset.inHome4, shouldAnimate: false },
          ],
        }),
        displacedBy: getDisplacedBy(axis, preset.inHome3.displaceBy),
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome2.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const moveForwardsOntoInHome2: ?DragImpact = moveToNextCombine({
        isMovingForward: true,
        draggable: preset.inHome3,
        destination: enableCombine(preset.home),
        insideDestination: preset.inHomeList,
        previousImpact: beforeInHome2,
      });
      invariant(moveForwardsOntoInHome2);

      const expected: DragImpact = {
        ...beforeInHome2,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome2.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };
      expect(moveForwardsOntoInHome2).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-foreign-list.legacy.spec.js,Conditional Test Logic,"{'line': 21, 'column': 23, 'index': 801}",Unknown,steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-foreign-list.legacy.spec.js,Eager Test,"{'line': 35, 'column': 19, 'index': 1277}","it('should move onto a displaced item when moving forwards', () => {
      // inHome1 cross axis moved after inForeign1,
      // now moving forward onto inForeign2
      const current: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: true,
        draggable: preset.inHome1,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: current,
      });
      invariant(result);

      const expected: DragImpact = {
        ...current,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign2.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-foreign-list.legacy.spec.js,Eager Test,"{'line': 59, 'column': 6, 'index': 1986}","it('should move onto a displaced item when moving forwards', () => {
      // inHome1 cross axis moved after inForeign1,
      // now moving forward onto inForeign2
      const current: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: true,
        draggable: preset.inHome1,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: current,
      });
      invariant(result);

      const expected: DragImpact = {
        ...current,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign2.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-foreign-list.legacy.spec.js,Eager Test,"{'line': 79, 'column': 19, 'index': 2613}","it('should move onto a non-displaced item when moving backwards', () => {
      // inHome1 in foreign list after inForeign2
      // moving backwards will move it onto the non-displaced inForeign2
      // ordered by closest impacted
      const current: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign3.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: false,
        draggable: preset.inHome1,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: current,
      });
      invariant(result);

      // no change to displacement
      const expected: DragImpact = {
        ...current,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign2.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-foreign-list.legacy.spec.js,Eager Test,"{'line': 102, 'column': 6, 'index': 3277}","it('should move onto a non-displaced item when moving backwards', () => {
      // inHome1 in foreign list after inForeign2
      // moving backwards will move it onto the non-displaced inForeign2
      // ordered by closest impacted
      const current: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign3.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: false,
        draggable: preset.inHome1,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: current,
      });
      invariant(result);

      // no change to displacement
      const expected: DragImpact = {
        ...current,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign2.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-foreign-list.legacy.spec.js,Lazy Test,"{'line': 35, 'column': 19, 'index': 1277}","it('should move onto a displaced item when moving forwards', () => {
      // inHome1 cross axis moved after inForeign1,
      // now moving forward onto inForeign2
      const current: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: true,
        draggable: preset.inHome1,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: current,
      });
      invariant(result);

      const expected: DragImpact = {
        ...current,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign2.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-foreign-list.legacy.spec.js,Lazy Test,"{'line': 59, 'column': 6, 'index': 1986}","it('should move onto a displaced item when moving forwards', () => {
      // inHome1 cross axis moved after inForeign1,
      // now moving forward onto inForeign2
      const current: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign2.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: true,
        draggable: preset.inHome1,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: current,
      });
      invariant(result);

      const expected: DragImpact = {
        ...current,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign2.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-foreign-list.legacy.spec.js,Lazy Test,"{'line': 79, 'column': 19, 'index': 2613}","it('should move onto a non-displaced item when moving backwards', () => {
      // inHome1 in foreign list after inForeign2
      // moving backwards will move it onto the non-displaced inForeign2
      // ordered by closest impacted
      const current: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign3.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: false,
        draggable: preset.inHome1,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: current,
      });
      invariant(result);

      // no change to displacement
      const expected: DragImpact = {
        ...current,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign2.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-foreign-list.legacy.spec.js,Lazy Test,"{'line': 102, 'column': 6, 'index': 3277}","it('should move onto a non-displaced item when moving backwards', () => {
      // inHome1 in foreign list after inForeign2
      // moving backwards will move it onto the non-displaced inForeign2
      // ordered by closest impacted
      const current: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inForeign3.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: false,
        draggable: preset.inHome1,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: current,
      });
      invariant(result);

      // no change to displacement
      const expected: DragImpact = {
        ...current,
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inForeign2.descriptor.id,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };
      expect(result).toEqual(expected);
    })",steel
/test/unit/state/move-in-direction/move-to-next-place/move-to-next-combine/in-foreign-list.legacy.spec.js,Lazy Test,"{'line': 120, 'column': 19, 'index': 3782}","it('should not allow combining with anything before the first item', () => {
      const current: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inForeign1 },
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          // in first position
          destination: {
            index: preset.inForeign1.descriptor.index,
            droppableId: preset.foreign.descriptor.id,
          },
        },
      };

      const result: ?DragImpact = moveToNextCombine({
        isMovingForward: false,
        draggable: preset.inHome1,
        destination: enableCombine(preset.foreign),
        insideDestination: preset.inForeignList,
        previousImpact: current,
      });

      expect(result).toEqual(null);
    })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-home-list.spec.js,Conditional Test Logic,"{'line': 20, 'column': 23, 'index': 821}",Unknown,steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-home-list.spec.js,Eager Test,"{'line': 71, 'column': 8, 'index': 2539}","it('should return a home impact with the original location', () => {
        // the second draggable is moving back into its preset.home
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome2,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome2.displaceBy,
        );

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: dontCare,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          moveRelativeTo: preset.inHome2,
          destination: preset.home,
          insideDestination: preset.inHomeList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // unlike the original displacement, this will be animated
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-home-list.spec.js,Eager Test,"{'line': 74, 'column': 21, 'index': 2619}","it('should return a home impact with the original location', () => {
        // the second draggable is moving back into its preset.home
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome2,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome2.displaceBy,
        );

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: dontCare,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          moveRelativeTo: preset.inHome2,
          destination: preset.home,
          insideDestination: preset.inHomeList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // unlike the original displacement, this will be animated
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-home-list.spec.js,Eager Test,"{'line': 118, 'column': 8, 'index': 4063}","it('should move the everything after the target index forward', () => {
        // moving preset.inHome4 into the preset.inHome2 position
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome4,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome4.displaceBy,
        );

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: dontCare,
          draggable: preset.inHome4,
          draggables: preset.draggables,
          moveRelativeTo: preset.inHome2,
          destination: preset.home,
          insideDestination: preset.inHomeList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2 },
              { dimension: preset.inHome3 },
              // inHome4 not displaced!
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-home-list.spec.js,Eager Test,"{'line': 121, 'column': 21, 'index': 4143}","it('should move the everything after the target index forward', () => {
        // moving preset.inHome4 into the preset.inHome2 position
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome4,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome4.displaceBy,
        );

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: dontCare,
          draggable: preset.inHome4,
          draggables: preset.draggables,
          moveRelativeTo: preset.inHome2,
          destination: preset.home,
          insideDestination: preset.inHomeList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2 },
              { dimension: preset.inHome3 },
              // inHome4 not displaced!
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-home-list.spec.js,Lazy Test,"{'line': 71, 'column': 8, 'index': 2539}","it('should return a home impact with the original location', () => {
        // the second draggable is moving back into its preset.home
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome2,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome2.displaceBy,
        );

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: dontCare,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          moveRelativeTo: preset.inHome2,
          destination: preset.home,
          insideDestination: preset.inHomeList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // unlike the original displacement, this will be animated
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-home-list.spec.js,Lazy Test,"{'line': 74, 'column': 21, 'index': 2619}","it('should return a home impact with the original location', () => {
        // the second draggable is moving back into its preset.home
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome2,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome2.displaceBy,
        );

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: dontCare,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          moveRelativeTo: preset.inHome2,
          destination: preset.home,
          insideDestination: preset.inHomeList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // unlike the original displacement, this will be animated
            visible: [
              { dimension: preset.inHome3 },
              { dimension: preset.inHome4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-home-list.spec.js,Lazy Test,"{'line': 118, 'column': 8, 'index': 4063}","it('should move the everything after the target index forward', () => {
        // moving preset.inHome4 into the preset.inHome2 position
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome4,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome4.displaceBy,
        );

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: dontCare,
          draggable: preset.inHome4,
          draggables: preset.draggables,
          moveRelativeTo: preset.inHome2,
          destination: preset.home,
          insideDestination: preset.inHomeList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2 },
              { dimension: preset.inHome3 },
              // inHome4 not displaced!
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-home-list.spec.js,Lazy Test,"{'line': 121, 'column': 21, 'index': 4143}","it('should move the everything after the target index forward', () => {
        // moving preset.inHome4 into the preset.inHome2 position
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome4,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome4.displaceBy,
        );

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: dontCare,
          draggable: preset.inHome4,
          draggables: preset.draggables,
          moveRelativeTo: preset.inHome2,
          destination: preset.home,
          insideDestination: preset.inHomeList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2 },
              { dimension: preset.inHome3 },
              // inHome4 not displaced!
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-home-list.spec.js,Lazy Test,"{'line': 164, 'column': 8, 'index': 5549}","it('should move the everything from the target index to the original index forward', () => {
        // moving inHome1 after inHome4
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome1,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome1.displaceBy,
        );
        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: dontCare,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          moveRelativeTo: preset.inHome4,
          destination: preset.home,
          insideDestination: preset.inHomeList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome4.descriptor.index,
            },
          },
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Conditional Test Logic,"{'line': 36, 'column': 23, 'index': 1309}",Unknown,steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Duplicate Assert,"{'line': 121, 'column': 12, 'index': 4351}","it('should not move into the start of list if the position is not visible due to droppable scroll', () => {
          const whatNewCenterWouldBeWithoutScroll: Position = goIntoStart({
            axis,
            moveInto: preset.emptyForeign.page,
            isMoving: preset.inHome1.page,
          });
          const totalShift: Position = subtract(
            whatNewCenterWouldBeWithoutScroll,
            preset.inHome1.page.borderBox.center,
          );
          const shiftedInHome1Page: Spacing = offsetByPosition(
            preset.inHome1.page.borderBox,
            totalShift,
          );
          invariant(preset.emptyForeign.subject.active);
          const maxAllowableScroll: Position = negate(
            subtract(
              patch(axis.line, preset.emptyForeign.subject.active[axis.start]),
              patch(axis.line, shiftedInHome1Page[axis.start]),
            ),
          );
          const pastMaxAllowableScroll: Position = add(
            maxAllowableScroll,
            patch(axis.line, 1),
          );

          // validation: no scrolled droppable
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }

          // center on visible edge = can move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.foreign,
              maxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              maxAllowableScroll,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }
          // center past visible edge = cannot move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.emptyForeign,
              pastMaxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              pastMaxAllowableScroll,
            );
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Duplicate Assert,"{'line': 121, 'column': 12, 'index': 4351}","it('should not move into the start of list if the position is not visible due to droppable scroll', () => {
          const whatNewCenterWouldBeWithoutScroll: Position = goIntoStart({
            axis,
            moveInto: preset.emptyForeign.page,
            isMoving: preset.inHome1.page,
          });
          const totalShift: Position = subtract(
            whatNewCenterWouldBeWithoutScroll,
            preset.inHome1.page.borderBox.center,
          );
          const shiftedInHome1Page: Spacing = offsetByPosition(
            preset.inHome1.page.borderBox,
            totalShift,
          );
          invariant(preset.emptyForeign.subject.active);
          const maxAllowableScroll: Position = negate(
            subtract(
              patch(axis.line, preset.emptyForeign.subject.active[axis.start]),
              patch(axis.line, shiftedInHome1Page[axis.start]),
            ),
          );
          const pastMaxAllowableScroll: Position = add(
            maxAllowableScroll,
            patch(axis.line, 1),
          );

          // validation: no scrolled droppable
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }

          // center on visible edge = can move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.foreign,
              maxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              maxAllowableScroll,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }
          // center past visible edge = cannot move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.emptyForeign,
              pastMaxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              pastMaxAllowableScroll,
            );
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Duplicate Assert,"{'line': 145, 'column': 12, 'index': 5170}","it('should not move into the start of list if the position is not visible due to droppable scroll', () => {
          const whatNewCenterWouldBeWithoutScroll: Position = goIntoStart({
            axis,
            moveInto: preset.emptyForeign.page,
            isMoving: preset.inHome1.page,
          });
          const totalShift: Position = subtract(
            whatNewCenterWouldBeWithoutScroll,
            preset.inHome1.page.borderBox.center,
          );
          const shiftedInHome1Page: Spacing = offsetByPosition(
            preset.inHome1.page.borderBox,
            totalShift,
          );
          invariant(preset.emptyForeign.subject.active);
          const maxAllowableScroll: Position = negate(
            subtract(
              patch(axis.line, preset.emptyForeign.subject.active[axis.start]),
              patch(axis.line, shiftedInHome1Page[axis.start]),
            ),
          );
          const pastMaxAllowableScroll: Position = add(
            maxAllowableScroll,
            patch(axis.line, 1),
          );

          // validation: no scrolled droppable
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }

          // center on visible edge = can move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.foreign,
              maxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              maxAllowableScroll,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }
          // center past visible edge = cannot move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.emptyForeign,
              pastMaxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              pastMaxAllowableScroll,
            );
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Duplicate Assert,"{'line': 145, 'column': 12, 'index': 5170}","it('should not move into the start of list if the position is not visible due to droppable scroll', () => {
          const whatNewCenterWouldBeWithoutScroll: Position = goIntoStart({
            axis,
            moveInto: preset.emptyForeign.page,
            isMoving: preset.inHome1.page,
          });
          const totalShift: Position = subtract(
            whatNewCenterWouldBeWithoutScroll,
            preset.inHome1.page.borderBox.center,
          );
          const shiftedInHome1Page: Spacing = offsetByPosition(
            preset.inHome1.page.borderBox,
            totalShift,
          );
          invariant(preset.emptyForeign.subject.active);
          const maxAllowableScroll: Position = negate(
            subtract(
              patch(axis.line, preset.emptyForeign.subject.active[axis.start]),
              patch(axis.line, shiftedInHome1Page[axis.start]),
            ),
          );
          const pastMaxAllowableScroll: Position = add(
            maxAllowableScroll,
            patch(axis.line, 1),
          );

          // validation: no scrolled droppable
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }

          // center on visible edge = can move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.foreign,
              maxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              maxAllowableScroll,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }
          // center past visible edge = cannot move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.emptyForeign,
              pastMaxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              pastMaxAllowableScroll,
            );
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Duplicate Assert,"{'line': 168, 'column': 12, 'index': 6006}","it('should not move into the start of list if the position is not visible due to droppable scroll', () => {
          const whatNewCenterWouldBeWithoutScroll: Position = goIntoStart({
            axis,
            moveInto: preset.emptyForeign.page,
            isMoving: preset.inHome1.page,
          });
          const totalShift: Position = subtract(
            whatNewCenterWouldBeWithoutScroll,
            preset.inHome1.page.borderBox.center,
          );
          const shiftedInHome1Page: Spacing = offsetByPosition(
            preset.inHome1.page.borderBox,
            totalShift,
          );
          invariant(preset.emptyForeign.subject.active);
          const maxAllowableScroll: Position = negate(
            subtract(
              patch(axis.line, preset.emptyForeign.subject.active[axis.start]),
              patch(axis.line, shiftedInHome1Page[axis.start]),
            ),
          );
          const pastMaxAllowableScroll: Position = add(
            maxAllowableScroll,
            patch(axis.line, 1),
          );

          // validation: no scrolled droppable
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }

          // center on visible edge = can move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.foreign,
              maxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              maxAllowableScroll,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }
          // center past visible edge = cannot move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.emptyForeign,
              pastMaxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              pastMaxAllowableScroll,
            );
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Duplicate Assert,"{'line': 202, 'column': 12, 'index': 7295}","it('should not move into the start of list if the position is not visible due to page scroll', () => {
          const emptyForeignPageBox: BoxModel = preset.emptyForeign.page;

          // How far to the start of the droppable content box?
          const distanceToStartOfDroppableContextBox: number =
            emptyForeignPageBox.marginBox[axis.start] +
            distanceToContentBoxStart(emptyForeignPageBox);

          const onVisibleStartEdge: Position = patch(
            axis.line,
            distanceToStartOfDroppableContextBox +
              preset.inHome1.page.margin[axis.start],
          );
          const pastVisibleStartEdge: Position = add(
            onVisibleStartEdge,
            patch(axis.line, 1),
          );
          // validate with no scroll
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              destination: preset.emptyForeign,
              moveRelativeTo: null,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBeTruthy();
          }
          // center on visible edge = can move
          {
            const scrolled: Viewport = scrollViewport(
              viewport,
              onVisibleStartEdge,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              destination: preset.emptyForeign,
              moveRelativeTo: null,
              insideDestination: [],
              viewport: scrolled,
              afterCritical,
            });

            expect(result).toBeTruthy();
          }
          // start is no longer visible = cannot move
          {
            const scrolled: Viewport = scrollViewport(
              viewport,
              pastVisibleStartEdge,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport: scrolled,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Duplicate Assert,"{'line': 202, 'column': 12, 'index': 7295}","it('should not move into the start of list if the position is not visible due to page scroll', () => {
          const emptyForeignPageBox: BoxModel = preset.emptyForeign.page;

          // How far to the start of the droppable content box?
          const distanceToStartOfDroppableContextBox: number =
            emptyForeignPageBox.marginBox[axis.start] +
            distanceToContentBoxStart(emptyForeignPageBox);

          const onVisibleStartEdge: Position = patch(
            axis.line,
            distanceToStartOfDroppableContextBox +
              preset.inHome1.page.margin[axis.start],
          );
          const pastVisibleStartEdge: Position = add(
            onVisibleStartEdge,
            patch(axis.line, 1),
          );
          // validate with no scroll
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              destination: preset.emptyForeign,
              moveRelativeTo: null,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBeTruthy();
          }
          // center on visible edge = can move
          {
            const scrolled: Viewport = scrollViewport(
              viewport,
              onVisibleStartEdge,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              destination: preset.emptyForeign,
              moveRelativeTo: null,
              insideDestination: [],
              viewport: scrolled,
              afterCritical,
            });

            expect(result).toBeTruthy();
          }
          // start is no longer visible = cannot move
          {
            const scrolled: Viewport = scrollViewport(
              viewport,
              pastVisibleStartEdge,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport: scrolled,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Duplicate Assert,"{'line': 222, 'column': 12, 'index': 7965}","it('should not move into the start of list if the position is not visible due to page scroll', () => {
          const emptyForeignPageBox: BoxModel = preset.emptyForeign.page;

          // How far to the start of the droppable content box?
          const distanceToStartOfDroppableContextBox: number =
            emptyForeignPageBox.marginBox[axis.start] +
            distanceToContentBoxStart(emptyForeignPageBox);

          const onVisibleStartEdge: Position = patch(
            axis.line,
            distanceToStartOfDroppableContextBox +
              preset.inHome1.page.margin[axis.start],
          );
          const pastVisibleStartEdge: Position = add(
            onVisibleStartEdge,
            patch(axis.line, 1),
          );
          // validate with no scroll
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              destination: preset.emptyForeign,
              moveRelativeTo: null,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBeTruthy();
          }
          // center on visible edge = can move
          {
            const scrolled: Viewport = scrollViewport(
              viewport,
              onVisibleStartEdge,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              destination: preset.emptyForeign,
              moveRelativeTo: null,
              insideDestination: [],
              viewport: scrolled,
              afterCritical,
            });

            expect(result).toBeTruthy();
          }
          // start is no longer visible = cannot move
          {
            const scrolled: Viewport = scrollViewport(
              viewport,
              pastVisibleStartEdge,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport: scrolled,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Duplicate Assert,"{'line': 222, 'column': 12, 'index': 7965}","it('should not move into the start of list if the position is not visible due to page scroll', () => {
          const emptyForeignPageBox: BoxModel = preset.emptyForeign.page;

          // How far to the start of the droppable content box?
          const distanceToStartOfDroppableContextBox: number =
            emptyForeignPageBox.marginBox[axis.start] +
            distanceToContentBoxStart(emptyForeignPageBox);

          const onVisibleStartEdge: Position = patch(
            axis.line,
            distanceToStartOfDroppableContextBox +
              preset.inHome1.page.margin[axis.start],
          );
          const pastVisibleStartEdge: Position = add(
            onVisibleStartEdge,
            patch(axis.line, 1),
          );
          // validate with no scroll
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              destination: preset.emptyForeign,
              moveRelativeTo: null,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBeTruthy();
          }
          // center on visible edge = can move
          {
            const scrolled: Viewport = scrollViewport(
              viewport,
              onVisibleStartEdge,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              destination: preset.emptyForeign,
              moveRelativeTo: null,
              insideDestination: [],
              viewport: scrolled,
              afterCritical,
            });

            expect(result).toBeTruthy();
          }
          // start is no longer visible = cannot move
          {
            const scrolled: Viewport = scrollViewport(
              viewport,
              pastVisibleStartEdge,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport: scrolled,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Duplicate Assert,"{'line': 242, 'column': 12, 'index': 8644}","it('should not move into the start of list if the position is not visible due to page scroll', () => {
          const emptyForeignPageBox: BoxModel = preset.emptyForeign.page;

          // How far to the start of the droppable content box?
          const distanceToStartOfDroppableContextBox: number =
            emptyForeignPageBox.marginBox[axis.start] +
            distanceToContentBoxStart(emptyForeignPageBox);

          const onVisibleStartEdge: Position = patch(
            axis.line,
            distanceToStartOfDroppableContextBox +
              preset.inHome1.page.margin[axis.start],
          );
          const pastVisibleStartEdge: Position = add(
            onVisibleStartEdge,
            patch(axis.line, 1),
          );
          // validate with no scroll
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              destination: preset.emptyForeign,
              moveRelativeTo: null,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBeTruthy();
          }
          // center on visible edge = can move
          {
            const scrolled: Viewport = scrollViewport(
              viewport,
              onVisibleStartEdge,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              destination: preset.emptyForeign,
              moveRelativeTo: null,
              insideDestination: [],
              viewport: scrolled,
              afterCritical,
            });

            expect(result).toBeTruthy();
          }
          // start is no longer visible = cannot move
          {
            const scrolled: Viewport = scrollViewport(
              viewport,
              pastVisibleStartEdge,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport: scrolled,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Eager Test,"{'line': 308, 'column': 8, 'index': 10855}","it('should move the target and everything below it forward', () => {
        // moving home1 into the second position of the list

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          // moving before target
          moveRelativeTo: preset.inForeign2,
          destination: preset.foreign,
          insideDestination: preset.inForeignList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };

        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Eager Test,"{'line': 311, 'column': 21, 'index': 10935}","it('should move the target and everything below it forward', () => {
        // moving home1 into the second position of the list

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          // moving before target
          moveRelativeTo: preset.inForeign2,
          destination: preset.foreign,
          insideDestination: preset.inForeignList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };

        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Lazy Test,"{'line': 60, 'column': 8, 'index': 2173}","it('should move into the first position of the list', () => {
        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          moveRelativeTo: null,
          destination: preset.emptyForeign,
          insideDestination: [],
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy: noDisplacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.emptyForeign.descriptor.id,
              index: 0,
            },
          },
        };

        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Lazy Test,"{'line': 97, 'column': 10, 'index': 3431}","it('should not move into the start of list if the position is not visible due to droppable scroll', () => {
          const whatNewCenterWouldBeWithoutScroll: Position = goIntoStart({
            axis,
            moveInto: preset.emptyForeign.page,
            isMoving: preset.inHome1.page,
          });
          const totalShift: Position = subtract(
            whatNewCenterWouldBeWithoutScroll,
            preset.inHome1.page.borderBox.center,
          );
          const shiftedInHome1Page: Spacing = offsetByPosition(
            preset.inHome1.page.borderBox,
            totalShift,
          );
          invariant(preset.emptyForeign.subject.active);
          const maxAllowableScroll: Position = negate(
            subtract(
              patch(axis.line, preset.emptyForeign.subject.active[axis.start]),
              patch(axis.line, shiftedInHome1Page[axis.start]),
            ),
          );
          const pastMaxAllowableScroll: Position = add(
            maxAllowableScroll,
            patch(axis.line, 1),
          );

          // validation: no scrolled droppable
          {
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: preset.emptyForeign,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }

          // center on visible edge = can move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.foreign,
              maxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              maxAllowableScroll,
            );

            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });
            expect(result).toBeTruthy();
          }
          // center past visible edge = cannot move
          {
            const scrollable: DroppableDimension = makeScrollable(
              preset.emptyForeign,
              pastMaxAllowableScroll[axis.line],
            );
            const scrolled: DroppableDimension = scrollDroppable(
              scrollable,
              pastMaxAllowableScroll,
            );
            const result: ?DragImpact = moveToNewDroppable({
              previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              moveRelativeTo: null,
              destination: scrolled,
              insideDestination: [],
              viewport,
              afterCritical,
            });

            expect(result).toBe(null);
          }
        })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Lazy Test,"{'line': 308, 'column': 8, 'index': 10855}","it('should move the target and everything below it forward', () => {
        // moving home1 into the second position of the list

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          // moving before target
          moveRelativeTo: preset.inForeign2,
          destination: preset.foreign,
          insideDestination: preset.inForeignList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };

        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Lazy Test,"{'line': 311, 'column': 21, 'index': 10935}","it('should move the target and everything below it forward', () => {
        // moving home1 into the second position of the list

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          // moving before target
          moveRelativeTo: preset.inForeign2,
          destination: preset.foreign,
          insideDestination: preset.inForeignList,
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };

        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Lazy Test,"{'line': 360, 'column': 21, 'index': 12581}","it('should move the target and everything below it forward', () => {
        // moving inHome3 relative to inForeign1 (will go after inForeign1)
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome1,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome3.displaceBy,
        );
        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
          draggable: preset.inHome3,
          draggables: preset.draggables,
          // moving relative to inForeign1
          // will actually go after it
          moveRelativeTo: preset.inForeign1,
          destination: preset.foreign,
          insideDestination: preset.inForeignList,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // everything after inForeign1
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign2 },
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign2.descriptor.index,
            },
          },
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/move-to-new-droppable/to-foreign-list.spec.js,Lazy Test,"{'line': 408, 'column': 8, 'index': 14260}","it('should go after the non-displaced last item in the list', () => {
        // Moving inHome4 relative to inForeign1
        // Stripping out all the other items in the foreign so that we
        // are sure to move after the last item (inForeign1)
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome4,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome4.displaceBy,
        );

        const result: ?DragImpact = moveToNewDroppable({
          previousPageBorderBoxCenter: preset.inHome1.page.borderBox.center,
          draggable: preset.inHome4,
          draggables: preset.draggables,
          moveRelativeTo: preset.inForeign1,
          destination: preset.foreign,
          insideDestination: [preset.inForeign1],
          viewport,
          afterCritical,
        });
        invariant(result);

        const expected: DragImpact = {
          displaced: emptyGroups,
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign1.descriptor.index + 1,
            },
          },
        };
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/move-in-direction/move-cross-axis/get-closest-draggable/without-starting-displacement.spec.js,Conditional Test Logic,"{'line': 24, 'column': 23, 'index': 955}",Unknown,steel
/test/unit/state/move-in-direction/move-cross-axis/get-closest-draggable/with-starting-displacement.spec.js,Conditional Test Logic,"{'line': 27, 'column': 23, 'index': 1248}",Unknown,steel
/test/unit/state/move-in-direction/move-cross-axis/get-closest-draggable/with-starting-displacement.spec.js,Duplicate Assert,"{'line': 120, 'column': 8, 'index': 3772}","it('should find the closest draggable based on the items visible position (without initial displacement)', () => {
      const center: Position = patch(
        axis.line,
        inHome2.page.borderBox.center[axis.line],
        100,
      );

      {
        const result: ?DraggableDimension = getClosestDraggable({
          pageBorderBoxCenter: center,
          destination: home,
          insideDestination,
          viewport,
          afterCritical,
        });
        expect(result).toEqual(inHome3);
      }
      // validation: without initial displacement it would have been inHome2
      {
        const result: ?DraggableDimension = getClosestDraggable({
          pageBorderBoxCenter: center,
          destination: home,
          insideDestination,
          viewport,
          afterCritical: noAfterCritical,
        });
        expect(result).toEqual(inHome2);
      }
    })",steel
/test/unit/state/move-in-direction/move-cross-axis/get-closest-draggable/with-starting-displacement.spec.js,Duplicate Assert,"{'line': 131, 'column': 8, 'index': 4143}","it('should find the closest draggable based on the items visible position (without initial displacement)', () => {
      const center: Position = patch(
        axis.line,
        inHome2.page.borderBox.center[axis.line],
        100,
      );

      {
        const result: ?DraggableDimension = getClosestDraggable({
          pageBorderBoxCenter: center,
          destination: home,
          insideDestination,
          viewport,
          afterCritical,
        });
        expect(result).toEqual(inHome3);
      }
      // validation: without initial displacement it would have been inHome2
      {
        const result: ?DraggableDimension = getClosestDraggable({
          pageBorderBoxCenter: center,
          destination: home,
          insideDestination,
          viewport,
          afterCritical: noAfterCritical,
        });
        expect(result).toEqual(inHome2);
      }
    })",steel
/test/unit/state/middleware/validate-indexes.spec.js,Duplicate Assert,"{'line': 74, 'column': 2, 'index': 2346}","it('should log a warning if items are added that do not have consecutive indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome2: DraggableDimension = {
    ...preset.inHome2,
    descriptor: {
      ...preset.inHome2.descriptor,
      index: preset.inHome2.descriptor.index + 5,
    },
  };
  const copied: DimensionMap = copy(preset.dimensions);
  copied.draggables[preset.inHome2.descriptor.id] = customInHome2;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(copied),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions: copied,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    // dimensions will be ordered by index
    // inHome1: index 0: all good
    // inHome3: index 2: boom
    // inHome4: index 3: all good (2 + 1)
    // inHome2: index 6: boom
    expect.stringContaining(`0, [ðŸ”¥2], 3, [ðŸ”¥6]`),
  );

  warn.mockRestore();
})",steel
/test/unit/state/middleware/validate-indexes.spec.js,Duplicate Assert,"{'line': 75, 'column': 2, 'index': 2399}","it('should log a warning if items are added that do not have consecutive indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome2: DraggableDimension = {
    ...preset.inHome2,
    descriptor: {
      ...preset.inHome2.descriptor,
      index: preset.inHome2.descriptor.index + 5,
    },
  };
  const copied: DimensionMap = copy(preset.dimensions);
  copied.draggables[preset.inHome2.descriptor.id] = customInHome2;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(copied),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions: copied,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    // dimensions will be ordered by index
    // inHome1: index 0: all good
    // inHome3: index 2: boom
    // inHome4: index 3: all good (2 + 1)
    // inHome2: index 6: boom
    expect.stringContaining(`0, [ðŸ”¥2], 3, [ðŸ”¥6]`),
  );

  warn.mockRestore();
})",steel
/test/unit/state/middleware/validate-indexes.spec.js,Duplicate Assert,"{'line': 76, 'column': 2, 'index': 2445}","it('should log a warning if items are added that do not have consecutive indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome2: DraggableDimension = {
    ...preset.inHome2,
    descriptor: {
      ...preset.inHome2.descriptor,
      index: preset.inHome2.descriptor.index + 5,
    },
  };
  const copied: DimensionMap = copy(preset.dimensions);
  copied.draggables[preset.inHome2.descriptor.id] = customInHome2;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(copied),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions: copied,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    // dimensions will be ordered by index
    // inHome1: index 0: all good
    // inHome3: index 2: boom
    // inHome4: index 3: all good (2 + 1)
    // inHome2: index 6: boom
    expect.stringContaining(`0, [ðŸ”¥2], 3, [ðŸ”¥6]`),
  );

  warn.mockRestore();
})",steel
/test/unit/state/middleware/validate-indexes.spec.js,Duplicate Assert,"{'line': 77, 'column': 2, 'index': 2523}","it('should log a warning if items are added that do not have consecutive indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome2: DraggableDimension = {
    ...preset.inHome2,
    descriptor: {
      ...preset.inHome2.descriptor,
      index: preset.inHome2.descriptor.index + 5,
    },
  };
  const copied: DimensionMap = copy(preset.dimensions);
  copied.draggables[preset.inHome2.descriptor.id] = customInHome2;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(copied),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions: copied,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    // dimensions will be ordered by index
    // inHome1: index 0: all good
    // inHome3: index 2: boom
    // inHome4: index 3: all good (2 + 1)
    // inHome2: index 6: boom
    expect.stringContaining(`0, [ðŸ”¥2], 3, [ðŸ”¥6]`),
  );

  warn.mockRestore();
})",steel
/test/unit/state/middleware/validate-indexes.spec.js,Duplicate Assert,"{'line': 78, 'column': 2, 'index': 2585}","it('should log a warning if items are added that do not have consecutive indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome2: DraggableDimension = {
    ...preset.inHome2,
    descriptor: {
      ...preset.inHome2.descriptor,
      index: preset.inHome2.descriptor.index + 5,
    },
  };
  const copied: DimensionMap = copy(preset.dimensions);
  copied.draggables[preset.inHome2.descriptor.id] = customInHome2;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(copied),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions: copied,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    // dimensions will be ordered by index
    // inHome1: index 0: all good
    // inHome3: index 2: boom
    // inHome4: index 3: all good (2 + 1)
    // inHome2: index 6: boom
    expect.stringContaining(`0, [ðŸ”¥2], 3, [ðŸ”¥6]`),
  );

  warn.mockRestore();
})",steel
/test/unit/state/middleware/validate-indexes.spec.js,Duplicate Assert,"{'line': 125, 'column': 2, 'index': 4014}","it('should log a warning if items are added have duplicate indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome4: DraggableDimension = {
    ...preset.inHome4,
    descriptor: {
      ...preset.inHome4.descriptor,
      // duplicate index
      index: preset.inHome3.descriptor.index,
    },
  };
  const dimensions: DimensionMap = copy(preset.dimensions);
  dimensions.draggables[preset.inHome4.descriptor.id] = customInHome4;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(dimensions),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('0, 1, [ðŸ”¥2], [ðŸ”¥2]'),
  );

  warn.mockRestore();
})",steel
/test/unit/state/middleware/validate-indexes.spec.js,Duplicate Assert,"{'line': 126, 'column': 2, 'index': 4067}","it('should log a warning if items are added have duplicate indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome4: DraggableDimension = {
    ...preset.inHome4,
    descriptor: {
      ...preset.inHome4.descriptor,
      // duplicate index
      index: preset.inHome3.descriptor.index,
    },
  };
  const dimensions: DimensionMap = copy(preset.dimensions);
  dimensions.draggables[preset.inHome4.descriptor.id] = customInHome4;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(dimensions),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('0, 1, [ðŸ”¥2], [ðŸ”¥2]'),
  );

  warn.mockRestore();
})",steel
/test/unit/state/middleware/validate-indexes.spec.js,Duplicate Assert,"{'line': 127, 'column': 2, 'index': 4113}","it('should log a warning if items are added have duplicate indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome4: DraggableDimension = {
    ...preset.inHome4,
    descriptor: {
      ...preset.inHome4.descriptor,
      // duplicate index
      index: preset.inHome3.descriptor.index,
    },
  };
  const dimensions: DimensionMap = copy(preset.dimensions);
  dimensions.draggables[preset.inHome4.descriptor.id] = customInHome4;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(dimensions),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('0, 1, [ðŸ”¥2], [ðŸ”¥2]'),
  );

  warn.mockRestore();
})",steel
/test/unit/state/middleware/validate-indexes.spec.js,Duplicate Assert,"{'line': 128, 'column': 2, 'index': 4191}","it('should log a warning if items are added have duplicate indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome4: DraggableDimension = {
    ...preset.inHome4,
    descriptor: {
      ...preset.inHome4.descriptor,
      // duplicate index
      index: preset.inHome3.descriptor.index,
    },
  };
  const dimensions: DimensionMap = copy(preset.dimensions);
  dimensions.draggables[preset.inHome4.descriptor.id] = customInHome4;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(dimensions),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('0, 1, [ðŸ”¥2], [ðŸ”¥2]'),
  );

  warn.mockRestore();
})",steel
/test/unit/state/middleware/validate-indexes.spec.js,Duplicate Assert,"{'line': 129, 'column': 2, 'index': 4253}","it('should log a warning if items are added have duplicate indexes', () => {
  const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

  const mock = jest.fn();
  const customInHome4: DraggableDimension = {
    ...preset.inHome4,
    descriptor: {
      ...preset.inHome4.descriptor,
      // duplicate index
      index: preset.inHome3.descriptor.index,
    },
  };
  const dimensions: DimensionMap = copy(preset.dimensions);
  dimensions.draggables[preset.inHome4.descriptor.id] = customInHome4;

  const marshal: DimensionMarshal = createMarshal(
    getPopulatedRegistry(dimensions),
    // lazy use of store.dispatch
    (action) =>
      // eslint-disable-next-line no-use-before-define
      store.dispatch(action),
  );
  const store: Store = createStore(passThrough(mock), middleware(marshal));
  const initial: InitialPublishArgs = {
    ...initialPublishArgs,
    dimensions,
  };

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledWith(initialPublish(initial));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');

  // a warning is logged
  expect(warn).toHaveBeenCalled();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('0, 1, [ðŸ”¥2], [ðŸ”¥2]'),
  );

  warn.mockRestore();
})",steel
/test/unit/state/middleware/style.spec.js,Conditional Test Logic,"{'line': 47, 'column': 21, 'index': 1435}","it('should use the resting styles when a drop completes', () => {
  ['DROP', 'CANCEL'].forEach((reason: DropReason) => {
    const marshal: StyleMarshal = getMarshalStub();
    const store: Store = createStore(middleware(marshal));

    store.dispatch(initialPublish(initialPublishArgs));

    expect(marshal.resting).not.toHaveBeenCalled();
    store.dispatch(completeDrop(getCompletedArgs(reason)));

    expect(marshal.resting).toHaveBeenCalled();
  });
})",steel
/test/unit/state/middleware/style.spec.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1642}","it('should use the resting styles when a drop completes', () => {
  ['DROP', 'CANCEL'].forEach((reason: DropReason) => {
    const marshal: StyleMarshal = getMarshalStub();
    const store: Store = createStore(middleware(marshal));

    store.dispatch(initialPublish(initialPublishArgs));

    expect(marshal.resting).not.toHaveBeenCalled();
    store.dispatch(completeDrop(getCompletedArgs(reason)));

    expect(marshal.resting).toHaveBeenCalled();
  });
})",steel
/test/unit/state/middleware/style.spec.js,Duplicate Assert,"{'line': 56, 'column': 4, 'index': 1755}","it('should use the resting styles when a drop completes', () => {
  ['DROP', 'CANCEL'].forEach((reason: DropReason) => {
    const marshal: StyleMarshal = getMarshalStub();
    const store: Store = createStore(middleware(marshal));

    store.dispatch(initialPublish(initialPublishArgs));

    expect(marshal.resting).not.toHaveBeenCalled();
    store.dispatch(completeDrop(getCompletedArgs(reason)));

    expect(marshal.resting).toHaveBeenCalled();
  });
})",steel
/test/unit/state/middleware/style.spec.js,Duplicate Assert,"{'line': 66, 'column': 2, 'index': 2033}","it('should use the resting styles when aborting', () => {
  const marshal: StyleMarshal = getMarshalStub();
  const store: Store = createStore(middleware(marshal));

  store.dispatch(initialPublish(initialPublishArgs));

  expect(marshal.resting).not.toHaveBeenCalled();
  store.dispatch(flush());

  expect(marshal.resting).toHaveBeenCalled();
})",steel
/test/unit/state/middleware/style.spec.js,Duplicate Assert,"{'line': 69, 'column': 2, 'index': 2111}","it('should use the resting styles when aborting', () => {
  const marshal: StyleMarshal = getMarshalStub();
  const store: Store = createStore(middleware(marshal));

  store.dispatch(initialPublish(initialPublishArgs));

  expect(marshal.resting).not.toHaveBeenCalled();
  store.dispatch(flush());

  expect(marshal.resting).toHaveBeenCalled();
})",steel
/test/unit/state/middleware/pending-drop.spec.js,Duplicate Assert,"{'line': 45, 'column': 2, 'index': 1400}","it('should trigger a drop on a dynamic publish if a drop pending is waiting', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    // will fire the pending drop action
    dropMiddleware,
    middleware,
  );

  store.dispatch(initialPublish(initialPublishWithScrollables));
  store.dispatch(collectionStarting());
  store.dispatch(drop({ reason: 'DROP' }));

  const postDrop: State = store.getState();
  invariant(
    postDrop.phase === 'DROP_PENDING',
    `Incorrect phase : ${postDrop.phase}`,
  );
  expect(postDrop.isWaiting).toBe(true);

  // This will finish the drag
  mock.mockReset();
  store.dispatch(publishWhileDragging(publishAdditionArgs));

  expect(mock).toHaveBeenCalledWith(drop({ reason: 'DROP' }));

  expect(mock).toHaveBeenCalledWith(
    // $ExpectError - this calculation is not completed by this module and it is non trival
    completeDrop({
      completed: expect.any(Object),
    }),
  );
  expect(mock).toHaveBeenCalledTimes(3);
  expect(store.getState().phase).toBe('IDLE');
})",steel
/test/unit/state/middleware/pending-drop.spec.js,Duplicate Assert,"{'line': 47, 'column': 2, 'index': 1464}","it('should trigger a drop on a dynamic publish if a drop pending is waiting', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    // will fire the pending drop action
    dropMiddleware,
    middleware,
  );

  store.dispatch(initialPublish(initialPublishWithScrollables));
  store.dispatch(collectionStarting());
  store.dispatch(drop({ reason: 'DROP' }));

  const postDrop: State = store.getState();
  invariant(
    postDrop.phase === 'DROP_PENDING',
    `Incorrect phase : ${postDrop.phase}`,
  );
  expect(postDrop.isWaiting).toBe(true);

  // This will finish the drag
  mock.mockReset();
  store.dispatch(publishWhileDragging(publishAdditionArgs));

  expect(mock).toHaveBeenCalledWith(drop({ reason: 'DROP' }));

  expect(mock).toHaveBeenCalledWith(
    // $ExpectError - this calculation is not completed by this module and it is non trival
    completeDrop({
      completed: expect.any(Object),
    }),
  );
  expect(mock).toHaveBeenCalledTimes(3);
  expect(store.getState().phase).toBe('IDLE');
})",steel
/test/unit/state/middleware/pending-drop.spec.js,Duplicate Assert,"{'line': 53, 'column': 2, 'index': 1662}","it('should trigger a drop on a dynamic publish if a drop pending is waiting', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    // will fire the pending drop action
    dropMiddleware,
    middleware,
  );

  store.dispatch(initialPublish(initialPublishWithScrollables));
  store.dispatch(collectionStarting());
  store.dispatch(drop({ reason: 'DROP' }));

  const postDrop: State = store.getState();
  invariant(
    postDrop.phase === 'DROP_PENDING',
    `Incorrect phase : ${postDrop.phase}`,
  );
  expect(postDrop.isWaiting).toBe(true);

  // This will finish the drag
  mock.mockReset();
  store.dispatch(publishWhileDragging(publishAdditionArgs));

  expect(mock).toHaveBeenCalledWith(drop({ reason: 'DROP' }));

  expect(mock).toHaveBeenCalledWith(
    // $ExpectError - this calculation is not completed by this module and it is non trival
    completeDrop({
      completed: expect.any(Object),
    }),
  );
  expect(mock).toHaveBeenCalledTimes(3);
  expect(store.getState().phase).toBe('IDLE');
})",steel
/test/unit/state/middleware/pending-drop.spec.js,Duplicate Assert,"{'line': 72, 'column': 2, 'index': 2189}","it('should not trigger a drop on a publish if a drop is not pending', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    // will fire the pending drop action
    dropMiddleware,
    middleware,
  );

  store.dispatch(initialPublish(initialPublishWithScrollables));
  store.dispatch(collectionStarting());

  mock.mockReset();
  store.dispatch(publishWhileDragging(publishAdditionArgs));

  expect(mock).toHaveBeenCalledWith(publishWhileDragging(publishAdditionArgs));
  expect(mock).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/pending-drop.spec.js,Duplicate Assert,"{'line': 73, 'column': 2, 'index': 2269}","it('should not trigger a drop on a publish if a drop is not pending', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    // will fire the pending drop action
    dropMiddleware,
    middleware,
  );

  store.dispatch(initialPublish(initialPublishWithScrollables));
  store.dispatch(collectionStarting());

  mock.mockReset();
  store.dispatch(publishWhileDragging(publishAdditionArgs));

  expect(mock).toHaveBeenCalledWith(publishWhileDragging(publishAdditionArgs));
  expect(mock).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/lift.spec.js,Duplicate Assert,"{'line': 84, 'column': 2, 'index': 2447}","it('should flush any animating drops', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // start a drag
  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');

  const completed: CompletedDrag = getCompletedArgs('DROP').completed;

  // start a drop
  const args: AnimateDropArgs = {
    newHomeClientOffset: { x: -1, y: -1 },
    dropDuration: 1,
    completed,
  };
  store.dispatch(animateDrop(args));
  expect(store.getState().phase).toBe('DROP_ANIMATING');

  // while drop animating a lift occurs
  mock.mockReset();
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // the previous drag is flushed
  expect(mock).toHaveBeenCalledWith(completeDrop({ completed }));
  // any animations are flushed
  expect(mock).toHaveBeenCalledWith(flush());
  // a before capture is fired
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  // the new lift continues
  expect(mock).toHaveBeenCalledTimes(5);
})",steel
/test/unit/state/middleware/lift.spec.js,Duplicate Assert,"{'line': 95, 'column': 2, 'index': 2744}","it('should flush any animating drops', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // start a drag
  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');

  const completed: CompletedDrag = getCompletedArgs('DROP').completed;

  // start a drop
  const args: AnimateDropArgs = {
    newHomeClientOffset: { x: -1, y: -1 },
    dropDuration: 1,
    completed,
  };
  store.dispatch(animateDrop(args));
  expect(store.getState().phase).toBe('DROP_ANIMATING');

  // while drop animating a lift occurs
  mock.mockReset();
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // the previous drag is flushed
  expect(mock).toHaveBeenCalledWith(completeDrop({ completed }));
  // any animations are flushed
  expect(mock).toHaveBeenCalledWith(flush());
  // a before capture is fired
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  // the new lift continues
  expect(mock).toHaveBeenCalledTimes(5);
})",steel
/test/unit/state/middleware/lift.spec.js,Duplicate Assert,"{'line': 100, 'column': 2, 'index': 2896}","it('should flush any animating drops', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // start a drag
  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');

  const completed: CompletedDrag = getCompletedArgs('DROP').completed;

  // start a drop
  const args: AnimateDropArgs = {
    newHomeClientOffset: { x: -1, y: -1 },
    dropDuration: 1,
    completed,
  };
  store.dispatch(animateDrop(args));
  expect(store.getState().phase).toBe('DROP_ANIMATING');

  // while drop animating a lift occurs
  mock.mockReset();
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // the previous drag is flushed
  expect(mock).toHaveBeenCalledWith(completeDrop({ completed }));
  // any animations are flushed
  expect(mock).toHaveBeenCalledWith(flush());
  // a before capture is fired
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  // the new lift continues
  expect(mock).toHaveBeenCalledTimes(5);
})",steel
/test/unit/state/middleware/lift.spec.js,Duplicate Assert,"{'line': 102, 'column': 2, 'index': 2983}","it('should flush any animating drops', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // start a drag
  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');

  const completed: CompletedDrag = getCompletedArgs('DROP').completed;

  // start a drop
  const args: AnimateDropArgs = {
    newHomeClientOffset: { x: -1, y: -1 },
    dropDuration: 1,
    completed,
  };
  store.dispatch(animateDrop(args));
  expect(store.getState().phase).toBe('DROP_ANIMATING');

  // while drop animating a lift occurs
  mock.mockReset();
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // the previous drag is flushed
  expect(mock).toHaveBeenCalledWith(completeDrop({ completed }));
  // any animations are flushed
  expect(mock).toHaveBeenCalledWith(flush());
  // a before capture is fired
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  // the new lift continues
  expect(mock).toHaveBeenCalledTimes(5);
})",steel
/test/unit/state/middleware/lift.spec.js,Duplicate Assert,"{'line': 104, 'column': 2, 'index': 3081}","it('should flush any animating drops', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // start a drag
  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');

  const completed: CompletedDrag = getCompletedArgs('DROP').completed;

  // start a drop
  const args: AnimateDropArgs = {
    newHomeClientOffset: { x: -1, y: -1 },
    dropDuration: 1,
    completed,
  };
  store.dispatch(animateDrop(args));
  expect(store.getState().phase).toBe('DROP_ANIMATING');

  // while drop animating a lift occurs
  mock.mockReset();
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // the previous drag is flushed
  expect(mock).toHaveBeenCalledWith(completeDrop({ completed }));
  // any animations are flushed
  expect(mock).toHaveBeenCalledWith(flush());
  // a before capture is fired
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  // the new lift continues
  expect(mock).toHaveBeenCalledTimes(5);
})",steel
/test/unit/state/middleware/lift.spec.js,Duplicate Assert,"{'line': 106, 'column': 2, 'index': 3158}","it('should flush any animating drops', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // start a drag
  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');

  const completed: CompletedDrag = getCompletedArgs('DROP').completed;

  // start a drop
  const args: AnimateDropArgs = {
    newHomeClientOffset: { x: -1, y: -1 },
    dropDuration: 1,
    completed,
  };
  store.dispatch(animateDrop(args));
  expect(store.getState().phase).toBe('DROP_ANIMATING');

  // while drop animating a lift occurs
  mock.mockReset();
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // the previous drag is flushed
  expect(mock).toHaveBeenCalledWith(completeDrop({ completed }));
  // any animations are flushed
  expect(mock).toHaveBeenCalledWith(flush());
  // a before capture is fired
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  // the new lift continues
  expect(mock).toHaveBeenCalledTimes(5);
})",steel
/test/unit/state/middleware/lift.spec.js,Duplicate Assert,"{'line': 108, 'column': 2, 'index': 3264}","it('should flush any animating drops', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // start a drag
  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');

  const completed: CompletedDrag = getCompletedArgs('DROP').completed;

  // start a drop
  const args: AnimateDropArgs = {
    newHomeClientOffset: { x: -1, y: -1 },
    dropDuration: 1,
    completed,
  };
  store.dispatch(animateDrop(args));
  expect(store.getState().phase).toBe('DROP_ANIMATING');

  // while drop animating a lift occurs
  mock.mockReset();
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // the previous drag is flushed
  expect(mock).toHaveBeenCalledWith(completeDrop({ completed }));
  // any animations are flushed
  expect(mock).toHaveBeenCalledWith(flush());
  // a before capture is fired
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  // the new lift continues
  expect(mock).toHaveBeenCalledTimes(5);
})",steel
/test/unit/state/middleware/lift.spec.js,Duplicate Assert,"{'line': 124, 'column': 2, 'index': 3638}","it('should publish the initial dimensions when lifting', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // last drag flushed
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(initialPublish(initialPublishArgs));
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');
})",steel
/test/unit/state/middleware/lift.spec.js,Duplicate Assert,"{'line': 126, 'column': 2, 'index': 3714}","it('should publish the initial dimensions when lifting', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // last drag flushed
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(initialPublish(initialPublishArgs));
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');
})",steel
/test/unit/state/middleware/lift.spec.js,Duplicate Assert,"{'line': 127, 'column': 2, 'index': 3760}","it('should publish the initial dimensions when lifting', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // last drag flushed
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(initialPublish(initialPublishArgs));
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');
})",steel
/test/unit/state/middleware/lift.spec.js,Duplicate Assert,"{'line': 128, 'column': 2, 'index': 3833}","it('should publish the initial dimensions when lifting', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // last drag flushed
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(initialPublish(initialPublishArgs));
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');
})",steel
/test/unit/state/middleware/lift.spec.js,Duplicate Assert,"{'line': 129, 'column': 2, 'index': 3911}","it('should publish the initial dimensions when lifting', () => {
  const mock = jest.fn();
  const store: Store = createStore(
    passThrough(mock),
    middleware(
      getBasicMarshal((action: Action) => {
        store.dispatch(action);
      }),
    ),
  );

  // first lift is preparing
  store.dispatch(lift(liftArgs));
  expect(mock).toHaveBeenCalledWith(lift(liftArgs));
  // last drag flushed
  expect(mock).toHaveBeenCalledWith(flush());
  expect(mock).toHaveBeenCalledWith(initialPublish(initialPublishArgs));
  expect(mock).toHaveBeenCalledWith(beforeInitialCapture(beforeCaptureArgs));
  expect(mock).toHaveBeenCalledTimes(4);
  expect(store.getState().phase).toBe('DRAGGING');
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 35, 'column': 2, 'index': 1038}","it('should stop a collection if a drag is aborted', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(middleware(getMarshal(stopPublishing)));

  store.dispatch(initialPublish(initialPublishArgs));

  expect(stopPublishing).not.toHaveBeenCalled();
  store.dispatch(flush());
  expect(stopPublishing).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 37, 'column': 2, 'index': 1114}","it('should stop a collection if a drag is aborted', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(middleware(getMarshal(stopPublishing)));

  store.dispatch(initialPublish(initialPublishArgs));

  expect(stopPublishing).not.toHaveBeenCalled();
  store.dispatch(flush());
  expect(stopPublishing).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 49, 'column': 2, 'index': 1479}","it('should not stop a collection if a drop is pending', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(
    middleware(getMarshal(stopPublishing)),
    // will convert the drop into a drop pending
    dropMiddleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());
  expect(store.getState().phase).toBe('COLLECTING');
  expect(stopPublishing).not.toHaveBeenCalled();

  // dropping
  store.dispatch(drop({ reason: 'DROP' }));
  expect(store.getState().phase).toBe('DROP_PENDING');
  expect(stopPublishing).not.toHaveBeenCalled();
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 51, 'column': 2, 'index': 1570}","it('should not stop a collection if a drop is pending', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(
    middleware(getMarshal(stopPublishing)),
    // will convert the drop into a drop pending
    dropMiddleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());
  expect(store.getState().phase).toBe('COLLECTING');
  expect(stopPublishing).not.toHaveBeenCalled();

  // dropping
  store.dispatch(drop({ reason: 'DROP' }));
  expect(store.getState().phase).toBe('DROP_PENDING');
  expect(stopPublishing).not.toHaveBeenCalled();
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 52, 'column': 2, 'index': 1623}","it('should not stop a collection if a drop is pending', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(
    middleware(getMarshal(stopPublishing)),
    // will convert the drop into a drop pending
    dropMiddleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());
  expect(store.getState().phase).toBe('COLLECTING');
  expect(stopPublishing).not.toHaveBeenCalled();

  // dropping
  store.dispatch(drop({ reason: 'DROP' }));
  expect(store.getState().phase).toBe('DROP_PENDING');
  expect(stopPublishing).not.toHaveBeenCalled();
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 52, 'column': 2, 'index': 1623}","it('should not stop a collection if a drop is pending', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(
    middleware(getMarshal(stopPublishing)),
    // will convert the drop into a drop pending
    dropMiddleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());
  expect(store.getState().phase).toBe('COLLECTING');
  expect(stopPublishing).not.toHaveBeenCalled();

  // dropping
  store.dispatch(drop({ reason: 'DROP' }));
  expect(store.getState().phase).toBe('DROP_PENDING');
  expect(stopPublishing).not.toHaveBeenCalled();
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 56, 'column': 2, 'index': 1731}","it('should not stop a collection if a drop is pending', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(
    middleware(getMarshal(stopPublishing)),
    // will convert the drop into a drop pending
    dropMiddleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());
  expect(store.getState().phase).toBe('COLLECTING');
  expect(stopPublishing).not.toHaveBeenCalled();

  // dropping
  store.dispatch(drop({ reason: 'DROP' }));
  expect(store.getState().phase).toBe('DROP_PENDING');
  expect(stopPublishing).not.toHaveBeenCalled();
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 57, 'column': 2, 'index': 1786}","it('should not stop a collection if a drop is pending', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(
    middleware(getMarshal(stopPublishing)),
    // will convert the drop into a drop pending
    dropMiddleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());
  expect(store.getState().phase).toBe('COLLECTING');
  expect(stopPublishing).not.toHaveBeenCalled();

  // dropping
  store.dispatch(drop({ reason: 'DROP' }));
  expect(store.getState().phase).toBe('DROP_PENDING');
  expect(stopPublishing).not.toHaveBeenCalled();
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 57, 'column': 2, 'index': 1786}","it('should not stop a collection if a drop is pending', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(
    middleware(getMarshal(stopPublishing)),
    // will convert the drop into a drop pending
    dropMiddleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());
  expect(store.getState().phase).toBe('COLLECTING');
  expect(stopPublishing).not.toHaveBeenCalled();

  // dropping
  store.dispatch(drop({ reason: 'DROP' }));
  expect(store.getState().phase).toBe('DROP_PENDING');
  expect(stopPublishing).not.toHaveBeenCalled();
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 70, 'column': 2, 'index': 2197}","it('should stop a collection if a drag is complete', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(
    middleware(getMarshal(stopPublishing)),
    // will convert the drop into a drop pending
    dropMiddleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  expect(stopPublishing).not.toHaveBeenCalled();

  // complete drop
  store.dispatch(completeDrop(getCompletedArgs('DROP')));

  expect(stopPublishing).toHaveBeenCalled();
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 75, 'column': 2, 'index': 2325}","it('should stop a collection if a drag is complete', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(
    middleware(getMarshal(stopPublishing)),
    // will convert the drop into a drop pending
    dropMiddleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  expect(stopPublishing).not.toHaveBeenCalled();

  // complete drop
  store.dispatch(completeDrop(getCompletedArgs('DROP')));

  expect(stopPublishing).toHaveBeenCalled();
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 88, 'column': 2, 'index': 2737}","it('should stop a collection if a drop animation starts', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(
    middleware(getMarshal(stopPublishing)),
    // will convert the drop into a drop pending
    dropMiddleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  expect(stopPublishing).not.toHaveBeenCalled();

  store.dispatch(animateDrop(userCancelArgs));

  expect(stopPublishing).toHaveBeenCalled();
})",steel
/test/unit/state/middleware/dimension-marshal-stopper.spec.js,Duplicate Assert,"{'line': 92, 'column': 2, 'index': 2835}","it('should stop a collection if a drop animation starts', () => {
  const stopPublishing = jest.fn();
  const store: Store = createStore(
    middleware(getMarshal(stopPublishing)),
    // will convert the drop into a drop pending
    dropMiddleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  expect(stopPublishing).not.toHaveBeenCalled();

  store.dispatch(animateDrop(userCancelArgs));

  expect(stopPublishing).toHaveBeenCalled();
})",steel
/test/unit/state/middleware/auto-scroll.spec.js,Duplicate Assert,"{'line': 55, 'column': 2, 'index': 1625}","it('should fire a scroll when there is an update', () => {
  const scroller: AutoScroller = getScrollerStub();
  const store: Store = createStore(middleware(scroller));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(scroller.start).toHaveBeenCalledWith(store.getState());

  expect(scroller.scroll).not.toHaveBeenCalled();
  store.dispatch(moveDown());
  expect(scroller.scroll).toHaveBeenCalledWith(store.getState());
})",steel
/test/unit/state/middleware/auto-scroll.spec.js,Duplicate Assert,"{'line': 57, 'column': 2, 'index': 1705}","it('should fire a scroll when there is an update', () => {
  const scroller: AutoScroller = getScrollerStub();
  const store: Store = createStore(middleware(scroller));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(scroller.start).toHaveBeenCalledWith(store.getState());

  expect(scroller.scroll).not.toHaveBeenCalled();
  store.dispatch(moveDown());
  expect(scroller.scroll).toHaveBeenCalledWith(store.getState());
})",steel
/test/unit/state/middleware/responders/update.spec.js,Duplicate Assert,"{'line': 34, 'column': 2, 'index': 1163}","it('should call onDragUpdate if the position has changed on move', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Okay let's move it
  store.dispatch(moveDown());
  // not called until next cycle
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();
  const update: DragUpdate = {
    ...getDragStart(),
    combine: null,
    destination: {
      droppableId: initialPublishArgs.critical.droppable.id,
      index: initialPublishArgs.critical.draggable.index + 1,
    },
  };
  expect(responders.onDragUpdate).toHaveBeenCalledWith(
    update,
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/update.spec.js,Duplicate Assert,"{'line': 34, 'column': 2, 'index': 1163}","it('should call onDragUpdate if the position has changed on move', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Okay let's move it
  store.dispatch(moveDown());
  // not called until next cycle
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();
  const update: DragUpdate = {
    ...getDragStart(),
    combine: null,
    destination: {
      droppableId: initialPublishArgs.critical.droppable.id,
      index: initialPublishArgs.critical.draggable.index + 1,
    },
  };
  expect(responders.onDragUpdate).toHaveBeenCalledWith(
    update,
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/update.spec.js,Duplicate Assert,"{'line': 39, 'column': 2, 'index': 1309}","it('should call onDragUpdate if the position has changed on move', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Okay let's move it
  store.dispatch(moveDown());
  // not called until next cycle
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();
  const update: DragUpdate = {
    ...getDragStart(),
    combine: null,
    destination: {
      droppableId: initialPublishArgs.critical.droppable.id,
      index: initialPublishArgs.critical.draggable.index + 1,
    },
  };
  expect(responders.onDragUpdate).toHaveBeenCalledWith(
    update,
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/update.spec.js,Duplicate Assert,"{'line': 39, 'column': 2, 'index': 1309}","it('should call onDragUpdate if the position has changed on move', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Okay let's move it
  store.dispatch(moveDown());
  // not called until next cycle
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();
  const update: DragUpdate = {
    ...getDragStart(),
    combine: null,
    destination: {
      droppableId: initialPublishArgs.critical.droppable.id,
      index: initialPublishArgs.critical.draggable.index + 1,
    },
  };
  expect(responders.onDragUpdate).toHaveBeenCalledWith(
    update,
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/update.spec.js,Duplicate Assert,"{'line': 50, 'column': 2, 'index': 1626}","it('should call onDragUpdate if the position has changed on move', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Okay let's move it
  store.dispatch(moveDown());
  // not called until next cycle
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();
  const update: DragUpdate = {
    ...getDragStart(),
    combine: null,
    destination: {
      droppableId: initialPublishArgs.critical.droppable.id,
      index: initialPublishArgs.critical.draggable.index + 1,
    },
  };
  expect(responders.onDragUpdate).toHaveBeenCalledWith(
    update,
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/update.spec.js,Duplicate Assert,"{'line': 65, 'column': 2, 'index': 2100}","it('should not call onDragUpdate if there is no movement from the last update', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);

  // onDragUpdate not called yet
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // A movement to the same index is not causing an update
  const moveArgs: MoveArgs = {
    // tiny change
    client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
  };
  store.dispatch(move(moveArgs));

  // update not called after flushing
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Triggering an actual movement
  store.dispatch(moveDown());
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

  const state: State = store.getState();
  invariant(
    state.phase === 'DRAGGING',
    'Expecting state to be in dragging phase',
  );

  // A small movement that should not trigger any index changes
  store.dispatch(
    move({
      client: add(state.current.client.selection, { x: -1, y: -1 }),
    }),
  );

  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/update.spec.js,Duplicate Assert,"{'line': 65, 'column': 2, 'index': 2100}","it('should not call onDragUpdate if there is no movement from the last update', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);

  // onDragUpdate not called yet
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // A movement to the same index is not causing an update
  const moveArgs: MoveArgs = {
    // tiny change
    client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
  };
  store.dispatch(move(moveArgs));

  // update not called after flushing
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Triggering an actual movement
  store.dispatch(moveDown());
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

  const state: State = store.getState();
  invariant(
    state.phase === 'DRAGGING',
    'Expecting state to be in dragging phase',
  );

  // A small movement that should not trigger any index changes
  store.dispatch(
    move({
      client: add(state.current.client.selection, { x: -1, y: -1 }),
    }),
  );

  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/update.spec.js,Duplicate Assert,"{'line': 76, 'column': 2, 'index': 2446}","it('should not call onDragUpdate if there is no movement from the last update', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);

  // onDragUpdate not called yet
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // A movement to the same index is not causing an update
  const moveArgs: MoveArgs = {
    // tiny change
    client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
  };
  store.dispatch(move(moveArgs));

  // update not called after flushing
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Triggering an actual movement
  store.dispatch(moveDown());
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

  const state: State = store.getState();
  invariant(
    state.phase === 'DRAGGING',
    'Expecting state to be in dragging phase',
  );

  // A small movement that should not trigger any index changes
  store.dispatch(
    move({
      client: add(state.current.client.selection, { x: -1, y: -1 }),
    }),
  );

  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/update.spec.js,Duplicate Assert,"{'line': 76, 'column': 2, 'index': 2446}","it('should not call onDragUpdate if there is no movement from the last update', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);

  // onDragUpdate not called yet
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // A movement to the same index is not causing an update
  const moveArgs: MoveArgs = {
    // tiny change
    client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
  };
  store.dispatch(move(moveArgs));

  // update not called after flushing
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Triggering an actual movement
  store.dispatch(moveDown());
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

  const state: State = store.getState();
  invariant(
    state.phase === 'DRAGGING',
    'Expecting state to be in dragging phase',
  );

  // A small movement that should not trigger any index changes
  store.dispatch(
    move({
      client: add(state.current.client.selection, { x: -1, y: -1 }),
    }),
  );

  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/update.spec.js,Duplicate Assert,"{'line': 81, 'column': 2, 'index': 2601}","it('should not call onDragUpdate if there is no movement from the last update', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);

  // onDragUpdate not called yet
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // A movement to the same index is not causing an update
  const moveArgs: MoveArgs = {
    // tiny change
    client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
  };
  store.dispatch(move(moveArgs));

  // update not called after flushing
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Triggering an actual movement
  store.dispatch(moveDown());
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

  const state: State = store.getState();
  invariant(
    state.phase === 'DRAGGING',
    'Expecting state to be in dragging phase',
  );

  // A small movement that should not trigger any index changes
  store.dispatch(
    move({
      client: add(state.current.client.selection, { x: -1, y: -1 }),
    }),
  );

  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/update.spec.js,Duplicate Assert,"{'line': 97, 'column': 2, 'index': 3008}","it('should not call onDragUpdate if there is no movement from the last update', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  start(store.dispatch);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);

  // onDragUpdate not called yet
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // A movement to the same index is not causing an update
  const moveArgs: MoveArgs = {
    // tiny change
    client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
  };
  store.dispatch(move(moveArgs));

  // update not called after flushing
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  // Triggering an actual movement
  store.dispatch(moveDown());
  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

  const state: State = store.getState();
  invariant(
    state.phase === 'DRAGGING',
    'Expecting state to be in dragging phase',
  );

  // A small movement that should not trigger any index changes
  store.dispatch(
    move({
      client: add(state.current.client.selection, { x: -1, y: -1 }),
    }),
  );

  jest.runOnlyPendingTimers();
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/start.spec.js,Duplicate Assert,"{'line': 23, 'column': 2, 'index': 945}","it('should call the onDragStart responder when a initial publish occurs', () => {
  const responders: Responders = getRespondersStub();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  // prepare step should not trigger responder
  expect(responders.onDragStart).not.toHaveBeenCalled();

  // first initial publish
  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();

  // flushing onDragStart
  jest.runOnlyPendingTimers();
  expect(responders.onDragStart).toHaveBeenCalledWith(
    getDragStart(),
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/start.spec.js,Duplicate Assert,"{'line': 23, 'column': 2, 'index': 945}","it('should call the onDragStart responder when a initial publish occurs', () => {
  const responders: Responders = getRespondersStub();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  // prepare step should not trigger responder
  expect(responders.onDragStart).not.toHaveBeenCalled();

  // first initial publish
  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();

  // flushing onDragStart
  jest.runOnlyPendingTimers();
  expect(responders.onDragStart).toHaveBeenCalledWith(
    getDragStart(),
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/start.spec.js,Duplicate Assert,"{'line': 27, 'column': 2, 'index': 1084}","it('should call the onDragStart responder when a initial publish occurs', () => {
  const responders: Responders = getRespondersStub();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  // prepare step should not trigger responder
  expect(responders.onDragStart).not.toHaveBeenCalled();

  // first initial publish
  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();

  // flushing onDragStart
  jest.runOnlyPendingTimers();
  expect(responders.onDragStart).toHaveBeenCalledWith(
    getDragStart(),
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/start.spec.js,Duplicate Assert,"{'line': 27, 'column': 2, 'index': 1084}","it('should call the onDragStart responder when a initial publish occurs', () => {
  const responders: Responders = getRespondersStub();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  // prepare step should not trigger responder
  expect(responders.onDragStart).not.toHaveBeenCalled();

  // first initial publish
  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();

  // flushing onDragStart
  jest.runOnlyPendingTimers();
  expect(responders.onDragStart).toHaveBeenCalledWith(
    getDragStart(),
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/start.spec.js,Duplicate Assert,"{'line': 31, 'column': 2, 'index': 1199}","it('should call the onDragStart responder when a initial publish occurs', () => {
  const responders: Responders = getRespondersStub();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  // prepare step should not trigger responder
  expect(responders.onDragStart).not.toHaveBeenCalled();

  // first initial publish
  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();

  // flushing onDragStart
  jest.runOnlyPendingTimers();
  expect(responders.onDragStart).toHaveBeenCalledWith(
    getDragStart(),
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/start.spec.js,Eager Test,"{'line': 65, 'column': 2, 'index': 2329}","it('should call the onBeforeDragState and onDragStart in the correct order', () => {
  let mockCalled: ?number = null;
  let onBeforeDragStartCalled: ?number = null;
  let onDragStartCalled: ?number = null;
  const mock = jest.fn().mockImplementation(() => {
    mockCalled = performance.now();
  });
  const responders: Responders = getRespondersStub();
  // $FlowFixMe - no property mockImplementation
  responders.onBeforeDragStart.mockImplementation(() => {
    onBeforeDragStartCalled = performance.now();
  });
  // $FlowFixMe - no property mockImplementation
  responders.onDragStart.mockImplementation(() => {
    onDragStartCalled = performance.now();
  });
  const store: Store = createStore(
    middleware(() => responders, getAnnounce()),
    passThrough(mock),
  );

  // first initial publish
  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onBeforeDragStart).toHaveBeenCalledWith(getDragStart());
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking the order
  invariant(onBeforeDragStartCalled);
  invariant(mockCalled);
  invariant(onDragStartCalled);
  expect(mock).toHaveBeenCalledTimes(1);
  expect(onBeforeDragStartCalled).toBeLessThan(mockCalled);
  expect(mockCalled).toBeLessThan(onDragStartCalled);
})",steel
/test/unit/state/middleware/responders/start.spec.js,Eager Test,"{'line': 66, 'column': 2, 'index': 2367}","it('should call the onBeforeDragState and onDragStart in the correct order', () => {
  let mockCalled: ?number = null;
  let onBeforeDragStartCalled: ?number = null;
  let onDragStartCalled: ?number = null;
  const mock = jest.fn().mockImplementation(() => {
    mockCalled = performance.now();
  });
  const responders: Responders = getRespondersStub();
  // $FlowFixMe - no property mockImplementation
  responders.onBeforeDragStart.mockImplementation(() => {
    onBeforeDragStartCalled = performance.now();
  });
  // $FlowFixMe - no property mockImplementation
  responders.onDragStart.mockImplementation(() => {
    onDragStartCalled = performance.now();
  });
  const store: Store = createStore(
    middleware(() => responders, getAnnounce()),
    passThrough(mock),
  );

  // first initial publish
  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onBeforeDragStart).toHaveBeenCalledWith(getDragStart());
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking the order
  invariant(onBeforeDragStartCalled);
  invariant(mockCalled);
  invariant(onDragStartCalled);
  expect(mock).toHaveBeenCalledTimes(1);
  expect(onBeforeDragStartCalled).toBeLessThan(mockCalled);
  expect(mockCalled).toBeLessThan(onDragStartCalled);
})",steel
/test/unit/state/middleware/responders/start.spec.js,Eager Test,"{'line': 67, 'column': 2, 'index': 2392}","it('should call the onBeforeDragState and onDragStart in the correct order', () => {
  let mockCalled: ?number = null;
  let onBeforeDragStartCalled: ?number = null;
  let onDragStartCalled: ?number = null;
  const mock = jest.fn().mockImplementation(() => {
    mockCalled = performance.now();
  });
  const responders: Responders = getRespondersStub();
  // $FlowFixMe - no property mockImplementation
  responders.onBeforeDragStart.mockImplementation(() => {
    onBeforeDragStartCalled = performance.now();
  });
  // $FlowFixMe - no property mockImplementation
  responders.onDragStart.mockImplementation(() => {
    onDragStartCalled = performance.now();
  });
  const store: Store = createStore(
    middleware(() => responders, getAnnounce()),
    passThrough(mock),
  );

  // first initial publish
  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onBeforeDragStart).toHaveBeenCalledWith(getDragStart());
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking the order
  invariant(onBeforeDragStartCalled);
  invariant(mockCalled);
  invariant(onDragStartCalled);
  expect(mock).toHaveBeenCalledTimes(1);
  expect(onBeforeDragStartCalled).toBeLessThan(mockCalled);
  expect(mockCalled).toBeLessThan(onDragStartCalled);
})",steel
/test/unit/state/middleware/responders/repeated-use.spec.js,Duplicate Assert,"{'line': 32, 'column': 4, 'index': 972}","it('should behave correctly across multiple drags', () => {
  const responders: Responders = createResponders();
  const store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    // start
    store.dispatch(initialPublish(initialPublishArgs));
    jest.runOnlyPendingTimers();
    expect(responders.onDragStart).toHaveBeenCalledWith(
      getDragStart(),
      expect.any(Object),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);

    // update
    const update: DragUpdate = {
      ...getDragStart(),
      destination: {
        droppableId: initialPublishArgs.critical.droppable.id,
        index: initialPublishArgs.critical.draggable.index + 1,
      },
      combine: null,
    };
    store.dispatch(moveDown());
    // flush responder call
    jest.runOnlyPendingTimers();
    expect(responders.onDragUpdate).toHaveBeenCalledWith(
      update,
      expect.any(Object),
    );
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

    // drop
    const result: DropResult = {
      ...update,
      reason: 'DROP',
    };
    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );
    expect(responders.onDragEnd).toHaveBeenCalledTimes(1);

    // cleanup
    store.dispatch(flush());
    // $ExpectError - unknown mock reset property
    responders.onDragStart.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragUpdate.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/repeated-use.spec.js,Duplicate Assert,"{'line': 36, 'column': 4, 'index': 1084}","it('should behave correctly across multiple drags', () => {
  const responders: Responders = createResponders();
  const store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    // start
    store.dispatch(initialPublish(initialPublishArgs));
    jest.runOnlyPendingTimers();
    expect(responders.onDragStart).toHaveBeenCalledWith(
      getDragStart(),
      expect.any(Object),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);

    // update
    const update: DragUpdate = {
      ...getDragStart(),
      destination: {
        droppableId: initialPublishArgs.critical.droppable.id,
        index: initialPublishArgs.critical.draggable.index + 1,
      },
      combine: null,
    };
    store.dispatch(moveDown());
    // flush responder call
    jest.runOnlyPendingTimers();
    expect(responders.onDragUpdate).toHaveBeenCalledWith(
      update,
      expect.any(Object),
    );
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

    // drop
    const result: DropResult = {
      ...update,
      reason: 'DROP',
    };
    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );
    expect(responders.onDragEnd).toHaveBeenCalledTimes(1);

    // cleanup
    store.dispatch(flush());
    // $ExpectError - unknown mock reset property
    responders.onDragStart.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragUpdate.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/repeated-use.spec.js,Duplicate Assert,"{'line': 50, 'column': 4, 'index': 1496}","it('should behave correctly across multiple drags', () => {
  const responders: Responders = createResponders();
  const store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    // start
    store.dispatch(initialPublish(initialPublishArgs));
    jest.runOnlyPendingTimers();
    expect(responders.onDragStart).toHaveBeenCalledWith(
      getDragStart(),
      expect.any(Object),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);

    // update
    const update: DragUpdate = {
      ...getDragStart(),
      destination: {
        droppableId: initialPublishArgs.critical.droppable.id,
        index: initialPublishArgs.critical.draggable.index + 1,
      },
      combine: null,
    };
    store.dispatch(moveDown());
    // flush responder call
    jest.runOnlyPendingTimers();
    expect(responders.onDragUpdate).toHaveBeenCalledWith(
      update,
      expect.any(Object),
    );
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

    // drop
    const result: DropResult = {
      ...update,
      reason: 'DROP',
    };
    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );
    expect(responders.onDragEnd).toHaveBeenCalledTimes(1);

    // cleanup
    store.dispatch(flush());
    // $ExpectError - unknown mock reset property
    responders.onDragStart.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragUpdate.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/repeated-use.spec.js,Duplicate Assert,"{'line': 54, 'column': 4, 'index': 1601}","it('should behave correctly across multiple drags', () => {
  const responders: Responders = createResponders();
  const store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    // start
    store.dispatch(initialPublish(initialPublishArgs));
    jest.runOnlyPendingTimers();
    expect(responders.onDragStart).toHaveBeenCalledWith(
      getDragStart(),
      expect.any(Object),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);

    // update
    const update: DragUpdate = {
      ...getDragStart(),
      destination: {
        droppableId: initialPublishArgs.critical.droppable.id,
        index: initialPublishArgs.critical.draggable.index + 1,
      },
      combine: null,
    };
    store.dispatch(moveDown());
    // flush responder call
    jest.runOnlyPendingTimers();
    expect(responders.onDragUpdate).toHaveBeenCalledWith(
      update,
      expect.any(Object),
    );
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

    // drop
    const result: DropResult = {
      ...update,
      reason: 'DROP',
    };
    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );
    expect(responders.onDragEnd).toHaveBeenCalledTimes(1);

    // cleanup
    store.dispatch(flush());
    // $ExpectError - unknown mock reset property
    responders.onDragStart.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragUpdate.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/repeated-use.spec.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 1882}","it('should behave correctly across multiple drags', () => {
  const responders: Responders = createResponders();
  const store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    // start
    store.dispatch(initialPublish(initialPublishArgs));
    jest.runOnlyPendingTimers();
    expect(responders.onDragStart).toHaveBeenCalledWith(
      getDragStart(),
      expect.any(Object),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);

    // update
    const update: DragUpdate = {
      ...getDragStart(),
      destination: {
        droppableId: initialPublishArgs.critical.droppable.id,
        index: initialPublishArgs.critical.draggable.index + 1,
      },
      combine: null,
    };
    store.dispatch(moveDown());
    // flush responder call
    jest.runOnlyPendingTimers();
    expect(responders.onDragUpdate).toHaveBeenCalledWith(
      update,
      expect.any(Object),
    );
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

    // drop
    const result: DropResult = {
      ...update,
      reason: 'DROP',
    };
    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );
    expect(responders.onDragEnd).toHaveBeenCalledTimes(1);

    // cleanup
    store.dispatch(flush());
    // $ExpectError - unknown mock reset property
    responders.onDragStart.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragUpdate.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/repeated-use.spec.js,Duplicate Assert,"{'line': 70, 'column': 4, 'index': 1984}","it('should behave correctly across multiple drags', () => {
  const responders: Responders = createResponders();
  const store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    // start
    store.dispatch(initialPublish(initialPublishArgs));
    jest.runOnlyPendingTimers();
    expect(responders.onDragStart).toHaveBeenCalledWith(
      getDragStart(),
      expect.any(Object),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);

    // update
    const update: DragUpdate = {
      ...getDragStart(),
      destination: {
        droppableId: initialPublishArgs.critical.droppable.id,
        index: initialPublishArgs.critical.draggable.index + 1,
      },
      combine: null,
    };
    store.dispatch(moveDown());
    // flush responder call
    jest.runOnlyPendingTimers();
    expect(responders.onDragUpdate).toHaveBeenCalledWith(
      update,
      expect.any(Object),
    );
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);

    // drop
    const result: DropResult = {
      ...update,
      reason: 'DROP',
    };
    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );
    expect(responders.onDragEnd).toHaveBeenCalledTimes(1);

    // cleanup
    store.dispatch(flush());
    // $ExpectError - unknown mock reset property
    responders.onDragStart.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragUpdate.mockReset();
    // $ExpectError - unknown mock reset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 37, 'column': 2, 'index': 1123}","it('should trigger an on drag start after in the next cycle', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 40, 'column': 2, 'index': 1212}","it('should trigger an on drag start after in the next cycle', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 48, 'column': 2, 'index': 1553}","it('should queue a drag start if an action comes in while the timeout is pending', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();

  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 48, 'column': 2, 'index': 1553}","it('should queue a drag start if an action comes in while the timeout is pending', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();

  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 51, 'column': 2, 'index': 1641}","it('should queue a drag start if an action comes in while the timeout is pending', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();

  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 51, 'column': 2, 'index': 1641}","it('should queue a drag start if an action comes in while the timeout is pending', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();

  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 55, 'column': 2, 'index': 1731}","it('should queue a drag start if an action comes in while the timeout is pending', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();

  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 64, 'column': 2, 'index': 2108}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 64, 'column': 2, 'index': 2108}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 65, 'column': 2, 'index': 2165}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 65, 'column': 2, 'index': 2165}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 68, 'column': 2, 'index': 2254}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 68, 'column': 2, 'index': 2254}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 69, 'column': 2, 'index': 2311}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 69, 'column': 2, 'index': 2311}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 72, 'column': 2, 'index': 2398}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 72, 'column': 2, 'index': 2398}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 73, 'column': 2, 'index': 2455}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 73, 'column': 2, 'index': 2455}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 80, 'column': 2, 'index': 2631}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 81, 'column': 2, 'index': 2690}","it('should flush any pending responders if a drop occurs', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveDown());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(moveUp());
  expect(responders.onDragStart).not.toHaveBeenCalled();
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragUpdate).toHaveBeenCalledTimes(2);
  expect(responders.onDragEnd).toHaveBeenCalledWith(result, expect.any(Object));
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 91, 'column': 4, 'index': 3178}","it('should work across multiple drags', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    store.dispatch(initialPublish(initialPublishArgs));
    expect(responders.onBeforeDragStart).toHaveBeenCalled();
    expect(responders.onDragStart).not.toHaveBeenCalled();

    store.dispatch(moveDown());
    expect(responders.onDragStart).not.toHaveBeenCalled();
    expect(responders.onDragUpdate).not.toHaveBeenCalled();

    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );

    // $FlowFixMe - responder does not have mockReset property
    responders.onDragStart.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragUpdate.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 91, 'column': 4, 'index': 3178}","it('should work across multiple drags', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    store.dispatch(initialPublish(initialPublishArgs));
    expect(responders.onBeforeDragStart).toHaveBeenCalled();
    expect(responders.onDragStart).not.toHaveBeenCalled();

    store.dispatch(moveDown());
    expect(responders.onDragStart).not.toHaveBeenCalled();
    expect(responders.onDragUpdate).not.toHaveBeenCalled();

    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );

    // $FlowFixMe - responder does not have mockReset property
    responders.onDragStart.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragUpdate.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 94, 'column': 4, 'index': 3270}","it('should work across multiple drags', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    store.dispatch(initialPublish(initialPublishArgs));
    expect(responders.onBeforeDragStart).toHaveBeenCalled();
    expect(responders.onDragStart).not.toHaveBeenCalled();

    store.dispatch(moveDown());
    expect(responders.onDragStart).not.toHaveBeenCalled();
    expect(responders.onDragUpdate).not.toHaveBeenCalled();

    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );

    // $FlowFixMe - responder does not have mockReset property
    responders.onDragStart.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragUpdate.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 94, 'column': 4, 'index': 3270}","it('should work across multiple drags', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    store.dispatch(initialPublish(initialPublishArgs));
    expect(responders.onBeforeDragStart).toHaveBeenCalled();
    expect(responders.onDragStart).not.toHaveBeenCalled();

    store.dispatch(moveDown());
    expect(responders.onDragStart).not.toHaveBeenCalled();
    expect(responders.onDragUpdate).not.toHaveBeenCalled();

    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );

    // $FlowFixMe - responder does not have mockReset property
    responders.onDragStart.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragUpdate.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 95, 'column': 4, 'index': 3329}","it('should work across multiple drags', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    store.dispatch(initialPublish(initialPublishArgs));
    expect(responders.onBeforeDragStart).toHaveBeenCalled();
    expect(responders.onDragStart).not.toHaveBeenCalled();

    store.dispatch(moveDown());
    expect(responders.onDragStart).not.toHaveBeenCalled();
    expect(responders.onDragUpdate).not.toHaveBeenCalled();

    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );

    // $FlowFixMe - responder does not have mockReset property
    responders.onDragStart.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragUpdate.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 102, 'column': 4, 'index': 3517}","it('should work across multiple drags', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    store.dispatch(initialPublish(initialPublishArgs));
    expect(responders.onBeforeDragStart).toHaveBeenCalled();
    expect(responders.onDragStart).not.toHaveBeenCalled();

    store.dispatch(moveDown());
    expect(responders.onDragStart).not.toHaveBeenCalled();
    expect(responders.onDragUpdate).not.toHaveBeenCalled();

    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );

    // $FlowFixMe - responder does not have mockReset property
    responders.onDragStart.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragUpdate.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/flushing.spec.js,Duplicate Assert,"{'line': 103, 'column': 4, 'index': 3578}","it('should work across multiple drags', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));
  Array.from({ length: 4 }).forEach(() => {
    store.dispatch(initialPublish(initialPublishArgs));
    expect(responders.onBeforeDragStart).toHaveBeenCalled();
    expect(responders.onDragStart).not.toHaveBeenCalled();

    store.dispatch(moveDown());
    expect(responders.onDragStart).not.toHaveBeenCalled();
    expect(responders.onDragUpdate).not.toHaveBeenCalled();

    store.dispatch(
      completeDrop({
        completed: getCompletedWithResult(result, store.getState()),
      }),
    );
    expect(responders.onDragStart).toHaveBeenCalledTimes(1);
    expect(responders.onDragUpdate).toHaveBeenCalledTimes(1);
    expect(responders.onDragEnd).toHaveBeenCalledWith(
      result,
      expect.any(Object),
    );

    // $FlowFixMe - responder does not have mockReset property
    responders.onDragStart.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragUpdate.mockReset();
    // $FlowFixMe - responder does not have mockReset property
    responders.onDragEnd.mockReset();
  });
})",steel
/test/unit/state/middleware/responders/drop.spec.js,Eager Test,"{'line': 81, 'column': 2, 'index': 2551}","it('should use the drop result and not the final impact', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  jest.runOnlyPendingTimers();
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);

  const state: State = store.getState();
  invariant(state.phase === 'DRAGGING');
  const destination: ?DraggableLocation = tryGetDestination(state.impact);
  invariant(destination);
  const fakeResult: DropResult = {
    ...getDragStart(),
    // ensuring the destination is different to the current impact to ensure
    // that the result is used for responders and not the last impact
    destination: {
      droppableId: destination.droppableId,
      index: destination.index + 1,
    },
    combine: null,
    reason: 'DROP',
  };

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(fakeResult, store.getState()),
    }),
  );
  expect(responders.onDragEnd).toHaveBeenCalledWith(
    fakeResult,
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/drop.spec.js,Eager Test,"{'line': 82, 'column': 42, 'index': 2632}","it('should use the drop result and not the final impact', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  jest.runOnlyPendingTimers();
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);

  const state: State = store.getState();
  invariant(state.phase === 'DRAGGING');
  const destination: ?DraggableLocation = tryGetDestination(state.impact);
  invariant(destination);
  const fakeResult: DropResult = {
    ...getDragStart(),
    // ensuring the destination is different to the current impact to ensure
    // that the result is used for responders and not the last impact
    destination: {
      droppableId: destination.droppableId,
      index: destination.index + 1,
    },
    combine: null,
    reason: 'DROP',
  };

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(fakeResult, store.getState()),
    }),
  );
  expect(responders.onDragEnd).toHaveBeenCalledWith(
    fakeResult,
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/drop.spec.js,Eager Test,"{'line': 83, 'column': 2, 'index': 2667}","it('should use the drop result and not the final impact', () => {
  const responders: Responders = getResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(initialPublish(initialPublishArgs));
  jest.runOnlyPendingTimers();
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);

  const state: State = store.getState();
  invariant(state.phase === 'DRAGGING');
  const destination: ?DraggableLocation = tryGetDestination(state.impact);
  invariant(destination);
  const fakeResult: DropResult = {
    ...getDragStart(),
    // ensuring the destination is different to the current impact to ensure
    // that the result is used for responders and not the last impact
    destination: {
      droppableId: destination.droppableId,
      index: destination.index + 1,
    },
    combine: null,
    reason: 'DROP',
  };

  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(fakeResult, store.getState()),
    }),
  );
  expect(responders.onDragEnd).toHaveBeenCalledWith(
    fakeResult,
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/announcements.spec.js,Conditional Test Logic,"{'line': 143, 'column': 6, 'index': 3774}","it('should announce with the default message if no responder is provided', () => {
      // This test is not relevant for onDragEnd as it must always be provided
      if (current.responder === 'onDragEnd') {
        expect(true).toBe(true);
        return;
      }
      // unsetting responder
      responders[current.responder] = undefined;
      current.execute(store);
      expect(announce).toHaveBeenCalledWith(current.defaultMessage);
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Duplicate Assert,"{'line': 163, 'column': 10, 'index': 4524}","it('should not announce twice if the responder makes an announcement', () => {
      responders[current.responder] = jest.fn(
        (data: any, provided: ResponderProvided) => {
          announce.mockReset();
          provided.announce('hello');
          expect(announce).toHaveBeenCalledWith('hello');
          // asserting there was no double call
          expect(announce).toHaveBeenCalledTimes(1);
        },
      );

      current.execute(store);
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Duplicate Assert,"{'line': 165, 'column': 10, 'index': 4630}","it('should not announce twice if the responder makes an announcement', () => {
      responders[current.responder] = jest.fn(
        (data: any, provided: ResponderProvided) => {
          announce.mockReset();
          provided.announce('hello');
          expect(announce).toHaveBeenCalledWith('hello');
          // asserting there was no double call
          expect(announce).toHaveBeenCalledTimes(1);
        },
      );

      current.execute(store);
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Duplicate Assert,"{'line': 186, 'column': 6, 'index': 5208}","it('should prevent async announcements', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
        },
      );

      current.execute(store);

      // We did not announce so it would have been called with the default message
      expect(announce).toHaveBeenCalledWith(current.defaultMessage);
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform an async message
      setTimeout(() => provided.announce('async message'));
      jest.runOnlyPendingTimers();

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      // cleanup
      warn.mockRestore();
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Duplicate Assert,"{'line': 187, 'column': 6, 'index': 5277}","it('should prevent async announcements', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
        },
      );

      current.execute(store);

      // We did not announce so it would have been called with the default message
      expect(announce).toHaveBeenCalledWith(current.defaultMessage);
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform an async message
      setTimeout(() => provided.announce('async message'));
      jest.runOnlyPendingTimers();

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      // cleanup
      warn.mockRestore();
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Duplicate Assert,"{'line': 188, 'column': 6, 'index': 5326}","it('should prevent async announcements', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
        },
      );

      current.execute(store);

      // We did not announce so it would have been called with the default message
      expect(announce).toHaveBeenCalledWith(current.defaultMessage);
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform an async message
      setTimeout(() => provided.announce('async message'));
      jest.runOnlyPendingTimers();

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      // cleanup
      warn.mockRestore();
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Duplicate Assert,"{'line': 195, 'column': 6, 'index': 5528}","it('should prevent async announcements', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
        },
      );

      current.execute(store);

      // We did not announce so it would have been called with the default message
      expect(announce).toHaveBeenCalledWith(current.defaultMessage);
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform an async message
      setTimeout(() => provided.announce('async message'));
      jest.runOnlyPendingTimers();

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      // cleanup
      warn.mockRestore();
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Duplicate Assert,"{'line': 196, 'column': 6, 'index': 5575}","it('should prevent async announcements', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
        },
      );

      current.execute(store);

      // We did not announce so it would have been called with the default message
      expect(announce).toHaveBeenCalledWith(current.defaultMessage);
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform an async message
      setTimeout(() => provided.announce('async message'));
      jest.runOnlyPendingTimers();

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      // cleanup
      warn.mockRestore();
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Duplicate Assert,"{'line': 216, 'column': 6, 'index': 6115}","it('should prevent multiple announcement calls from a consumer', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
          provided.announce('hello');
        },
      );

      current.execute(store);

      expect(announce).toHaveBeenCalledWith('hello');
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform another announcement
      invariant(provided, 'provided is not set');
      provided.announce('another one');

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      warn.mockRestore();
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Duplicate Assert,"{'line': 217, 'column': 6, 'index': 6169}","it('should prevent multiple announcement calls from a consumer', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
          provided.announce('hello');
        },
      );

      current.execute(store);

      expect(announce).toHaveBeenCalledWith('hello');
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform another announcement
      invariant(provided, 'provided is not set');
      provided.announce('another one');

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      warn.mockRestore();
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Duplicate Assert,"{'line': 218, 'column': 6, 'index': 6218}","it('should prevent multiple announcement calls from a consumer', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
          provided.announce('hello');
        },
      );

      current.execute(store);

      expect(announce).toHaveBeenCalledWith('hello');
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform another announcement
      invariant(provided, 'provided is not set');
      provided.announce('another one');

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      warn.mockRestore();
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Duplicate Assert,"{'line': 225, 'column': 6, 'index': 6419}","it('should prevent multiple announcement calls from a consumer', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
          provided.announce('hello');
        },
      );

      current.execute(store);

      expect(announce).toHaveBeenCalledWith('hello');
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform another announcement
      invariant(provided, 'provided is not set');
      provided.announce('another one');

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      warn.mockRestore();
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Duplicate Assert,"{'line': 226, 'column': 6, 'index': 6466}","it('should prevent multiple announcement calls from a consumer', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
          provided.announce('hello');
        },
      );

      current.execute(store);

      expect(announce).toHaveBeenCalledWith('hello');
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform another announcement
      invariant(provided, 'provided is not set');
      provided.announce('another one');

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      warn.mockRestore();
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Redundant Assertion,"{'column': 8, 'line': 144}","it('should announce with the default message if no responder is provided', () => {
      // This test is not relevant for onDragEnd as it must always be provided
      if (current.responder === 'onDragEnd') {
        expect(true).toBe(true);
        return;
      }
      // unsetting responder
      responders[current.responder] = undefined;
      current.execute(store);
      expect(announce).toHaveBeenCalledWith(current.defaultMessage);
    })",steel
/test/unit/state/middleware/responders/announcements.spec.js,Sleepy Test,"{'line': 192, 'column': 6, 'index': 5432}","it('should prevent async announcements', () => {
      const warn = jest.spyOn(console, 'warn').mockImplementation(() => {});

      let provided: ResponderProvided;
      responders[current.responder] = jest.fn(
        (data: any, supplied: ResponderProvided) => {
          announce.mockReset();
          provided = supplied;
        },
      );

      current.execute(store);

      // We did not announce so it would have been called with the default message
      expect(announce).toHaveBeenCalledWith(current.defaultMessage);
      expect(announce).toHaveBeenCalledTimes(1);
      expect(warn).not.toHaveBeenCalled();
      announce.mockReset();

      // perform an async message
      setTimeout(() => provided.announce('async message'));
      jest.runOnlyPendingTimers();

      expect(announce).not.toHaveBeenCalled();
      expect(warn).toHaveBeenCalled();

      // cleanup
      warn.mockRestore();
    })",steel
/test/unit/state/middleware/responders/abort.spec.js,Duplicate Assert,"{'line': 103, 'column': 2, 'index': 3075}","it('should not publish an onDragEnd if aborted after a drop', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  // lift
  store.dispatch(flush());
  store.dispatch(initialPublish(initialPublishArgs));
  jest.runOnlyPendingTimers();
  expect(responders.onDragStart).toHaveBeenCalled();

  // drop
  const result: DropResult = {
    ...getDragStart(),
    destination: null,
    combine: null,
    reason: 'CANCEL',
  };
  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragEnd).toHaveBeenCalledTimes(1);
  // $ExpectError - mock
  responders.onDragEnd.mockReset();

  // abort
  store.dispatch(flush());
  expect(responders.onDragEnd).not.toHaveBeenCalled();
})",steel
/test/unit/state/middleware/responders/abort.spec.js,Duplicate Assert,"{'line': 109, 'column': 2, 'index': 3232}","it('should not publish an onDragEnd if aborted after a drop', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  // lift
  store.dispatch(flush());
  store.dispatch(initialPublish(initialPublishArgs));
  jest.runOnlyPendingTimers();
  expect(responders.onDragStart).toHaveBeenCalled();

  // drop
  const result: DropResult = {
    ...getDragStart(),
    destination: null,
    combine: null,
    reason: 'CANCEL',
  };
  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragEnd).toHaveBeenCalledTimes(1);
  // $ExpectError - mock
  responders.onDragEnd.mockReset();

  // abort
  store.dispatch(flush());
  expect(responders.onDragEnd).not.toHaveBeenCalled();
})",steel
/test/unit/state/middleware/responders/abort.spec.js,Duplicate Assert,"{'line': 120, 'column': 2, 'index': 3643}","it('should publish an on drag end if aborted before the publish of an onDragStart', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  // lift
  store.dispatch(flush());
  store.dispatch(initialPublish(initialPublishArgs));
  // onDragStart not flushed yet
  expect(responders.onDragStart).not.toHaveBeenCalled();

  // drop
  const result: DropResult = {
    ...getDragStart(),
    destination: null,
    combine: null,
    reason: 'CANCEL',
  };
  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragEnd).toHaveBeenCalledTimes(1);

  // validation - onDragStart has been flushed
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/abort.spec.js,Duplicate Assert,"{'line': 137, 'column': 2, 'index': 4056}","it('should publish an on drag end if aborted before the publish of an onDragStart', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  // lift
  store.dispatch(flush());
  store.dispatch(initialPublish(initialPublishArgs));
  // onDragStart not flushed yet
  expect(responders.onDragStart).not.toHaveBeenCalled();

  // drop
  const result: DropResult = {
    ...getDragStart(),
    destination: null,
    combine: null,
    reason: 'CANCEL',
  };
  store.dispatch(
    completeDrop({
      completed: getCompletedWithResult(result, store.getState()),
    }),
  );
  expect(responders.onDragEnd).toHaveBeenCalledTimes(1);

  // validation - onDragStart has been flushed
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/responders/abort.spec.js,Eager Test,"{'line': 59, 'column': 2, 'index': 1878}","it('should publish an onDragEnd with no destination even if there is a current destination', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(flush());
  store.dispatch(initialPublish(initialPublishArgs));
  jest.runOnlyPendingTimers();

  const state: State = store.getState();
  invariant(state.phase === 'DRAGGING');
  // in home location
  const home: DraggableLocation = {
    droppableId: initialPublishArgs.critical.droppable.id,
    index: initialPublishArgs.critical.draggable.index,
  };
  expect(tryGetDestination(state.impact)).toEqual(home);

  store.dispatch(flush());
  const expected: DropResult = {
    ...getDragStart(),
    // destination has been cleared
    destination: null,
    combine: null,
    reason: 'CANCEL',
  };
  expect(responders.onDragEnd).toHaveBeenCalledWith(
    expected,
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/responders/abort.spec.js,Eager Test,"{'line': 65, 'column': 9, 'index': 2104}","it('should publish an onDragEnd with no destination even if there is a current destination', () => {
  const responders: Responders = createResponders();
  const store: Store = createStore(middleware(() => responders, getAnnounce()));

  store.dispatch(flush());
  store.dispatch(initialPublish(initialPublishArgs));
  jest.runOnlyPendingTimers();

  const state: State = store.getState();
  invariant(state.phase === 'DRAGGING');
  // in home location
  const home: DraggableLocation = {
    droppableId: initialPublishArgs.critical.droppable.id,
    index: initialPublishArgs.critical.draggable.index,
  };
  expect(tryGetDestination(state.impact)).toEqual(home);

  store.dispatch(flush());
  const expected: DropResult = {
    ...getDragStart(),
    // destination has been cleared
    destination: null,
    combine: null,
    reason: 'CANCEL',
  };
  expect(responders.onDragEnd).toHaveBeenCalledWith(
    expected,
    expect.any(Object),
  );
})",steel
/test/unit/state/middleware/drop/timing.spec.js,Duplicate Assert,"{'line': 31, 'column': 2, 'index': 1073}","it('should throw an error if a drop action occurs while not in a phase where you can drop', () => {
  const store: Store = createStore(middleware);

  // idle (it is okay to perform a defensive drop here)
  // this can happen during an exception flow
  expect(() => {
    store.dispatch(drop({ reason: 'DROP' }));
  }).not.toThrow();

  // drop animating
  store.dispatch(flush());
  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');

  // moving a little bit so that a drop animation will be needed
  store.dispatch(
    move({
      client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
    }),
  );

  store.dispatch(drop({ reason: 'DROP' }));
  expect(store.getState().phase).toBe('DROP_ANIMATING');

  expect(() => store.dispatch(drop({ reason: 'DROP' }))).toThrow();
})",steel
/test/unit/state/middleware/drop/timing.spec.js,Duplicate Assert,"{'line': 41, 'column': 2, 'index': 1348}","it('should throw an error if a drop action occurs while not in a phase where you can drop', () => {
  const store: Store = createStore(middleware);

  // idle (it is okay to perform a defensive drop here)
  // this can happen during an exception flow
  expect(() => {
    store.dispatch(drop({ reason: 'DROP' }));
  }).not.toThrow();

  // drop animating
  store.dispatch(flush());
  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');

  // moving a little bit so that a drop animation will be needed
  store.dispatch(
    move({
      client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
    }),
  );

  store.dispatch(drop({ reason: 'DROP' }));
  expect(store.getState().phase).toBe('DROP_ANIMATING');

  expect(() => store.dispatch(drop({ reason: 'DROP' }))).toThrow();
})",steel
/test/unit/state/middleware/drop/timing.spec.js,Duplicate Assert,"{'line': 51, 'column': 2, 'index': 1693}","it('should dispatch a DROP_PENDING action if COLLECTING', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());

  // now in the bulk collecting phase
  expect(store.getState().phase).toBe('COLLECTING');
  mock.mockReset();

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  expect(mock).toHaveBeenCalledWith(drop({ reason: 'DROP' }));
  expect(mock).toHaveBeenCalledWith(dropPending({ reason: 'DROP' }));
  expect(mock).toHaveBeenCalledTimes(2);
  expect(store.getState().phase).toBe('DROP_PENDING');
})",steel
/test/unit/state/middleware/drop/timing.spec.js,Duplicate Assert,"{'line': 55, 'column': 2, 'index': 1823}","it('should dispatch a DROP_PENDING action if COLLECTING', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());

  // now in the bulk collecting phase
  expect(store.getState().phase).toBe('COLLECTING');
  mock.mockReset();

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  expect(mock).toHaveBeenCalledWith(drop({ reason: 'DROP' }));
  expect(mock).toHaveBeenCalledWith(dropPending({ reason: 'DROP' }));
  expect(mock).toHaveBeenCalledTimes(2);
  expect(store.getState().phase).toBe('DROP_PENDING');
})",steel
/test/unit/state/middleware/drop/timing.spec.js,Duplicate Assert,"{'line': 61, 'column': 2, 'index': 1952}","it('should dispatch a DROP_PENDING action if COLLECTING', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());

  // now in the bulk collecting phase
  expect(store.getState().phase).toBe('COLLECTING');
  mock.mockReset();

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  expect(mock).toHaveBeenCalledWith(drop({ reason: 'DROP' }));
  expect(mock).toHaveBeenCalledWith(dropPending({ reason: 'DROP' }));
  expect(mock).toHaveBeenCalledTimes(2);
  expect(store.getState().phase).toBe('DROP_PENDING');
})",steel
/test/unit/state/middleware/drop/timing.spec.js,Duplicate Assert,"{'line': 62, 'column': 2, 'index': 2015}","it('should dispatch a DROP_PENDING action if COLLECTING', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());

  // now in the bulk collecting phase
  expect(store.getState().phase).toBe('COLLECTING');
  mock.mockReset();

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  expect(mock).toHaveBeenCalledWith(drop({ reason: 'DROP' }));
  expect(mock).toHaveBeenCalledWith(dropPending({ reason: 'DROP' }));
  expect(mock).toHaveBeenCalledTimes(2);
  expect(store.getState().phase).toBe('DROP_PENDING');
})",steel
/test/unit/state/middleware/drop/timing.spec.js,Duplicate Assert,"{'line': 63, 'column': 2, 'index': 2085}","it('should dispatch a DROP_PENDING action if COLLECTING', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());

  // now in the bulk collecting phase
  expect(store.getState().phase).toBe('COLLECTING');
  mock.mockReset();

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  expect(mock).toHaveBeenCalledWith(drop({ reason: 'DROP' }));
  expect(mock).toHaveBeenCalledWith(dropPending({ reason: 'DROP' }));
  expect(mock).toHaveBeenCalledTimes(2);
  expect(store.getState().phase).toBe('DROP_PENDING');
})",steel
/test/unit/state/middleware/drop/timing.spec.js,Duplicate Assert,"{'line': 64, 'column': 2, 'index': 2126}","it('should dispatch a DROP_PENDING action if COLLECTING', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  store.dispatch(collectionStarting());

  // now in the bulk collecting phase
  expect(store.getState().phase).toBe('COLLECTING');
  mock.mockReset();

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  expect(mock).toHaveBeenCalledWith(drop({ reason: 'DROP' }));
  expect(mock).toHaveBeenCalledWith(dropPending({ reason: 'DROP' }));
  expect(mock).toHaveBeenCalledTimes(2);
  expect(store.getState().phase).toBe('DROP_PENDING');
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 29, 'column': 2, 'index': 1085}","it('should clear any destination from a final impact if not dropping on a droppable', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination !== null);

  // no destination
  store.dispatch(move({ client: { x: 10000, y: 10000 } }));
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
  }

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 30, 'column': 2, 'index': 1128}","it('should clear any destination from a final impact if not dropping on a droppable', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination !== null);

  // no destination
  store.dispatch(move({ client: { x: 10000, y: 10000 } }));
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
  }

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 36, 'column': 4, 'index': 1301}","it('should clear any destination from a final impact if not dropping on a droppable', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination !== null);

  // no destination
  store.dispatch(move({ client: { x: 10000, y: 10000 } }));
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
  }

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 37, 'column': 11, 'index': 1353}","it('should clear any destination from a final impact if not dropping on a droppable', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination !== null);

  // no destination
  store.dispatch(move({ client: { x: 10000, y: 10000 } }));
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
  }

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 48, 'column': 9, 'index': 1668}","it('should clear any destination from a final impact if not dropping on a droppable', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination !== null);

  // no destination
  store.dispatch(move({ client: { x: 10000, y: 10000 } }));
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
  }

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 49, 'column': 4, 'index': 1715}","it('should clear any destination from a final impact if not dropping on a droppable', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination !== null);

  // no destination
  store.dispatch(move({ client: { x: 10000, y: 10000 } }));
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
  }

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 62, 'column': 2, 'index': 2193}","it('should clear any destination from a final impact canceling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // cancel
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 63, 'column': 2, 'index': 2236}","it('should clear any destination from a final impact canceling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // cancel
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 63, 'column': 12, 'index': 2246}","it('should clear any destination from a final impact canceling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // cancel
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 73, 'column': 9, 'index': 2559}","it('should clear any destination from a final impact canceling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // cancel
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 74, 'column': 4, 'index': 2606}","it('should clear any destination from a final impact canceling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // cancel
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 96, 'column': 2, 'index': 3309}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 97, 'column': 2, 'index': 3352}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 97, 'column': 12, 'index': 3362}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 103, 'column': 4, 'index': 3518}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 104, 'column': 11, 'index': 3570}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 105, 'column': 11, 'index': 3628}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 116, 'column': 9, 'index': 3922}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 118, 'column': 9, 'index': 4066}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Eager Test,"{'line': 119, 'column': 4, 'index': 4113}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Lazy Test,"{'line': 29, 'column': 2, 'index': 1085}","it('should clear any destination from a final impact if not dropping on a droppable', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination !== null);

  // no destination
  store.dispatch(move({ client: { x: 10000, y: 10000 } }));
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
  }

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Lazy Test,"{'line': 37, 'column': 11, 'index': 1353}","it('should clear any destination from a final impact if not dropping on a droppable', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination !== null);

  // no destination
  store.dispatch(move({ client: { x: 10000, y: 10000 } }));
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
  }

  // drop
  store.dispatch(drop({ reason: 'DROP' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Lazy Test,"{'line': 62, 'column': 2, 'index': 2193}","it('should clear any destination from a final impact canceling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // cancel
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Lazy Test,"{'line': 63, 'column': 12, 'index': 2246}","it('should clear any destination from a final impact canceling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(initialPublish(initialPublishArgs));
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // cancel
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the impact has the home destination for animation
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // but the consumer will be told that there was no destination
  expect(completed.result.destination).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Lazy Test,"{'line': 96, 'column': 2, 'index': 3309}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",steel
/test/unit/state/middleware/drop/result-impact-mismatch.spec.js,Lazy Test,"{'line': 97, 'column': 12, 'index': 3362}","it('should clear any combine from a final impact if cancelling', () => {
  const mock = jest.fn();
  const store: Store = createStore(passThrough(mock), middleware);

  store.dispatch(
    initialPublish({
      ...initialPublishArgs,
      dimensions: {
        draggables: initialPublishArgs.dimensions.draggables,
        droppables: enableCombining(initialPublishArgs.dimensions.droppables),
      },
      movementMode: 'SNAP',
    }),
  );
  expect(store.getState().phase).toBe('DRAGGING');
  const initial: State = store.getState();
  invariant(initial.phase === 'DRAGGING');
  invariant(tryGetDestination(initial.impact) !== null);

  // moving onto a combine
  store.dispatch(moveDown());
  {
    const current: State = store.getState();
    invariant(current.phase === 'DRAGGING');
    expect(tryGetDestination(current.impact)).toBe(null);
    expect(tryGetCombine(current.impact)).toBeTruthy();
  }

  // drop
  store.dispatch(drop({ reason: 'CANCEL' }));

  const args: AnimateDropArgs =
    mock.mock.calls[mock.mock.calls.length - 1][0].payload;
  const completed: CompletedDrag = args.completed;

  // the combine has been removed
  expect(tryGetCombine(completed.impact)).toBe(null);
  // for animation purposes it has a final impact of moving back to the starting position
  expect(tryGetDestination(completed.impact)).toBe(
    tryGetDestination(initial.impact),
  );
  // the consumer will be told that there was no combine
  expect(completed.result.combine).toBe(null);
})",steel
/test/unit/state/middleware/drop/get-drop-duration.spec.js,Duplicate Assert,"{'line': 17, 'column': 2, 'index': 492}","it('should return the a small amount if not moving anywhere', () => {
  const noWhere: number = getDropDuration({
    current: { x: 10, y: 10 },
    destination: { x: 10, y: 10 },
    reason: 'DROP',
  });
  const further: number = getDropDuration({
    current: { x: 1, y: 1 },
    destination: { x: 100, y: 100 },
    reason: 'DROP',
  });

  expect(noWhere).toEqual(expect.any(Number));
  expect(noWhere).toBeLessThan(further);
})",steel
/test/unit/state/middleware/drop/get-drop-duration.spec.js,Duplicate Assert,"{'line': 18, 'column': 2, 'index': 539}","it('should return the a small amount if not moving anywhere', () => {
  const noWhere: number = getDropDuration({
    current: { x: 10, y: 10 },
    destination: { x: 10, y: 10 },
    reason: 'DROP',
  });
  const further: number = getDropDuration({
    current: { x: 1, y: 1 },
    destination: { x: 100, y: 100 },
    reason: 'DROP',
  });

  expect(noWhere).toEqual(expect.any(Number));
  expect(noWhere).toBeLessThan(further);
})",steel
/test/unit/state/middleware/drop/drop-position.spec.js,Conditional Test Logic,"{'line': 22, 'column': 23, 'index': 1074}",Unknown,steel
/test/unit/state/middleware/drop/drop-position.spec.js,Lazy Test,"{'line': 51, 'column': 19, 'index': 2035}","it('should return the difference between the current client position and where it needs to be', () => {
      // inHome1 in inHome2 position
      const pastInHome2: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            { dimension: preset.inHome3, shouldAnimate: false },
            { dimension: preset.inHome4, shouldAnimate: false },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: preset.inHome2.descriptor.index,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const currentClientCenter: Position = getClientBorderBoxCenter({
        impact: pastInHome2,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        afterCritical,
        droppable: preset.home,
        viewport: preset.viewport,
      });
      const offsetFromHome: Position = getNewHomeClientOffset({
        impact: pastInHome2,
        draggable: preset.inHome1,
        dimensions: preset.dimensions,
        viewport: preset.viewport,
        afterCritical,
      });

      const diff: Position = subtract(
        currentClientCenter,
        preset.inHome1.client.borderBox.center,
      );
      expect(offsetFromHome).toEqual(diff);
    })",steel
/test/unit/state/middleware/drop/drop-position.spec.js,Lazy Test,"{'line': 95, 'column': 19, 'index': 3425}","it('should account for a collapsing home draggable when merging', () => {
      // inHome1 merging with inHome3
      // inHome1 will collapse on drop and this needs to be accounted for
      const mergingWithInHome3: DragImpact = {
        displacedBy,
        displaced: getForcedDisplacement({
          // inHome2 is no longer displaced
          visible: [
            { dimension: preset.inHome3, shouldAnimate: false },
            { dimension: preset.inHome4, shouldAnimate: false },
          ],
        }),
        at: {
          type: 'COMBINE',
          combine: {
            draggableId: preset.inHome3.descriptor.id,
            droppableId: preset.home.descriptor.id,
          },
        },
      };

      const currentClientCenter: Position = getClientBorderBoxCenter({
        impact: mergingWithInHome3,
        draggable: preset.inHome1,
        draggables: preset.draggables,
        afterCritical,
        droppable: preset.home,
        viewport: preset.viewport,
      });
      const offsetFromHome: Position = getNewHomeClientOffset({
        impact: mergingWithInHome3,
        draggable: preset.inHome1,
        dimensions: preset.dimensions,
        viewport: preset.viewport,
        afterCritical,
      });
      const offset: Position = subtract(
        currentClientCenter,
        preset.inHome1.client.borderBox.center,
      );

      expect(offsetFromHome).toEqual(offset);
    })",steel
/test/unit/state/middleware/drop/drop-impact.spec.js,Lazy Test,"{'line': 80, 'column': 15, 'index': 2313}","it('should use the existing impact when reordering', () => {
  // inHome1 moved into position of inHome2
  const lastImpact: DragImpact = {
    displaced: getForcedDisplacement({
      // initial displacement is not animated
      visible: [
        { dimension: preset.inHome3, shouldAnimate: false },
        { dimension: preset.inHome4, shouldAnimate: false },
      ],
    }),
    displacedBy,
    at: {
      type: 'REORDER',
      destination: {
        index: preset.inHome2.descriptor.index,
        droppableId: preset.home.descriptor.id,
      },
    },
  };

  const result: Result = getDropImpact({
    reason: 'DROP',
    lastImpact,
    home: preset.home,
    viewport: preset.viewport,
    draggables: preset.draggables,
    onLiftImpact: homeImpact,
    afterCritical,
  });

  const expected: Result = {
    impact: lastImpact,
    didDropInsideDroppable: true,
  };
  expect(result).toEqual(expected);
})",steel
/test/unit/state/middleware/drop/drop-impact.spec.js,Lazy Test,"{'line': 118, 'column': 15, 'index': 3294}","it('should remove any movement when merging so items will collapse', () => {
  // inHome1 moved forward and merged with inHome3
  // inHome2 has been moved past
  const lastImpact: DragImpact = {
    displaced: getForcedDisplacement({
      visible: [
        // initial displacement is not animated
        { dimension: preset.inHome3, shouldAnimate: false },
        { dimension: preset.inHome4, shouldAnimate: false },
      ],
    }),
    displacedBy,
    at: {
      type: 'COMBINE',
      combine: {
        droppableId: preset.home.descriptor.id,
        draggableId: preset.inHome3.descriptor.id,
      },
    },
  };

  const result: Result = getDropImpact({
    reason: 'DROP',
    lastImpact,
    home: preset.home,
    viewport: preset.viewport,
    draggables: preset.draggables,
    onLiftImpact: homeImpact,
    afterCritical,
  });

  const newImpact: DragImpact = {
    ...lastImpact,
    displaced: emptyGroups,
  };
  const expected: Result = {
    impact: newImpact,
    didDropInsideDroppable: true,
  };
  expect(result).toEqual(expected);
})",steel
/test/unit/state/middleware/drop/drop-animation-flush-on-scroll-middleware.spec.js,Conditional Test Logic,"{'line': 90, 'column': 4, 'index': 2625}","it('should not try to cancel a drop animation if the drop finished', () => {
  [
    flush(),
    completeDrop(getCompletedArgs('DROP')),
    dropAnimationFinished(),
  ].forEach((action: Action) => {
    const mock = jest.fn();
    const store: Store = getToDropAnimation(mock);

    store.dispatch(action);
    mock.mockClear();

    // would normally trigger a dropAnimationFinished
    requestAnimationFrame.step();
    window.dispatchEvent(new Event('scroll'));

    expect(mock).not.toHaveBeenCalled();
  });
})",steel
/test/unit/state/middleware/drop/drop-animation-flush-on-scroll-middleware.spec.js,Duplicate Assert,"{'line': 60, 'column': 2, 'index': 1767}","it('should clear any running drop is a scroll event occurs', () => {
  const mock = jest.fn();
  getToDropAnimation(mock);

  mock.mockReset();
  // waiting for an animation frame before any scroll events would cancel a drag
  window.dispatchEvent(new Event('scroll'));
  expect(mock).not.toHaveBeenCalled();

  // after an animation frame, we should be in business
  requestAnimationFrame.step();
  window.dispatchEvent(new Event('scroll'));

  expect(mock).toHaveBeenCalledWith(dropAnimationFinished());
  expect(mock).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/drop/drop-animation-flush-on-scroll-middleware.spec.js,Duplicate Assert,"{'line': 66, 'column': 2, 'index': 1941}","it('should clear any running drop is a scroll event occurs', () => {
  const mock = jest.fn();
  getToDropAnimation(mock);

  mock.mockReset();
  // waiting for an animation frame before any scroll events would cancel a drag
  window.dispatchEvent(new Event('scroll'));
  expect(mock).not.toHaveBeenCalled();

  // after an animation frame, we should be in business
  requestAnimationFrame.step();
  window.dispatchEvent(new Event('scroll'));

  expect(mock).toHaveBeenCalledWith(dropAnimationFinished());
  expect(mock).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/drop/drop-animation-flush-on-scroll-middleware.spec.js,Duplicate Assert,"{'line': 67, 'column': 2, 'index': 2003}","it('should clear any running drop is a scroll event occurs', () => {
  const mock = jest.fn();
  getToDropAnimation(mock);

  mock.mockReset();
  // waiting for an animation frame before any scroll events would cancel a drag
  window.dispatchEvent(new Event('scroll'));
  expect(mock).not.toHaveBeenCalled();

  // after an animation frame, we should be in business
  requestAnimationFrame.step();
  window.dispatchEvent(new Event('scroll'));

  expect(mock).toHaveBeenCalledWith(dropAnimationFinished());
  expect(mock).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/drop/drop-animation-flush-on-scroll-middleware.spec.js,Duplicate Assert,"{'line': 81, 'column': 2, 'index': 2348}","it('should only try to clear once', () => {
  const mock = jest.fn();
  getToDropAnimation(mock);

  mock.mockReset();

  // after an animation frame, we should be in business
  requestAnimationFrame.step();
  window.dispatchEvent(new Event('scroll'));
  window.dispatchEvent(new Event('scroll'));

  expect(mock).toHaveBeenCalledWith(dropAnimationFinished());
  expect(mock).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/drop/drop-animation-flush-on-scroll-middleware.spec.js,Duplicate Assert,"{'line': 82, 'column': 2, 'index': 2410}","it('should only try to clear once', () => {
  const mock = jest.fn();
  getToDropAnimation(mock);

  mock.mockReset();

  // after an animation frame, we should be in business
  requestAnimationFrame.step();
  window.dispatchEvent(new Event('scroll'));
  window.dispatchEvent(new Event('scroll'));

  expect(mock).toHaveBeenCalledWith(dropAnimationFinished());
  expect(mock).toHaveBeenCalledTimes(1);
})",steel
/test/unit/state/middleware/drop/drop-animation-finish-middleware.spec.js,Duplicate Assert,"{'line': 52, 'column': 2, 'index': 1568}","it('should fire a complete drop action when a drop animation finish action is fired', () => {
  const mock = jest.fn();

  const store: Store = createStore(
    passThrough(mock),
    // will convert the drop into a drop animate
    dropMiddleware,
    middleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));

  expect(store.getState().phase).toBe('DRAGGING');

  // A small movement so a drop animation will be needed
  store.dispatch(
    move({
      client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
    }),
  );
  store.dispatch(drop({ reason: 'DROP' }));

  const state: State = store.getState();
  invariant(
    state.phase === 'DROP_ANIMATING',
    `Incorrect phase: ${state.phase}`,
  );

  mock.mockReset();
  store.dispatch(dropAnimationFinished());
  expect(mock).toHaveBeenCalledWith(dropAnimationFinished());

  expect(mock).toHaveBeenCalledWith(completeDrop(getCompletedArgs('DROP')));
  expect(mock).toHaveBeenCalledTimes(2);
})",steel
/test/unit/state/middleware/drop/drop-animation-finish-middleware.spec.js,Duplicate Assert,"{'line': 54, 'column': 2, 'index': 1631}","it('should fire a complete drop action when a drop animation finish action is fired', () => {
  const mock = jest.fn();

  const store: Store = createStore(
    passThrough(mock),
    // will convert the drop into a drop animate
    dropMiddleware,
    middleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));

  expect(store.getState().phase).toBe('DRAGGING');

  // A small movement so a drop animation will be needed
  store.dispatch(
    move({
      client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
    }),
  );
  store.dispatch(drop({ reason: 'DROP' }));

  const state: State = store.getState();
  invariant(
    state.phase === 'DROP_ANIMATING',
    `Incorrect phase: ${state.phase}`,
  );

  mock.mockReset();
  store.dispatch(dropAnimationFinished());
  expect(mock).toHaveBeenCalledWith(dropAnimationFinished());

  expect(mock).toHaveBeenCalledWith(completeDrop(getCompletedArgs('DROP')));
  expect(mock).toHaveBeenCalledTimes(2);
})",steel
/test/unit/state/middleware/drop/drop-animation-finish-middleware.spec.js,Duplicate Assert,"{'line': 55, 'column': 2, 'index': 1708}","it('should fire a complete drop action when a drop animation finish action is fired', () => {
  const mock = jest.fn();

  const store: Store = createStore(
    passThrough(mock),
    // will convert the drop into a drop animate
    dropMiddleware,
    middleware,
  );

  store.dispatch(initialPublish(initialPublishArgs));

  expect(store.getState().phase).toBe('DRAGGING');

  // A small movement so a drop animation will be needed
  store.dispatch(
    move({
      client: add(initialPublishArgs.clientSelection, { x: 1, y: 1 }),
    }),
  );
  store.dispatch(drop({ reason: 'DROP' }));

  const state: State = store.getState();
  invariant(
    state.phase === 'DROP_ANIMATING',
    `Incorrect phase: ${state.phase}`,
  );

  mock.mockReset();
  store.dispatch(dropAnimationFinished());
  expect(mock).toHaveBeenCalledWith(dropAnimationFinished());

  expect(mock).toHaveBeenCalledWith(completeDrop(getCompletedArgs('DROP')));
  expect(mock).toHaveBeenCalledTimes(2);
})",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Conditional Test Logic,"{'line': 46, 'column': 19, 'index': 1383}",Unknown,steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 54, 'column': 6, 'index': 1750}","it('should fire a complete drop action is no drop animation is required', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      store.dispatch(flush());
      store.dispatch(initialPublish(initialPublishArgs));
      expect(store.getState().phase).toBe('DRAGGING');

      // no movement yet
      mock.mockReset();
      store.dispatch(drop({ reason }));

      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(completeDrop(getCompletedArgs(reason)));
      expect(mock).toHaveBeenCalledTimes(2);

      // reset to initial phase
      expect(store.getState().phase).toBe('IDLE');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 60, 'column': 6, 'index': 1896}","it('should fire a complete drop action is no drop animation is required', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      store.dispatch(flush());
      store.dispatch(initialPublish(initialPublishArgs));
      expect(store.getState().phase).toBe('DRAGGING');

      // no movement yet
      mock.mockReset();
      store.dispatch(drop({ reason }));

      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(completeDrop(getCompletedArgs(reason)));
      expect(mock).toHaveBeenCalledTimes(2);

      // reset to initial phase
      expect(store.getState().phase).toBe('IDLE');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 61, 'column': 6, 'index': 1955}","it('should fire a complete drop action is no drop animation is required', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      store.dispatch(flush());
      store.dispatch(initialPublish(initialPublishArgs));
      expect(store.getState().phase).toBe('DRAGGING');

      // no movement yet
      mock.mockReset();
      store.dispatch(drop({ reason }));

      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(completeDrop(getCompletedArgs(reason)));
      expect(mock).toHaveBeenCalledTimes(2);

      // reset to initial phase
      expect(store.getState().phase).toBe('IDLE');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 62, 'column': 6, 'index': 2036}","it('should fire a complete drop action is no drop animation is required', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      store.dispatch(flush());
      store.dispatch(initialPublish(initialPublishArgs));
      expect(store.getState().phase).toBe('DRAGGING');

      // no movement yet
      mock.mockReset();
      store.dispatch(drop({ reason }));

      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(completeDrop(getCompletedArgs(reason)));
      expect(mock).toHaveBeenCalledTimes(2);

      // reset to initial phase
      expect(store.getState().phase).toBe('IDLE');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 65, 'column': 6, 'index': 2114}","it('should fire a complete drop action is no drop animation is required', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      store.dispatch(flush());
      store.dispatch(initialPublish(initialPublishArgs));
      expect(store.getState().phase).toBe('DRAGGING');

      // no movement yet
      mock.mockReset();
      store.dispatch(drop({ reason }));

      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(completeDrop(getCompletedArgs(reason)));
      expect(mock).toHaveBeenCalledTimes(2);

      // reset to initial phase
      expect(store.getState().phase).toBe('IDLE');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 73, 'column': 6, 'index': 2428}","it('should fire an animate drop action if a drop animation movement is required', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      store.dispatch(initialPublish(initialPublishArgs));
      expect(store.getState().phase).toBe('DRAGGING');

      // moving a little bit so that a drop animation will be needed
      const shift: Position = { x: 1, y: 1 };
      store.dispatch(
        move({
          client: add(initialPublishArgs.clientSelection, shift),
        }),
      );
      const current: State = store.getState();
      invariant(current.isDragging);
      // impact is cleared when cancelling
      const destination: ?DraggableLocation =
        reason === 'DROP' ? getDragStart().source : null;

      mock.mockReset();
      store.dispatch(drop({ reason }));

      const result: DropResult = {
        ...getDragStart(),
        destination,
        reason,
        combine: null,
      };
      const completed: CompletedDrag = {
        result,
        impact: getDropImpactForReason(reason),
        critical,
        afterCritical,
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: origin,
        dropDuration: getDropDuration({
          current: shift,
          destination: origin,
          reason,
        }),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 112, 'column': 6, 'index': 3536}","it('should fire an animate drop action if a drop animation movement is required', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      store.dispatch(initialPublish(initialPublishArgs));
      expect(store.getState().phase).toBe('DRAGGING');

      // moving a little bit so that a drop animation will be needed
      const shift: Position = { x: 1, y: 1 };
      store.dispatch(
        move({
          client: add(initialPublishArgs.clientSelection, shift),
        }),
      );
      const current: State = store.getState();
      invariant(current.isDragging);
      // impact is cleared when cancelling
      const destination: ?DraggableLocation =
        reason === 'DROP' ? getDragStart().source : null;

      mock.mockReset();
      store.dispatch(drop({ reason }));

      const result: DropResult = {
        ...getDragStart(),
        destination,
        reason,
        combine: null,
      };
      const completed: CompletedDrag = {
        result,
        impact: getDropImpactForReason(reason),
        critical,
        afterCritical,
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: origin,
        dropDuration: getDropDuration({
          current: shift,
          destination: origin,
          reason,
        }),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 113, 'column': 6, 'index': 3595}","it('should fire an animate drop action if a drop animation movement is required', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      store.dispatch(initialPublish(initialPublishArgs));
      expect(store.getState().phase).toBe('DRAGGING');

      // moving a little bit so that a drop animation will be needed
      const shift: Position = { x: 1, y: 1 };
      store.dispatch(
        move({
          client: add(initialPublishArgs.clientSelection, shift),
        }),
      );
      const current: State = store.getState();
      invariant(current.isDragging);
      // impact is cleared when cancelling
      const destination: ?DraggableLocation =
        reason === 'DROP' ? getDragStart().source : null;

      mock.mockReset();
      store.dispatch(drop({ reason }));

      const result: DropResult = {
        ...getDragStart(),
        destination,
        reason,
        combine: null,
      };
      const completed: CompletedDrag = {
        result,
        impact: getDropImpactForReason(reason),
        critical,
        afterCritical,
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: origin,
        dropDuration: getDropDuration({
          current: shift,
          destination: origin,
          reason,
        }),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 114, 'column': 6, 'index': 3655}","it('should fire an animate drop action if a drop animation movement is required', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      store.dispatch(initialPublish(initialPublishArgs));
      expect(store.getState().phase).toBe('DRAGGING');

      // moving a little bit so that a drop animation will be needed
      const shift: Position = { x: 1, y: 1 };
      store.dispatch(
        move({
          client: add(initialPublishArgs.clientSelection, shift),
        }),
      );
      const current: State = store.getState();
      invariant(current.isDragging);
      // impact is cleared when cancelling
      const destination: ?DraggableLocation =
        reason === 'DROP' ? getDragStart().source : null;

      mock.mockReset();
      store.dispatch(drop({ reason }));

      const result: DropResult = {
        ...getDragStart(),
        destination,
        reason,
        combine: null,
      };
      const completed: CompletedDrag = {
        result,
        impact: getDropImpactForReason(reason),
        critical,
        afterCritical,
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: origin,
        dropDuration: getDropDuration({
          current: shift,
          destination: origin,
          reason,
        }),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 115, 'column': 6, 'index': 3700}","it('should fire an animate drop action if a drop animation movement is required', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      store.dispatch(initialPublish(initialPublishArgs));
      expect(store.getState().phase).toBe('DRAGGING');

      // moving a little bit so that a drop animation will be needed
      const shift: Position = { x: 1, y: 1 };
      store.dispatch(
        move({
          client: add(initialPublishArgs.clientSelection, shift),
        }),
      );
      const current: State = store.getState();
      invariant(current.isDragging);
      // impact is cleared when cancelling
      const destination: ?DraggableLocation =
        reason === 'DROP' ? getDragStart().source : null;

      mock.mockReset();
      store.dispatch(drop({ reason }));

      const result: DropResult = {
        ...getDragStart(),
        destination,
        reason,
        combine: null,
      };
      const completed: CompletedDrag = {
        result,
        impact: getDropImpactForReason(reason),
        critical,
        afterCritical,
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: origin,
        dropDuration: getDropDuration({
          current: shift,
          destination: origin,
          reason,
        }),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 199, 'column': 6, 'index': 6284}","it('should fire an animate drop action if combining', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      const inSnapMode: InitialPublishArgs = {
        ...initialPublishArgs,
        movementMode: 'SNAP',
      };
      store.dispatch(initialPublish(inSnapMode));
      store.dispatch(
        updateDroppableIsCombineEnabled({
          id: inSnapMode.critical.droppable.id,
          isCombineEnabled: true,
        }),
      );
      {
        const current: State = store.getState();
        invariant(current.phase === 'DRAGGING');
        invariant(current.movementMode === 'SNAP');
        invariant(
          current.dimensions.droppables[inSnapMode.critical.droppable.id]
            .isCombineEnabled,
        );
      }
      // combine
      store.dispatch(moveDown());
      // move past and shift item up
      store.dispatch(moveDown());
      // move backwards onto the displaced item
      store.dispatch(moveUp());
      mock.mockReset();

      const current: State = store.getState();
      invariant(current.isDragging);

      // if (reason === 'DROP') {
      const combine: ?Combine = tryGetCombine(current.impact);
      invariant(combine);
      // moved forwards past in home2, and then backwards onto it
      expect(combine).toEqual({
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      });

      store.dispatch(drop({ reason }));

      const combineDropImpact: DragImpact = getDropImpact({
        reason,
        draggables: preset.draggables,
        lastImpact: current.impact,
        home: preset.home,
        viewport: preset.viewport,
        onLiftImpact: homeImpact,
        afterCritical,
      }).impact;

      const completed: CompletedDrag = {
        critical,
        impact: combineDropImpact,
        afterCritical,
        result: {
          ...getDragStart(),
          // we are using snap movements
          mode: 'SNAP',
          destination: null,
          combine: reason === 'DROP' ? combine : null,
          reason,
        },
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: getNewHomeClientOffset({
          impact: combineDropImpact,
          draggable: preset.inHome1,
          dimensions: preset.dimensions,
          viewport: preset.viewport,
          afterCritical,
        }),
        // $ExpectError - wrong type
        dropDuration: expect.any(Number),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 200, 'column': 6, 'index': 6343}","it('should fire an animate drop action if combining', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      const inSnapMode: InitialPublishArgs = {
        ...initialPublishArgs,
        movementMode: 'SNAP',
      };
      store.dispatch(initialPublish(inSnapMode));
      store.dispatch(
        updateDroppableIsCombineEnabled({
          id: inSnapMode.critical.droppable.id,
          isCombineEnabled: true,
        }),
      );
      {
        const current: State = store.getState();
        invariant(current.phase === 'DRAGGING');
        invariant(current.movementMode === 'SNAP');
        invariant(
          current.dimensions.droppables[inSnapMode.critical.droppable.id]
            .isCombineEnabled,
        );
      }
      // combine
      store.dispatch(moveDown());
      // move past and shift item up
      store.dispatch(moveDown());
      // move backwards onto the displaced item
      store.dispatch(moveUp());
      mock.mockReset();

      const current: State = store.getState();
      invariant(current.isDragging);

      // if (reason === 'DROP') {
      const combine: ?Combine = tryGetCombine(current.impact);
      invariant(combine);
      // moved forwards past in home2, and then backwards onto it
      expect(combine).toEqual({
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      });

      store.dispatch(drop({ reason }));

      const combineDropImpact: DragImpact = getDropImpact({
        reason,
        draggables: preset.draggables,
        lastImpact: current.impact,
        home: preset.home,
        viewport: preset.viewport,
        onLiftImpact: homeImpact,
        afterCritical,
      }).impact;

      const completed: CompletedDrag = {
        critical,
        impact: combineDropImpact,
        afterCritical,
        result: {
          ...getDragStart(),
          // we are using snap movements
          mode: 'SNAP',
          destination: null,
          combine: reason === 'DROP' ? combine : null,
          reason,
        },
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: getNewHomeClientOffset({
          impact: combineDropImpact,
          draggable: preset.inHome1,
          dimensions: preset.dimensions,
          viewport: preset.viewport,
          afterCritical,
        }),
        // $ExpectError - wrong type
        dropDuration: expect.any(Number),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Duplicate Assert,"{'line': 201, 'column': 6, 'index': 6403}","it('should fire an animate drop action if combining', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      const inSnapMode: InitialPublishArgs = {
        ...initialPublishArgs,
        movementMode: 'SNAP',
      };
      store.dispatch(initialPublish(inSnapMode));
      store.dispatch(
        updateDroppableIsCombineEnabled({
          id: inSnapMode.critical.droppable.id,
          isCombineEnabled: true,
        }),
      );
      {
        const current: State = store.getState();
        invariant(current.phase === 'DRAGGING');
        invariant(current.movementMode === 'SNAP');
        invariant(
          current.dimensions.droppables[inSnapMode.critical.droppable.id]
            .isCombineEnabled,
        );
      }
      // combine
      store.dispatch(moveDown());
      // move past and shift item up
      store.dispatch(moveDown());
      // move backwards onto the displaced item
      store.dispatch(moveUp());
      mock.mockReset();

      const current: State = store.getState();
      invariant(current.isDragging);

      // if (reason === 'DROP') {
      const combine: ?Combine = tryGetCombine(current.impact);
      invariant(combine);
      // moved forwards past in home2, and then backwards onto it
      expect(combine).toEqual({
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      });

      store.dispatch(drop({ reason }));

      const combineDropImpact: DragImpact = getDropImpact({
        reason,
        draggables: preset.draggables,
        lastImpact: current.impact,
        home: preset.home,
        viewport: preset.viewport,
        onLiftImpact: homeImpact,
        afterCritical,
      }).impact;

      const completed: CompletedDrag = {
        critical,
        impact: combineDropImpact,
        afterCritical,
        result: {
          ...getDragStart(),
          // we are using snap movements
          mode: 'SNAP',
          destination: null,
          combine: reason === 'DROP' ? combine : null,
          reason,
        },
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: getNewHomeClientOffset({
          impact: combineDropImpact,
          draggable: preset.inHome1,
          dimensions: preset.dimensions,
          viewport: preset.viewport,
          afterCritical,
        }),
        // $ExpectError - wrong type
        dropDuration: expect.any(Number),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Eager Test,"{'line': 135, 'column': 8, 'index': 4331}","it('should fire an animate drop action if combining', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      const inSnapMode: InitialPublishArgs = {
        ...initialPublishArgs,
        movementMode: 'SNAP',
      };
      store.dispatch(initialPublish(inSnapMode));
      store.dispatch(
        updateDroppableIsCombineEnabled({
          id: inSnapMode.critical.droppable.id,
          isCombineEnabled: true,
        }),
      );
      {
        const current: State = store.getState();
        invariant(current.phase === 'DRAGGING');
        invariant(current.movementMode === 'SNAP');
        invariant(
          current.dimensions.droppables[inSnapMode.critical.droppable.id]
            .isCombineEnabled,
        );
      }
      // combine
      store.dispatch(moveDown());
      // move past and shift item up
      store.dispatch(moveDown());
      // move backwards onto the displaced item
      store.dispatch(moveUp());
      mock.mockReset();

      const current: State = store.getState();
      invariant(current.isDragging);

      // if (reason === 'DROP') {
      const combine: ?Combine = tryGetCombine(current.impact);
      invariant(combine);
      // moved forwards past in home2, and then backwards onto it
      expect(combine).toEqual({
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      });

      store.dispatch(drop({ reason }));

      const combineDropImpact: DragImpact = getDropImpact({
        reason,
        draggables: preset.draggables,
        lastImpact: current.impact,
        home: preset.home,
        viewport: preset.viewport,
        onLiftImpact: homeImpact,
        afterCritical,
      }).impact;

      const completed: CompletedDrag = {
        critical,
        impact: combineDropImpact,
        afterCritical,
        result: {
          ...getDragStart(),
          // we are using snap movements
          mode: 'SNAP',
          destination: null,
          combine: reason === 'DROP' ? combine : null,
          reason,
        },
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: getNewHomeClientOffset({
          impact: combineDropImpact,
          draggable: preset.inHome1,
          dimensions: preset.dimensions,
          viewport: preset.viewport,
          afterCritical,
        }),
        // $ExpectError - wrong type
        dropDuration: expect.any(Number),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Eager Test,"{'line': 136, 'column': 8, 'index': 4380}","it('should fire an animate drop action if combining', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      const inSnapMode: InitialPublishArgs = {
        ...initialPublishArgs,
        movementMode: 'SNAP',
      };
      store.dispatch(initialPublish(inSnapMode));
      store.dispatch(
        updateDroppableIsCombineEnabled({
          id: inSnapMode.critical.droppable.id,
          isCombineEnabled: true,
        }),
      );
      {
        const current: State = store.getState();
        invariant(current.phase === 'DRAGGING');
        invariant(current.movementMode === 'SNAP');
        invariant(
          current.dimensions.droppables[inSnapMode.critical.droppable.id]
            .isCombineEnabled,
        );
      }
      // combine
      store.dispatch(moveDown());
      // move past and shift item up
      store.dispatch(moveDown());
      // move backwards onto the displaced item
      store.dispatch(moveUp());
      mock.mockReset();

      const current: State = store.getState();
      invariant(current.isDragging);

      // if (reason === 'DROP') {
      const combine: ?Combine = tryGetCombine(current.impact);
      invariant(combine);
      // moved forwards past in home2, and then backwards onto it
      expect(combine).toEqual({
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      });

      store.dispatch(drop({ reason }));

      const combineDropImpact: DragImpact = getDropImpact({
        reason,
        draggables: preset.draggables,
        lastImpact: current.impact,
        home: preset.home,
        viewport: preset.viewport,
        onLiftImpact: homeImpact,
        afterCritical,
      }).impact;

      const completed: CompletedDrag = {
        critical,
        impact: combineDropImpact,
        afterCritical,
        result: {
          ...getDragStart(),
          // we are using snap movements
          mode: 'SNAP',
          destination: null,
          combine: reason === 'DROP' ? combine : null,
          reason,
        },
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: getNewHomeClientOffset({
          impact: combineDropImpact,
          draggable: preset.inHome1,
          dimensions: preset.dimensions,
          viewport: preset.viewport,
          afterCritical,
        }),
        // $ExpectError - wrong type
        dropDuration: expect.any(Number),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Eager Test,"{'line': 137, 'column': 8, 'index': 4432}","it('should fire an animate drop action if combining', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      const inSnapMode: InitialPublishArgs = {
        ...initialPublishArgs,
        movementMode: 'SNAP',
      };
      store.dispatch(initialPublish(inSnapMode));
      store.dispatch(
        updateDroppableIsCombineEnabled({
          id: inSnapMode.critical.droppable.id,
          isCombineEnabled: true,
        }),
      );
      {
        const current: State = store.getState();
        invariant(current.phase === 'DRAGGING');
        invariant(current.movementMode === 'SNAP');
        invariant(
          current.dimensions.droppables[inSnapMode.critical.droppable.id]
            .isCombineEnabled,
        );
      }
      // combine
      store.dispatch(moveDown());
      // move past and shift item up
      store.dispatch(moveDown());
      // move backwards onto the displaced item
      store.dispatch(moveUp());
      mock.mockReset();

      const current: State = store.getState();
      invariant(current.isDragging);

      // if (reason === 'DROP') {
      const combine: ?Combine = tryGetCombine(current.impact);
      invariant(combine);
      // moved forwards past in home2, and then backwards onto it
      expect(combine).toEqual({
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      });

      store.dispatch(drop({ reason }));

      const combineDropImpact: DragImpact = getDropImpact({
        reason,
        draggables: preset.draggables,
        lastImpact: current.impact,
        home: preset.home,
        viewport: preset.viewport,
        onLiftImpact: homeImpact,
        afterCritical,
      }).impact;

      const completed: CompletedDrag = {
        critical,
        impact: combineDropImpact,
        afterCritical,
        result: {
          ...getDragStart(),
          // we are using snap movements
          mode: 'SNAP',
          destination: null,
          combine: reason === 'DROP' ? combine : null,
          reason,
        },
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: getNewHomeClientOffset({
          impact: combineDropImpact,
          draggable: preset.inHome1,
          dimensions: preset.dimensions,
          viewport: preset.viewport,
          afterCritical,
        }),
        // $ExpectError - wrong type
        dropDuration: expect.any(Number),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Eager Test,"{'line': 151, 'column': 6, 'index': 4847}","it('should fire an animate drop action if combining', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      const inSnapMode: InitialPublishArgs = {
        ...initialPublishArgs,
        movementMode: 'SNAP',
      };
      store.dispatch(initialPublish(inSnapMode));
      store.dispatch(
        updateDroppableIsCombineEnabled({
          id: inSnapMode.critical.droppable.id,
          isCombineEnabled: true,
        }),
      );
      {
        const current: State = store.getState();
        invariant(current.phase === 'DRAGGING');
        invariant(current.movementMode === 'SNAP');
        invariant(
          current.dimensions.droppables[inSnapMode.critical.droppable.id]
            .isCombineEnabled,
        );
      }
      // combine
      store.dispatch(moveDown());
      // move past and shift item up
      store.dispatch(moveDown());
      // move backwards onto the displaced item
      store.dispatch(moveUp());
      mock.mockReset();

      const current: State = store.getState();
      invariant(current.isDragging);

      // if (reason === 'DROP') {
      const combine: ?Combine = tryGetCombine(current.impact);
      invariant(combine);
      // moved forwards past in home2, and then backwards onto it
      expect(combine).toEqual({
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      });

      store.dispatch(drop({ reason }));

      const combineDropImpact: DragImpact = getDropImpact({
        reason,
        draggables: preset.draggables,
        lastImpact: current.impact,
        home: preset.home,
        viewport: preset.viewport,
        onLiftImpact: homeImpact,
        afterCritical,
      }).impact;

      const completed: CompletedDrag = {
        critical,
        impact: combineDropImpact,
        afterCritical,
        result: {
          ...getDragStart(),
          // we are using snap movements
          mode: 'SNAP',
          destination: null,
          combine: reason === 'DROP' ? combine : null,
          reason,
        },
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: getNewHomeClientOffset({
          impact: combineDropImpact,
          draggable: preset.inHome1,
          dimensions: preset.dimensions,
          viewport: preset.viewport,
          afterCritical,
        }),
        // $ExpectError - wrong type
        dropDuration: expect.any(Number),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Eager Test,"{'line': 154, 'column': 32, 'index': 4945}","it('should fire an animate drop action if combining', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      const inSnapMode: InitialPublishArgs = {
        ...initialPublishArgs,
        movementMode: 'SNAP',
      };
      store.dispatch(initialPublish(inSnapMode));
      store.dispatch(
        updateDroppableIsCombineEnabled({
          id: inSnapMode.critical.droppable.id,
          isCombineEnabled: true,
        }),
      );
      {
        const current: State = store.getState();
        invariant(current.phase === 'DRAGGING');
        invariant(current.movementMode === 'SNAP');
        invariant(
          current.dimensions.droppables[inSnapMode.critical.droppable.id]
            .isCombineEnabled,
        );
      }
      // combine
      store.dispatch(moveDown());
      // move past and shift item up
      store.dispatch(moveDown());
      // move backwards onto the displaced item
      store.dispatch(moveUp());
      mock.mockReset();

      const current: State = store.getState();
      invariant(current.isDragging);

      // if (reason === 'DROP') {
      const combine: ?Combine = tryGetCombine(current.impact);
      invariant(combine);
      // moved forwards past in home2, and then backwards onto it
      expect(combine).toEqual({
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      });

      store.dispatch(drop({ reason }));

      const combineDropImpact: DragImpact = getDropImpact({
        reason,
        draggables: preset.draggables,
        lastImpact: current.impact,
        home: preset.home,
        viewport: preset.viewport,
        onLiftImpact: homeImpact,
        afterCritical,
      }).impact;

      const completed: CompletedDrag = {
        critical,
        impact: combineDropImpact,
        afterCritical,
        result: {
          ...getDragStart(),
          // we are using snap movements
          mode: 'SNAP',
          destination: null,
          combine: reason === 'DROP' ? combine : null,
          reason,
        },
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: getNewHomeClientOffset({
          impact: combineDropImpact,
          draggable: preset.inHome1,
          dimensions: preset.dimensions,
          viewport: preset.viewport,
          afterCritical,
        }),
        // $ExpectError - wrong type
        dropDuration: expect.any(Number),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Eager Test,"{'line': 155, 'column': 6, 'index': 4982}","it('should fire an animate drop action if combining', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      const inSnapMode: InitialPublishArgs = {
        ...initialPublishArgs,
        movementMode: 'SNAP',
      };
      store.dispatch(initialPublish(inSnapMode));
      store.dispatch(
        updateDroppableIsCombineEnabled({
          id: inSnapMode.critical.droppable.id,
          isCombineEnabled: true,
        }),
      );
      {
        const current: State = store.getState();
        invariant(current.phase === 'DRAGGING');
        invariant(current.movementMode === 'SNAP');
        invariant(
          current.dimensions.droppables[inSnapMode.critical.droppable.id]
            .isCombineEnabled,
        );
      }
      // combine
      store.dispatch(moveDown());
      // move past and shift item up
      store.dispatch(moveDown());
      // move backwards onto the displaced item
      store.dispatch(moveUp());
      mock.mockReset();

      const current: State = store.getState();
      invariant(current.isDragging);

      // if (reason === 'DROP') {
      const combine: ?Combine = tryGetCombine(current.impact);
      invariant(combine);
      // moved forwards past in home2, and then backwards onto it
      expect(combine).toEqual({
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      });

      store.dispatch(drop({ reason }));

      const combineDropImpact: DragImpact = getDropImpact({
        reason,
        draggables: preset.draggables,
        lastImpact: current.impact,
        home: preset.home,
        viewport: preset.viewport,
        onLiftImpact: homeImpact,
        afterCritical,
      }).impact;

      const completed: CompletedDrag = {
        critical,
        impact: combineDropImpact,
        afterCritical,
        result: {
          ...getDragStart(),
          // we are using snap movements
          mode: 'SNAP',
          destination: null,
          combine: reason === 'DROP' ? combine : null,
          reason,
        },
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: getNewHomeClientOffset({
          impact: combineDropImpact,
          draggable: preset.inHome1,
          dimensions: preset.dimensions,
          viewport: preset.viewport,
          afterCritical,
        }),
        // $ExpectError - wrong type
        dropDuration: expect.any(Number),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Lazy Test,"{'line': 83, 'column': 6, 'index': 2770}","it('should fire an animate drop action if a drop animation movement is required', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      store.dispatch(initialPublish(initialPublishArgs));
      expect(store.getState().phase).toBe('DRAGGING');

      // moving a little bit so that a drop animation will be needed
      const shift: Position = { x: 1, y: 1 };
      store.dispatch(
        move({
          client: add(initialPublishArgs.clientSelection, shift),
        }),
      );
      const current: State = store.getState();
      invariant(current.isDragging);
      // impact is cleared when cancelling
      const destination: ?DraggableLocation =
        reason === 'DROP' ? getDragStart().source : null;

      mock.mockReset();
      store.dispatch(drop({ reason }));

      const result: DropResult = {
        ...getDragStart(),
        destination,
        reason,
        combine: null,
      };
      const completed: CompletedDrag = {
        result,
        impact: getDropImpactForReason(reason),
        critical,
        afterCritical,
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: origin,
        dropDuration: getDropDuration({
          current: shift,
          destination: origin,
          reason,
        }),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/middleware/drop/conditionally-animate-drop.spec.js,Lazy Test,"{'line': 135, 'column': 8, 'index': 4331}","it('should fire an animate drop action if combining', () => {
      const mock = jest.fn();
      const store: Store = createStore(passThrough(mock), middleware);

      const inSnapMode: InitialPublishArgs = {
        ...initialPublishArgs,
        movementMode: 'SNAP',
      };
      store.dispatch(initialPublish(inSnapMode));
      store.dispatch(
        updateDroppableIsCombineEnabled({
          id: inSnapMode.critical.droppable.id,
          isCombineEnabled: true,
        }),
      );
      {
        const current: State = store.getState();
        invariant(current.phase === 'DRAGGING');
        invariant(current.movementMode === 'SNAP');
        invariant(
          current.dimensions.droppables[inSnapMode.critical.droppable.id]
            .isCombineEnabled,
        );
      }
      // combine
      store.dispatch(moveDown());
      // move past and shift item up
      store.dispatch(moveDown());
      // move backwards onto the displaced item
      store.dispatch(moveUp());
      mock.mockReset();

      const current: State = store.getState();
      invariant(current.isDragging);

      // if (reason === 'DROP') {
      const combine: ?Combine = tryGetCombine(current.impact);
      invariant(combine);
      // moved forwards past in home2, and then backwards onto it
      expect(combine).toEqual({
        draggableId: preset.inHome2.descriptor.id,
        droppableId: preset.home.descriptor.id,
      });

      store.dispatch(drop({ reason }));

      const combineDropImpact: DragImpact = getDropImpact({
        reason,
        draggables: preset.draggables,
        lastImpact: current.impact,
        home: preset.home,
        viewport: preset.viewport,
        onLiftImpact: homeImpact,
        afterCritical,
      }).impact;

      const completed: CompletedDrag = {
        critical,
        impact: combineDropImpact,
        afterCritical,
        result: {
          ...getDragStart(),
          // we are using snap movements
          mode: 'SNAP',
          destination: null,
          combine: reason === 'DROP' ? combine : null,
          reason,
        },
      };
      const args: AnimateDropArgs = {
        completed,
        newHomeClientOffset: getNewHomeClientOffset({
          impact: combineDropImpact,
          draggable: preset.inHome1,
          dimensions: preset.dimensions,
          viewport: preset.viewport,
          afterCritical,
        }),
        // $ExpectError - wrong type
        dropDuration: expect.any(Number),
      };
      expect(mock).toHaveBeenCalledWith(drop({ reason }));
      expect(mock).toHaveBeenCalledWith(animateDrop(args));
      expect(mock).toHaveBeenCalledTimes(2);
      expect(store.getState().phase).toBe('DROP_ANIMATING');
    })",steel
/test/unit/state/get-lift-effect/get-lift-effect.spec.js,Eager Test,"{'line': 40, 'column': 16, 'index': 1077}","it('should mark everything after the critical ', () => {
  const { impact, afterCritical } = getLiftEffect({
    draggable: preset.inHome2,
    home: preset.home,
    draggables: preset.draggables,
    viewport: preset.viewport,
  });

  // originally displacement
  const displacedBy: DisplacedBy = getDisplacedBy(
    preset.home.axis,
    preset.inHome2.displaceBy,
  );

  // ordered by closest impacted
  const all: DraggableDimension[] = [preset.inHome3, preset.inHome4];

  {
    const expected: LiftEffect = {
      inVirtualList: false,
      effected: getDraggableIdMap(getDraggableIds(all)),
      displacedBy,
    };
    expect(afterCritical).toEqual(expected);
  }
  {
    const expected: DragImpact = {
      displaced: getForcedDisplacement({
        visible: all.map((dimension) => ({ dimension, shouldAnimate: false })),
      }),
      displacedBy,
      at: {
        type: 'REORDER',
        destination: getHomeLocation(preset.inHome2.descriptor),
      },
    };
    expect(impact).toEqual(expected);
  }
})",steel
/test/unit/state/get-lift-effect/get-lift-effect.spec.js,Eager Test,"{'line': 40, 'column': 34, 'index': 1095}","it('should mark everything after the critical ', () => {
  const { impact, afterCritical } = getLiftEffect({
    draggable: preset.inHome2,
    home: preset.home,
    draggables: preset.draggables,
    viewport: preset.viewport,
  });

  // originally displacement
  const displacedBy: DisplacedBy = getDisplacedBy(
    preset.home.axis,
    preset.inHome2.displaceBy,
  );

  // ordered by closest impacted
  const all: DraggableDimension[] = [preset.inHome3, preset.inHome4];

  {
    const expected: LiftEffect = {
      inVirtualList: false,
      effected: getDraggableIdMap(getDraggableIds(all)),
      displacedBy,
    };
    expect(afterCritical).toEqual(expected);
  }
  {
    const expected: DragImpact = {
      displaced: getForcedDisplacement({
        visible: all.map((dimension) => ({ dimension, shouldAnimate: false })),
      }),
      displacedBy,
      at: {
        type: 'REORDER',
        destination: getHomeLocation(preset.inHome2.descriptor),
      },
    };
    expect(impact).toEqual(expected);
  }
})",steel
/test/unit/state/get-lift-effect/get-lift-effect.spec.js,Eager Test,"{'line': 47, 'column': 17, 'index': 1249}","it('should mark everything after the critical ', () => {
  const { impact, afterCritical } = getLiftEffect({
    draggable: preset.inHome2,
    home: preset.home,
    draggables: preset.draggables,
    viewport: preset.viewport,
  });

  // originally displacement
  const displacedBy: DisplacedBy = getDisplacedBy(
    preset.home.axis,
    preset.inHome2.displaceBy,
  );

  // ordered by closest impacted
  const all: DraggableDimension[] = [preset.inHome3, preset.inHome4];

  {
    const expected: LiftEffect = {
      inVirtualList: false,
      effected: getDraggableIdMap(getDraggableIds(all)),
      displacedBy,
    };
    expect(afterCritical).toEqual(expected);
  }
  {
    const expected: DragImpact = {
      displaced: getForcedDisplacement({
        visible: all.map((dimension) => ({ dimension, shouldAnimate: false })),
      }),
      displacedBy,
      at: {
        type: 'REORDER',
        destination: getHomeLocation(preset.inHome2.descriptor),
      },
    };
    expect(impact).toEqual(expected);
  }
})",steel
/test/unit/state/get-droppable-over/preferencing.spec.js,Eager Test,"{'line': 89, 'column': 17, 'index': 2142}","it('should prefer the furthest away droppable when multiple lists are hit', () => {
  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: droppableThird.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableThird.axis,
  });

  const pageBorderBox: Rect = offsetRectByPosition(
    draggable.page.borderBox,
    afterCrossAxisPoint(droppableThird.axis, offset),
  );

  const result = getDroppableOver({
    pageBorderBox,
    draggable,
    droppables: toDroppableMap([
      droppableOrigin,
      droppableFirst,
      droppableSecond,
      droppableThird,
    ]),
  });

  expect(result).toEqual(droppableThird.descriptor.id);
})",steel
/test/unit/state/get-droppable-over/preferencing.spec.js,Eager Test,"{'line': 97, 'column': 4, 'index': 2399}","it('should prefer the furthest away droppable when multiple lists are hit', () => {
  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: droppableThird.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableThird.axis,
  });

  const pageBorderBox: Rect = offsetRectByPosition(
    draggable.page.borderBox,
    afterCrossAxisPoint(droppableThird.axis, offset),
  );

  const result = getDroppableOver({
    pageBorderBox,
    draggable,
    droppables: toDroppableMap([
      droppableOrigin,
      droppableFirst,
      droppableSecond,
      droppableThird,
    ]),
  });

  expect(result).toEqual(droppableThird.descriptor.id);
})",steel
/test/unit/state/get-droppable-over/preferencing.spec.js,Eager Test,"{'line': 119, 'column': 17, 'index': 3011}","it('should prefer the second furthest away droppable when multiple lists are hit', () => {
  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: droppableSecond.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableSecond.axis,
  });

  const pageBorderBox: Rect = offsetRectByPosition(
    draggable.page.borderBox,
    afterCrossAxisPoint(droppableSecond.axis, offset),
  );

  const result = getDroppableOver({
    pageBorderBox,
    draggable,
    droppables: toDroppableMap([
      droppableOrigin,
      droppableFirst,
      droppableSecond,
      droppableThird,
    ]),
  });

  expect(result).toEqual(droppableSecond.descriptor.id);
})",steel
/test/unit/state/get-droppable-over/preferencing.spec.js,Eager Test,"{'line': 127, 'column': 4, 'index': 3270}","it('should prefer the second furthest away droppable when multiple lists are hit', () => {
  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: droppableSecond.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableSecond.axis,
  });

  const pageBorderBox: Rect = offsetRectByPosition(
    draggable.page.borderBox,
    afterCrossAxisPoint(droppableSecond.axis, offset),
  );

  const result = getDroppableOver({
    pageBorderBox,
    draggable,
    droppables: toDroppableMap([
      droppableOrigin,
      droppableFirst,
      droppableSecond,
      droppableThird,
    ]),
  });

  expect(result).toEqual(droppableSecond.descriptor.id);
})",steel
/test/unit/state/get-droppable-over/preferencing.spec.js,Lazy Test,"{'line': 89, 'column': 17, 'index': 2142}","it('should prefer the furthest away droppable when multiple lists are hit', () => {
  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: droppableThird.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableThird.axis,
  });

  const pageBorderBox: Rect = offsetRectByPosition(
    draggable.page.borderBox,
    afterCrossAxisPoint(droppableThird.axis, offset),
  );

  const result = getDroppableOver({
    pageBorderBox,
    draggable,
    droppables: toDroppableMap([
      droppableOrigin,
      droppableFirst,
      droppableSecond,
      droppableThird,
    ]),
  });

  expect(result).toEqual(droppableThird.descriptor.id);
})",steel
/test/unit/state/get-droppable-over/preferencing.spec.js,Lazy Test,"{'line': 97, 'column': 4, 'index': 2399}","it('should prefer the furthest away droppable when multiple lists are hit', () => {
  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: droppableThird.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableThird.axis,
  });

  const pageBorderBox: Rect = offsetRectByPosition(
    draggable.page.borderBox,
    afterCrossAxisPoint(droppableThird.axis, offset),
  );

  const result = getDroppableOver({
    pageBorderBox,
    draggable,
    droppables: toDroppableMap([
      droppableOrigin,
      droppableFirst,
      droppableSecond,
      droppableThird,
    ]),
  });

  expect(result).toEqual(droppableThird.descriptor.id);
})",steel
/test/unit/state/get-droppable-over/preferencing.spec.js,Lazy Test,"{'line': 119, 'column': 17, 'index': 3011}","it('should prefer the second furthest away droppable when multiple lists are hit', () => {
  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: droppableSecond.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableSecond.axis,
  });

  const pageBorderBox: Rect = offsetRectByPosition(
    draggable.page.borderBox,
    afterCrossAxisPoint(droppableSecond.axis, offset),
  );

  const result = getDroppableOver({
    pageBorderBox,
    draggable,
    droppables: toDroppableMap([
      droppableOrigin,
      droppableFirst,
      droppableSecond,
      droppableThird,
    ]),
  });

  expect(result).toEqual(droppableSecond.descriptor.id);
})",steel
/test/unit/state/get-droppable-over/preferencing.spec.js,Lazy Test,"{'line': 127, 'column': 4, 'index': 3270}","it('should prefer the second furthest away droppable when multiple lists are hit', () => {
  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: droppableSecond.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableSecond.axis,
  });

  const pageBorderBox: Rect = offsetRectByPosition(
    draggable.page.borderBox,
    afterCrossAxisPoint(droppableSecond.axis, offset),
  );

  const result = getDroppableOver({
    pageBorderBox,
    draggable,
    droppables: toDroppableMap([
      droppableOrigin,
      droppableFirst,
      droppableSecond,
      droppableThird,
    ]),
  });

  expect(result).toEqual(droppableSecond.descriptor.id);
})",steel
/test/unit/state/get-droppable-over/item-is-totally-over.spec.js,Duplicate Assert,"{'line': 88, 'column': 4, 'index': 2264}","it('should hit when dragging element completely covers the list (end edge +1)', () => {
  const endEdge: Position = patch(
    axis.line,
    droppableSmall.page.borderBox[axis.crossAxisEnd],
    droppableSmall.page.borderBox.center[axis.line],
  );

  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: endEdge,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  // we do not have overlap yet
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  // we have overlap
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      afterCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-is-totally-over.spec.js,Duplicate Assert,"{'line': 104, 'column': 4, 'index': 2631}","it('should hit when dragging element completely covers the list (end edge +1)', () => {
  const endEdge: Position = patch(
    axis.line,
    droppableSmall.page.borderBox[axis.crossAxisEnd],
    droppableSmall.page.borderBox.center[axis.line],
  );

  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: endEdge,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  // we do not have overlap yet
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  // we have overlap
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      afterCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-is-totally-over.spec.js,Duplicate Assert,"{'line': 134, 'column': 4, 'index': 3417}","it('should hit when dragging element completely covers the list (start edge -1)', () => {
  const startEdge: Position = patch(
    axis.line,
    droppableSmall.page.borderBox[axis.crossAxisStart],
    droppableSmall.page.borderBox.center[axis.line],
  );

  const offset = getOffsetForCrossAxisStartEdge({
    crossAxisStartEdgeOn: startEdge,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  // we do not have overlap yet
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  // we have overlap
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      beforeCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-is-totally-over.spec.js,Duplicate Assert,"{'line': 150, 'column': 4, 'index': 3785}","it('should hit when dragging element completely covers the list (start edge -1)', () => {
  const startEdge: Position = patch(
    axis.line,
    droppableSmall.page.borderBox[axis.crossAxisStart],
    droppableSmall.page.borderBox.center[axis.line],
  );

  const offset = getOffsetForCrossAxisStartEdge({
    crossAxisStartEdgeOn: startEdge,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  // we do not have overlap yet
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  // we have overlap
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      beforeCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-is-totally-over.spec.js,Eager Test,"{'line': 69, 'column': 17, 'index': 1821}","it('should hit when dragging element completely covers the list (end edge +1)', () => {
  const endEdge: Position = patch(
    axis.line,
    droppableSmall.page.borderBox[axis.crossAxisEnd],
    droppableSmall.page.borderBox.center[axis.line],
  );

  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: endEdge,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  // we do not have overlap yet
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  // we have overlap
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      afterCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-is-totally-over.spec.js,Eager Test,"{'line': 95, 'column': 6, 'index': 2416}","it('should hit when dragging element completely covers the list (end edge +1)', () => {
  const endEdge: Position = patch(
    axis.line,
    droppableSmall.page.borderBox[axis.crossAxisEnd],
    droppableSmall.page.borderBox.center[axis.line],
  );

  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: endEdge,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  // we do not have overlap yet
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  // we have overlap
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      afterCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-is-totally-over.spec.js,Eager Test,"{'line': 115, 'column': 17, 'index': 2968}","it('should hit when dragging element completely covers the list (start edge -1)', () => {
  const startEdge: Position = patch(
    axis.line,
    droppableSmall.page.borderBox[axis.crossAxisStart],
    droppableSmall.page.borderBox.center[axis.line],
  );

  const offset = getOffsetForCrossAxisStartEdge({
    crossAxisStartEdgeOn: startEdge,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  // we do not have overlap yet
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  // we have overlap
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      beforeCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-is-totally-over.spec.js,Eager Test,"{'line': 141, 'column': 6, 'index': 3569}","it('should hit when dragging element completely covers the list (start edge -1)', () => {
  const startEdge: Position = patch(
    axis.line,
    droppableSmall.page.borderBox[axis.crossAxisStart],
    droppableSmall.page.borderBox.center[axis.line],
  );

  const offset = getOffsetForCrossAxisStartEdge({
    crossAxisStartEdgeOn: startEdge,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  // we do not have overlap yet
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  // we have overlap
  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      beforeCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-edge-is-over-list-center.spec.js,Duplicate Assert,"{'line': 79, 'column': 4, 'index': 1988}","it('should hit when dragging cross axis end edge is over the list center', () => {
  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: droppableSmall.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      afterCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-edge-is-over-list-center.spec.js,Duplicate Assert,"{'line': 94, 'column': 4, 'index': 2334}","it('should hit when dragging cross axis end edge is over the list center', () => {
  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: droppableSmall.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      afterCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-edge-is-over-list-center.spec.js,Duplicate Assert,"{'line': 118, 'column': 4, 'index': 3028}","it('should hit when dragging cross axis start edge is over the list center', () => {
  const offset = getOffsetForCrossAxisStartEdge({
    crossAxisStartEdgeOn: droppableSmall.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      beforeCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-edge-is-over-list-center.spec.js,Duplicate Assert,"{'line': 133, 'column': 4, 'index': 3375}","it('should hit when dragging cross axis start edge is over the list center', () => {
  const offset = getOffsetForCrossAxisStartEdge({
    crossAxisStartEdgeOn: droppableSmall.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      beforeCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-edge-is-over-list-center.spec.js,Eager Test,"{'line': 61, 'column': 17, 'index': 1548}","it('should hit when dragging cross axis end edge is over the list center', () => {
  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: droppableSmall.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      afterCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-edge-is-over-list-center.spec.js,Eager Test,"{'line': 85, 'column': 6, 'index': 2119}","it('should hit when dragging cross axis end edge is over the list center', () => {
  const offset = getOffsetForCrossAxisEndEdge({
    crossAxisEndEdgeOn: droppableSmall.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      afterCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-edge-is-over-list-center.spec.js,Eager Test,"{'line': 100, 'column': 17, 'index': 2584}","it('should hit when dragging cross axis start edge is over the list center', () => {
  const offset = getOffsetForCrossAxisStartEdge({
    crossAxisStartEdgeOn: droppableSmall.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      beforeCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/item-edge-is-over-list-center.spec.js,Eager Test,"{'line': 124, 'column': 6, 'index': 3159}","it('should hit when dragging cross axis start edge is over the list center', () => {
  const offset = getOffsetForCrossAxisStartEdge({
    crossAxisStartEdgeOn: droppableSmall.page.borderBox.center,
    dragging: draggable.page.borderBox,
    axis: droppableSmall.axis,
  });

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      offset,
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(null);
  }

  {
    const pageBorderBox: Rect = offsetRectByPosition(
      draggable.page.borderBox,
      beforeCrossAxisPoint(droppableSmall.axis, offset),
    );

    const result = getDroppableOver({
      pageBorderBox,
      draggable,
      droppables: toDroppableMap([droppableLarge, droppableSmall]),
    });

    expect(result).toEqual(droppableSmall.descriptor.id);
  }
})",steel
/test/unit/state/get-droppable-over/center-is-over.spec.js,Conditional Test Logic,"{'line': 16, 'column': 23, 'index': 636}",Unknown,steel
/test/unit/state/get-drag-impact/over-nothing.spec.js,Conditional Test Logic,"{'line': 10, 'column': 23, 'index': 453}",Unknown,steel
/test/unit/state/get-drag-impact/is-disabled.spec.js,Conditional Test Logic,"{'line': 15, 'column': 23, 'index': 533}",Unknown,steel
/test/unit/state/get-drag-impact/reorder/over-home-list/with-droppable-scroll.spec.js,Conditional Test Logic,"{'line': 23, 'column': 23, 'index': 938}",Unknown,steel
/test/unit/state/get-drag-impact/reorder/over-home-list/with-droppable-scroll.spec.js,Lazy Test,"{'line': 74, 'column': 21, 'index': 2685}","it('should move past other draggables', () => {
        const centerOfInHome2: number =
          preset.inHome2.page.borderBox.center[axis.line];
        const distanceNeeded: Position = patch(
          axis.line,
          centerOfInHome2 - preset.inHome1.page.borderBox[axis.end] + 1,
        );

        const scrolledHome: DroppableDimension = scrollDroppable(
          scrollableHome,
          distanceNeeded,
        );
        const updatedDroppables: DroppableDimensionMap = {
          ...withScrollableHome,
          [preset.home.descriptor.id]: scrolledHome,
        };
        // moving forward over inHome2
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome1.displaceBy,
        );
        const impact: DragImpact = getDragImpact({
          pageOffset: origin,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: updatedDroppables,
          previousImpact: homeImpact,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // inHome2 no longer displaced
            // originally displaced so not animated
            visible: [
              { dimension: preset.inHome3, shouldAnimate: false },
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // now in position of inHome2 as it has moved backwards (it started displaced)
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(impact).toEqual(expected);
      })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/with-droppable-scroll.spec.js,Lazy Test,"{'line': 139, 'column': 21, 'index': 4906}","it('should move back past inHome2', () => {
        const centerOfInHome2: number =
          preset.inHome2.page.borderBox.center[axis.line];

        // Displacement will end when start goes past the displaced center of inHome2
        const distanceNeeded: Position = patch(
          axis.line,
          centerOfInHome2 - preset.inHome4.page.borderBox[axis.start] - 1,
        );
        const scrolledHome: DroppableDimension = scrollDroppable(
          scrollableHome,
          distanceNeeded,
        );
        const updatedDroppables: DroppableDimensionMap = {
          ...withScrollableHome,
          [preset.home.descriptor.id]: scrolledHome,
        };

        const impact: DragImpact = getDragImpact({
          // no changes in current page center from original
          pageOffset: origin,
          draggable: preset.inHome4,
          draggables: preset.draggables,
          droppables: updatedDroppables,
          previousImpact: homeImpact,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              // ordered by closest to current location
              { dimension: preset.inHome2 },
              { dimension: preset.inHome3 },
              // inHome4 not displaced as it is the dragging item
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in place of inHome2
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(impact).toEqual(expected);
      })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-before-critical.spec.js,Conditional Test Logic,"{'line': 23, 'column': 23, 'index': 878}",Unknown,steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-before-critical.spec.js,Duplicate Assert,"{'line': 142, 'column': 8, 'index': 4956}","it('should end displacement if the dragging item bottom edge goes forward past the displaced center', () => {
      const displacedInHome1Center: Position = add(
        preset.inHome1.page.borderBox.center,
        displacedBy.point,
      );

      const offsetForEndOnDisplacedInHome1Center: Position = getOffsetForEndEdge(
        {
          endEdgeOn: displacedInHome1Center,
          dragging: preset.inHome3.page.borderBox,
          axis,
        },
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForEndOnDisplacedInHome1Center,
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: startBeforeInHome1Center,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(startBeforeInHome1Center);
      }
      // no longer displace as we have moved onto the displaced top edge
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, offsetForEndOnDisplacedInHome1Center),
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: startBeforeInHome1Center,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2 },
              // not displacing inHome3 as it is the dragging item
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              // is now in position of inHome2
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-before-critical.spec.js,Duplicate Assert,"{'line': 174, 'column': 8, 'index': 6065}","it('should end displacement if the dragging item bottom edge goes forward past the displaced center', () => {
      const displacedInHome1Center: Position = add(
        preset.inHome1.page.borderBox.center,
        displacedBy.point,
      );

      const offsetForEndOnDisplacedInHome1Center: Position = getOffsetForEndEdge(
        {
          endEdgeOn: displacedInHome1Center,
          dragging: preset.inHome3.page.borderBox,
          axis,
        },
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForEndOnDisplacedInHome1Center,
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: startBeforeInHome1Center,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(startBeforeInHome1Center);
      }
      // no longer displace as we have moved onto the displaced top edge
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, offsetForEndOnDisplacedInHome1Center),
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: startBeforeInHome1Center,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2 },
              // not displacing inHome3 as it is the dragging item
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              // is now in position of inHome2
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-before-critical.spec.js,Eager Test,"{'line': 69, 'column': 21, 'index': 2426}","it('should displace items forward when the start edge of the dragging item goes backwards past the items center', () => {
      // after center of inHome1
      {
        const startOnInHome1Center: DragImpact = getDragImpact({
          pageOffset: offsetForStartOnInHome1Center,
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest to current location
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // inHome3 is not displaced as it is the dragging item
              // inHome4 would have been displaced on lift so it won't be animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inHome2
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(startOnInHome1Center).toEqual(expected);
      }
      // on center of inHome1
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest to current location
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome2 },
              // inHome3 is not displaced as it is the dragging item
              // inHome4 would have been displaced on lift so it won't be animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inHome1
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(startBeforeInHome1Center).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-before-critical.spec.js,Eager Test,"{'line': 93, 'column': 21, 'index': 3292}","it('should displace items forward when the start edge of the dragging item goes backwards past the items center', () => {
      // after center of inHome1
      {
        const startOnInHome1Center: DragImpact = getDragImpact({
          pageOffset: offsetForStartOnInHome1Center,
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest to current location
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // inHome3 is not displaced as it is the dragging item
              // inHome4 would have been displaced on lift so it won't be animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inHome2
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(startOnInHome1Center).toEqual(expected);
      }
      // on center of inHome1
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest to current location
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome2 },
              // inHome3 is not displaced as it is the dragging item
              // inHome4 would have been displaced on lift so it won't be animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inHome1
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(startBeforeInHome1Center).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-before-critical.spec.js,Eager Test,"{'line': 123, 'column': 61, 'index': 4407}","it('should end displacement if the dragging item bottom edge goes forward past the displaced center', () => {
      const displacedInHome1Center: Position = add(
        preset.inHome1.page.borderBox.center,
        displacedBy.point,
      );

      const offsetForEndOnDisplacedInHome1Center: Position = getOffsetForEndEdge(
        {
          endEdgeOn: displacedInHome1Center,
          dragging: preset.inHome3.page.borderBox,
          axis,
        },
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForEndOnDisplacedInHome1Center,
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: startBeforeInHome1Center,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(startBeforeInHome1Center);
      }
      // no longer displace as we have moved onto the displaced top edge
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, offsetForEndOnDisplacedInHome1Center),
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: startBeforeInHome1Center,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2 },
              // not displacing inHome3 as it is the dragging item
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              // is now in position of inHome2
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-before-critical.spec.js,Eager Test,"{'line': 157, 'column': 21, 'index': 5513}","it('should end displacement if the dragging item bottom edge goes forward past the displaced center', () => {
      const displacedInHome1Center: Position = add(
        preset.inHome1.page.borderBox.center,
        displacedBy.point,
      );

      const offsetForEndOnDisplacedInHome1Center: Position = getOffsetForEndEdge(
        {
          endEdgeOn: displacedInHome1Center,
          dragging: preset.inHome3.page.borderBox,
          axis,
        },
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForEndOnDisplacedInHome1Center,
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: startBeforeInHome1Center,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(startBeforeInHome1Center);
      }
      // no longer displace as we have moved onto the displaced top edge
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, offsetForEndOnDisplacedInHome1Center),
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: startBeforeInHome1Center,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2 },
              // not displacing inHome3 as it is the dragging item
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              // is now in position of inHome2
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-before-critical.spec.js,Lazy Test,"{'line': 69, 'column': 21, 'index': 2426}","it('should displace items forward when the start edge of the dragging item goes backwards past the items center', () => {
      // after center of inHome1
      {
        const startOnInHome1Center: DragImpact = getDragImpact({
          pageOffset: offsetForStartOnInHome1Center,
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest to current location
            visible: [
              { dimension: preset.inHome2, shouldAnimate: true },
              // inHome3 is not displaced as it is the dragging item
              // inHome4 would have been displaced on lift so it won't be animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inHome2
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(startOnInHome1Center).toEqual(expected);
      }
      // on center of inHome1
      {
        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest to current location
            visible: [
              { dimension: preset.inHome1 },
              { dimension: preset.inHome2 },
              // inHome3 is not displaced as it is the dragging item
              // inHome4 would have been displaced on lift so it won't be animated
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inHome1
              droppableId: preset.home.descriptor.id,
              index: preset.inHome1.descriptor.index,
            },
          },
        };
        expect(startBeforeInHome1Center).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-before-critical.spec.js,Lazy Test,"{'line': 157, 'column': 21, 'index': 5513}","it('should end displacement if the dragging item bottom edge goes forward past the displaced center', () => {
      const displacedInHome1Center: Position = add(
        preset.inHome1.page.borderBox.center,
        displacedBy.point,
      );

      const offsetForEndOnDisplacedInHome1Center: Position = getOffsetForEndEdge(
        {
          endEdgeOn: displacedInHome1Center,
          dragging: preset.inHome3.page.borderBox,
          axis,
        },
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForEndOnDisplacedInHome1Center,
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: startBeforeInHome1Center,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(startBeforeInHome1Center);
      }
      // no longer displace as we have moved onto the displaced top edge
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, offsetForEndOnDisplacedInHome1Center),
          draggable: preset.inHome3,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: startBeforeInHome1Center,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              { dimension: preset.inHome2 },
              // not displacing inHome3 as it is the dragging item
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              // is now in position of inHome2
              index: preset.inHome2.descriptor.index,
            },
          },
        };
        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-after-critical.spec.js,Conditional Test Logic,"{'line': 24, 'column': 23, 'index': 960}",Unknown,steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-after-critical.spec.js,Duplicate Assert,"{'line': 143, 'column': 8, 'index': 4665}","it('should end displacement if the start of the dragging item is less than the displaced target center', () => {
      const displacedInHome3Center: Position = subtract(
        preset.inHome3.page.borderBox.center,
        displacedBy.point,
      );

      const offsetForStartOnDisplacedInHome2Center: Position = getOffsetForStartEdge(
        {
          startEdgeOn: displacedInHome3Center,
          dragging: preset.inHome2.page.borderBox,
          axis,
        },
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForStartOnDisplacedInHome2Center,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: endPastInHome3Center,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(endPastInHome3Center);
      }
      // no longer displace as we move backwards past the displaced center
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: beforePoint(axis, offsetForStartOnDisplacedInHome2Center),
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: endPastInHome3Center,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // inHome4 would have been displaced on lift so it won't be animated
            visible: [
              // inHome3 is now animated
              {
                dimension: preset.inHome3,
                shouldAnimate: true,
              },
              // inHome4 displacement stays not displaced
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };

        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-after-critical.spec.js,Duplicate Assert,"{'line': 183, 'column': 8, 'index': 5953}","it('should end displacement if the start of the dragging item is less than the displaced target center', () => {
      const displacedInHome3Center: Position = subtract(
        preset.inHome3.page.borderBox.center,
        displacedBy.point,
      );

      const offsetForStartOnDisplacedInHome2Center: Position = getOffsetForStartEdge(
        {
          startEdgeOn: displacedInHome3Center,
          dragging: preset.inHome2.page.borderBox,
          axis,
        },
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForStartOnDisplacedInHome2Center,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: endPastInHome3Center,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(endPastInHome3Center);
      }
      // no longer displace as we move backwards past the displaced center
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: beforePoint(axis, offsetForStartOnDisplacedInHome2Center),
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: endPastInHome3Center,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // inHome4 would have been displaced on lift so it won't be animated
            visible: [
              // inHome3 is now animated
              {
                dimension: preset.inHome3,
                shouldAnimate: true,
              },
              // inHome4 displacement stays not displaced
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };

        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-after-critical.spec.js,Eager Test,"{'line': 69, 'column': 21, 'index': 2436}","it('should displace items backwards when end of dragging item goes past the target center', () => {
      {
        const endOnInHome3Center: DragImpact = getDragImpact({
          pageOffset: offsetForEndOnInHome3Center,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // inHome4 would have been displaced on lift so it won't be animated
            visible: [
              {
                dimension: preset.inHome3,
                shouldAnimate: false,
              },
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: getHomeLocation(preset.inHome2.descriptor),
          },
        };

        expect(endOnInHome3Center).toEqual(expected);
      }

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inHome4 would have been displaced on lift so it won't be animated
          visible: [
            {
              dimension: preset.inHome4,
              shouldAnimate: false,
            },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            // is now in position of inHome3
            droppableId: preset.home.descriptor.id,
            index: preset.inHome3.descriptor.index,
          },
        },
      };

      expect(endPastInHome3Center).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-after-critical.spec.js,Eager Test,"{'line': 93, 'column': 19, 'index': 3102}","it('should displace items backwards when end of dragging item goes past the target center', () => {
      {
        const endOnInHome3Center: DragImpact = getDragImpact({
          pageOffset: offsetForEndOnInHome3Center,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // inHome4 would have been displaced on lift so it won't be animated
            visible: [
              {
                dimension: preset.inHome3,
                shouldAnimate: false,
              },
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: getHomeLocation(preset.inHome2.descriptor),
          },
        };

        expect(endOnInHome3Center).toEqual(expected);
      }

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inHome4 would have been displaced on lift so it won't be animated
          visible: [
            {
              dimension: preset.inHome4,
              shouldAnimate: false,
            },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            // is now in position of inHome3
            droppableId: preset.home.descriptor.id,
            index: preset.inHome3.descriptor.index,
          },
        },
      };

      expect(endPastInHome3Center).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-after-critical.spec.js,Eager Test,"{'line': 124, 'column': 63, 'index': 4114}","it('should end displacement if the start of the dragging item is less than the displaced target center', () => {
      const displacedInHome3Center: Position = subtract(
        preset.inHome3.page.borderBox.center,
        displacedBy.point,
      );

      const offsetForStartOnDisplacedInHome2Center: Position = getOffsetForStartEdge(
        {
          startEdgeOn: displacedInHome3Center,
          dragging: preset.inHome2.page.borderBox,
          axis,
        },
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForStartOnDisplacedInHome2Center,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: endPastInHome3Center,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(endPastInHome3Center);
      }
      // no longer displace as we move backwards past the displaced center
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: beforePoint(axis, offsetForStartOnDisplacedInHome2Center),
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: endPastInHome3Center,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // inHome4 would have been displaced on lift so it won't be animated
            visible: [
              // inHome3 is now animated
              {
                dimension: preset.inHome3,
                shouldAnimate: true,
              },
              // inHome4 displacement stays not displaced
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };

        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-after-critical.spec.js,Eager Test,"{'line': 158, 'column': 21, 'index': 5219}","it('should end displacement if the start of the dragging item is less than the displaced target center', () => {
      const displacedInHome3Center: Position = subtract(
        preset.inHome3.page.borderBox.center,
        displacedBy.point,
      );

      const offsetForStartOnDisplacedInHome2Center: Position = getOffsetForStartEdge(
        {
          startEdgeOn: displacedInHome3Center,
          dragging: preset.inHome2.page.borderBox,
          axis,
        },
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForStartOnDisplacedInHome2Center,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: endPastInHome3Center,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(endPastInHome3Center);
      }
      // no longer displace as we move backwards past the displaced center
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: beforePoint(axis, offsetForStartOnDisplacedInHome2Center),
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: endPastInHome3Center,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // inHome4 would have been displaced on lift so it won't be animated
            visible: [
              // inHome3 is now animated
              {
                dimension: preset.inHome3,
                shouldAnimate: true,
              },
              // inHome4 displacement stays not displaced
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };

        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-after-critical.spec.js,Lazy Test,"{'line': 69, 'column': 21, 'index': 2436}","it('should displace items backwards when end of dragging item goes past the target center', () => {
      {
        const endOnInHome3Center: DragImpact = getDragImpact({
          pageOffset: offsetForEndOnInHome3Center,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // inHome4 would have been displaced on lift so it won't be animated
            visible: [
              {
                dimension: preset.inHome3,
                shouldAnimate: false,
              },
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: getHomeLocation(preset.inHome2.descriptor),
          },
        };

        expect(endOnInHome3Center).toEqual(expected);
      }

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // inHome4 would have been displaced on lift so it won't be animated
          visible: [
            {
              dimension: preset.inHome4,
              shouldAnimate: false,
            },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            // is now in position of inHome3
            droppableId: preset.home.descriptor.id,
            index: preset.inHome3.descriptor.index,
          },
        },
      };

      expect(endPastInHome3Center).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/started-after-critical.spec.js,Lazy Test,"{'line': 158, 'column': 21, 'index': 5219}","it('should end displacement if the start of the dragging item is less than the displaced target center', () => {
      const displacedInHome3Center: Position = subtract(
        preset.inHome3.page.borderBox.center,
        displacedBy.point,
      );

      const offsetForStartOnDisplacedInHome2Center: Position = getOffsetForStartEdge(
        {
          startEdgeOn: displacedInHome3Center,
          dragging: preset.inHome2.page.borderBox,
          axis,
        },
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForStartOnDisplacedInHome2Center,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: endPastInHome3Center,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(endPastInHome3Center);
      }
      // no longer displace as we move backwards past the displaced center
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: beforePoint(axis, offsetForStartOnDisplacedInHome2Center),
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: endPastInHome3Center,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // inHome4 would have been displaced on lift so it won't be animated
            visible: [
              // inHome3 is now animated
              {
                dimension: preset.inHome3,
                shouldAnimate: true,
              },
              // inHome4 displacement stays not displaced
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              droppableId: preset.home.descriptor.id,
              index: preset.inHome2.descriptor.index,
            },
          },
        };

        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/move-past-last-item.spec.js,Conditional Test Logic,"{'line': 13, 'column': 23, 'index': 709}",Unknown,steel
/test/unit/state/get-drag-impact/reorder/over-home-list/displacement-visibility.spec.js,Conditional Test Logic,"{'line': 31, 'column': 23, 'index': 1114}",Unknown,steel
/test/unit/state/get-drag-impact/reorder/over-home-list/displacement-visibility.spec.js,Lazy Test,"{'line': 141, 'column': 19, 'index': 4746}","it('should indicate when a displacement is not visible due to being outside of the droppable frame', () => {
      const droppable: DroppableDimension = getDroppableDimension({
        descriptor: {
          id: 'my-custom-droppable',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          [axis.start]: 0,
          // will be cut by the frame
          [axis.end]: 200,
        },
        closest: {
          borderBox: {
            [axis.crossAxisStart]: crossAxisStart,
            [axis.crossAxisEnd]: crossAxisEnd,
            [axis.start]: 0,
            // will cut the subject,
            [axis.end]: 100,
          },
          scrollSize: {
            scrollWidth: 100,
            scrollHeight: 100,
          },
          scroll: { x: 0, y: 0 },
          shouldClipSubject: true,
        },
      });
      const visible: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'visible',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 0,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          [axis.start]: 0,
          [axis.end]: 90,
        },
      });
      const partialVisible: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'partial-visible',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 1,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          // partially in frame
          [axis.start]: 90,
          [axis.end]: 120,
        },
      });
      const notVisible1: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'not-visible-1',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 2,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          // inside the frame, but not in the visible area
          [axis.start]: 130,
          [axis.end]: 140,
        },
      });
      const notVisible2: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'not-visible-2',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 3,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          // inside the frame, but not in the visible area
          [axis.start]: 150,
          [axis.end]: 170,
        },
      });
      const customDraggables: DraggableDimensionMap = {
        [visible.descriptor.id]: visible,
        [partialVisible.descriptor.id]: partialVisible,
        [notVisible1.descriptor.id]: notVisible1,
        [notVisible2.descriptor.id]: notVisible2,
      };
      const customDroppables: DroppableDimensionMap = {
        [droppable.descriptor.id]: droppable,
      };
      // dragging notVisible2 backwards into first position
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        notVisible2.displaceBy,
      );
      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            {
              dimension: visible,
              shouldAnimate: true,
            },
            {
              dimension: partialVisible,
              shouldAnimate: true,
            },
          ],
          invisible: [notVisible1],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: droppable.descriptor.id,
            index: 0,
          },
        },
      };

      const { afterCritical, impact: homeImpact } = getLiftEffect({
        draggable: notVisible2,
        home: droppable,
        draggables: customDraggables,
        viewport,
      });
      // moving backwards to near the start of the droppable
      const destination: Position = { x: 1, y: 1 };
      const offset: Position = subtract(
        destination,
        notVisible2.page.borderBox.center,
      );
      const impact: DragImpact = getDragImpact({
        pageOffset: offset,
        draggable: notVisible2,
        draggables: customDraggables,
        droppables: customDroppables,
        previousImpact: homeImpact,
        viewport,
        afterCritical,
      });

      expect(impact).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/reorder/over-home-list/displacement-visibility.spec.js,Lazy Test,"{'line': 280, 'column': 19, 'index': 9328}","it('should indicate when a displacement is not visible due to being outside of the viewport', () => {
      const droppable: DroppableDimension = getDroppableDimension({
        descriptor: {
          id: 'my-custom-droppable',
          type: 'TYPE',
          mode: 'standard',
        },
        direction: axis.direction,
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          [axis.start]: 0,
          [axis.end]: viewport.frame[axis.end] + 100,
        },
      });
      const visible: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'visible',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 0,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          [axis.start]: 0,
          [axis.end]: viewport.frame[axis.end] - 20,
        },
      });
      const partialVisible: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'partial-visible',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 1,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          [axis.start]: viewport.frame[axis.end] - 20,
          [axis.end]: viewport.frame[axis.end] + 10,
        },
      });
      const notVisible1: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'not-visible-1',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 2,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          [axis.start]:
            viewport.frame[axis.end] + visible.page.marginBox[axis.size],
          [axis.end]:
            viewport.frame[axis.end] +
            visible.page.marginBox[axis.crossAxisSize],
        },
      });
      const notVisible2: DraggableDimension = getDraggableDimension({
        descriptor: {
          id: 'not-visible-2',
          droppableId: droppable.descriptor.id,
          type: droppable.descriptor.type,
          index: 3,
        },
        borderBox: {
          [axis.crossAxisStart]: crossAxisStart,
          [axis.crossAxisEnd]: crossAxisEnd,
          // inside the droppable, but not in the visible area
          [axis.start]:
            viewport.frame[axis.end] + visible.page.marginBox[axis.size] + 1,
          [axis.end]:
            viewport.frame[axis.end] +
            visible.page.marginBox[axis.crossAxisSize] +
            1,
        },
      });
      const customDraggables: DraggableDimensionMap = {
        [visible.descriptor.id]: visible,
        [partialVisible.descriptor.id]: partialVisible,
        [notVisible1.descriptor.id]: notVisible1,
        [notVisible2.descriptor.id]: notVisible2,
      };
      const customDroppables: DroppableDimensionMap = {
        [droppable.descriptor.id]: droppable,
      };
      const displacedBy: DisplacedBy = getDisplacedBy(axis, visible.displaceBy);
      const expected: DragImpact = {
        // no longer the same due to visibility overscanning
        displaced: getForcedDisplacement({
          visible: [
            {
              dimension: partialVisible,
              shouldAnimate: true,
            },
            {
              dimension: notVisible1,
              shouldAnimate: true,
            },
          ],
          invisible: [notVisible2],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            droppableId: droppable.descriptor.id,
            index: 0,
          },
        },
      };

      const impact: DragImpact = getDragImpact({
        pageOffset: origin,
        draggable: visible,
        draggables: customDraggables,
        droppables: customDroppables,
        previousImpact: noImpact,
        viewport,
        afterCritical: noAfterCritical,
      });

      expect(impact).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/move-past-last-item.spec.js,Conditional Test Logic,"{'line': 17, 'column': 23, 'index': 675}",Unknown,steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/move-backward-from-last-item.spec.js,Conditional Test Logic,"{'line': 19, 'column': 23, 'index': 803}",Unknown,steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/move-backward-from-last-item.spec.js,Eager Test,"{'line': 48, 'column': 55, 'index': 1735}","it('should allow movement past from last item', () => {
      const preset = getPreset(axis);
      const viewport: Viewport = preset.viewport;
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome1.displaceBy,
      );

      const inLastSpot: DragImpact = {
        displaced: emptyGroups,
        displacedBy,
        at: {
          type: 'REORDER',
          // after last item
          destination: {
            index: preset.inForeign4.descriptor.index + 1,
            droppableId: preset.inForeign4.descriptor.droppableId,
          },
        },
      };

      const offsetForEndOnInForeign4Center: Position = getOffsetForStartEdge({
        startEdgeOn: preset.inForeign4.page.borderBox.center,
        dragging: preset.inHome1.page.borderBox,
        axis,
      });

      const goingBackwards: DragImpact = getDragImpact({
        pageOffset: beforePoint(axis, offsetForEndOnInForeign4Center),
        draggable: preset.inHome1,
        draggables: preset.draggables,
        droppables: preset.droppables,
        previousImpact: inLastSpot,
        viewport,
        afterCritical,
      });

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inForeign4 }],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          // now in visual spot of inForeign4
          destination: {
            index: preset.inForeign4.descriptor.index,
            droppableId: preset.inForeign4.descriptor.droppableId,
          },
        },
      };
      expect(goingBackwards).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/move-backward-from-last-item.spec.js,Eager Test,"{'line': 65, 'column': 19, 'index': 2280}","it('should allow movement past from last item', () => {
      const preset = getPreset(axis);
      const viewport: Viewport = preset.viewport;
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome1.displaceBy,
      );

      const inLastSpot: DragImpact = {
        displaced: emptyGroups,
        displacedBy,
        at: {
          type: 'REORDER',
          // after last item
          destination: {
            index: preset.inForeign4.descriptor.index + 1,
            droppableId: preset.inForeign4.descriptor.droppableId,
          },
        },
      };

      const offsetForEndOnInForeign4Center: Position = getOffsetForStartEdge({
        startEdgeOn: preset.inForeign4.page.borderBox.center,
        dragging: preset.inHome1.page.borderBox,
        axis,
      });

      const goingBackwards: DragImpact = getDragImpact({
        pageOffset: beforePoint(axis, offsetForEndOnInForeign4Center),
        draggable: preset.inHome1,
        draggables: preset.draggables,
        droppables: preset.droppables,
        previousImpact: inLastSpot,
        viewport,
        afterCritical,
      });

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [{ dimension: preset.inForeign4 }],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          // now in visual spot of inForeign4
          destination: {
            index: preset.inForeign4.descriptor.index,
            droppableId: preset.inForeign4.descriptor.droppableId,
          },
        },
      };
      expect(goingBackwards).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/did-not-start-displaced.spec.js,Conditional Test Logic,"{'line': 23, 'column': 23, 'index': 878}",Unknown,steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/did-not-start-displaced.spec.js,Duplicate Assert,"{'line': 134, 'column': 8, 'index': 4403}","it('should end displacement if moving forward over the displaced center', () => {
      const offsetForEndOnInForeign2Center: Position = getOffsetForEndEdge({
        endEdgeOn: preset.inForeign2.page.borderBox.center,
        dragging: preset.inHome1.page.borderBox,
        axis,
      });
      const displaced: Position = add(
        offsetForEndOnInForeign2Center,
        displacedBy.point,
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: displaced,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: goingBackwards,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(goingBackwards);
      }
      // no longer displace as we have moved forwards past the displaced center
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, displaced),
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: goingBackwards,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inForeign3
              droppableId: preset.inForeign3.descriptor.droppableId,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/did-not-start-displaced.spec.js,Duplicate Assert,"{'line': 166, 'column': 8, 'index': 5453}","it('should end displacement if moving forward over the displaced center', () => {
      const offsetForEndOnInForeign2Center: Position = getOffsetForEndEdge({
        endEdgeOn: preset.inForeign2.page.borderBox.center,
        dragging: preset.inHome1.page.borderBox,
        axis,
      });
      const displaced: Position = add(
        offsetForEndOnInForeign2Center,
        displacedBy.point,
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: displaced,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: goingBackwards,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(goingBackwards);
      }
      // no longer displace as we have moved forwards past the displaced center
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, displaced),
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: goingBackwards,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inForeign3
              droppableId: preset.inForeign3.descriptor.droppableId,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/did-not-start-displaced.spec.js,Eager Test,"{'line': 68, 'column': 21, 'index': 2340}","it('should displace items when moving backwards past their bottom edge', () => {
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForStartOnInForeign2Center,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              // ordered by closest to current location
              // animated and visible as it is a foreign list
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inForeign3
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };

        expect(impact).toEqual(expected);
      }

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // ordered by closest to current location
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            // is now in position of inForeign2
            droppableId: preset.inForeign2.descriptor.droppableId,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };
      expect(goingBackwards).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/did-not-start-displaced.spec.js,Eager Test,"{'line': 91, 'column': 19, 'index': 3036}","it('should displace items when moving backwards past their bottom edge', () => {
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForStartOnInForeign2Center,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              // ordered by closest to current location
              // animated and visible as it is a foreign list
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inForeign3
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };

        expect(impact).toEqual(expected);
      }

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // ordered by closest to current location
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            // is now in position of inForeign2
            droppableId: preset.inForeign2.descriptor.droppableId,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };
      expect(goingBackwards).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/did-not-start-displaced.spec.js,Eager Test,"{'line': 113, 'column': 55, 'index': 3784}","it('should end displacement if moving forward over the displaced center', () => {
      const offsetForEndOnInForeign2Center: Position = getOffsetForEndEdge({
        endEdgeOn: preset.inForeign2.page.borderBox.center,
        dragging: preset.inHome1.page.borderBox,
        axis,
      });
      const displaced: Position = add(
        offsetForEndOnInForeign2Center,
        displacedBy.point,
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: displaced,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: goingBackwards,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(goingBackwards);
      }
      // no longer displace as we have moved forwards past the displaced center
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, displaced),
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: goingBackwards,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inForeign3
              droppableId: preset.inForeign3.descriptor.droppableId,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/did-not-start-displaced.spec.js,Eager Test,"{'line': 149, 'column': 21, 'index': 4920}","it('should end displacement if moving forward over the displaced center', () => {
      const offsetForEndOnInForeign2Center: Position = getOffsetForEndEdge({
        endEdgeOn: preset.inForeign2.page.borderBox.center,
        dragging: preset.inHome1.page.borderBox,
        axis,
      });
      const displaced: Position = add(
        offsetForEndOnInForeign2Center,
        displacedBy.point,
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: displaced,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: goingBackwards,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(goingBackwards);
      }
      // no longer displace as we have moved forwards past the displaced center
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, displaced),
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: goingBackwards,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inForeign3
              droppableId: preset.inForeign3.descriptor.droppableId,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/did-not-start-displaced.spec.js,Lazy Test,"{'line': 68, 'column': 21, 'index': 2340}","it('should displace items when moving backwards past their bottom edge', () => {
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: offsetForStartOnInForeign2Center,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              // ordered by closest to current location
              // animated and visible as it is a foreign list
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inForeign3
              droppableId: preset.foreign.descriptor.id,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };

        expect(impact).toEqual(expected);
      }

      const expected: DragImpact = {
        displaced: getForcedDisplacement({
          // ordered by closest to current location
          visible: [
            { dimension: preset.inForeign2 },
            { dimension: preset.inForeign3 },
            { dimension: preset.inForeign4 },
          ],
        }),
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            // is now in position of inForeign2
            droppableId: preset.inForeign2.descriptor.droppableId,
            index: preset.inForeign2.descriptor.index,
          },
        },
      };
      expect(goingBackwards).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/reorder/over-foreign-list/did-not-start-displaced.spec.js,Lazy Test,"{'line': 149, 'column': 21, 'index': 4920}","it('should end displacement if moving forward over the displaced center', () => {
      const offsetForEndOnInForeign2Center: Position = getOffsetForEndEdge({
        endEdgeOn: preset.inForeign2.page.borderBox.center,
        dragging: preset.inHome1.page.borderBox,
        axis,
      });
      const displaced: Position = add(
        offsetForEndOnInForeign2Center,
        displacedBy.point,
      );

      // still not far enough
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: displaced,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: goingBackwards,
          viewport,
          afterCritical,
        });
        expect(impact).toEqual(goingBackwards);
      }
      // no longer displace as we have moved forwards past the displaced center
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, displaced),
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: goingBackwards,
          viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            // ordered by closest impacted
            visible: [
              { dimension: preset.inForeign3 },
              { dimension: preset.inForeign4 },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              // is now in position of inForeign3
              droppableId: preset.inForeign3.descriptor.droppableId,
              index: preset.inForeign3.descriptor.index,
            },
          },
        };
        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/combine/with-droppable-scroll.spec.js,Conditional Test Logic,"{'line': 18, 'column': 23, 'index': 756}",Unknown,steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Conditional Test Logic,"{'line': 24, 'column': 23, 'index': 954}",Unknown,steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Duplicate Assert,"{'line': 131, 'column': 12, 'index': 4474}","it('should combine when moving forward past the displaced start threshold', () => {
          const endOnCombineStart: Position = getOffsetForEndEdge({
            endEdgeOn: combineStart,
            dragging: preset.inHome1.page.borderBox,
            axis,
          });

          // it should not merge on the threshold
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: endOnCombineStart,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });
            expect(impact).toEqual(whenEnteredForeign);
          }
          // it should merge with the item when it goes onto the displaced start
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: afterPoint(axis, endOnCombineStart),
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });
            expect(impact).toEqual(combineWithDisplacedInForeign3);
          }
        })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Duplicate Assert,"{'line': 144, 'column': 12, 'index': 5021}","it('should combine when moving forward past the displaced start threshold', () => {
          const endOnCombineStart: Position = getOffsetForEndEdge({
            endEdgeOn: combineStart,
            dragging: preset.inHome1.page.borderBox,
            axis,
          });

          // it should not merge on the threshold
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: endOnCombineStart,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });
            expect(impact).toEqual(whenEnteredForeign);
          }
          // it should merge with the item when it goes onto the displaced start
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: afterPoint(axis, endOnCombineStart),
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });
            expect(impact).toEqual(combineWithDisplacedInForeign3);
          }
        })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Duplicate Assert,"{'line': 166, 'column': 12, 'index': 5825}","it('should no longer merge when moving onto 4/5 of the target', () => {
          const endOnCombineEnd: Position = getOffsetForEndEdge({
            endEdgeOn: combineEnd,
            dragging: preset.inHome1.page.borderBox,
            axis,
          });

          // merge when still in on two thirds
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: beforePoint(axis, endOnCombineEnd),
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });
            expect(impact).toEqual(combineWithDisplacedInForeign3);
          }
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: endOnCombineEnd,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });

            const expected: DragImpact = {
              displaced: getForcedDisplacement({
                visible: [{ dimension: preset.inForeign4 }],
              }),
              displacedBy,
              at: {
                type: 'REORDER',
                // now in spot of inForeign4
                destination: {
                  index: preset.inForeign4.descriptor.index,
                  droppableId: preset.inForeign4.descriptor.droppableId,
                },
              },
            };
            expect(impact).toEqual(expected);
          }
        })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Duplicate Assert,"{'line': 193, 'column': 12, 'index': 6796}","it('should no longer merge when moving onto 4/5 of the target', () => {
          const endOnCombineEnd: Position = getOffsetForEndEdge({
            endEdgeOn: combineEnd,
            dragging: preset.inHome1.page.borderBox,
            axis,
          });

          // merge when still in on two thirds
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: beforePoint(axis, endOnCombineEnd),
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });
            expect(impact).toEqual(combineWithDisplacedInForeign3);
          }
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: endOnCombineEnd,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });

            const expected: DragImpact = {
              displaced: getForcedDisplacement({
                visible: [{ dimension: preset.inForeign4 }],
              }),
              displacedBy,
              at: {
                type: 'REORDER',
                // now in spot of inForeign4
                destination: {
                  index: preset.inForeign4.descriptor.index,
                  droppableId: preset.inForeign4.descriptor.droppableId,
                },
              },
            };
            expect(impact).toEqual(expected);
          }
        })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Duplicate Assert,"{'line': 249, 'column': 10, 'index': 8703}","it('should combine with an item when moving backwards past 1 / 5 of the items size', () => {
        const startOnCombineEnd: Position = getOffsetForStartEdge({
          startEdgeOn: combineEnd,
          dragging: preset.inHome1.page.borderBox,
          axis,
        });
        // on edge is not far enough
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: startOnCombineEnd,
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(whenEnteredForeign);
        }
        // over edge is enough
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: beforePoint(axis, startOnCombineEnd),
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(combineWithInForeign2);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Duplicate Assert,"{'line': 262, 'column': 10, 'index': 9177}","it('should combine with an item when moving backwards past 1 / 5 of the items size', () => {
        const startOnCombineEnd: Position = getOffsetForStartEdge({
          startEdgeOn: combineEnd,
          dragging: preset.inHome1.page.borderBox,
          axis,
        });
        // on edge is not far enough
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: startOnCombineEnd,
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(whenEnteredForeign);
        }
        // over edge is enough
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: beforePoint(axis, startOnCombineEnd),
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(combineWithInForeign2);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Duplicate Assert,"{'line': 283, 'column': 10, 'index': 9935}","it('should stop combining when going back onto 2/3 of the size', () => {
        const startOnCombineStart: Position = getOffsetForStartEdge({
          startEdgeOn: combineStart,
          dragging: preset.inHome1.page.borderBox,
          axis,
        });
        // after start is all good
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: afterPoint(axis, startOnCombineStart),
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(combineWithInForeign2);
        }
        // on combine start = stop combining
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: startOnCombineStart,
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });

          const expected: DragImpact = {
            displaced: getForcedDisplacement({
              visible: [
                { dimension: preset.inForeign2 },
                { dimension: preset.inForeign3 },
                { dimension: preset.inForeign4 },
              ],
            }),
            displacedBy,
            at: {
              type: 'REORDER',
              destination: {
                index: preset.inForeign2.descriptor.index,
                droppableId: preset.inForeign2.descriptor.droppableId,
              },
            },
          };
          expect(impact).toEqual(expected);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Duplicate Assert,"{'line': 314, 'column': 10, 'index': 10984}","it('should stop combining when going back onto 2/3 of the size', () => {
        const startOnCombineStart: Position = getOffsetForStartEdge({
          startEdgeOn: combineStart,
          dragging: preset.inHome1.page.borderBox,
          axis,
        });
        // after start is all good
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: afterPoint(axis, startOnCombineStart),
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(combineWithInForeign2);
        }
        // on combine start = stop combining
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: startOnCombineStart,
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });

          const expected: DragImpact = {
            displaced: getForcedDisplacement({
              visible: [
                { dimension: preset.inForeign2 },
                { dimension: preset.inForeign3 },
                { dimension: preset.inForeign4 },
              ],
            }),
            displacedBy,
            at: {
              type: 'REORDER',
              destination: {
                index: preset.inForeign2.descriptor.index,
                droppableId: preset.inForeign2.descriptor.droppableId,
              },
            },
          };
          expect(impact).toEqual(expected);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Eager Test,"{'line': 149, 'column': 44, 'index': 5226}","it('should no longer merge when moving onto 4/5 of the target', () => {
          const endOnCombineEnd: Position = getOffsetForEndEdge({
            endEdgeOn: combineEnd,
            dragging: preset.inHome1.page.borderBox,
            axis,
          });

          // merge when still in on two thirds
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: beforePoint(axis, endOnCombineEnd),
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });
            expect(impact).toEqual(combineWithDisplacedInForeign3);
          }
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: endOnCombineEnd,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });

            const expected: DragImpact = {
              displaced: getForcedDisplacement({
                visible: [{ dimension: preset.inForeign4 }],
              }),
              displacedBy,
              at: {
                type: 'REORDER',
                // now in spot of inForeign4
                destination: {
                  index: preset.inForeign4.descriptor.index,
                  droppableId: preset.inForeign4.descriptor.droppableId,
                },
              },
            };
            expect(impact).toEqual(expected);
          }
        })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Eager Test,"{'line': 180, 'column': 25, 'index': 6340}","it('should no longer merge when moving onto 4/5 of the target', () => {
          const endOnCombineEnd: Position = getOffsetForEndEdge({
            endEdgeOn: combineEnd,
            dragging: preset.inHome1.page.borderBox,
            axis,
          });

          // merge when still in on two thirds
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: beforePoint(axis, endOnCombineEnd),
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });
            expect(impact).toEqual(combineWithDisplacedInForeign3);
          }
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: endOnCombineEnd,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });

            const expected: DragImpact = {
              displaced: getForcedDisplacement({
                visible: [{ dimension: preset.inForeign4 }],
              }),
              displacedBy,
              at: {
                type: 'REORDER',
                // now in spot of inForeign4
                destination: {
                  index: preset.inForeign4.descriptor.index,
                  droppableId: preset.inForeign4.descriptor.droppableId,
                },
              },
            };
            expect(impact).toEqual(expected);
          }
        })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Eager Test,"{'line': 267, 'column': 46, 'index': 9370}","it('should stop combining when going back onto 2/3 of the size', () => {
        const startOnCombineStart: Position = getOffsetForStartEdge({
          startEdgeOn: combineStart,
          dragging: preset.inHome1.page.borderBox,
          axis,
        });
        // after start is all good
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: afterPoint(axis, startOnCombineStart),
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(combineWithInForeign2);
        }
        // on combine start = stop combining
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: startOnCombineStart,
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });

          const expected: DragImpact = {
            displaced: getForcedDisplacement({
              visible: [
                { dimension: preset.inForeign2 },
                { dimension: preset.inForeign3 },
                { dimension: preset.inForeign4 },
              ],
            }),
            displacedBy,
            at: {
              type: 'REORDER',
              destination: {
                index: preset.inForeign2.descriptor.index,
                droppableId: preset.inForeign2.descriptor.droppableId,
              },
            },
          };
          expect(impact).toEqual(expected);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Eager Test,"{'line': 298, 'column': 23, 'index': 10464}","it('should stop combining when going back onto 2/3 of the size', () => {
        const startOnCombineStart: Position = getOffsetForStartEdge({
          startEdgeOn: combineStart,
          dragging: preset.inHome1.page.borderBox,
          axis,
        });
        // after start is all good
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: afterPoint(axis, startOnCombineStart),
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(combineWithInForeign2);
        }
        // on combine start = stop combining
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: startOnCombineStart,
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });

          const expected: DragImpact = {
            displaced: getForcedDisplacement({
              visible: [
                { dimension: preset.inForeign2 },
                { dimension: preset.inForeign3 },
                { dimension: preset.inForeign4 },
              ],
            }),
            displacedBy,
            at: {
              type: 'REORDER',
              destination: {
                index: preset.inForeign2.descriptor.index,
                droppableId: preset.inForeign2.descriptor.droppableId,
              },
            },
          };
          expect(impact).toEqual(expected);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Lazy Test,"{'line': 114, 'column': 46, 'index': 3887}","it('should combine when moving forward past the displaced start threshold', () => {
          const endOnCombineStart: Position = getOffsetForEndEdge({
            endEdgeOn: combineStart,
            dragging: preset.inHome1.page.borderBox,
            axis,
          });

          // it should not merge on the threshold
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: endOnCombineStart,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });
            expect(impact).toEqual(whenEnteredForeign);
          }
          // it should merge with the item when it goes onto the displaced start
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: afterPoint(axis, endOnCombineStart),
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });
            expect(impact).toEqual(combineWithDisplacedInForeign3);
          }
        })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Lazy Test,"{'line': 149, 'column': 44, 'index': 5226}","it('should no longer merge when moving onto 4/5 of the target', () => {
          const endOnCombineEnd: Position = getOffsetForEndEdge({
            endEdgeOn: combineEnd,
            dragging: preset.inHome1.page.borderBox,
            axis,
          });

          // merge when still in on two thirds
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: beforePoint(axis, endOnCombineEnd),
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });
            expect(impact).toEqual(combineWithDisplacedInForeign3);
          }
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: endOnCombineEnd,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });

            const expected: DragImpact = {
              displaced: getForcedDisplacement({
                visible: [{ dimension: preset.inForeign4 }],
              }),
              displacedBy,
              at: {
                type: 'REORDER',
                // now in spot of inForeign4
                destination: {
                  index: preset.inForeign4.descriptor.index,
                  droppableId: preset.inForeign4.descriptor.droppableId,
                },
              },
            };
            expect(impact).toEqual(expected);
          }
        })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Lazy Test,"{'line': 180, 'column': 25, 'index': 6340}","it('should no longer merge when moving onto 4/5 of the target', () => {
          const endOnCombineEnd: Position = getOffsetForEndEdge({
            endEdgeOn: combineEnd,
            dragging: preset.inHome1.page.borderBox,
            axis,
          });

          // merge when still in on two thirds
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: beforePoint(axis, endOnCombineEnd),
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });
            expect(impact).toEqual(combineWithDisplacedInForeign3);
          }
          {
            const impact: DragImpact = getDragImpact({
              pageOffset: endOnCombineEnd,
              draggable: preset.inHome1,
              draggables: preset.draggables,
              droppables: withCombineEnabled,
              previousImpact: whenEnteredForeign,
              viewport: preset.viewport,
              afterCritical,
            });

            const expected: DragImpact = {
              displaced: getForcedDisplacement({
                visible: [{ dimension: preset.inForeign4 }],
              }),
              displacedBy,
              at: {
                type: 'REORDER',
                // now in spot of inForeign4
                destination: {
                  index: preset.inForeign4.descriptor.index,
                  droppableId: preset.inForeign4.descriptor.droppableId,
                },
              },
            };
            expect(impact).toEqual(expected);
          }
        })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Lazy Test,"{'line': 233, 'column': 44, 'index': 8158}","it('should combine with an item when moving backwards past 1 / 5 of the items size', () => {
        const startOnCombineEnd: Position = getOffsetForStartEdge({
          startEdgeOn: combineEnd,
          dragging: preset.inHome1.page.borderBox,
          axis,
        });
        // on edge is not far enough
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: startOnCombineEnd,
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(whenEnteredForeign);
        }
        // over edge is enough
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: beforePoint(axis, startOnCombineEnd),
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(combineWithInForeign2);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Lazy Test,"{'line': 267, 'column': 46, 'index': 9370}","it('should stop combining when going back onto 2/3 of the size', () => {
        const startOnCombineStart: Position = getOffsetForStartEdge({
          startEdgeOn: combineStart,
          dragging: preset.inHome1.page.borderBox,
          axis,
        });
        // after start is all good
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: afterPoint(axis, startOnCombineStart),
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(combineWithInForeign2);
        }
        // on combine start = stop combining
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: startOnCombineStart,
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });

          const expected: DragImpact = {
            displaced: getForcedDisplacement({
              visible: [
                { dimension: preset.inForeign2 },
                { dimension: preset.inForeign3 },
                { dimension: preset.inForeign4 },
              ],
            }),
            displacedBy,
            at: {
              type: 'REORDER',
              destination: {
                index: preset.inForeign2.descriptor.index,
                droppableId: preset.inForeign2.descriptor.droppableId,
              },
            },
          };
          expect(impact).toEqual(expected);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-before-critical.spec.js,Lazy Test,"{'line': 298, 'column': 23, 'index': 10464}","it('should stop combining when going back onto 2/3 of the size', () => {
        const startOnCombineStart: Position = getOffsetForStartEdge({
          startEdgeOn: combineStart,
          dragging: preset.inHome1.page.borderBox,
          axis,
        });
        // after start is all good
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: afterPoint(axis, startOnCombineStart),
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(combineWithInForeign2);
        }
        // on combine start = stop combining
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: startOnCombineStart,
            draggable: preset.inHome1,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: whenEnteredForeign,
            viewport: preset.viewport,
            afterCritical,
          });

          const expected: DragImpact = {
            displaced: getForcedDisplacement({
              visible: [
                { dimension: preset.inForeign2 },
                { dimension: preset.inForeign3 },
                { dimension: preset.inForeign4 },
              ],
            }),
            displacedBy,
            at: {
              type: 'REORDER',
              destination: {
                index: preset.inForeign2.descriptor.index,
                droppableId: preset.inForeign2.descriptor.droppableId,
              },
            },
          };
          expect(impact).toEqual(expected);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Conditional Test Logic,"{'line': 25, 'column': 23, 'index': 1030}",Unknown,steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Duplicate Assert,"{'line': 96, 'column': 10, 'index': 3433}","it('should move onto a target once it hits (1/5) of the targets size ', () => {
        const offset: Position = getOffsetForEndEdge({
          endEdgeOn: combineStart,
          dragging: preset.inHome2.page.borderBox,
          axis,
        });

        // sitting on combine point
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: offset,
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact).toEqual(homeImpact);
        }
        // gone past combine point
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: afterPoint(axis, offset),
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact).toEqual(combineWithInHome3Impact);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Duplicate Assert,"{'line': 110, 'column': 10, 'index': 3884}","it('should move onto a target once it hits (1/5) of the targets size ', () => {
        const offset: Position = getOffsetForEndEdge({
          endEdgeOn: combineStart,
          dragging: preset.inHome2.page.borderBox,
          axis,
        });

        // sitting on combine point
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: offset,
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact).toEqual(homeImpact);
        }
        // gone past combine point
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: afterPoint(axis, offset),
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact).toEqual(combineWithInHome3Impact);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Duplicate Assert,"{'line': 131, 'column': 10, 'index': 4600}","it('should remain displaced until the bottom of the dragging item goes onto the (4/5) mark', () => {
        const offset: Position = getOffsetForEndEdge({
          endEdgeOn: combineEnd,
          dragging: preset.inHome2.page.borderBox,
          axis,
        });
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: beforePoint(axis, offset),
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact).toEqual(combineWithInHome3Impact);
        }
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: offset,
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          const expected: DragImpact = {
            displaced: getForcedDisplacement({
              visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
            }),
            displacedBy,
            at: {
              type: 'REORDER',
              // now in position of inHome3
              destination: {
                index: preset.inHome3.descriptor.index,
                droppableId: preset.inHome3.descriptor.droppableId,
              },
            },
          };
          expect(impact).toEqual(expected);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Duplicate Assert,"{'line': 158, 'column': 10, 'index': 5510}","it('should remain displaced until the bottom of the dragging item goes onto the (4/5) mark', () => {
        const offset: Position = getOffsetForEndEdge({
          endEdgeOn: combineEnd,
          dragging: preset.inHome2.page.borderBox,
          axis,
        });
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: beforePoint(axis, offset),
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact).toEqual(combineWithInHome3Impact);
        }
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: offset,
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          const expected: DragImpact = {
            displaced: getForcedDisplacement({
              visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
            }),
            displacedBy,
            at: {
              type: 'REORDER',
              // now in position of inHome3
              destination: {
                index: preset.inHome3.descriptor.index,
                droppableId: preset.inHome3.descriptor.droppableId,
              },
            },
          };
          expect(impact).toEqual(expected);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Eager Test,"{'line': 115, 'column': 33, 'index': 4095}","it('should remain displaced until the bottom of the dragging item goes onto the (4/5) mark', () => {
        const offset: Position = getOffsetForEndEdge({
          endEdgeOn: combineEnd,
          dragging: preset.inHome2.page.borderBox,
          axis,
        });
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: beforePoint(axis, offset),
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact).toEqual(combineWithInHome3Impact);
        }
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: offset,
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          const expected: DragImpact = {
            displaced: getForcedDisplacement({
              visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
            }),
            displacedBy,
            at: {
              type: 'REORDER',
              // now in position of inHome3
              destination: {
                index: preset.inHome3.descriptor.index,
                droppableId: preset.inHome3.descriptor.droppableId,
              },
            },
          };
          expect(impact).toEqual(expected);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Eager Test,"{'line': 145, 'column': 23, 'index': 5066}","it('should remain displaced until the bottom of the dragging item goes onto the (4/5) mark', () => {
        const offset: Position = getOffsetForEndEdge({
          endEdgeOn: combineEnd,
          dragging: preset.inHome2.page.borderBox,
          axis,
        });
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: beforePoint(axis, offset),
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact).toEqual(combineWithInHome3Impact);
        }
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: offset,
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          const expected: DragImpact = {
            displaced: getForcedDisplacement({
              visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
            }),
            displacedBy,
            at: {
              type: 'REORDER',
              // now in position of inHome3
              destination: {
                index: preset.inHome3.descriptor.index,
                droppableId: preset.inHome3.descriptor.droppableId,
              },
            },
          };
          expect(impact).toEqual(expected);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Eager Test,"{'line': 292, 'column': 41, 'index': 9860}","it('should understand that when re-entering a list, items that started displaced no longer are', () => {
      const inHome4Threshold: Position = getThreshold(axis, preset.inHome4);
      const endOfInHome4: Position = patch(
        axis.line,
        preset.inHome4.page.borderBox[axis.end],
        preset.inHome4.page.borderBox.center[axis.crossAxisLine],
      );
      const displacedEndOfInHome4: Position = subtract(
        endOfInHome4,
        displacedBy.point,
      );
      const combineEnd: Position = subtract(
        displacedEndOfInHome4,
        inHome4Threshold,
      );

      const offset: Position = getOffsetForStartEdge({
        startEdgeOn: combineEnd,
        dragging: preset.inHome3.page.borderBox,
        axis,
      });

      const impact: DragImpact = getDragImpact({
        pageOffset: beforePoint(axis, offset),
        draggable: preset.inHome3,
        draggables: preset.draggables,
        droppables: withCombineEnabled,
        // out of the list
        previousImpact: noImpact,
        viewport: preset.viewport,
        afterCritical,
      });
      const expected: DragImpact = {
        displaced: emptyGroups,
        displacedBy: getDisplacedBy(axis, preset.inHome3.displaceBy),
        // below inHome4
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.inHome3.descriptor.droppableId,
            index: preset.inHome4.descriptor.index,
          },
        },
      };
      expect(impact).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Eager Test,"{'line': 307, 'column': 31, 'index': 10340}","it('should understand that when re-entering a list, items that started displaced no longer are', () => {
      const inHome4Threshold: Position = getThreshold(axis, preset.inHome4);
      const endOfInHome4: Position = patch(
        axis.line,
        preset.inHome4.page.borderBox[axis.end],
        preset.inHome4.page.borderBox.center[axis.crossAxisLine],
      );
      const displacedEndOfInHome4: Position = subtract(
        endOfInHome4,
        displacedBy.point,
      );
      const combineEnd: Position = subtract(
        displacedEndOfInHome4,
        inHome4Threshold,
      );

      const offset: Position = getOffsetForStartEdge({
        startEdgeOn: combineEnd,
        dragging: preset.inHome3.page.borderBox,
        axis,
      });

      const impact: DragImpact = getDragImpact({
        pageOffset: beforePoint(axis, offset),
        draggable: preset.inHome3,
        draggables: preset.draggables,
        droppables: withCombineEnabled,
        // out of the list
        previousImpact: noImpact,
        viewport: preset.viewport,
        afterCritical,
      });
      const expected: DragImpact = {
        displaced: emptyGroups,
        displacedBy: getDisplacedBy(axis, preset.inHome3.displaceBy),
        // below inHome4
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.inHome3.descriptor.droppableId,
            index: preset.inHome4.descriptor.index,
          },
        },
      };
      expect(impact).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Lazy Test,"{'line': 78, 'column': 33, 'index': 2908}","it('should move onto a target once it hits (1/5) of the targets size ', () => {
        const offset: Position = getOffsetForEndEdge({
          endEdgeOn: combineStart,
          dragging: preset.inHome2.page.borderBox,
          axis,
        });

        // sitting on combine point
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: offset,
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact).toEqual(homeImpact);
        }
        // gone past combine point
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: afterPoint(axis, offset),
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact).toEqual(combineWithInHome3Impact);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Lazy Test,"{'line': 115, 'column': 33, 'index': 4095}","it('should remain displaced until the bottom of the dragging item goes onto the (4/5) mark', () => {
        const offset: Position = getOffsetForEndEdge({
          endEdgeOn: combineEnd,
          dragging: preset.inHome2.page.borderBox,
          axis,
        });
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: beforePoint(axis, offset),
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact).toEqual(combineWithInHome3Impact);
        }
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: offset,
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: homeImpact,
            viewport: preset.viewport,
            afterCritical,
          });

          const expected: DragImpact = {
            displaced: getForcedDisplacement({
              visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
            }),
            displacedBy,
            at: {
              type: 'REORDER',
              // now in position of inHome3
              destination: {
                index: preset.inHome3.descriptor.index,
                droppableId: preset.inHome3.descriptor.droppableId,
              },
            },
          };
          expect(impact).toEqual(expected);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Lazy Test,"{'line': 215, 'column': 33, 'index': 7254}","it('should move backwards onto an item that has shifted backwards', () => {
        const offset: Position = getOffsetForStartEdge({
          startEdgeOn: combineEnd,
          dragging: preset.inHome2.page.borderBox,
          axis,
        });

        // have not moved far enough backwards yet
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: offset,
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: first,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact.at).toHaveProperty('type', 'REORDER');
        }
        // moved back enough
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: beforePoint(axis, offset),
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: first,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact).toEqual(combineWithDisplacedInHome3Impact);
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Lazy Test,"{'line': 251, 'column': 33, 'index': 8450}","it('should no longer combine with an item once it hits the top threshold', () => {
        const offset: Position = getOffsetForStartEdge({
          startEdgeOn: combineStart,
          dragging: preset.inHome2.page.borderBox,
          axis,
        });

        // have not moved far enough backwards yet
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: afterPoint(axis, offset),
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: first,
            viewport: preset.viewport,
            afterCritical,
          });
          expect(impact).toEqual(combineWithDisplacedInHome3Impact);
        }
        // moved back enough
        {
          const impact: DragImpact = getDragImpact({
            pageOffset: offset,
            draggable: preset.inHome2,
            draggables: preset.draggables,
            droppables: withCombineEnabled,
            previousImpact: first,
            viewport: preset.viewport,
            afterCritical,
          });

          expect(impact.at).toHaveProperty('type', 'REORDER');
        }
      })",steel
/test/unit/state/get-drag-impact/combine/started-after-critical.spec.js,Lazy Test,"{'line': 307, 'column': 31, 'index': 10340}","it('should understand that when re-entering a list, items that started displaced no longer are', () => {
      const inHome4Threshold: Position = getThreshold(axis, preset.inHome4);
      const endOfInHome4: Position = patch(
        axis.line,
        preset.inHome4.page.borderBox[axis.end],
        preset.inHome4.page.borderBox.center[axis.crossAxisLine],
      );
      const displacedEndOfInHome4: Position = subtract(
        endOfInHome4,
        displacedBy.point,
      );
      const combineEnd: Position = subtract(
        displacedEndOfInHome4,
        inHome4Threshold,
      );

      const offset: Position = getOffsetForStartEdge({
        startEdgeOn: combineEnd,
        dragging: preset.inHome3.page.borderBox,
        axis,
      });

      const impact: DragImpact = getDragImpact({
        pageOffset: beforePoint(axis, offset),
        draggable: preset.inHome3,
        draggables: preset.draggables,
        droppables: withCombineEnabled,
        // out of the list
        previousImpact: noImpact,
        viewport: preset.viewport,
        afterCritical,
      });
      const expected: DragImpact = {
        displaced: emptyGroups,
        displacedBy: getDisplacedBy(axis, preset.inHome3.displaceBy),
        // below inHome4
        at: {
          type: 'REORDER',
          destination: {
            droppableId: preset.inHome3.descriptor.droppableId,
            index: preset.inHome4.descriptor.index,
          },
        },
      };
      expect(impact).toEqual(expected);
    })",steel
/test/unit/state/get-drag-impact/combine/should-not-combine-with-home-draggable.spec.js,Conditional Test Logic,"{'line': 13, 'column': 23, 'index': 472}",Unknown,steel
/test/unit/state/get-drag-impact/combine/is-combine-disabled.spec.js,Conditional Test Logic,"{'line': 19, 'column': 23, 'index': 844}",Unknown,steel
/test/unit/state/get-drag-impact/combine/is-combine-disabled.spec.js,Duplicate Assert,"{'line': 57, 'column': 8, 'index': 2167}","it('should not create a combine impact when combining is disabled', () => {
      // does not combine when combine is disabled
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, combineStart),
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          viewport: preset.viewport,
          afterCritical,
        });

        expect(impact).toEqual(homeImpact);
      }
      // would have combined if was enabled (validation)
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, combineStart),
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: withCombineEnabled,
          previousImpact: homeImpact,
          viewport: preset.viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              // displaced is not animated as it was the starting displacement
              { dimension: preset.inHome3, shouldAnimate: false },
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
          at: {
            type: 'COMBINE',
            combine: {
              draggableId: preset.inHome3.descriptor.id,
              droppableId: preset.inHome3.descriptor.droppableId,
            },
          },
        };
        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-drag-impact/combine/is-combine-disabled.spec.js,Duplicate Assert,"{'line': 88, 'column': 8, 'index': 3273}","it('should not create a combine impact when combining is disabled', () => {
      // does not combine when combine is disabled
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, combineStart),
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: preset.droppables,
          previousImpact: homeImpact,
          viewport: preset.viewport,
          afterCritical,
        });

        expect(impact).toEqual(homeImpact);
      }
      // would have combined if was enabled (validation)
      {
        const impact: DragImpact = getDragImpact({
          pageOffset: afterPoint(axis, combineStart),
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppables: withCombineEnabled,
          previousImpact: homeImpact,
          viewport: preset.viewport,
          afterCritical,
        });

        const expected: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              // displaced is not animated as it was the starting displacement
              { dimension: preset.inHome3, shouldAnimate: false },
              { dimension: preset.inHome4, shouldAnimate: false },
            ],
          }),
          displacedBy: getDisplacedBy(axis, preset.inHome2.displaceBy),
          at: {
            type: 'COMBINE',
            combine: {
              draggableId: preset.inHome3.descriptor.id,
              droppableId: preset.inHome3.descriptor.droppableId,
            },
          },
        };
        expect(impact).toEqual(expected);
      }
    })",steel
/test/unit/state/get-displacement-groups/use-initial-position-not-displaced.spec.js,Conditional Test Logic,"{'line': 20, 'column': 23, 'index': 875}",Unknown,steel
/test/unit/state/get-displacement-groups/get-displacement-groups.spec.js,Conditional Test Logic,"{'line': 27, 'column': 23, 'index': 1016}",Unknown,steel
/test/unit/state/get-displacement-groups/get-displacement-groups.spec.js,Eager Test,"{'line': 215, 'column': 39, 'index': 6306}","it('should mark an item as not animated when moving from invisible to visible', () => {
      const last: DisplacementGroups = getForcedDisplacement({
        visible: [
          { dimension: isVisible },
          { dimension: isVisibleDueToOverScanning },
        ],
        invisible: [isNotVisible],
      });
      // scrolling enough for isNotVisible to be visible
      const scrolled: Viewport = scrollViewport(viewport, patch(axis.line, 1));

      const result: DisplacementGroups = getDisplacementGroups({
        afterDragging,
        destination: foreign,
        displacedBy,
        last,
        viewport: scrolled.frame,
      });

      const expected: DisplacementGroups = getForcedDisplacement({
        visible: [
          { dimension: isVisible },
          { dimension: isVisibleDueToOverScanning },
          { dimension: isNotVisible, shouldAnimate: false },
        ],
      });

      expect(result).toEqual(expected);
    })",steel
/test/unit/state/get-displacement-groups/get-displacement-groups.spec.js,Eager Test,"{'line': 233, 'column': 43, 'index': 6873}","it('should mark an item as not animated when moving from invisible to visible', () => {
      const last: DisplacementGroups = getForcedDisplacement({
        visible: [
          { dimension: isVisible },
          { dimension: isVisibleDueToOverScanning },
        ],
        invisible: [isNotVisible],
      });
      // scrolling enough for isNotVisible to be visible
      const scrolled: Viewport = scrollViewport(viewport, patch(axis.line, 1));

      const result: DisplacementGroups = getDisplacementGroups({
        afterDragging,
        destination: foreign,
        displacedBy,
        last,
        viewport: scrolled.frame,
      });

      const expected: DisplacementGroups = getForcedDisplacement({
        visible: [
          { dimension: isVisible },
          { dimension: isVisibleDueToOverScanning },
          { dimension: isNotVisible, shouldAnimate: false },
        ],
      });

      expect(result).toEqual(expected);
    })",steel
/test/unit/state/get-displacement-groups/get-displacement-groups.spec.js,Lazy Test,"{'line': 181, 'column': 43, 'index': 5270}","it('should correctly mark item visibility', () => {
      const result: DisplacementGroups = getDisplacementGroups({
        afterDragging,
        destination: foreign,
        displacedBy,
        last: homeImpact.displaced,
        viewport: viewport.frame,
      });

      const expected: DisplacementGroups = getForcedDisplacement({
        visible: [
          { dimension: isVisible },
          // overscanning
          { dimension: isVisibleDueToOverScanning },
        ],
        invisible: [isNotVisible],
      });

      expect(result).toEqual(expected);
    })",steel
/test/unit/state/get-displacement-groups/get-displacement-groups.spec.js,Lazy Test,"{'line': 194, 'column': 39, 'index': 5651}","it('should keep displacement animation consistent between calls', () => {
      const last: DisplacementGroups = getForcedDisplacement({
        visible: [
          // forcing this to be difference so we know this is working
          { dimension: isVisible, shouldAnimate: false },
          { dimension: isVisibleDueToOverScanning },
        ],
        invisible: [isNotVisible],
      });

      const result: DisplacementGroups = getDisplacementGroups({
        afterDragging,
        destination: foreign,
        displacedBy,
        last,
        viewport: viewport.frame,
      });

      expect(result).toEqual(last);
    })",steel
/test/unit/state/get-displacement-groups/get-displacement-groups.spec.js,Lazy Test,"{'line': 215, 'column': 39, 'index': 6306}","it('should mark an item as not animated when moving from invisible to visible', () => {
      const last: DisplacementGroups = getForcedDisplacement({
        visible: [
          { dimension: isVisible },
          { dimension: isVisibleDueToOverScanning },
        ],
        invisible: [isNotVisible],
      });
      // scrolling enough for isNotVisible to be visible
      const scrolled: Viewport = scrollViewport(viewport, patch(axis.line, 1));

      const result: DisplacementGroups = getDisplacementGroups({
        afterDragging,
        destination: foreign,
        displacedBy,
        last,
        viewport: scrolled.frame,
      });

      const expected: DisplacementGroups = getForcedDisplacement({
        visible: [
          { dimension: isVisible },
          { dimension: isVisibleDueToOverScanning },
          { dimension: isNotVisible, shouldAnimate: false },
        ],
      });

      expect(result).toEqual(expected);
    })",steel
/test/unit/state/get-displacement-groups/get-displacement-groups.spec.js,Lazy Test,"{'line': 253, 'column': 43, 'index': 7481}","it('should make displacement animated if being displaced for the first time', () => {
      const result: DisplacementGroups = getDisplacementGroups({
        afterDragging,
        destination: foreign,
        displacedBy,
        last: emptyGroups,
        viewport: viewport.frame,
      });

      const expected: DisplacementGroups = getForcedDisplacement({
        // both are animated
        visible: [
          { dimension: isVisible },
          // overscanning
          { dimension: isVisibleDueToOverScanning },
        ],
        invisible: [isNotVisible],
      });

      expect(result).toEqual(expected);
    })",steel
/test/unit/state/get-displacement-groups/get-displacement-groups.spec.js,Lazy Test,"{'line': 276, 'column': 43, 'index': 8129}","it('should force the animation value when requested', () => {
      const result: DisplacementGroups = getDisplacementGroups({
        afterDragging,
        destination: foreign,
        displacedBy,
        last: emptyGroups,
        viewport: viewport.frame,
        forceShouldAnimate: false,
      });

      const expected: DisplacementGroups = getForcedDisplacement({
        visible: [
          { dimension: isVisible, shouldAnimate: false },
          { dimension: isVisibleDueToOverScanning, shouldAnimate: false },
        ],

        invisible: [isNotVisible],
      });

      expect(result).toEqual(expected);
    })",steel
/test/unit/state/get-center-from-impact/move-relative-to.spec.js,Conditional Test Logic,"{'line': 56, 'column': 23, 'index': 1282}",Unknown,steel
/test/unit/state/get-center-from-impact/get-client-border-box-center.spec.js,Conditional Test Logic,"{'line': 21, 'column': 23, 'index': 921}",Unknown,steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/over-nothing.spec.js,Conditional Test Logic,"{'line': 9, 'column': 23, 'index': 443}",Unknown,steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/in-home-location.spec.js,Conditional Test Logic,"{'line': 9, 'column': 23, 'index': 443}",Unknown,steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/reorder/with-droppable-scroll.spec.js,Conditional Test Logic,"{'line': 19, 'column': 23, 'index': 925}",Unknown,steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/reorder/with-droppable-scroll.spec.js,Duplicate Assert,"{'line': 60, 'column': 8, 'index': 2234}","it('should account for any scroll in the droppable being dropped into (into foreign list)', () => {
      // inHome1 over the end of empty
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome1.displaceBy,
      );
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const impact: DragImpact = {
        displaced: emptyGroups,
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: 0,
            droppableId: preset.emptyForeign.descriptor.id,
          },
        },
      };
      const expectedCenter: Position = goIntoStart({
        axis,
        moveInto: preset.emptyForeign.page,
        isMoving: preset.inHome1.page,
      });
      // into start of empty foreign list (without scroll)
      {
        const result: Position = getPageBorderBoxCenter({
          impact,
          draggable: preset.inHome1,
          draggables: preset.dimensions.draggables,
          droppable: preset.emptyForeign,
          afterCritical,
        });

        expect(result).toEqual(expectedCenter);
      }
      // into start of empty foreign list (with scroll)
      {
        const scroll: Position = { x: 10, y: 20 };
        const displacement: Position = negate(scroll);
        const scrollable: DroppableDimension = makeScrollable(
          preset.emptyForeign,
        );
        const scrolled: DroppableDimension = scrollDroppable(
          scrollable,
          scroll,
        );

        const result: Position = getPageBorderBoxCenter({
          impact,
          draggable: preset.inHome1,
          draggables: preset.dimensions.draggables,
          droppable: scrolled,
          afterCritical,
        });

        expect(result).toEqual(add(expectedCenter, displacement));
      }
    })",steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/reorder/with-droppable-scroll.spec.js,Duplicate Assert,"{'line': 82, 'column': 8, 'index': 2913}","it('should account for any scroll in the droppable being dropped into (into foreign list)', () => {
      // inHome1 over the end of empty
      const displacedBy: DisplacedBy = getDisplacedBy(
        axis,
        preset.inHome1.displaceBy,
      );
      const { afterCritical } = getLiftEffect({
        draggable: preset.inHome1,
        home: preset.home,
        draggables: preset.draggables,
        viewport: preset.viewport,
      });
      const impact: DragImpact = {
        displaced: emptyGroups,
        displacedBy,
        at: {
          type: 'REORDER',
          destination: {
            index: 0,
            droppableId: preset.emptyForeign.descriptor.id,
          },
        },
      };
      const expectedCenter: Position = goIntoStart({
        axis,
        moveInto: preset.emptyForeign.page,
        isMoving: preset.inHome1.page,
      });
      // into start of empty foreign list (without scroll)
      {
        const result: Position = getPageBorderBoxCenter({
          impact,
          draggable: preset.inHome1,
          draggables: preset.dimensions.draggables,
          droppable: preset.emptyForeign,
          afterCritical,
        });

        expect(result).toEqual(expectedCenter);
      }
      // into start of empty foreign list (with scroll)
      {
        const scroll: Position = { x: 10, y: 20 };
        const displacement: Position = negate(scroll);
        const scrollable: DroppableDimension = makeScrollable(
          preset.emptyForeign,
        );
        const scrolled: DroppableDimension = scrollDroppable(
          scrollable,
          scroll,
        );

        const result: Position = getPageBorderBoxCenter({
          impact,
          draggable: preset.inHome1,
          draggables: preset.dimensions.draggables,
          droppable: scrolled,
          afterCritical,
        });

        expect(result).toEqual(add(expectedCenter, displacement));
      }
    })",steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/reorder/there-is-displacement.spec.js,Conditional Test Logic,"{'line': 17, 'column': 23, 'index': 769}",Unknown,steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/reorder/there-is-displacement.spec.js,Lazy Test,"{'line': 36, 'column': 21, 'index': 1448}","it('should go before the visible (displaced) position of the item', () => {
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome1,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome1.displaceBy,
        );

        const impact: DragImpact = {
          // moved forward over inHome2
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome3,
                shouldAnimate: false,
              },
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            destination: {
              index: preset.inHome3.descriptor.index,
              droppableId: preset.inHome3.descriptor.id,
            },
          },
        };
        const result: Position = getPageBorderBoxCenter({
          impact,
          afterCritical,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppable: preset.home,
        });

        const expected: Position = goBefore({
          axis,
          moveRelativeTo: preset.inHome3.page,
          isMoving: preset.inHome1.page,
        });
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/reorder/there-is-displacement.spec.js,Lazy Test,"{'line': 88, 'column': 21, 'index': 2999}","it('should go before the displaced position of the item', () => {
        const { afterCritical } = getLiftEffect({
          draggable: preset.inHome1,
          home: preset.home,
          draggables: preset.draggables,
          viewport: preset.viewport,
        });
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          preset.inHome1.displaceBy,
        );
        // moved into foreign
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inForeign2,
                shouldAnimate: false,
              },
              {
                dimension: preset.inForeign3,
                shouldAnimate: false,
              },
              {
                dimension: preset.inForeign4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'REORDER',
            // currently in position of inForeign2
            destination: {
              index: preset.inForeign2.descriptor.index,
              droppableId: preset.inForeign2.descriptor.id,
            },
          },
        };
        const result: Position = getPageBorderBoxCenter({
          impact,
          afterCritical,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppable: preset.foreign,
        });

        const expected: Position = goBefore({
          axis,
          moveRelativeTo: offset(preset.inForeign2.page, displacedBy.point),
          isMoving: preset.inHome1.page,
        });
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/reorder/nothing-displaced.spec.js,Conditional Test Logic,"{'line': 17, 'column': 23, 'index': 800}",Unknown,steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/reorder/in-empty-list.spec.js,Conditional Test Logic,"{'line': 10, 'column': 23, 'index': 557}",Unknown,steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/combine/with-droppable-scroll.spec.js,Conditional Test Logic,"{'line': 18, 'column': 23, 'index': 825}",Unknown,steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/combine/with-droppable-scroll.spec.js,Duplicate Assert,"{'line': 77, 'column': 8, 'index': 2545}","it('should account for any scroll in the droppable being dropped into (into foreign list)', () => {
      // combining with inHome2
      const impact: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            {
              dimension: preset.inHome2,
              shouldAnimate: false,
            },
            {
              dimension: preset.inHome3,
              shouldAnimate: false,
            },
            {
              dimension: preset.inHome4,
              shouldAnimate: false,
            },
          ],
        }),
        displacedBy,
        at: {
          type: 'COMBINE',
          // combining with inHome2
          combine: {
            draggableId: preset.inHome2.descriptor.id,
            droppableId: preset.inHome2.descriptor.droppableId,
          },
        },
      };

      const inHome2Center: Position = preset.inHome2.page.borderBox.center;
      // without any scroll
      {
        const result: Position = getPageBorderBoxCenter({
          impact,
          afterCritical,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppable: withCombineEnabled,
        });

        expect(result).toEqual(inHome2Center);
      }
      // into start of empty foreign list (with scroll)
      {
        const scroll: Position = { x: 10, y: 20 };
        const displacement: Position = negate(scroll);
        const scrollable: DroppableDimension = makeScrollable(
          withCombineEnabled,
        );
        const scrolled: DroppableDimension = scrollDroppable(
          scrollable,
          scroll,
        );

        const result: Position = getPageBorderBoxCenter({
          impact,
          draggable: preset.inHome1,
          draggables: preset.dimensions.draggables,
          droppable: scrolled,
          afterCritical,
        });

        expect(result).toEqual(add(inHome2Center, displacement));
      }
    })",steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/combine/with-droppable-scroll.spec.js,Duplicate Assert,"{'line': 99, 'column': 8, 'index': 3222}","it('should account for any scroll in the droppable being dropped into (into foreign list)', () => {
      // combining with inHome2
      const impact: DragImpact = {
        displaced: getForcedDisplacement({
          visible: [
            {
              dimension: preset.inHome2,
              shouldAnimate: false,
            },
            {
              dimension: preset.inHome3,
              shouldAnimate: false,
            },
            {
              dimension: preset.inHome4,
              shouldAnimate: false,
            },
          ],
        }),
        displacedBy,
        at: {
          type: 'COMBINE',
          // combining with inHome2
          combine: {
            draggableId: preset.inHome2.descriptor.id,
            droppableId: preset.inHome2.descriptor.droppableId,
          },
        },
      };

      const inHome2Center: Position = preset.inHome2.page.borderBox.center;
      // without any scroll
      {
        const result: Position = getPageBorderBoxCenter({
          impact,
          afterCritical,
          draggable: preset.inHome1,
          draggables: preset.draggables,
          droppable: withCombineEnabled,
        });

        expect(result).toEqual(inHome2Center);
      }
      // into start of empty foreign list (with scroll)
      {
        const scroll: Position = { x: 10, y: 20 };
        const displacement: Position = negate(scroll);
        const scrollable: DroppableDimension = makeScrollable(
          withCombineEnabled,
        );
        const scrolled: DroppableDimension = scrollDroppable(
          scrollable,
          scroll,
        );

        const result: Position = getPageBorderBoxCenter({
          impact,
          draggable: preset.inHome1,
          draggables: preset.dimensions.draggables,
          droppable: scrolled,
          afterCritical,
        });

        expect(result).toEqual(add(inHome2Center, displacement));
      }
    })",steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/combine/when-combining.spec.js,Conditional Test Logic,"{'line': 17, 'column': 23, 'index': 725}",Unknown,steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/combine/when-combining.spec.js,Lazy Test,"{'line': 38, 'column': 21, 'index': 1432}","it('should move onto a displaced center - the initial visible center', () => {
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [
              {
                dimension: preset.inHome3,
                shouldAnimate: false,
              },
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'COMBINE',
            // combining with inHome3
            combine: {
              draggableId: preset.inHome3.descriptor.id,
              droppableId: preset.inHome3.descriptor.droppableId,
            },
          },
        };

        const result: Position = getPageBorderBoxCenter({
          impact,
          afterCritical,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppable: withCombineEnabled,
        });

        expect(result).toEqual(preset.inHome3.page.borderBox.center);
      })",steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/combine/when-combining.spec.js,Lazy Test,"{'line': 76, 'column': 21, 'index': 2595}","it('should move onto a non-displaced center', () => {
        // combining with inHome3 which is no longer displaced
        // inHome2 would have moved forward and is now moving backwards
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            visible: [{ dimension: preset.inHome4, shouldAnimate: false }],
          }),
          displacedBy,
          at: {
            type: 'COMBINE',
            // combining with not displaced inHome1
            combine: {
              draggableId: preset.inHome3.descriptor.id,
              droppableId: preset.inHome3.descriptor.droppableId,
            },
          },
        };

        const result: Position = getPageBorderBoxCenter({
          impact,
          afterCritical,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppable: withCombineEnabled,
        });

        const expected: Position = subtract(
          preset.inHome3.page.borderBox.center,
          displacedBy.point,
        );
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/combine/when-combining.spec.js,Lazy Test,"{'line': 111, 'column': 21, 'index': 3719}","it('should move onto a displaced center', () => {
        // moving inHome2 backwards past inHome1 (pushing it forward)
        // and then moving onto inHome1
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            // inHome2 not displaced as it is the dragging item
            visible: [
              {
                dimension: preset.inHome1,
                shouldAnimate: true,
              },
              {
                dimension: preset.inHome3,
                shouldAnimate: false,
              },
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'COMBINE',
            // combining with not displaced inHome1
            combine: {
              draggableId: preset.inHome1.descriptor.id,
              droppableId: preset.inHome1.descriptor.droppableId,
            },
          },
        };

        const result: Position = getPageBorderBoxCenter({
          impact,
          afterCritical,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppable: withCombineEnabled,
        });

        const expected: Position = add(
          preset.inHome1.page.borderBox.center,
          displacedBy.point,
        );
        expect(result).toEqual(expected);
      })",steel
/test/unit/state/get-center-from-impact/get-page-border-box-center/combine/when-combining.spec.js,Lazy Test,"{'line': 157, 'column': 21, 'index': 5087}","it('should move onto a non-displaced center', () => {
        // moving inHome2 backwards onto inHome1
        const impact: DragImpact = {
          displaced: getForcedDisplacement({
            // inHome2 not displaced as it is the dragging item
            visible: [
              {
                dimension: preset.inHome3,
                shouldAnimate: false,
              },
              {
                dimension: preset.inHome4,
                shouldAnimate: false,
              },
            ],
          }),
          displacedBy,
          at: {
            type: 'COMBINE',
            // combining with not displaced inHome1
            combine: {
              draggableId: preset.inHome1.descriptor.id,
              droppableId: preset.inHome1.descriptor.droppableId,
            },
          },
        };

        const result: Position = getPageBorderBoxCenter({
          impact,
          afterCritical,
          draggable: preset.inHome2,
          draggables: preset.draggables,
          droppable: withCombineEnabled,
        });

        expect(result).toEqual(preset.inHome1.page.borderBox.center);
      })",steel
/test/unit/state/droppable/with-placeholder.spec.js,Conditional Test Logic,"{'line': 33, 'column': 23, 'index': 1030}",Unknown,steel
/test/unit/state/droppable/with-placeholder.spec.js,Eager Test,"{'line': 248, 'column': 8, 'index': 7976}","it('should grow the subject if required', () => {
        const excess: number = 20;
        const inHome: DraggableDimension = getHomeDraggable(gap + excess);

        const result: DroppableDimension = addPlaceholder(
          withFrame,
          inHome,
          withHomeDraggable(inHome),
        );

        const increasedBy: Position = patch(axis.line, excess);
        const active: ?Rect = withFrame.subject.active;
        invariant(active);
        const expected: DroppableSubject = {
          // unchanged
          page: withFrame.subject.page,
          // increased
          active: getRect({
            ...active,
            [axis.end]: active[axis.end] + excess,
          }),
          // added
          withPlaceholder: {
            increasedBy,
            oldFrameMaxScroll: originalFrame.scroll.max,
            placeholderSize: getPlaceholderSize(inHome),
          },
        };
        expect(result.subject).toEqual(expected);
        // max scroll change
        const newFrame: ?Scrollable = result.frame;
        invariant(newFrame);
        expect(originalFrame.scroll.max).not.toEqual(newFrame.scroll.max);
        expect(newFrame.scroll.max).toEqual(
          add(originalFrame.scroll.max, increasedBy),
        );
        // no client change
        expect(newFrame.frameClient).toEqual(newFrame.frameClient);
      })",steel
/test/unit/state/droppable/with-placeholder.spec.js,Eager Test,"{'line': 267, 'column': 8, 'index': 8592}","it('should grow the subject if required', () => {
        const excess: number = 20;
        const inHome: DraggableDimension = getHomeDraggable(gap + excess);

        const result: DroppableDimension = addPlaceholder(
          withFrame,
          inHome,
          withHomeDraggable(inHome),
        );

        const increasedBy: Position = patch(axis.line, excess);
        const active: ?Rect = withFrame.subject.active;
        invariant(active);
        const expected: DroppableSubject = {
          // unchanged
          page: withFrame.subject.page,
          // increased
          active: getRect({
            ...active,
            [axis.end]: active[axis.end] + excess,
          }),
          // added
          withPlaceholder: {
            increasedBy,
            oldFrameMaxScroll: originalFrame.scroll.max,
            placeholderSize: getPlaceholderSize(inHome),
          },
        };
        expect(result.subject).toEqual(expected);
        // max scroll change
        const newFrame: ?Scrollable = result.frame;
        invariant(newFrame);
        expect(originalFrame.scroll.max).not.toEqual(newFrame.scroll.max);
        expect(newFrame.scroll.max).toEqual(
          add(originalFrame.scroll.max, increasedBy),
        );
        // no client change
        expect(newFrame.frameClient).toEqual(newFrame.frameClient);
      })",steel
/test/unit/state/droppable/with-placeholder.spec.js,Eager Test,"{'line': 333, 'column': 8, 'index': 10889}","it('should always grow the subject required', () => {
        const inHome: DraggableDimension = getHomeDraggable(gap - 5);
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          inHome.displaceBy,
        );
        // increasing by the whole amount, not just the gap
        // for virtual lists we cannot count the size of existing items
        // as they all might not be there
        const increasedBy: Position = patch(axis.line, displacedBy.value);

        const result: DroppableDimension = addPlaceholder(
          virtual,
          inHome,
          withHomeDraggable(inHome),
        );

        const active: ?Rect = virtual.subject.active;
        invariant(active);
        const expected: DroppableSubject = {
          // unchanged
          page: virtual.subject.page,
          // increased
          active: getRect({
            ...active,
            [axis.end]: active[axis.end] + displacedBy.value,
          }),
          // added
          withPlaceholder: {
            increasedBy,
            oldFrameMaxScroll: originalFrame.scroll.max,
            placeholderSize: getPlaceholderSize(inHome),
          },
        };
        expect(result.subject).toEqual(expected);
        // max scroll change
        const newFrame: ?Scrollable = result.frame;
        invariant(newFrame);
        expect(originalFrame.scroll.max).not.toEqual(newFrame.scroll.max);
        expect(newFrame.scroll.max).toEqual(
          add(originalFrame.scroll.max, increasedBy),
        );
        // no client change
        expect(newFrame.frameClient).toEqual(newFrame.frameClient);
      })",steel
/test/unit/state/droppable/with-placeholder.spec.js,Eager Test,"{'line': 352, 'column': 8, 'index': 11514}","it('should always grow the subject required', () => {
        const inHome: DraggableDimension = getHomeDraggable(gap - 5);
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          inHome.displaceBy,
        );
        // increasing by the whole amount, not just the gap
        // for virtual lists we cannot count the size of existing items
        // as they all might not be there
        const increasedBy: Position = patch(axis.line, displacedBy.value);

        const result: DroppableDimension = addPlaceholder(
          virtual,
          inHome,
          withHomeDraggable(inHome),
        );

        const active: ?Rect = virtual.subject.active;
        invariant(active);
        const expected: DroppableSubject = {
          // unchanged
          page: virtual.subject.page,
          // increased
          active: getRect({
            ...active,
            [axis.end]: active[axis.end] + displacedBy.value,
          }),
          // added
          withPlaceholder: {
            increasedBy,
            oldFrameMaxScroll: originalFrame.scroll.max,
            placeholderSize: getPlaceholderSize(inHome),
          },
        };
        expect(result.subject).toEqual(expected);
        // max scroll change
        const newFrame: ?Scrollable = result.frame;
        invariant(newFrame);
        expect(originalFrame.scroll.max).not.toEqual(newFrame.scroll.max);
        expect(newFrame.scroll.max).toEqual(
          add(originalFrame.scroll.max, increasedBy),
        );
        // no client change
        expect(newFrame.frameClient).toEqual(newFrame.frameClient);
      })",steel
/test/unit/state/droppable/with-placeholder.spec.js,Lazy Test,"{'line': 151, 'column': 10, 'index': 4702}","it('should grow the subject if required', () => {
          const excess: number = 20;
          const inHome: DraggableDimension = getHomeDraggable(gap + excess);

          const result: DroppableDimension = addPlaceholder(
            withoutFrame,
            inHome,
            withHomeDraggable(inHome),
          );

          const active: ?Rect = withoutFrame.subject.active;
          invariant(active);
          const expected: DroppableSubject = {
            // unchanged
            page: withoutFrame.subject.page,
            // increased
            active: getRect({
              ...active,
              [axis.end]: active[axis.end] + excess,
            }),
            // added
            withPlaceholder: {
              increasedBy: patch(axis.line, excess),
              oldFrameMaxScroll: null,
              placeholderSize: getPlaceholderSize(inHome),
            },
          };
          expect(result.subject).toEqual(expected);
        })",steel
/test/unit/state/droppable/with-placeholder.spec.js,Lazy Test,"{'line': 231, 'column': 8, 'index': 7382}","it('should not grow the subject if not required', () => {
        const inHome: DraggableDimension = getHomeDraggable(gap - 5);

        const result: DroppableDimension = addPlaceholder(
          withFrame,
          inHome,
          withHomeDraggable(inHome),
        );

        const expected: DroppableSubject = {
          // unchanged
          page: withFrame.subject.page,
          active: withFrame.subject.active,
          // added
          withPlaceholder: {
            increasedBy: null,
            // holding onto old max regardless
            oldFrameMaxScroll: originalFrame.scroll.max,
            placeholderSize: getPlaceholderSize(inHome),
          },
        };
        expect(result.subject).toEqual(expected);
        // no change in frame or scroll
        const newFrame: ?Scrollable = result.frame;
        invariant(newFrame);
        expect(originalFrame.scroll.max).toEqual(newFrame.scroll.max);
        expect(originalFrame).toEqual(newFrame);
      })",steel
/test/unit/state/droppable/with-placeholder.spec.js,Lazy Test,"{'line': 248, 'column': 8, 'index': 7976}","it('should grow the subject if required', () => {
        const excess: number = 20;
        const inHome: DraggableDimension = getHomeDraggable(gap + excess);

        const result: DroppableDimension = addPlaceholder(
          withFrame,
          inHome,
          withHomeDraggable(inHome),
        );

        const increasedBy: Position = patch(axis.line, excess);
        const active: ?Rect = withFrame.subject.active;
        invariant(active);
        const expected: DroppableSubject = {
          // unchanged
          page: withFrame.subject.page,
          // increased
          active: getRect({
            ...active,
            [axis.end]: active[axis.end] + excess,
          }),
          // added
          withPlaceholder: {
            increasedBy,
            oldFrameMaxScroll: originalFrame.scroll.max,
            placeholderSize: getPlaceholderSize(inHome),
          },
        };
        expect(result.subject).toEqual(expected);
        // max scroll change
        const newFrame: ?Scrollable = result.frame;
        invariant(newFrame);
        expect(originalFrame.scroll.max).not.toEqual(newFrame.scroll.max);
        expect(newFrame.scroll.max).toEqual(
          add(originalFrame.scroll.max, increasedBy),
        );
        // no client change
        expect(newFrame.frameClient).toEqual(newFrame.frameClient);
      })",steel
/test/unit/state/droppable/with-placeholder.spec.js,Lazy Test,"{'line': 333, 'column': 8, 'index': 10889}","it('should always grow the subject required', () => {
        const inHome: DraggableDimension = getHomeDraggable(gap - 5);
        const displacedBy: DisplacedBy = getDisplacedBy(
          axis,
          inHome.displaceBy,
        );
        // increasing by the whole amount, not just the gap
        // for virtual lists we cannot count the size of existing items
        // as they all might not be there
        const increasedBy: Position = patch(axis.line, displacedBy.value);

        const result: DroppableDimension = addPlaceholder(
          virtual,
          inHome,
          withHomeDraggable(inHome),
        );

        const active: ?Rect = virtual.subject.active;
        invariant(active);
        const expected: DroppableSubject = {
          // unchanged
          page: virtual.subject.page,
          // increased
          active: getRect({
            ...active,
            [axis.end]: active[axis.end] + displacedBy.value,
          }),
          // added
          withPlaceholder: {
            increasedBy,
            oldFrameMaxScroll: originalFrame.scroll.max,
            placeholderSize: getPlaceholderSize(inHome),
          },
        };
        expect(result.subject).toEqual(expected);
        // max scroll change
        const newFrame: ?Scrollable = result.frame;
        invariant(newFrame);
        expect(originalFrame.scroll.max).not.toEqual(newFrame.scroll.max);
        expect(newFrame.scroll.max).toEqual(
          add(originalFrame.scroll.max, increasedBy),
        );
        // no client change
        expect(newFrame.frameClient).toEqual(newFrame.frameClient);
      })",steel
/test/unit/state/droppable/scroll-droppable.spec.js,Eager Test,"{'line': 72, 'column': 2, 'index': 1808}","it('should update the frame scroll and the subject', () => {
  const scrollSize: ScrollSize = {
    scrollHeight: 500,
    scrollWidth: 100,
  };
  const customClient: BoxModel = createBox({
    borderBox: {
      // 500 px high
      top: 0,
      left: 0,
      bottom: scrollSize.scrollHeight,
      right: scrollSize.scrollWidth,
    },
  });
  const customPage: BoxModel = customClient;
  const frameClient: BoxModel = createBox({
    borderBox: {
      // only viewing top 100px
      bottom: 100,
      // unchanged
      top: 0,
      right: scrollSize.scrollWidth,
      left: 0,
    },
  });
  const framePage: BoxModel = frameClient;
  const originalFrameScroll: Position = { x: 0, y: 0 };
  const droppable: DroppableDimension = getDroppable({
    descriptor,
    client: customClient,
    page: customPage,
    direction: 'vertical',
    isEnabled: true,
    isCombineEnabled: false,
    isFixedOnPage: false,
    closest: {
      client: frameClient,
      page: framePage,
      scrollSize,
      scroll: originalFrameScroll,
      shouldClipSubject: true,
    },
  });

  const originalFrame: ?Scrollable = droppable.frame;
  invariant(originalFrame);
  // original frame
  expect(originalFrame.pageMarginBox).toEqual(framePage.marginBox);
  // subject is currently clipped by the frame
  expect(droppable.subject.active).toEqual(framePage.marginBox);

  // scrolling down
  const newScroll: Position = { x: 0, y: 100 };
  const updated: DroppableDimension = scrollDroppable(droppable, newScroll);
  const updatedFrame: ?Scrollable = updated.frame;
  invariant(updatedFrame);

  // unchanged frame client
  expect(updatedFrame.frameClient).toEqual(originalFrame.frameClient);
  expect(updatedFrame.pageMarginBox).toEqual(framePage.marginBox);

  // updated scroll info
  {
    const expected: ScrollDetails = {
      initial: originalFrameScroll,
      current: newScroll,
      diff: {
        value: newScroll,
        displacement: negate(newScroll),
      },
      max: getMaxScroll({
        scrollWidth: scrollSize.scrollWidth,
        scrollHeight: scrollSize.scrollHeight,
        width: frameClient.paddingBox.width,
        height: frameClient.paddingBox.height,
      }),
    };
    expect(updatedFrame.scroll).toEqual(expected);
  }

  // updated clipped
  // can now see the bottom half of the subject
  expect(updated.subject.active).toEqual(
    getRect({
      top: 0,
      bottom: 100,
      // unchanged
      right: 100,
      left: 0,
    }),
  );
})",steel
/test/unit/state/droppable/scroll-droppable.spec.js,Eager Test,"{'line': 82, 'column': 2, 'index': 2233}","it('should update the frame scroll and the subject', () => {
  const scrollSize: ScrollSize = {
    scrollHeight: 500,
    scrollWidth: 100,
  };
  const customClient: BoxModel = createBox({
    borderBox: {
      // 500 px high
      top: 0,
      left: 0,
      bottom: scrollSize.scrollHeight,
      right: scrollSize.scrollWidth,
    },
  });
  const customPage: BoxModel = customClient;
  const frameClient: BoxModel = createBox({
    borderBox: {
      // only viewing top 100px
      bottom: 100,
      // unchanged
      top: 0,
      right: scrollSize.scrollWidth,
      left: 0,
    },
  });
  const framePage: BoxModel = frameClient;
  const originalFrameScroll: Position = { x: 0, y: 0 };
  const droppable: DroppableDimension = getDroppable({
    descriptor,
    client: customClient,
    page: customPage,
    direction: 'vertical',
    isEnabled: true,
    isCombineEnabled: false,
    isFixedOnPage: false,
    closest: {
      client: frameClient,
      page: framePage,
      scrollSize,
      scroll: originalFrameScroll,
      shouldClipSubject: true,
    },
  });

  const originalFrame: ?Scrollable = droppable.frame;
  invariant(originalFrame);
  // original frame
  expect(originalFrame.pageMarginBox).toEqual(framePage.marginBox);
  // subject is currently clipped by the frame
  expect(droppable.subject.active).toEqual(framePage.marginBox);

  // scrolling down
  const newScroll: Position = { x: 0, y: 100 };
  const updated: DroppableDimension = scrollDroppable(droppable, newScroll);
  const updatedFrame: ?Scrollable = updated.frame;
  invariant(updatedFrame);

  // unchanged frame client
  expect(updatedFrame.frameClient).toEqual(originalFrame.frameClient);
  expect(updatedFrame.pageMarginBox).toEqual(framePage.marginBox);

  // updated scroll info
  {
    const expected: ScrollDetails = {
      initial: originalFrameScroll,
      current: newScroll,
      diff: {
        value: newScroll,
        displacement: negate(newScroll),
      },
      max: getMaxScroll({
        scrollWidth: scrollSize.scrollWidth,
        scrollHeight: scrollSize.scrollHeight,
        width: frameClient.paddingBox.width,
        height: frameClient.paddingBox.height,
      }),
    };
    expect(updatedFrame.scroll).toEqual(expected);
  }

  // updated clipped
  // can now see the bottom half of the subject
  expect(updated.subject.active).toEqual(
    getRect({
      top: 0,
      bottom: 100,
      // unchanged
      right: 100,
      left: 0,
    }),
  );
})",steel
/test/unit/state/droppable/scroll-droppable.spec.js,Eager Test,"{'line': 158, 'column': 2, 'index': 4066}","it('should allow scrolling beyond the max position', () => {
  const customClient: BoxModel = createBox({
    borderBox: {
      top: 0,
      left: 0,
      right: 200,
      bottom: 200,
    },
  });
  const frameClient: BoxModel = createBox({
    borderBox: {
      top: 0,
      left: 0,
      right: 100,
      bottom: 100,
    },
  });
  // this is to allow for scrolling into a foreign placeholder
  const scrollable: DroppableDimension = getDroppable({
    descriptor,
    client: customClient,
    page: customClient,
    isEnabled: true,
    direction: 'vertical',
    isCombineEnabled: false,
    isFixedOnPage: false,
    closest: {
      client: frameClient,
      page: frameClient,
      scrollSize: {
        scrollWidth: 200,
        scrollHeight: 200,
      },
      scroll: { x: 0, y: 0 },
      shouldClipSubject: true,
    },
  });
  const originalFrame: ?Scrollable = scrollable.frame;
  invariant(originalFrame);

  const scrolled: DroppableDimension = scrollDroppable(scrollable, {
    x: 300,
    y: 300,
  });

  // current is larger than max
  const updatedFrame: ?Scrollable = scrolled.frame;
  invariant(updatedFrame);
  expect(updatedFrame.scroll.current).toEqual({
    x: 300,
    y: 300,
  });
  // current max is unchanged
  expect(updatedFrame.scroll.max).toEqual(originalFrame.scroll.max);
})",steel
/test/unit/state/droppable/scroll-droppable.spec.js,Eager Test,"{'line': 167, 'column': 2, 'index': 4279}","it('should allow scrolling beyond the max position', () => {
  const customClient: BoxModel = createBox({
    borderBox: {
      top: 0,
      left: 0,
      right: 200,
      bottom: 200,
    },
  });
  const frameClient: BoxModel = createBox({
    borderBox: {
      top: 0,
      left: 0,
      right: 100,
      bottom: 100,
    },
  });
  // this is to allow for scrolling into a foreign placeholder
  const scrollable: DroppableDimension = getDroppable({
    descriptor,
    client: customClient,
    page: customClient,
    isEnabled: true,
    direction: 'vertical',
    isCombineEnabled: false,
    isFixedOnPage: false,
    closest: {
      client: frameClient,
      page: frameClient,
      scrollSize: {
        scrollWidth: 200,
        scrollHeight: 200,
      },
      scroll: { x: 0, y: 0 },
      shouldClipSubject: true,
    },
  });
  const originalFrame: ?Scrollable = scrollable.frame;
  invariant(originalFrame);

  const scrolled: DroppableDimension = scrollDroppable(scrollable, {
    x: 300,
    y: 300,
  });

  // current is larger than max
  const updatedFrame: ?Scrollable = scrolled.frame;
  invariant(updatedFrame);
  expect(updatedFrame.scroll.current).toEqual({
    x: 300,
    y: 300,
  });
  // current max is unchanged
  expect(updatedFrame.scroll.max).toEqual(originalFrame.scroll.max);
})",steel
/test/unit/state/droppable/scroll-droppable.spec.js,Lazy Test,"{'line': 72, 'column': 2, 'index': 1808}","it('should update the frame scroll and the subject', () => {
  const scrollSize: ScrollSize = {
    scrollHeight: 500,
    scrollWidth: 100,
  };
  const customClient: BoxModel = createBox({
    borderBox: {
      // 500 px high
      top: 0,
      left: 0,
      bottom: scrollSize.scrollHeight,
      right: scrollSize.scrollWidth,
    },
  });
  const customPage: BoxModel = customClient;
  const frameClient: BoxModel = createBox({
    borderBox: {
      // only viewing top 100px
      bottom: 100,
      // unchanged
      top: 0,
      right: scrollSize.scrollWidth,
      left: 0,
    },
  });
  const framePage: BoxModel = frameClient;
  const originalFrameScroll: Position = { x: 0, y: 0 };
  const droppable: DroppableDimension = getDroppable({
    descriptor,
    client: customClient,
    page: customPage,
    direction: 'vertical',
    isEnabled: true,
    isCombineEnabled: false,
    isFixedOnPage: false,
    closest: {
      client: frameClient,
      page: framePage,
      scrollSize,
      scroll: originalFrameScroll,
      shouldClipSubject: true,
    },
  });

  const originalFrame: ?Scrollable = droppable.frame;
  invariant(originalFrame);
  // original frame
  expect(originalFrame.pageMarginBox).toEqual(framePage.marginBox);
  // subject is currently clipped by the frame
  expect(droppable.subject.active).toEqual(framePage.marginBox);

  // scrolling down
  const newScroll: Position = { x: 0, y: 100 };
  const updated: DroppableDimension = scrollDroppable(droppable, newScroll);
  const updatedFrame: ?Scrollable = updated.frame;
  invariant(updatedFrame);

  // unchanged frame client
  expect(updatedFrame.frameClient).toEqual(originalFrame.frameClient);
  expect(updatedFrame.pageMarginBox).toEqual(framePage.marginBox);

  // updated scroll info
  {
    const expected: ScrollDetails = {
      initial: originalFrameScroll,
      current: newScroll,
      diff: {
        value: newScroll,
        displacement: negate(newScroll),
      },
      max: getMaxScroll({
        scrollWidth: scrollSize.scrollWidth,
        scrollHeight: scrollSize.scrollHeight,
        width: frameClient.paddingBox.width,
        height: frameClient.paddingBox.height,
      }),
    };
    expect(updatedFrame.scroll).toEqual(expected);
  }

  // updated clipped
  // can now see the bottom half of the subject
  expect(updated.subject.active).toEqual(
    getRect({
      top: 0,
      bottom: 100,
      // unchanged
      right: 100,
      left: 0,
    }),
  );
})",steel
/test/unit/state/droppable/scroll-droppable.spec.js,Lazy Test,"{'line': 158, 'column': 2, 'index': 4066}","it('should allow scrolling beyond the max position', () => {
  const customClient: BoxModel = createBox({
    borderBox: {
      top: 0,
      left: 0,
      right: 200,
      bottom: 200,
    },
  });
  const frameClient: BoxModel = createBox({
    borderBox: {
      top: 0,
      left: 0,
      right: 100,
      bottom: 100,
    },
  });
  // this is to allow for scrolling into a foreign placeholder
  const scrollable: DroppableDimension = getDroppable({
    descriptor,
    client: customClient,
    page: customClient,
    isEnabled: true,
    direction: 'vertical',
    isCombineEnabled: false,
    isFixedOnPage: false,
    closest: {
      client: frameClient,
      page: frameClient,
      scrollSize: {
        scrollWidth: 200,
        scrollHeight: 200,
      },
      scroll: { x: 0, y: 0 },
      shouldClipSubject: true,
    },
  });
  const originalFrame: ?Scrollable = scrollable.frame;
  invariant(originalFrame);

  const scrolled: DroppableDimension = scrollDroppable(scrollable, {
    x: 300,
    y: 300,
  });

  // current is larger than max
  const updatedFrame: ?Scrollable = scrolled.frame;
  invariant(updatedFrame);
  expect(updatedFrame.scroll.current).toEqual({
    x: 300,
    y: 300,
  });
  // current max is unchanged
  expect(updatedFrame.scroll.max).toEqual(originalFrame.scroll.max);
})",steel
/test/unit/state/droppable/get-subject.spec.js,Conditional Test Logic,"{'line': 78, 'column': 25, 'index': 1933}","it('should increase the subject by a placeholder', () => {
  [vertical, horizontal].forEach((axis: Axis) => {
    const increasedBy: Position = patch(axis.line, 100);

    const result: DroppableSubject = getSubject({
      page,
      withPlaceholder: {
        increasedBy,
        placeholderSize: increasedBy,
        oldFrameMaxScroll: null,
      },
      axis,
      frame: null,
    });

    const expected: Rect = getRect({
      ...page.marginBox,
      [axis.end]: page.marginBox[axis.end] + increasedBy[axis.line],
    });
    expect(result.active).toEqual(expected);
  });
})",steel
/test/unit/state/droppable/get-droppable.spec.js,Lazy Test,"{'line': 110, 'column': 6, 'index': 2374}","it('should offset the frame client by the window scroll', () => {
      invariant(dimension.frame);
      expect(dimension.frame.pageMarginBox).toEqual(page.marginBox);
    })",steel
/test/unit/state/droppable/get-droppable.spec.js,Lazy Test,"{'line': 207, 'column': 6, 'index': 5265}","it('should not clip the frame if requested not to', () => {
      const expandedClient: BoxModel = createBox({
        borderBox: expandBySpacing(frameClient.borderBox, ten),
        margin,
        padding,
        border,
      });
      const expandedPage: BoxModel = withScroll(expandedClient, windowScroll);
      const bigClient: BoxModel = createBox({
        borderBox: expandedClient.borderBox,
        margin,
        padding,
        border,
      });

      const droppable: DroppableDimension = getWithClient(bigClient, {
        shouldClipSubject: false,
      });

      // Not clipped
      expect(droppable.subject.active).toEqual(expandedPage.marginBox);
      invariant(droppable.frame);
      expect(droppable.frame.shouldClipSubject).toBe(false);
    })",steel
/test/unit/state/auto-scroll/jump-scroller.spec.js,Conditional Test Logic,"{'line': 72, 'column': 23, 'index': 1783}",Unknown,steel
/test/unit/state/auto-scroll/choosing-the-right-scroller.spec.js,Duplicate Assert,"{'line': 66, 'column': 2, 'index': 1741}","it('should use the fluid scroller when in fluid mode', () => {
  const mocks: Args = getMocks();
  const scroller: AutoScroller = getScroller(mocks);

  // lift in center - should not cause an auto scroll
  scroller.start(onCenter('FLUID'));
  requestAnimationFrame.flush();
  expect(mocks.scrollWindow).not.toHaveBeenCalled();

  // now scrolling on visibile edge. Should cause a big auto scroll
  // this will be done with the fluid scroller
  scroller.scroll(onEnd('FLUID'));
  requestAnimationFrame.step();
  expect(mocks.scrollWindow).toHaveBeenCalled();
})",steel
/test/unit/state/auto-scroll/choosing-the-right-scroller.spec.js,Duplicate Assert,"{'line': 72, 'column': 2, 'index': 1977}","it('should use the fluid scroller when in fluid mode', () => {
  const mocks: Args = getMocks();
  const scroller: AutoScroller = getScroller(mocks);

  // lift in center - should not cause an auto scroll
  scroller.start(onCenter('FLUID'));
  requestAnimationFrame.flush();
  expect(mocks.scrollWindow).not.toHaveBeenCalled();

  // now scrolling on visibile edge. Should cause a big auto scroll
  // this will be done with the fluid scroller
  scroller.scroll(onEnd('FLUID'));
  requestAnimationFrame.step();
  expect(mocks.scrollWindow).toHaveBeenCalled();
})",steel
/test/unit/state/auto-scroll/choosing-the-right-scroller.spec.js,Duplicate Assert,"{'line': 82, 'column': 2, 'index': 2338}","it('should use the jump scroller when in SNAP mode and there is a jumpScrollerRequest', () => {
  const mocks: Args = getMocks();
  const scroller: AutoScroller = getScroller(mocks);

  // lift in center - should not cause an auto scroll
  scroller.start(onCenter('SNAP'));
  requestAnimationFrame.flush();
  expect(mocks.scrollWindow).not.toHaveBeenCalled();

  // now scrolling on visibile edge. Should not cause an auto scroll because we are in SNAP mode
  scroller.scroll(onEnd('SNAP'));
  requestAnimationFrame.step();
  expect(mocks.scrollWindow).not.toHaveBeenCalled();

  const request: Position = { x: 1, y: 1 };
  const withRequest: DraggingState = state.scrollJumpRequest(
    request,
    scrollableViewport,
  );
  scroller.scroll(withRequest);
  requestAnimationFrame.step();
  expect(mocks.scrollWindow).toHaveBeenCalled();
})",steel
/test/unit/state/auto-scroll/choosing-the-right-scroller.spec.js,Duplicate Assert,"{'line': 82, 'column': 2, 'index': 2338}","it('should use the jump scroller when in SNAP mode and there is a jumpScrollerRequest', () => {
  const mocks: Args = getMocks();
  const scroller: AutoScroller = getScroller(mocks);

  // lift in center - should not cause an auto scroll
  scroller.start(onCenter('SNAP'));
  requestAnimationFrame.flush();
  expect(mocks.scrollWindow).not.toHaveBeenCalled();

  // now scrolling on visibile edge. Should not cause an auto scroll because we are in SNAP mode
  scroller.scroll(onEnd('SNAP'));
  requestAnimationFrame.step();
  expect(mocks.scrollWindow).not.toHaveBeenCalled();

  const request: Position = { x: 1, y: 1 };
  const withRequest: DraggingState = state.scrollJumpRequest(
    request,
    scrollableViewport,
  );
  scroller.scroll(withRequest);
  requestAnimationFrame.step();
  expect(mocks.scrollWindow).toHaveBeenCalled();
})",steel
/test/unit/state/auto-scroll/choosing-the-right-scroller.spec.js,Duplicate Assert,"{'line': 87, 'column': 2, 'index': 2555}","it('should use the jump scroller when in SNAP mode and there is a jumpScrollerRequest', () => {
  const mocks: Args = getMocks();
  const scroller: AutoScroller = getScroller(mocks);

  // lift in center - should not cause an auto scroll
  scroller.start(onCenter('SNAP'));
  requestAnimationFrame.flush();
  expect(mocks.scrollWindow).not.toHaveBeenCalled();

  // now scrolling on visibile edge. Should not cause an auto scroll because we are in SNAP mode
  scroller.scroll(onEnd('SNAP'));
  requestAnimationFrame.step();
  expect(mocks.scrollWindow).not.toHaveBeenCalled();

  const request: Position = { x: 1, y: 1 };
  const withRequest: DraggingState = state.scrollJumpRequest(
    request,
    scrollableViewport,
  );
  scroller.scroll(withRequest);
  requestAnimationFrame.step();
  expect(mocks.scrollWindow).toHaveBeenCalled();
})",steel
/test/unit/state/auto-scroll/choosing-the-right-scroller.spec.js,Duplicate Assert,"{'line': 87, 'column': 2, 'index': 2555}","it('should use the jump scroller when in SNAP mode and there is a jumpScrollerRequest', () => {
  const mocks: Args = getMocks();
  const scroller: AutoScroller = getScroller(mocks);

  // lift in center - should not cause an auto scroll
  scroller.start(onCenter('SNAP'));
  requestAnimationFrame.flush();
  expect(mocks.scrollWindow).not.toHaveBeenCalled();

  // now scrolling on visibile edge. Should not cause an auto scroll because we are in SNAP mode
  scroller.scroll(onEnd('SNAP'));
  requestAnimationFrame.step();
  expect(mocks.scrollWindow).not.toHaveBeenCalled();

  const request: Position = { x: 1, y: 1 };
  const withRequest: DraggingState = state.scrollJumpRequest(
    request,
    scrollableViewport,
  );
  scroller.scroll(withRequest);
  requestAnimationFrame.step();
  expect(mocks.scrollWindow).toHaveBeenCalled();
})",steel
/test/unit/state/auto-scroll/choosing-the-right-scroller.spec.js,Duplicate Assert,"{'line': 96, 'column': 2, 'index': 2821}","it('should use the jump scroller when in SNAP mode and there is a jumpScrollerRequest', () => {
  const mocks: Args = getMocks();
  const scroller: AutoScroller = getScroller(mocks);

  // lift in center - should not cause an auto scroll
  scroller.start(onCenter('SNAP'));
  requestAnimationFrame.flush();
  expect(mocks.scrollWindow).not.toHaveBeenCalled();

  // now scrolling on visibile edge. Should not cause an auto scroll because we are in SNAP mode
  scroller.scroll(onEnd('SNAP'));
  requestAnimationFrame.step();
  expect(mocks.scrollWindow).not.toHaveBeenCalled();

  const request: Position = { x: 1, y: 1 };
  const withRequest: DraggingState = state.scrollJumpRequest(
    request,
    scrollableViewport,
  );
  scroller.scroll(withRequest);
  requestAnimationFrame.step();
  expect(mocks.scrollWindow).toHaveBeenCalled();
})",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 85, 'column': 6, 'index': 2669}","it('should scroll if on the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: scrollableViewport,
          state,
        }),
      );

      expect(mocks.scrollWindow).not.toHaveBeenCalled();
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalled();
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 87, 'column': 6, 'index': 2762}","it('should scroll if on the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: scrollableViewport,
          state,
        }),
      );

      expect(mocks.scrollWindow).not.toHaveBeenCalled();
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalled();
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 103, 'column': 6, 'index': 3208}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = add(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: scrollableViewport,
          state,
        }),
      );

      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalled();
      // moving forwards
      const request: Position = mocks.scrollWindow.mock.calls[0][0];
      expect(request[axis.line]).toBeGreaterThan(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 107, 'column': 6, 'index': 3337}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = add(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: scrollableViewport,
          state,
        }),
      );

      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalled();
      // moving forwards
      const request: Position = mocks.scrollWindow.mock.calls[0][0];
      expect(request[axis.line]).toBeGreaterThan(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 125, 'column': 6, 'index': 4001}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = subtract(
        onMaxBoundary,
        patch(axis.line, 1),
      );

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrollableViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrollableViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeLessThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 135, 'column': 6, 'index': 4250}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = subtract(
        onMaxBoundary,
        patch(axis.line, 1),
      );

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrollableViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrollableViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeLessThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 146, 'column': 6, 'index': 4575}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = subtract(
        onMaxBoundary,
        patch(axis.line, 1),
      );

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrollableViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrollableViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeLessThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 216, 'column': 6, 'index': 6703}","it('should throttle multiple scrolls into a single animation frame', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target1: Position = add(onStartBoundary, patch(axis.line, 1));
      const target2: Position = subtract(onMaxBoundary, patch(axis.line, 1));

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: target1,
          viewport: scrollableViewport,
          state,
        }),
      );
      scroller.scroll(
        dragTo({
          selection: target2,
          viewport: scrollableViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        patch(axis.line, config.maxPixelScroll),
      );
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 217, 'column': 6, 'index': 6762}","it('should throttle multiple scrolls into a single animation frame', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target1: Position = add(onStartBoundary, patch(axis.line, 1));
      const target2: Position = subtract(onMaxBoundary, patch(axis.line, 1));

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: target1,
          viewport: scrollableViewport,
          state,
        }),
      );
      scroller.scroll(
        dragTo({
          selection: target2,
          viewport: scrollableViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        patch(axis.line, config.maxPixelScroll),
      );
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 283, 'column': 6, 'index': 8663}","it('should scroll if on the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: scrolledViewport,
          state,
        }),
      );

      expect(mocks.scrollWindow).not.toHaveBeenCalled();
      requestAnimationFrame.flush();
      expect(mocks.scrollWindow).toHaveBeenCalled();
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 285, 'column': 6, 'index': 8757}","it('should scroll if on the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: scrolledViewport,
          state,
        }),
      );

      expect(mocks.scrollWindow).not.toHaveBeenCalled();
      requestAnimationFrame.flush();
      expect(mocks.scrollWindow).toHaveBeenCalled();
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 301, 'column': 6, 'index': 9206}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = subtract(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: scrolledViewport,
          state,
        }),
      );

      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalled();
      // moving forwards
      const request: Position = mocks.scrollWindow.mock.calls[0][0];
      expect(request[axis.line]).toBeLessThan(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 305, 'column': 6, 'index': 9335}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = subtract(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: scrolledViewport,
          state,
        }),
      );

      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalled();
      // moving forwards
      const request: Position = mocks.scrollWindow.mock.calls[0][0];
      expect(request[axis.line]).toBeLessThan(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 320, 'column': 6, 'index': 9966}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 330, 'column': 6, 'index': 10213}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 341, 'column': 6, 'index': 10536}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 411, 'column': 6, 'index': 12680}","it('should throttle multiple scrolls into a single animation frame', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target1: Position = subtract(onStartBoundary, patch(axis.line, 1));
      const target2: Position = add(onMaxBoundary, patch(axis.line, 1));

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: target1,
          viewport: scrolledViewport,
          state,
        }),
      );
      scroller.scroll(
        dragTo({
          selection: target2,
          viewport: scrolledViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        negate(patch(axis.line, config.maxPixelScroll)),
      );
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Duplicate Assert,"{'line': 412, 'column': 6, 'index': 12739}","it('should throttle multiple scrolls into a single animation frame', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target1: Position = subtract(onStartBoundary, patch(axis.line, 1));
      const target2: Position = add(onMaxBoundary, patch(axis.line, 1));

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: target1,
          viewport: scrolledViewport,
          state,
        }),
      );
      scroller.scroll(
        dragTo({
          selection: target2,
          viewport: scrolledViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        negate(patch(axis.line, config.maxPixelScroll)),
      );
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Magic Number,"{'line': 110, 'column': 49, 'index': 3527}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = add(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: scrollableViewport,
          state,
        }),
      );

      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalled();
      // moving forwards
      const request: Position = mocks.scrollWindow.mock.calls[0][0];
      expect(request[axis.line]).toBeGreaterThan(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Magic Number,"{'line': 152, 'column': 47, 'index': 4840}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = subtract(
        onMaxBoundary,
        patch(axis.line, 1),
      );

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrollableViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrollableViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeLessThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Magic Number,"{'line': 153, 'column': 47, 'index': 4891}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = subtract(
        onMaxBoundary,
        patch(axis.line, 1),
      );

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrollableViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrollableViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeLessThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Magic Number,"{'line': 308, 'column': 46, 'index': 9522}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = subtract(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: scrolledViewport,
          state,
        }),
      );

      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalled();
      // moving forwards
      const request: Position = mocks.scrollWindow.mock.calls[0][0];
      expect(request[axis.line]).toBeLessThan(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Magic Number,"{'line': 347, 'column': 47, 'index': 10804}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/window-scrolling.spec.js,Magic Number,"{'line': 348, 'column': 47, 'index': 10855}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollWindow).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollWindow.mock.calls[0][0]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: scrolledViewport,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollWindow.mock.calls[1][0]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 66, 'column': 4, 'index': 2289}","it('should not dampen scrolling if not starting in scrollable area', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // no scroll on initial lift
    scroller.start(
      dragTo({
        selection: scrollableViewport.frame.center,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.flush();
    expect(mocks.scrollWindow).not.toHaveBeenCalled();

    // would be a max scroll
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, config.maxPixelScroll),
    );
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 78, 'column': 4, 'index': 2549}","it('should not dampen scrolling if not starting in scrollable area', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // no scroll on initial lift
    scroller.start(
      dragTo({
        selection: scrollableViewport.frame.center,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.flush();
    expect(mocks.scrollWindow).not.toHaveBeenCalled();

    // would be a max scroll
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, config.maxPixelScroll),
    );
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 99, 'column': 6, 'index': 3119}","it('should dampen if lifted in a scrollable area', () => {
    // on start of boundary: would have been a min scroll anyway
    {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      // lifting in scrollable area
      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: scrollableViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        patch(axis.line, minScroll),
      );
    }
    // would normally be max scroll speed
    {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      // lifting in scrollable area
      scroller.start(
        dragTo({
          selection: onMaxBoundary,
          viewport: scrollableViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        patch(axis.line, minScroll),
      );
    }
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 99, 'column': 6, 'index': 3119}","it('should dampen if lifted in a scrollable area', () => {
    // on start of boundary: would have been a min scroll anyway
    {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      // lifting in scrollable area
      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: scrollableViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        patch(axis.line, minScroll),
      );
    }
    // would normally be max scroll speed
    {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      // lifting in scrollable area
      scroller.start(
        dragTo({
          selection: onMaxBoundary,
          viewport: scrollableViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        patch(axis.line, minScroll),
      );
    }
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 118, 'column': 6, 'index': 3594}","it('should dampen if lifted in a scrollable area', () => {
    // on start of boundary: would have been a min scroll anyway
    {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      // lifting in scrollable area
      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: scrollableViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        patch(axis.line, minScroll),
      );
    }
    // would normally be max scroll speed
    {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      // lifting in scrollable area
      scroller.start(
        dragTo({
          selection: onMaxBoundary,
          viewport: scrollableViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        patch(axis.line, minScroll),
      );
    }
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 118, 'column': 6, 'index': 3594}","it('should dampen if lifted in a scrollable area', () => {
    // on start of boundary: would have been a min scroll anyway
    {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      // lifting in scrollable area
      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: scrollableViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        patch(axis.line, minScroll),
      );
    }
    // would normally be max scroll speed
    {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      // lifting in scrollable area
      scroller.start(
        dragTo({
          selection: onMaxBoundary,
          viewport: scrollableViewport,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollWindow).toHaveBeenCalledWith(
        patch(axis.line, minScroll),
      );
    }
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 137, 'column': 4, 'index': 4151}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 137, 'column': 4, 'index': 4151}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 154, 'column': 4, 'index': 4602}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 154, 'column': 4, 'index': 4602}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 170, 'column': 4, 'index': 5070}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 170, 'column': 4, 'index': 5070}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 187, 'column': 4, 'index': 5604}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 188, 'column': 4, 'index': 5678}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 206, 'column': 4, 'index': 6229}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 209, 'column': 4, 'index': 6341}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 210, 'column': 4, 'index': 6416}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 227, 'column': 4, 'index': 6934}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 230, 'column': 4, 'index': 7044}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/time-dampening.spec.js,Duplicate Assert,"{'line': 231, 'column': 4, 'index': 7117}","it('should have the minimum scroll up to a small time threshold and then accelerate to the max speed as time continues', () => {
    const mocks = getArgsMock();
    const scroller: FluidScroller = getScroller(mocks);

    // starting on the max boundary which normally
    scroller.start(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // moving up to just before the acceleration point
    mockNow.mockReturnValueOnce(startAcceleratingAt - 1);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );

    // still on the min scroll
    requestAnimationFrame.step();
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // now on the acceleration start point
    mockNow.mockReturnValueOnce(startAcceleratingAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    // still on the min scroll as the % change will be quite low
    expect(mocks.scrollWindow).toHaveBeenCalledWith(
      patch(axis.line, minScroll),
    );
    mocks.scrollWindow.mockClear();

    // Moving 30% of the way into the time dampening period
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.3);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const firstAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    expect(firstAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(firstAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Now passing event more time (60%)
    mockNow.mockReturnValueOnce(startAcceleratingAt + accelerationRange * 0.6);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const secondAcceleratedScroll: Position =
      mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(secondAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(secondAcceleratedScroll[axis.line]).toBeLessThan(
      config.maxPixelScroll,
    );
    mocks.scrollWindow.mockClear();

    // Moving to the end of the time dampening period
    mockNow.mockReturnValueOnce(stopAt);
    scroller.scroll(
      dragTo({
        selection: onMaxBoundary,
        viewport: scrollableViewport,
        state,
      }),
    );
    requestAnimationFrame.step();
    const lastAcceleratedScroll: Position = mocks.scrollWindow.mock.calls[0][0];
    // is greater in acceleration
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(
      firstAcceleratedScroll[axis.line],
    );
    expect(lastAcceleratedScroll[axis.line]).toBeGreaterThan(minScroll);
    expect(lastAcceleratedScroll[axis.line]).toEqual(config.maxPixelScroll);
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/lifecycle.spec.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 511}","it('should throw if a scroll occurs before a drag as started', () => {
    const scroller: FluidScroller = getScroller(getMocks());
    expect(() => scroller.scroll(base)).toThrow();

    // after a drag
    scroller.start(base);
    scroller.stop();

    expect(() => scroller.scroll(base)).toThrow();
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/lifecycle.spec.js,Duplicate Assert,"{'line': 13, 'column': 4, 'index': 511}","it('should throw if a scroll occurs before a drag as started', () => {
    const scroller: FluidScroller = getScroller(getMocks());
    expect(() => scroller.scroll(base)).toThrow();

    // after a drag
    scroller.start(base);
    scroller.stop();

    expect(() => scroller.scroll(base)).toThrow();
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/lifecycle.spec.js,Duplicate Assert,"{'line': 19, 'column': 4, 'index': 631}","it('should throw if a scroll occurs before a drag as started', () => {
    const scroller: FluidScroller = getScroller(getMocks());
    expect(() => scroller.scroll(base)).toThrow();

    // after a drag
    scroller.start(base);
    scroller.stop();

    expect(() => scroller.scroll(base)).toThrow();
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/lifecycle.spec.js,Duplicate Assert,"{'line': 19, 'column': 4, 'index': 631}","it('should throw if a scroll occurs before a drag as started', () => {
    const scroller: FluidScroller = getScroller(getMocks());
    expect(() => scroller.scroll(base)).toThrow();

    // after a drag
    scroller.start(base);
    scroller.stop();

    expect(() => scroller.scroll(base)).toThrow();
  })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 91, 'column': 6, 'index': 2920}","it('should scroll if on the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalled();
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 93, 'column': 6, 'index': 3016}","it('should scroll if on the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalled();
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 110, 'column': 6, 'index': 3500}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = add(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalled();
      // moving forwards
      const id: DroppableId = mocks.scrollDroppable.mock.calls[0][0];
      const request: Position = mocks.scrollDroppable.mock.calls[0][1];
      expect(id).toEqual(scrollable.descriptor.id);
      expect(request[axis.line]).toBeGreaterThan(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 114, 'column': 6, 'index': 3632}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = add(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalled();
      // moving forwards
      const id: DroppableId = mocks.scrollDroppable.mock.calls[0][0];
      const request: Position = mocks.scrollDroppable.mock.calls[0][1];
      expect(id).toEqual(scrollable.descriptor.id);
      expect(request[axis.line]).toBeGreaterThan(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 134, 'column': 6, 'index': 4424}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = subtract(
        onMaxBoundary,
        patch(axis.line, 1),
      );

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeLessThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 145, 'column': 6, 'index': 4711}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = subtract(
        onMaxBoundary,
        patch(axis.line, 1),
      );

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeLessThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 157, 'column': 6, 'index': 5077}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = subtract(
        onMaxBoundary,
        patch(axis.line, 1),
      );

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeLessThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 233, 'column': 6, 'index': 7425}","it('should throttle multiple scrolls into a single animation frame', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target1: Position = add(onStartBoundary, patch(axis.line, 1));
      const target2: Position = subtract(onMaxBoundary, patch(axis.line, 1));

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: target1,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      scroller.scroll(
        dragTo({
          selection: target2,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      expect(mocks.scrollDroppable).toHaveBeenCalledWith(
        scrollable.descriptor.id,
        patch(axis.line, config.maxPixelScroll),
      );
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 234, 'column': 6, 'index': 7487}","it('should throttle multiple scrolls into a single animation frame', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target1: Position = add(onStartBoundary, patch(axis.line, 1));
      const target2: Position = subtract(onMaxBoundary, patch(axis.line, 1));

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: target1,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      scroller.scroll(
        dragTo({
          selection: target2,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      expect(mocks.scrollDroppable).toHaveBeenCalledWith(
        scrollable.descriptor.id,
        patch(axis.line, config.maxPixelScroll),
      );
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 304, 'column': 6, 'index': 9553}","it('should scroll if on the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();
      requestAnimationFrame.flush();
      expect(mocks.scrollDroppable).toHaveBeenCalled();
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 306, 'column': 6, 'index': 9650}","it('should scroll if on the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);

      scroller.start(
        dragTo({
          selection: onStartBoundary,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();
      requestAnimationFrame.flush();
      expect(mocks.scrollDroppable).toHaveBeenCalled();
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 323, 'column': 6, 'index': 10137}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = subtract(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalled();
      // moving forwards
      const request: Position = mocks.scrollDroppable.mock.calls[0][1];
      expect(request[axis.line]).toBeLessThan(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 327, 'column': 6, 'index': 10269}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = subtract(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalled();
      // moving forwards
      const request: Position = mocks.scrollDroppable.mock.calls[0][1];
      expect(request[axis.line]).toBeLessThan(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 342, 'column': 6, 'index': 10906}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 353, 'column': 6, 'index': 11191}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 365, 'column': 6, 'index': 11555}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 441, 'column': 6, 'index': 13915}","it('should throttle multiple scrolls into a single animation frame', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target1: Position = subtract(onStartBoundary, patch(axis.line, 1));
      const target2: Position = add(onMaxBoundary, patch(axis.line, 1));

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: target1,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      scroller.scroll(
        dragTo({
          selection: target2,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      expect(mocks.scrollDroppable).toHaveBeenCalledWith(
        scrolled.descriptor.id,
        negate(patch(axis.line, config.maxPixelScroll)),
      );
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Duplicate Assert,"{'line': 442, 'column': 6, 'index': 13977}","it('should throttle multiple scrolls into a single animation frame', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target1: Position = subtract(onStartBoundary, patch(axis.line, 1));
      const target2: Position = add(onMaxBoundary, patch(axis.line, 1));

      startWithNoScroll(scroller);
      scroller.scroll(
        dragTo({
          selection: target1,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      scroller.scroll(
        dragTo({
          selection: target2,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );

      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      expect(mocks.scrollDroppable).toHaveBeenCalledWith(
        scrolled.descriptor.id,
        negate(patch(axis.line, config.maxPixelScroll)),
      );
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Magic Number,"{'line': 119, 'column': 49, 'index': 3950}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = add(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalled();
      // moving forwards
      const id: DroppableId = mocks.scrollDroppable.mock.calls[0][0];
      const request: Position = mocks.scrollDroppable.mock.calls[0][1];
      expect(id).toEqual(scrollable.descriptor.id);
      expect(request[axis.line]).toBeGreaterThan(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Magic Number,"{'line': 163, 'column': 47, 'index': 5348}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = subtract(
        onMaxBoundary,
        patch(axis.line, 1),
      );

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeLessThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Magic Number,"{'line': 164, 'column': 47, 'index': 5399}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = subtract(
        onMaxBoundary,
        patch(axis.line, 1),
      );

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrollable,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeLessThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Magic Number,"{'line': 330, 'column': 46, 'index': 10462}","it('should scroll if moving beyond the start threshold', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const target: Position = subtract(onStartBoundary, patch(axis.line, 1));

      scroller.start(
        dragTo({
          selection: target,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );

      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      // only called after a frame
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalled();
      // moving forwards
      const request: Position = mocks.scrollDroppable.mock.calls[0][1];
      expect(request[axis.line]).toBeLessThan(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Magic Number,"{'line': 371, 'column': 47, 'index': 11829}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/droppable-scrolling.spec.js,Magic Number,"{'line': 372, 'column': 47, 'index': 11880}","it('should get faster the closer to the max speed point', () => {
      const mocks = getArgsMock();
      const scroller: FluidScroller = getScroller(mocks);
      const atStartOfRange: Position = onStartBoundary;
      const atEndOfRange: Position = add(onMaxBoundary, patch(axis.line, 1));

      // start the drag with no auto scrolling
      // this will opt out of time dampening
      startWithNoScroll(scroller);
      expect(mocks.scrollDroppable).not.toHaveBeenCalled();

      scroller.scroll(
        dragTo({
          selection: atStartOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(1);
      const scroll1: Position = (mocks.scrollDroppable.mock.calls[0][1]: any);

      scroller.scroll(
        dragTo({
          selection: atEndOfRange,
          viewport: unscrollableViewport,
          droppable: scrolled,
          state,
        }),
      );
      requestAnimationFrame.step();
      expect(mocks.scrollDroppable).toHaveBeenCalledTimes(2);
      const scroll2: Position = (mocks.scrollDroppable.mock.calls[1][1]: any);

      expect(scroll1[axis.line]).toBeGreaterThan(scroll2[axis.line]);

      // validation
      expect(scroll1[axis.crossAxisLine]).toBe(0);
      expect(scroll2[axis.crossAxisLine]).toBe(0);
    })",steel
/test/unit/state/auto-scroll/fluid-scroller/util/for-each.js,Conditional Test Logic,"{'line': 16, 'column': 25, 'index': 469}",Unknown,steel
/test/unit/integration/responders-timing.spec.js,Duplicate Assert,"{'line': 99, 'column': 2, 'index': 3167}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  let onBeforeDragStartTime: ?DOMHighResTimeStamp = null;
  let onDragStartTime: ?DOMHighResTimeStamp = null;
  let renderTime: ?DOMHighResTimeStamp = null;
  const responders: Responders = {
    onBeforeDragStart: jest.fn().mockImplementation(() => {
      invariant(!onBeforeDragStartTime, 'onBeforeDragStartTime already set');
      onBeforeDragStartTime = performance.now();
    }),
    onDragStart: jest.fn().mockImplementation(() => {
      invariant(!onDragStartTime, 'onDragStartTime already set');
      onDragStartTime = performance.now();
    }),
    onDragEnd: jest.fn(),
  };
  const onItemRender = jest.fn().mockImplementation(() => {
    invariant(!renderTime, 'renderTime already set');
    renderTime = performance.now();
  });
  // Both list and item will have the same dimensions
  jest
    .spyOn(Element.prototype, 'getBoundingClientRect')
    .mockImplementation(() =>
      getRect({
        top: 0,
        left: 0,
        right: 100,
        bottom: 100,
      }),
    );

  // Stubbing out totally - not including margins in this
  jest
    .spyOn(window, 'getComputedStyle')
    .mockImplementation(() => getComputedSpacing({}));
  const { getByTestId, unmount } = render(
    <DragDropContext {...responders}>
      <Droppable droppableId=""droppable"">
        {(droppableProvided: DroppableProvided) => (
          <div
            ref={droppableProvided.innerRef}
            {...droppableProvided.droppableProps}
          >
            <h2>Droppable</h2>
            <Draggable draggableId=""draggable"" index={0}>
              {(draggableProvided: DraggableProvided) => (
                <Item onRender={onItemRender} provided={draggableProvided} />
              )}
            </Draggable>
            {droppableProvided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>,
  );

  // clearing the initial render before a drag
  expect(onItemRender).toHaveBeenCalledTimes(1);
  renderTime = null;
  onItemRender.mockClear();

  // start a drag
  const handle: HTMLElement = getByTestId('drag-handle');
  simpleLift(keyboard, handle);
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking values are set
  invariant(onBeforeDragStartTime, 'onBeforeDragStartTime should be set');
  invariant(onDragStartTime, 'onDragStartTime should be set');
  invariant(renderTime, 'renderTime should be set');

  // expected order
  // 1. onBeforeDragStart
  // 2. item render
  // 3. onDragStart
  expect(onBeforeDragStartTime).toBeLessThan(renderTime);
  expect(renderTime).toBeLessThan(onDragStartTime);

  // validation
  expect(responders.onBeforeDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(onItemRender).toHaveBeenCalledTimes(1);
  unmount();
})",steel
/test/unit/integration/responders-timing.spec.js,Duplicate Assert,"{'line': 124, 'column': 2, 'index': 3990}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  let onBeforeDragStartTime: ?DOMHighResTimeStamp = null;
  let onDragStartTime: ?DOMHighResTimeStamp = null;
  let renderTime: ?DOMHighResTimeStamp = null;
  const responders: Responders = {
    onBeforeDragStart: jest.fn().mockImplementation(() => {
      invariant(!onBeforeDragStartTime, 'onBeforeDragStartTime already set');
      onBeforeDragStartTime = performance.now();
    }),
    onDragStart: jest.fn().mockImplementation(() => {
      invariant(!onDragStartTime, 'onDragStartTime already set');
      onDragStartTime = performance.now();
    }),
    onDragEnd: jest.fn(),
  };
  const onItemRender = jest.fn().mockImplementation(() => {
    invariant(!renderTime, 'renderTime already set');
    renderTime = performance.now();
  });
  // Both list and item will have the same dimensions
  jest
    .spyOn(Element.prototype, 'getBoundingClientRect')
    .mockImplementation(() =>
      getRect({
        top: 0,
        left: 0,
        right: 100,
        bottom: 100,
      }),
    );

  // Stubbing out totally - not including margins in this
  jest
    .spyOn(window, 'getComputedStyle')
    .mockImplementation(() => getComputedSpacing({}));
  const { getByTestId, unmount } = render(
    <DragDropContext {...responders}>
      <Droppable droppableId=""droppable"">
        {(droppableProvided: DroppableProvided) => (
          <div
            ref={droppableProvided.innerRef}
            {...droppableProvided.droppableProps}
          >
            <h2>Droppable</h2>
            <Draggable draggableId=""draggable"" index={0}>
              {(draggableProvided: DraggableProvided) => (
                <Item onRender={onItemRender} provided={draggableProvided} />
              )}
            </Draggable>
            {droppableProvided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>,
  );

  // clearing the initial render before a drag
  expect(onItemRender).toHaveBeenCalledTimes(1);
  renderTime = null;
  onItemRender.mockClear();

  // start a drag
  const handle: HTMLElement = getByTestId('drag-handle');
  simpleLift(keyboard, handle);
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking values are set
  invariant(onBeforeDragStartTime, 'onBeforeDragStartTime should be set');
  invariant(onDragStartTime, 'onDragStartTime should be set');
  invariant(renderTime, 'renderTime should be set');

  // expected order
  // 1. onBeforeDragStart
  // 2. item render
  // 3. onDragStart
  expect(onBeforeDragStartTime).toBeLessThan(renderTime);
  expect(renderTime).toBeLessThan(onDragStartTime);

  // validation
  expect(responders.onBeforeDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(onItemRender).toHaveBeenCalledTimes(1);
  unmount();
})",steel
/test/unit/integration/responders-timing.spec.js,Eager Test,"{'line': 48, 'column': 6, 'index': 1531}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  let onBeforeDragStartTime: ?DOMHighResTimeStamp = null;
  let onDragStartTime: ?DOMHighResTimeStamp = null;
  let renderTime: ?DOMHighResTimeStamp = null;
  const responders: Responders = {
    onBeforeDragStart: jest.fn().mockImplementation(() => {
      invariant(!onBeforeDragStartTime, 'onBeforeDragStartTime already set');
      onBeforeDragStartTime = performance.now();
    }),
    onDragStart: jest.fn().mockImplementation(() => {
      invariant(!onDragStartTime, 'onDragStartTime already set');
      onDragStartTime = performance.now();
    }),
    onDragEnd: jest.fn(),
  };
  const onItemRender = jest.fn().mockImplementation(() => {
    invariant(!renderTime, 'renderTime already set');
    renderTime = performance.now();
  });
  // Both list and item will have the same dimensions
  jest
    .spyOn(Element.prototype, 'getBoundingClientRect')
    .mockImplementation(() =>
      getRect({
        top: 0,
        left: 0,
        right: 100,
        bottom: 100,
      }),
    );

  // Stubbing out totally - not including margins in this
  jest
    .spyOn(window, 'getComputedStyle')
    .mockImplementation(() => getComputedSpacing({}));
  const { getByTestId, unmount } = render(
    <DragDropContext {...responders}>
      <Droppable droppableId=""droppable"">
        {(droppableProvided: DroppableProvided) => (
          <div
            ref={droppableProvided.innerRef}
            {...droppableProvided.droppableProps}
          >
            <h2>Droppable</h2>
            <Draggable draggableId=""draggable"" index={0}>
              {(draggableProvided: DraggableProvided) => (
                <Item onRender={onItemRender} provided={draggableProvided} />
              )}
            </Draggable>
            {droppableProvided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>,
  );

  // clearing the initial render before a drag
  expect(onItemRender).toHaveBeenCalledTimes(1);
  renderTime = null;
  onItemRender.mockClear();

  // start a drag
  const handle: HTMLElement = getByTestId('drag-handle');
  simpleLift(keyboard, handle);
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking values are set
  invariant(onBeforeDragStartTime, 'onBeforeDragStartTime should be set');
  invariant(onDragStartTime, 'onDragStartTime should be set');
  invariant(renderTime, 'renderTime should be set');

  // expected order
  // 1. onBeforeDragStart
  // 2. item render
  // 3. onDragStart
  expect(onBeforeDragStartTime).toBeLessThan(renderTime);
  expect(renderTime).toBeLessThan(onDragStartTime);

  // validation
  expect(responders.onBeforeDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(onItemRender).toHaveBeenCalledTimes(1);
  unmount();
})",steel
/test/unit/integration/responders-timing.spec.js,Eager Test,"{'line': 52, 'column': 6, 'index': 1720}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  let onBeforeDragStartTime: ?DOMHighResTimeStamp = null;
  let onDragStartTime: ?DOMHighResTimeStamp = null;
  let renderTime: ?DOMHighResTimeStamp = null;
  const responders: Responders = {
    onBeforeDragStart: jest.fn().mockImplementation(() => {
      invariant(!onBeforeDragStartTime, 'onBeforeDragStartTime already set');
      onBeforeDragStartTime = performance.now();
    }),
    onDragStart: jest.fn().mockImplementation(() => {
      invariant(!onDragStartTime, 'onDragStartTime already set');
      onDragStartTime = performance.now();
    }),
    onDragEnd: jest.fn(),
  };
  const onItemRender = jest.fn().mockImplementation(() => {
    invariant(!renderTime, 'renderTime already set');
    renderTime = performance.now();
  });
  // Both list and item will have the same dimensions
  jest
    .spyOn(Element.prototype, 'getBoundingClientRect')
    .mockImplementation(() =>
      getRect({
        top: 0,
        left: 0,
        right: 100,
        bottom: 100,
      }),
    );

  // Stubbing out totally - not including margins in this
  jest
    .spyOn(window, 'getComputedStyle')
    .mockImplementation(() => getComputedSpacing({}));
  const { getByTestId, unmount } = render(
    <DragDropContext {...responders}>
      <Droppable droppableId=""droppable"">
        {(droppableProvided: DroppableProvided) => (
          <div
            ref={droppableProvided.innerRef}
            {...droppableProvided.droppableProps}
          >
            <h2>Droppable</h2>
            <Draggable draggableId=""draggable"" index={0}>
              {(draggableProvided: DraggableProvided) => (
                <Item onRender={onItemRender} provided={draggableProvided} />
              )}
            </Draggable>
            {droppableProvided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>,
  );

  // clearing the initial render before a drag
  expect(onItemRender).toHaveBeenCalledTimes(1);
  renderTime = null;
  onItemRender.mockClear();

  // start a drag
  const handle: HTMLElement = getByTestId('drag-handle');
  simpleLift(keyboard, handle);
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking values are set
  invariant(onBeforeDragStartTime, 'onBeforeDragStartTime should be set');
  invariant(onDragStartTime, 'onDragStartTime should be set');
  invariant(renderTime, 'renderTime should be set');

  // expected order
  // 1. onBeforeDragStart
  // 2. item render
  // 3. onDragStart
  expect(onBeforeDragStartTime).toBeLessThan(renderTime);
  expect(renderTime).toBeLessThan(onDragStartTime);

  // validation
  expect(responders.onBeforeDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(onItemRender).toHaveBeenCalledTimes(1);
  unmount();
})",steel
/test/unit/integration/responders-timing.spec.js,Eager Test,"{'line': 58, 'column': 4, 'index': 1926}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  let onBeforeDragStartTime: ?DOMHighResTimeStamp = null;
  let onDragStartTime: ?DOMHighResTimeStamp = null;
  let renderTime: ?DOMHighResTimeStamp = null;
  const responders: Responders = {
    onBeforeDragStart: jest.fn().mockImplementation(() => {
      invariant(!onBeforeDragStartTime, 'onBeforeDragStartTime already set');
      onBeforeDragStartTime = performance.now();
    }),
    onDragStart: jest.fn().mockImplementation(() => {
      invariant(!onDragStartTime, 'onDragStartTime already set');
      onDragStartTime = performance.now();
    }),
    onDragEnd: jest.fn(),
  };
  const onItemRender = jest.fn().mockImplementation(() => {
    invariant(!renderTime, 'renderTime already set');
    renderTime = performance.now();
  });
  // Both list and item will have the same dimensions
  jest
    .spyOn(Element.prototype, 'getBoundingClientRect')
    .mockImplementation(() =>
      getRect({
        top: 0,
        left: 0,
        right: 100,
        bottom: 100,
      }),
    );

  // Stubbing out totally - not including margins in this
  jest
    .spyOn(window, 'getComputedStyle')
    .mockImplementation(() => getComputedSpacing({}));
  const { getByTestId, unmount } = render(
    <DragDropContext {...responders}>
      <Droppable droppableId=""droppable"">
        {(droppableProvided: DroppableProvided) => (
          <div
            ref={droppableProvided.innerRef}
            {...droppableProvided.droppableProps}
          >
            <h2>Droppable</h2>
            <Draggable draggableId=""draggable"" index={0}>
              {(draggableProvided: DraggableProvided) => (
                <Item onRender={onItemRender} provided={draggableProvided} />
              )}
            </Draggable>
            {droppableProvided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>,
  );

  // clearing the initial render before a drag
  expect(onItemRender).toHaveBeenCalledTimes(1);
  renderTime = null;
  onItemRender.mockClear();

  // start a drag
  const handle: HTMLElement = getByTestId('drag-handle');
  simpleLift(keyboard, handle);
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking values are set
  invariant(onBeforeDragStartTime, 'onBeforeDragStartTime should be set');
  invariant(onDragStartTime, 'onDragStartTime should be set');
  invariant(renderTime, 'renderTime should be set');

  // expected order
  // 1. onBeforeDragStart
  // 2. item render
  // 3. onDragStart
  expect(onBeforeDragStartTime).toBeLessThan(renderTime);
  expect(renderTime).toBeLessThan(onDragStartTime);

  // validation
  expect(responders.onBeforeDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(onItemRender).toHaveBeenCalledTimes(1);
  unmount();
})",steel
/test/unit/integration/responders-timing.spec.js,Eager Test,"{'line': 105, 'column': 2, 'index': 3342}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  let onBeforeDragStartTime: ?DOMHighResTimeStamp = null;
  let onDragStartTime: ?DOMHighResTimeStamp = null;
  let renderTime: ?DOMHighResTimeStamp = null;
  const responders: Responders = {
    onBeforeDragStart: jest.fn().mockImplementation(() => {
      invariant(!onBeforeDragStartTime, 'onBeforeDragStartTime already set');
      onBeforeDragStartTime = performance.now();
    }),
    onDragStart: jest.fn().mockImplementation(() => {
      invariant(!onDragStartTime, 'onDragStartTime already set');
      onDragStartTime = performance.now();
    }),
    onDragEnd: jest.fn(),
  };
  const onItemRender = jest.fn().mockImplementation(() => {
    invariant(!renderTime, 'renderTime already set');
    renderTime = performance.now();
  });
  // Both list and item will have the same dimensions
  jest
    .spyOn(Element.prototype, 'getBoundingClientRect')
    .mockImplementation(() =>
      getRect({
        top: 0,
        left: 0,
        right: 100,
        bottom: 100,
      }),
    );

  // Stubbing out totally - not including margins in this
  jest
    .spyOn(window, 'getComputedStyle')
    .mockImplementation(() => getComputedSpacing({}));
  const { getByTestId, unmount } = render(
    <DragDropContext {...responders}>
      <Droppable droppableId=""droppable"">
        {(droppableProvided: DroppableProvided) => (
          <div
            ref={droppableProvided.innerRef}
            {...droppableProvided.droppableProps}
          >
            <h2>Droppable</h2>
            <Draggable draggableId=""draggable"" index={0}>
              {(draggableProvided: DraggableProvided) => (
                <Item onRender={onItemRender} provided={draggableProvided} />
              )}
            </Draggable>
            {droppableProvided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>,
  );

  // clearing the initial render before a drag
  expect(onItemRender).toHaveBeenCalledTimes(1);
  renderTime = null;
  onItemRender.mockClear();

  // start a drag
  const handle: HTMLElement = getByTestId('drag-handle');
  simpleLift(keyboard, handle);
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking values are set
  invariant(onBeforeDragStartTime, 'onBeforeDragStartTime should be set');
  invariant(onDragStartTime, 'onDragStartTime should be set');
  invariant(renderTime, 'renderTime should be set');

  // expected order
  // 1. onBeforeDragStart
  // 2. item render
  // 3. onDragStart
  expect(onBeforeDragStartTime).toBeLessThan(renderTime);
  expect(renderTime).toBeLessThan(onDragStartTime);

  // validation
  expect(responders.onBeforeDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(onItemRender).toHaveBeenCalledTimes(1);
  unmount();
})",steel
/test/unit/integration/responders-timing.spec.js,Eager Test,"{'line': 110, 'column': 2, 'index': 3461}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  let onBeforeDragStartTime: ?DOMHighResTimeStamp = null;
  let onDragStartTime: ?DOMHighResTimeStamp = null;
  let renderTime: ?DOMHighResTimeStamp = null;
  const responders: Responders = {
    onBeforeDragStart: jest.fn().mockImplementation(() => {
      invariant(!onBeforeDragStartTime, 'onBeforeDragStartTime already set');
      onBeforeDragStartTime = performance.now();
    }),
    onDragStart: jest.fn().mockImplementation(() => {
      invariant(!onDragStartTime, 'onDragStartTime already set');
      onDragStartTime = performance.now();
    }),
    onDragEnd: jest.fn(),
  };
  const onItemRender = jest.fn().mockImplementation(() => {
    invariant(!renderTime, 'renderTime already set');
    renderTime = performance.now();
  });
  // Both list and item will have the same dimensions
  jest
    .spyOn(Element.prototype, 'getBoundingClientRect')
    .mockImplementation(() =>
      getRect({
        top: 0,
        left: 0,
        right: 100,
        bottom: 100,
      }),
    );

  // Stubbing out totally - not including margins in this
  jest
    .spyOn(window, 'getComputedStyle')
    .mockImplementation(() => getComputedSpacing({}));
  const { getByTestId, unmount } = render(
    <DragDropContext {...responders}>
      <Droppable droppableId=""droppable"">
        {(droppableProvided: DroppableProvided) => (
          <div
            ref={droppableProvided.innerRef}
            {...droppableProvided.droppableProps}
          >
            <h2>Droppable</h2>
            <Draggable draggableId=""draggable"" index={0}>
              {(draggableProvided: DraggableProvided) => (
                <Item onRender={onItemRender} provided={draggableProvided} />
              )}
            </Draggable>
            {droppableProvided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>,
  );

  // clearing the initial render before a drag
  expect(onItemRender).toHaveBeenCalledTimes(1);
  renderTime = null;
  onItemRender.mockClear();

  // start a drag
  const handle: HTMLElement = getByTestId('drag-handle');
  simpleLift(keyboard, handle);
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking values are set
  invariant(onBeforeDragStartTime, 'onBeforeDragStartTime should be set');
  invariant(onDragStartTime, 'onDragStartTime should be set');
  invariant(renderTime, 'renderTime should be set');

  // expected order
  // 1. onBeforeDragStart
  // 2. item render
  // 3. onDragStart
  expect(onBeforeDragStartTime).toBeLessThan(renderTime);
  expect(renderTime).toBeLessThan(onDragStartTime);

  // validation
  expect(responders.onBeforeDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(onItemRender).toHaveBeenCalledTimes(1);
  unmount();
})",steel
/test/unit/integration/responders-timing.spec.js,Eager Test,"{'line': 111, 'column': 2, 'index': 3536}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  let onBeforeDragStartTime: ?DOMHighResTimeStamp = null;
  let onDragStartTime: ?DOMHighResTimeStamp = null;
  let renderTime: ?DOMHighResTimeStamp = null;
  const responders: Responders = {
    onBeforeDragStart: jest.fn().mockImplementation(() => {
      invariant(!onBeforeDragStartTime, 'onBeforeDragStartTime already set');
      onBeforeDragStartTime = performance.now();
    }),
    onDragStart: jest.fn().mockImplementation(() => {
      invariant(!onDragStartTime, 'onDragStartTime already set');
      onDragStartTime = performance.now();
    }),
    onDragEnd: jest.fn(),
  };
  const onItemRender = jest.fn().mockImplementation(() => {
    invariant(!renderTime, 'renderTime already set');
    renderTime = performance.now();
  });
  // Both list and item will have the same dimensions
  jest
    .spyOn(Element.prototype, 'getBoundingClientRect')
    .mockImplementation(() =>
      getRect({
        top: 0,
        left: 0,
        right: 100,
        bottom: 100,
      }),
    );

  // Stubbing out totally - not including margins in this
  jest
    .spyOn(window, 'getComputedStyle')
    .mockImplementation(() => getComputedSpacing({}));
  const { getByTestId, unmount } = render(
    <DragDropContext {...responders}>
      <Droppable droppableId=""droppable"">
        {(droppableProvided: DroppableProvided) => (
          <div
            ref={droppableProvided.innerRef}
            {...droppableProvided.droppableProps}
          >
            <h2>Droppable</h2>
            <Draggable draggableId=""draggable"" index={0}>
              {(draggableProvided: DraggableProvided) => (
                <Item onRender={onItemRender} provided={draggableProvided} />
              )}
            </Draggable>
            {droppableProvided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>,
  );

  // clearing the initial render before a drag
  expect(onItemRender).toHaveBeenCalledTimes(1);
  renderTime = null;
  onItemRender.mockClear();

  // start a drag
  const handle: HTMLElement = getByTestId('drag-handle');
  simpleLift(keyboard, handle);
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking values are set
  invariant(onBeforeDragStartTime, 'onBeforeDragStartTime should be set');
  invariant(onDragStartTime, 'onDragStartTime should be set');
  invariant(renderTime, 'renderTime should be set');

  // expected order
  // 1. onBeforeDragStart
  // 2. item render
  // 3. onDragStart
  expect(onBeforeDragStartTime).toBeLessThan(renderTime);
  expect(renderTime).toBeLessThan(onDragStartTime);

  // validation
  expect(responders.onBeforeDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(onItemRender).toHaveBeenCalledTimes(1);
  unmount();
})",steel
/test/unit/integration/responders-timing.spec.js,Eager Test,"{'line': 112, 'column': 2, 'index': 3599}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  let onBeforeDragStartTime: ?DOMHighResTimeStamp = null;
  let onDragStartTime: ?DOMHighResTimeStamp = null;
  let renderTime: ?DOMHighResTimeStamp = null;
  const responders: Responders = {
    onBeforeDragStart: jest.fn().mockImplementation(() => {
      invariant(!onBeforeDragStartTime, 'onBeforeDragStartTime already set');
      onBeforeDragStartTime = performance.now();
    }),
    onDragStart: jest.fn().mockImplementation(() => {
      invariant(!onDragStartTime, 'onDragStartTime already set');
      onDragStartTime = performance.now();
    }),
    onDragEnd: jest.fn(),
  };
  const onItemRender = jest.fn().mockImplementation(() => {
    invariant(!renderTime, 'renderTime already set');
    renderTime = performance.now();
  });
  // Both list and item will have the same dimensions
  jest
    .spyOn(Element.prototype, 'getBoundingClientRect')
    .mockImplementation(() =>
      getRect({
        top: 0,
        left: 0,
        right: 100,
        bottom: 100,
      }),
    );

  // Stubbing out totally - not including margins in this
  jest
    .spyOn(window, 'getComputedStyle')
    .mockImplementation(() => getComputedSpacing({}));
  const { getByTestId, unmount } = render(
    <DragDropContext {...responders}>
      <Droppable droppableId=""droppable"">
        {(droppableProvided: DroppableProvided) => (
          <div
            ref={droppableProvided.innerRef}
            {...droppableProvided.droppableProps}
          >
            <h2>Droppable</h2>
            <Draggable draggableId=""draggable"" index={0}>
              {(draggableProvided: DraggableProvided) => (
                <Item onRender={onItemRender} provided={draggableProvided} />
              )}
            </Draggable>
            {droppableProvided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>,
  );

  // clearing the initial render before a drag
  expect(onItemRender).toHaveBeenCalledTimes(1);
  renderTime = null;
  onItemRender.mockClear();

  // start a drag
  const handle: HTMLElement = getByTestId('drag-handle');
  simpleLift(keyboard, handle);
  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // checking values are set
  invariant(onBeforeDragStartTime, 'onBeforeDragStartTime should be set');
  invariant(onDragStartTime, 'onDragStartTime should be set');
  invariant(renderTime, 'renderTime should be set');

  // expected order
  // 1. onBeforeDragStart
  // 2. item render
  // 3. onDragStart
  expect(onBeforeDragStartTime).toBeLessThan(renderTime);
  expect(renderTime).toBeLessThan(onDragStartTime);

  // validation
  expect(responders.onBeforeDragStart).toHaveBeenCalledTimes(1);
  expect(responders.onDragStart).toHaveBeenCalledTimes(1);
  expect(onItemRender).toHaveBeenCalledTimes(1);
  unmount();
})",steel
/test/unit/integration/responders-integration.spec.js,Conditional Test Logic,"{'line': 36, 'column': 2, 'index': 1234}",Unknown,steel
/test/unit/integration/responders-integration.spec.js,Unknown Test,"{'column': 4, 'line': 263}","it('should call the onBeforeDragCapture responder just before the drag starts', () => {
      drag.start();

      wasOnBeforeCaptureCalled();

      // cleanup
      drag.stop();
    })",steel
/test/unit/integration/responders-integration.spec.js,Unknown Test,"{'column': 4, 'line': 274}","it('should call the onBeforeDragStart responder just before the drag starts', () => {
      drag.start();

      wasOnBeforeDragCalled();

      // cleanup
      drag.stop();
    })",steel
/test/unit/integration/responders-integration.spec.js,Unknown Test,"{'column': 4, 'line': 299}","it('should call the onDragStart responder when a drag starts', () => {
      drag.start();

      wasDragStarted();

      // cleanup
      drag.stop();
    })",steel
/test/unit/integration/responders-integration.spec.js,Unknown Test,"{'column': 4, 'line': 324}","it('should call the onDragEnd responder when a drag ends', () => {
      drag.perform();

      wasDragCompleted();
    })",steel
/test/unit/integration/responders-integration.spec.js,Unknown Test,"{'column': 4, 'line': 330}","it('should call the onDragEnd responder when a drag ends when instantly stopped', () => {
      drag.start();
      drag.stop();

      wasDragCompleted();
    })",steel
/test/unit/integration/responders-integration.spec.js,Unknown Test,"{'column': 4, 'line': 339}","it('should call onDragEnd when a drag is canceled', () => {
      drag.start();
      drag.move();
      drag.cancel();

      wasDragCancelled();
    })",steel
/test/unit/integration/responders-integration.spec.js,Unknown Test,"{'column': 4, 'line': 347}","it('should call onDragEnd when a drag is canceled instantly', () => {
      drag.start();
      drag.cancel();

      wasDragCancelled();
    })",steel
/test/unit/integration/responders-integration.spec.js,Unknown Test,"{'column': 4, 'line': 356}","it('should cancel a drag if unmounted mid drag', () => {
      drag.start();

      wrapper.unmount();

      wasDragCancelled();
    })",steel
/test/unit/integration/responders-integration.spec.js,Unknown Test,"{'column': 4, 'line': 366}","it('should publish subsequent drags', () => {
      drag.perform();
      wasDragStarted(1);
      wasDragCompleted(1);

      drag.perform();
      wasDragStarted(2);
      wasDragCompleted(2);
    })",steel
/test/unit/integration/responders-integration.spec.js,Unknown Test,"{'column': 4, 'line': 376}","it('should publish subsequent drags after a cancel', () => {
      drag.start();
      drag.cancel();
      wasOnBeforeDragCalled(1);
      wasDragStarted(1);
      wasDragCancelled(1);

      drag.perform();
      wasOnBeforeDragCalled(2);
      wasDragStarted(2);
      wasDragCompleted(2);
    })",steel
/test/unit/integration/responders-integration.spec.js,Unknown Test,"{'column': 4, 'line': 429}","it('should allow you to change responders between drags', () => {
      const newResponders: Responders = {
        onDragStart: jest.fn(),
        onDragEnd: jest.fn(),
      };

      // first drag
      drag.perform();
      wasDragStarted(1, responders);
      wasDragCompleted(1, responders);

      // second drag
      setResponders(newResponders);
      drag.perform();

      // new responders called for second drag
      wasDragStarted(1, newResponders);
      wasDragCompleted(1, newResponders);
      // original responders should not have been called again
      wasDragStarted(1, responders);
      wasDragCompleted(1, responders);
    })",steel
/test/unit/integration/reorder-render-sync.spec.js,Conditional Test Logic,"{'line': 65, 'column': 4, 'index': 1724}",Unknown,steel
/test/unit/integration/reorder-render-sync.spec.js,Conditional Test Logic,"{'line': 87, 'column': 2, 'index': 2325}",Unknown,steel
/test/unit/integration/reorder-render-sync.spec.js,Conditional Test Logic,"{'line': 107, 'column': 4, 'index': 2664}",Unknown,steel
/test/unit/integration/reorder-render-sync.spec.js,Conditional Test Logic,"{'line': 125, 'column': 4, 'index': 2992}",Unknown,steel
/test/unit/integration/reorder-render-sync.spec.js,Conditional Test Logic,"{'line': 147, 'column': 4, 'index': 3397}",Unknown,steel
/test/unit/integration/reorder-render-sync.spec.js,Duplicate Assert,"{'line': 191, 'column': 2, 'index': 4531}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  jest.useFakeTimers();
  const clearRenderMocks = () => {
    first.onRender.mockClear();
    second.onRender.mockClear();
  };

  const { getAllByTestId, unmount } = render(<App />);

  // clearing the initial render before a drag
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // start a drag
  const handle: HTMLElement = getAllByTestId('drag-handle')[0];
  simpleLift(keyboard, handle);

  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // initial lift will render the first item
  expect(first.onRender).toHaveBeenCalledTimes(1);
  // it will also render the second item as it needs to be pushed down
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  fireEvent.keyDown(handle, { keyCode: keyCodes.arrowDown });
  // flushing keyboard movement
  requestAnimationFrame.step();

  // item1: moving down
  // item2: moving up
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // drop (there is no animation because already in the home spot)
  keyboard.drop(handle);

  // only a single render for the reorder and connected component update
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);

  // checking for no post renders
  clearRenderMocks();
  requestAnimationFrame.flush();
  jest.runAllTimers();
  expect(first.onRender).toHaveBeenCalledTimes(0);
  expect(second.onRender).toHaveBeenCalledTimes(0);

  unmount();
})",steel
/test/unit/integration/reorder-render-sync.spec.js,Duplicate Assert,"{'line': 192, 'column': 2, 'index': 4582}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  jest.useFakeTimers();
  const clearRenderMocks = () => {
    first.onRender.mockClear();
    second.onRender.mockClear();
  };

  const { getAllByTestId, unmount } = render(<App />);

  // clearing the initial render before a drag
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // start a drag
  const handle: HTMLElement = getAllByTestId('drag-handle')[0];
  simpleLift(keyboard, handle);

  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // initial lift will render the first item
  expect(first.onRender).toHaveBeenCalledTimes(1);
  // it will also render the second item as it needs to be pushed down
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  fireEvent.keyDown(handle, { keyCode: keyCodes.arrowDown });
  // flushing keyboard movement
  requestAnimationFrame.step();

  // item1: moving down
  // item2: moving up
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // drop (there is no animation because already in the home spot)
  keyboard.drop(handle);

  // only a single render for the reorder and connected component update
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);

  // checking for no post renders
  clearRenderMocks();
  requestAnimationFrame.flush();
  jest.runAllTimers();
  expect(first.onRender).toHaveBeenCalledTimes(0);
  expect(second.onRender).toHaveBeenCalledTimes(0);

  unmount();
})",steel
/test/unit/integration/reorder-render-sync.spec.js,Duplicate Assert,"{'line': 203, 'column': 2, 'index': 4875}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  jest.useFakeTimers();
  const clearRenderMocks = () => {
    first.onRender.mockClear();
    second.onRender.mockClear();
  };

  const { getAllByTestId, unmount } = render(<App />);

  // clearing the initial render before a drag
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // start a drag
  const handle: HTMLElement = getAllByTestId('drag-handle')[0];
  simpleLift(keyboard, handle);

  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // initial lift will render the first item
  expect(first.onRender).toHaveBeenCalledTimes(1);
  // it will also render the second item as it needs to be pushed down
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  fireEvent.keyDown(handle, { keyCode: keyCodes.arrowDown });
  // flushing keyboard movement
  requestAnimationFrame.step();

  // item1: moving down
  // item2: moving up
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // drop (there is no animation because already in the home spot)
  keyboard.drop(handle);

  // only a single render for the reorder and connected component update
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);

  // checking for no post renders
  clearRenderMocks();
  requestAnimationFrame.flush();
  jest.runAllTimers();
  expect(first.onRender).toHaveBeenCalledTimes(0);
  expect(second.onRender).toHaveBeenCalledTimes(0);

  unmount();
})",steel
/test/unit/integration/reorder-render-sync.spec.js,Duplicate Assert,"{'line': 205, 'column': 2, 'index': 4997}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  jest.useFakeTimers();
  const clearRenderMocks = () => {
    first.onRender.mockClear();
    second.onRender.mockClear();
  };

  const { getAllByTestId, unmount } = render(<App />);

  // clearing the initial render before a drag
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // start a drag
  const handle: HTMLElement = getAllByTestId('drag-handle')[0];
  simpleLift(keyboard, handle);

  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // initial lift will render the first item
  expect(first.onRender).toHaveBeenCalledTimes(1);
  // it will also render the second item as it needs to be pushed down
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  fireEvent.keyDown(handle, { keyCode: keyCodes.arrowDown });
  // flushing keyboard movement
  requestAnimationFrame.step();

  // item1: moving down
  // item2: moving up
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // drop (there is no animation because already in the home spot)
  keyboard.drop(handle);

  // only a single render for the reorder and connected component update
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);

  // checking for no post renders
  clearRenderMocks();
  requestAnimationFrame.flush();
  jest.runAllTimers();
  expect(first.onRender).toHaveBeenCalledTimes(0);
  expect(second.onRender).toHaveBeenCalledTimes(0);

  unmount();
})",steel
/test/unit/integration/reorder-render-sync.spec.js,Duplicate Assert,"{'line': 214, 'column': 2, 'index': 5245}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  jest.useFakeTimers();
  const clearRenderMocks = () => {
    first.onRender.mockClear();
    second.onRender.mockClear();
  };

  const { getAllByTestId, unmount } = render(<App />);

  // clearing the initial render before a drag
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // start a drag
  const handle: HTMLElement = getAllByTestId('drag-handle')[0];
  simpleLift(keyboard, handle);

  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // initial lift will render the first item
  expect(first.onRender).toHaveBeenCalledTimes(1);
  // it will also render the second item as it needs to be pushed down
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  fireEvent.keyDown(handle, { keyCode: keyCodes.arrowDown });
  // flushing keyboard movement
  requestAnimationFrame.step();

  // item1: moving down
  // item2: moving up
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // drop (there is no animation because already in the home spot)
  keyboard.drop(handle);

  // only a single render for the reorder and connected component update
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);

  // checking for no post renders
  clearRenderMocks();
  requestAnimationFrame.flush();
  jest.runAllTimers();
  expect(first.onRender).toHaveBeenCalledTimes(0);
  expect(second.onRender).toHaveBeenCalledTimes(0);

  unmount();
})",steel
/test/unit/integration/reorder-render-sync.spec.js,Duplicate Assert,"{'line': 215, 'column': 2, 'index': 5296}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  jest.useFakeTimers();
  const clearRenderMocks = () => {
    first.onRender.mockClear();
    second.onRender.mockClear();
  };

  const { getAllByTestId, unmount } = render(<App />);

  // clearing the initial render before a drag
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // start a drag
  const handle: HTMLElement = getAllByTestId('drag-handle')[0];
  simpleLift(keyboard, handle);

  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // initial lift will render the first item
  expect(first.onRender).toHaveBeenCalledTimes(1);
  // it will also render the second item as it needs to be pushed down
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  fireEvent.keyDown(handle, { keyCode: keyCodes.arrowDown });
  // flushing keyboard movement
  requestAnimationFrame.step();

  // item1: moving down
  // item2: moving up
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // drop (there is no animation because already in the home spot)
  keyboard.drop(handle);

  // only a single render for the reorder and connected component update
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);

  // checking for no post renders
  clearRenderMocks();
  requestAnimationFrame.flush();
  jest.runAllTimers();
  expect(first.onRender).toHaveBeenCalledTimes(0);
  expect(second.onRender).toHaveBeenCalledTimes(0);

  unmount();
})",steel
/test/unit/integration/reorder-render-sync.spec.js,Duplicate Assert,"{'line': 222, 'column': 2, 'index': 5537}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  jest.useFakeTimers();
  const clearRenderMocks = () => {
    first.onRender.mockClear();
    second.onRender.mockClear();
  };

  const { getAllByTestId, unmount } = render(<App />);

  // clearing the initial render before a drag
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // start a drag
  const handle: HTMLElement = getAllByTestId('drag-handle')[0];
  simpleLift(keyboard, handle);

  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // initial lift will render the first item
  expect(first.onRender).toHaveBeenCalledTimes(1);
  // it will also render the second item as it needs to be pushed down
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  fireEvent.keyDown(handle, { keyCode: keyCodes.arrowDown });
  // flushing keyboard movement
  requestAnimationFrame.step();

  // item1: moving down
  // item2: moving up
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // drop (there is no animation because already in the home spot)
  keyboard.drop(handle);

  // only a single render for the reorder and connected component update
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);

  // checking for no post renders
  clearRenderMocks();
  requestAnimationFrame.flush();
  jest.runAllTimers();
  expect(first.onRender).toHaveBeenCalledTimes(0);
  expect(second.onRender).toHaveBeenCalledTimes(0);

  unmount();
})",steel
/test/unit/integration/reorder-render-sync.spec.js,Duplicate Assert,"{'line': 223, 'column': 2, 'index': 5588}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  jest.useFakeTimers();
  const clearRenderMocks = () => {
    first.onRender.mockClear();
    second.onRender.mockClear();
  };

  const { getAllByTestId, unmount } = render(<App />);

  // clearing the initial render before a drag
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // start a drag
  const handle: HTMLElement = getAllByTestId('drag-handle')[0];
  simpleLift(keyboard, handle);

  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // initial lift will render the first item
  expect(first.onRender).toHaveBeenCalledTimes(1);
  // it will also render the second item as it needs to be pushed down
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  fireEvent.keyDown(handle, { keyCode: keyCodes.arrowDown });
  // flushing keyboard movement
  requestAnimationFrame.step();

  // item1: moving down
  // item2: moving up
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // drop (there is no animation because already in the home spot)
  keyboard.drop(handle);

  // only a single render for the reorder and connected component update
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);

  // checking for no post renders
  clearRenderMocks();
  requestAnimationFrame.flush();
  jest.runAllTimers();
  expect(first.onRender).toHaveBeenCalledTimes(0);
  expect(second.onRender).toHaveBeenCalledTimes(0);

  unmount();
})",steel
/test/unit/integration/reorder-render-sync.spec.js,Duplicate Assert,"{'line': 229, 'column': 2, 'index': 5753}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  jest.useFakeTimers();
  const clearRenderMocks = () => {
    first.onRender.mockClear();
    second.onRender.mockClear();
  };

  const { getAllByTestId, unmount } = render(<App />);

  // clearing the initial render before a drag
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // start a drag
  const handle: HTMLElement = getAllByTestId('drag-handle')[0];
  simpleLift(keyboard, handle);

  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // initial lift will render the first item
  expect(first.onRender).toHaveBeenCalledTimes(1);
  // it will also render the second item as it needs to be pushed down
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  fireEvent.keyDown(handle, { keyCode: keyCodes.arrowDown });
  // flushing keyboard movement
  requestAnimationFrame.step();

  // item1: moving down
  // item2: moving up
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // drop (there is no animation because already in the home spot)
  keyboard.drop(handle);

  // only a single render for the reorder and connected component update
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);

  // checking for no post renders
  clearRenderMocks();
  requestAnimationFrame.flush();
  jest.runAllTimers();
  expect(first.onRender).toHaveBeenCalledTimes(0);
  expect(second.onRender).toHaveBeenCalledTimes(0);

  unmount();
})",steel
/test/unit/integration/reorder-render-sync.spec.js,Duplicate Assert,"{'line': 230, 'column': 2, 'index': 5804}","it('should call the onBeforeDragStart before connected components are updated, and onDragStart after', () => {
  jest.useFakeTimers();
  const clearRenderMocks = () => {
    first.onRender.mockClear();
    second.onRender.mockClear();
  };

  const { getAllByTestId, unmount } = render(<App />);

  // clearing the initial render before a drag
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // start a drag
  const handle: HTMLElement = getAllByTestId('drag-handle')[0];
  simpleLift(keyboard, handle);

  // flushing onDragStart
  jest.runOnlyPendingTimers();

  // initial lift will render the first item
  expect(first.onRender).toHaveBeenCalledTimes(1);
  // it will also render the second item as it needs to be pushed down
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  fireEvent.keyDown(handle, { keyCode: keyCodes.arrowDown });
  // flushing keyboard movement
  requestAnimationFrame.step();

  // item1: moving down
  // item2: moving up
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);
  clearRenderMocks();

  // drop (there is no animation because already in the home spot)
  keyboard.drop(handle);

  // only a single render for the reorder and connected component update
  expect(first.onRender).toHaveBeenCalledTimes(1);
  expect(second.onRender).toHaveBeenCalledTimes(1);

  // checking for no post renders
  clearRenderMocks();
  requestAnimationFrame.flush();
  jest.runAllTimers();
  expect(first.onRender).toHaveBeenCalledTimes(0);
  expect(second.onRender).toHaveBeenCalledTimes(0);

  unmount();
})",steel
/test/unit/integration/disable-on-start.spec.js,Duplicate Assert,"{'line': 121, 'column': 2, 'index': 3312}","it('should allow the disabling of a droppable in onDragStart', () => {
  const responders: Responders = {
    onDragStart: jest.fn(),
    onDragUpdate: jest.fn(),
    onDragEnd: jest.fn(),
  };
  const { getByTestId } = render(<App {...responders} />);
  const handle: HTMLElement = getByTestId('drag-handle');

  simpleLift(keyboard, handle);
  // flush responder
  jest.runOnlyPendingTimers();

  const start: DragStart = {
    draggableId: 'draggable',
    source: {
      droppableId: 'droppable',
      index: 0,
    },
    type: 'DEFAULT',
    mode: 'SNAP',
  };
  expect(responders.onDragStart).toHaveBeenCalledWith(start);

  // onDragUpdate will occur after setTimeout
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();
  // an update should be fired as the home location has changed
  const update: DragUpdate = {
    ...start,
    // no destination as it is now disabled
    destination: null,
    combine: null,
  };
  expect(responders.onDragUpdate).toHaveBeenCalledWith(update);
})",steel
/test/unit/integration/disable-on-start.spec.js,Duplicate Assert,"{'line': 131, 'column': 2, 'index': 3602}","it('should allow the disabling of a droppable in onDragStart', () => {
  const responders: Responders = {
    onDragStart: jest.fn(),
    onDragUpdate: jest.fn(),
    onDragEnd: jest.fn(),
  };
  const { getByTestId } = render(<App {...responders} />);
  const handle: HTMLElement = getByTestId('drag-handle');

  simpleLift(keyboard, handle);
  // flush responder
  jest.runOnlyPendingTimers();

  const start: DragStart = {
    draggableId: 'draggable',
    source: {
      droppableId: 'droppable',
      index: 0,
    },
    type: 'DEFAULT',
    mode: 'SNAP',
  };
  expect(responders.onDragStart).toHaveBeenCalledWith(start);

  // onDragUpdate will occur after setTimeout
  expect(responders.onDragUpdate).not.toHaveBeenCalled();

  jest.runOnlyPendingTimers();
  // an update should be fired as the home location has changed
  const update: DragUpdate = {
    ...start,
    // no destination as it is now disabled
    destination: null,
    combine: null,
  };
  expect(responders.onDragUpdate).toHaveBeenCalledWith(update);
})",steel
/test/unit/integration/body-removal-before-unmount.spec.js,Eager Test,"{'line': 28, 'column': 4, 'index': 850}","it('should have any errors when body is changed just before unmount: mid drag', () => {
    const { unmount, getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    // mid drag
    simpleLift(control, handle);
    expect(isDragging(handle)).toEqual(true);

    expect(() => {
      getBodyElement().innerHTML = '';
      unmount();
      jest.runOnlyPendingTimers();
    }).not.toThrow();
  })",steel
/test/unit/integration/body-removal-before-unmount.spec.js,Eager Test,"{'line': 29, 'column': 11, 'index': 890}","it('should have any errors when body is changed just before unmount: mid drag', () => {
    const { unmount, getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    // mid drag
    simpleLift(control, handle);
    expect(isDragging(handle)).toEqual(true);

    expect(() => {
      getBodyElement().innerHTML = '';
      unmount();
      jest.runOnlyPendingTimers();
    }).not.toThrow();
  })",steel
/test/unit/integration/server-side-rendering/server-rendering.spec.js,Duplicate Assert,"{'line': 44, 'column': 2, 'index': 1202}","it('should support rendering to a string', () => {
  const result: string = renderToString(<App />);

  expect(result).toEqual(expect.any(String));
  expect(result).toMatchSnapshot();
  expectConsoleNotCalled();
})",steel
/test/unit/integration/server-side-rendering/server-rendering.spec.js,Duplicate Assert,"{'line': 45, 'column': 2, 'index': 1248}","it('should support rendering to a string', () => {
  const result: string = renderToString(<App />);

  expect(result).toEqual(expect.any(String));
  expect(result).toMatchSnapshot();
  expectConsoleNotCalled();
})",steel
/test/unit/integration/server-side-rendering/server-rendering.spec.js,Duplicate Assert,"{'line': 52, 'column': 2, 'index': 1430}","it('should support rendering to static markup', () => {
  const result: string = renderToStaticMarkup(<App />);

  expect(result).toEqual(expect.any(String));
  expect(result).toMatchSnapshot();
  expectConsoleNotCalled();
})",steel
/test/unit/integration/server-side-rendering/server-rendering.spec.js,Duplicate Assert,"{'line': 53, 'column': 2, 'index': 1476}","it('should support rendering to static markup', () => {
  const result: string = renderToStaticMarkup(<App />);

  expect(result).toEqual(expect.any(String));
  expect(result).toMatchSnapshot();
  expectConsoleNotCalled();
})",steel
/test/unit/integration/server-side-rendering/server-rendering.spec.js,Duplicate Assert,"{'line': 60, 'column': 2, 'index': 1734}","it('should render identical content when resetting context between renders', () => {
  const firstRender = renderToString(<App />);
  const nextRenderBeforeReset = renderToString(<App />);
  expect(firstRender).not.toEqual(nextRenderBeforeReset);

  resetServerContext();
  const nextRenderAfterReset = renderToString(<App />);
  expect(firstRender).toEqual(nextRenderAfterReset);
  expectConsoleNotCalled();
})",steel
/test/unit/integration/server-side-rendering/server-rendering.spec.js,Duplicate Assert,"{'line': 64, 'column': 2, 'index': 1873}","it('should render identical content when resetting context between renders', () => {
  const firstRender = renderToString(<App />);
  const nextRenderBeforeReset = renderToString(<App />);
  expect(firstRender).not.toEqual(nextRenderBeforeReset);

  resetServerContext();
  const nextRenderAfterReset = renderToString(<App />);
  expect(firstRender).toEqual(nextRenderAfterReset);
  expectConsoleNotCalled();
})",steel
/test/unit/integration/server-side-rendering/client-hydration.spec.js,Eager Test,"{'line': 29, 'column': 2, 'index': 1028}","it('should support hydrating a server side rendered application', () => {
  // would be done server side
  // we need to mock out the warnings caused by useLayoutEffect
  // This will not happen on the client as the string is rendered
  // on the server
  const error = jest.spyOn(console, 'error').mockImplementation(noop);

  resetServerContext();
  const serverHTML: string = ReactDOMServer.renderToString(<App />);

  error.mock.calls.forEach((call) => {
    expect(
      call[0].includes('Warning: useLayoutEffect does nothing on the server'),
    ).toBe(true);
  });
  error.mockRestore();

  // would be done client side
  // would have a fresh server context on the client
  resetServerContext();
  const el = document.createElement('div');
  el.innerHTML = serverHTML;
  getBodyElement().appendChild(el);

  expect(() => ReactDOM.hydrate(<App />, el)).not.toThrow();
})",steel
/test/unit/integration/server-side-rendering/client-hydration.spec.js,Eager Test,"{'line': 41, 'column': 2, 'index': 1384}","it('should support hydrating a server side rendered application', () => {
  // would be done server side
  // we need to mock out the warnings caused by useLayoutEffect
  // This will not happen on the client as the string is rendered
  // on the server
  const error = jest.spyOn(console, 'error').mockImplementation(noop);

  resetServerContext();
  const serverHTML: string = ReactDOMServer.renderToString(<App />);

  error.mock.calls.forEach((call) => {
    expect(
      call[0].includes('Warning: useLayoutEffect does nothing on the server'),
    ).toBe(true);
  });
  error.mockRestore();

  // would be done client side
  // would have a fresh server context on the client
  resetServerContext();
  const el = document.createElement('div');
  el.innerHTML = serverHTML;
  getBodyElement().appendChild(el);

  expect(() => ReactDOM.hydrate(<App />, el)).not.toThrow();
})",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 77, 'column': 6, 'index': 2733}","it('should remove all placeholders if an error occurs while dragging', () => {
  withPoorBoardDimensions((preset) => {
    toDroppableList(preset.droppables).forEach((droppable) => {
      const { container, getByTestId, unmount } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);
      const box0 = preset.inHome1.client.borderBox;

      expandedMouse.powerLift(handle, box0.center);
      expandedMouse.move(handle, droppable.client.borderBox.center);

      expect(isDragging(handle)).toBe(true);
      expect(isOver(handle)).toBe(droppable.descriptor.id);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

      withWarn(() => {
        const event: Event = new Event('error');
        fireEvent(window, event);
      });

      expect(isDragging(handle)).toBe(false);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(false);

      unmount();
    });
  });
})",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 79, 'column': 6, 'index': 2838}","it('should remove all placeholders if an error occurs while dragging', () => {
  withPoorBoardDimensions((preset) => {
    toDroppableList(preset.droppables).forEach((droppable) => {
      const { container, getByTestId, unmount } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);
      const box0 = preset.inHome1.client.borderBox;

      expandedMouse.powerLift(handle, box0.center);
      expandedMouse.move(handle, droppable.client.borderBox.center);

      expect(isDragging(handle)).toBe(true);
      expect(isOver(handle)).toBe(droppable.descriptor.id);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

      withWarn(() => {
        const event: Event = new Event('error');
        fireEvent(window, event);
      });

      expect(isDragging(handle)).toBe(false);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(false);

      unmount();
    });
  });
})",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 86, 'column': 6, 'index': 3033}","it('should remove all placeholders if an error occurs while dragging', () => {
  withPoorBoardDimensions((preset) => {
    toDroppableList(preset.droppables).forEach((droppable) => {
      const { container, getByTestId, unmount } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);
      const box0 = preset.inHome1.client.borderBox;

      expandedMouse.powerLift(handle, box0.center);
      expandedMouse.move(handle, droppable.client.borderBox.center);

      expect(isDragging(handle)).toBe(true);
      expect(isOver(handle)).toBe(droppable.descriptor.id);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

      withWarn(() => {
        const event: Event = new Event('error');
        fireEvent(window, event);
      });

      expect(isDragging(handle)).toBe(false);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(false);

      unmount();
    });
  });
})",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 87, 'column': 6, 'index': 3079}","it('should remove all placeholders if an error occurs while dragging', () => {
  withPoorBoardDimensions((preset) => {
    toDroppableList(preset.droppables).forEach((droppable) => {
      const { container, getByTestId, unmount } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);
      const box0 = preset.inHome1.client.borderBox;

      expandedMouse.powerLift(handle, box0.center);
      expandedMouse.move(handle, droppable.client.borderBox.center);

      expect(isDragging(handle)).toBe(true);
      expect(isOver(handle)).toBe(droppable.descriptor.id);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

      withWarn(() => {
        const event: Event = new Event('error');
        fireEvent(window, event);
      });

      expect(isDragging(handle)).toBe(false);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(false);

      unmount();
    });
  });
})",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 126, 'column': 8, 'index': 4618}","it('should immediately remove the home placeholder after dropping into any list', () => {
    withPoorBoardDimensions((preset) => {
      toDroppableList(preset.droppables).forEach((droppable) => {
        const { container, getByTestId, unmount } = render(<Board />);
        const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

        expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
        expandedMouse.move(handle, droppable.client.borderBox.center);
        expect(isOver(handle)).toBe(droppable.descriptor.id);

        expandedMouse.startDrop(handle);
        expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

        // placeholder removed straight after drop
        expandedMouse.finishDrop(handle);
        expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(false);

        unmount();
      });
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 130, 'column': 8, 'index': 4791}","it('should immediately remove the home placeholder after dropping into any list', () => {
    withPoorBoardDimensions((preset) => {
      toDroppableList(preset.droppables).forEach((droppable) => {
        const { container, getByTestId, unmount } = render(<Board />);
        const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

        expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
        expandedMouse.move(handle, droppable.client.borderBox.center);
        expect(isOver(handle)).toBe(droppable.descriptor.id);

        expandedMouse.startDrop(handle);
        expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

        // placeholder removed straight after drop
        expandedMouse.finishDrop(handle);
        expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(false);

        unmount();
      });
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 147, 'column': 6, 'index': 5406}","it('should immediately remove the home placeholder after dropping nowhere', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, { x: 10000, y: 10000 });
      expect(isOver(handle)).toBe(null);

      // placeholder present when over nothing
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder present when drop started
      expandedMouse.startDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder gone after drop finished
      expandedMouse.finishDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 147, 'column': 6, 'index': 5406}","it('should immediately remove the home placeholder after dropping nowhere', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, { x: 10000, y: 10000 });
      expect(isOver(handle)).toBe(null);

      // placeholder present when over nothing
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder present when drop started
      expandedMouse.startDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder gone after drop finished
      expandedMouse.finishDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 151, 'column': 6, 'index': 5572}","it('should immediately remove the home placeholder after dropping nowhere', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, { x: 10000, y: 10000 });
      expect(isOver(handle)).toBe(null);

      // placeholder present when over nothing
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder present when drop started
      expandedMouse.startDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder gone after drop finished
      expandedMouse.finishDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 151, 'column': 6, 'index': 5572}","it('should immediately remove the home placeholder after dropping nowhere', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, { x: 10000, y: 10000 });
      expect(isOver(handle)).toBe(null);

      // placeholder present when over nothing
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder present when drop started
      expandedMouse.startDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder gone after drop finished
      expandedMouse.finishDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 155, 'column': 6, 'index': 5738}","it('should immediately remove the home placeholder after dropping nowhere', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, { x: 10000, y: 10000 });
      expect(isOver(handle)).toBe(null);

      // placeholder present when over nothing
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder present when drop started
      expandedMouse.startDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder gone after drop finished
      expandedMouse.finishDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 170, 'column': 6, 'index': 6416}","it('should animate the home placeholder closed after dropping into a foreign list', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

      expandedMouse.startDrop(handle);
      // foreign placeholder remaining in place
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );
      // home placeholder remaining in place
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // gone after drop finished
      expandedMouse.finishDrop(handle);

      // foreign placeholder is now gone
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
      // home placeholder is still around and will now animate closed
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder is now collapsing
      const placeholder: HTMLElement = getPlaceholder(
        preset.home.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // faking a transition end
      fireEvent(placeholder, getTransitionEnd('height'));

      // placeholder is gone
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 174, 'column': 6, 'index': 6560}","it('should animate the home placeholder closed after dropping into a foreign list', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

      expandedMouse.startDrop(handle);
      // foreign placeholder remaining in place
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );
      // home placeholder remaining in place
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // gone after drop finished
      expandedMouse.finishDrop(handle);

      // foreign placeholder is now gone
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
      // home placeholder is still around and will now animate closed
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder is now collapsing
      const placeholder: HTMLElement = getPlaceholder(
        preset.home.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // faking a transition end
      fireEvent(placeholder, getTransitionEnd('height'));

      // placeholder is gone
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 174, 'column': 6, 'index': 6560}","it('should animate the home placeholder closed after dropping into a foreign list', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

      expandedMouse.startDrop(handle);
      // foreign placeholder remaining in place
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );
      // home placeholder remaining in place
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // gone after drop finished
      expandedMouse.finishDrop(handle);

      // foreign placeholder is now gone
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
      // home placeholder is still around and will now animate closed
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder is now collapsing
      const placeholder: HTMLElement = getPlaceholder(
        preset.home.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // faking a transition end
      fireEvent(placeholder, getTransitionEnd('height'));

      // placeholder is gone
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 180, 'column': 6, 'index': 6756}","it('should animate the home placeholder closed after dropping into a foreign list', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

      expandedMouse.startDrop(handle);
      // foreign placeholder remaining in place
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );
      // home placeholder remaining in place
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // gone after drop finished
      expandedMouse.finishDrop(handle);

      // foreign placeholder is now gone
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
      // home placeholder is still around and will now animate closed
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder is now collapsing
      const placeholder: HTMLElement = getPlaceholder(
        preset.home.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // faking a transition end
      fireEvent(placeholder, getTransitionEnd('height'));

      // placeholder is gone
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 184, 'column': 6, 'index': 6926}","it('should animate the home placeholder closed after dropping into a foreign list', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

      expandedMouse.startDrop(handle);
      // foreign placeholder remaining in place
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );
      // home placeholder remaining in place
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // gone after drop finished
      expandedMouse.finishDrop(handle);

      // foreign placeholder is now gone
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
      // home placeholder is still around and will now animate closed
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder is now collapsing
      const placeholder: HTMLElement = getPlaceholder(
        preset.home.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // faking a transition end
      fireEvent(placeholder, getTransitionEnd('height'));

      // placeholder is gone
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 184, 'column': 6, 'index': 6926}","it('should animate the home placeholder closed after dropping into a foreign list', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

      expandedMouse.startDrop(handle);
      // foreign placeholder remaining in place
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );
      // home placeholder remaining in place
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // gone after drop finished
      expandedMouse.finishDrop(handle);

      // foreign placeholder is now gone
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
      // home placeholder is still around and will now animate closed
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder is now collapsing
      const placeholder: HTMLElement = getPlaceholder(
        preset.home.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // faking a transition end
      fireEvent(placeholder, getTransitionEnd('height'));

      // placeholder is gone
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 197, 'column': 6, 'index': 7337}","it('should animate the home placeholder closed after dropping into a foreign list', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

      expandedMouse.startDrop(handle);
      // foreign placeholder remaining in place
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );
      // home placeholder remaining in place
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // gone after drop finished
      expandedMouse.finishDrop(handle);

      // foreign placeholder is now gone
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
      // home placeholder is still around and will now animate closed
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder is now collapsing
      const placeholder: HTMLElement = getPlaceholder(
        preset.home.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // faking a transition end
      fireEvent(placeholder, getTransitionEnd('height'));

      // placeholder is gone
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 213, 'column': 8, 'index': 8036}","it('should flush a home placeholder collapse animation if starting a new drag', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      {
        const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

        expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
        expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
        expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

        expandedMouse.powerDrop(handle);
        // placeholder still here + animating closed
        expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);
        const placeholder: HTMLElement = getPlaceholder(
          preset.home.descriptor.id,
          container,
        );
        // animating height closed
        expect(placeholder.style.height).toBe('0px');
      }
      {
        const handle: HTMLElement = getByTestId(
          preset.inForeign1.descriptor.id,
        );

        // using raw power lift as we don't want to combine renders
        // (we need a render to flush the placeholder out)
        expandedMouse.rawPowerLift(
          handle,
          preset.inForeign1.client.borderBox.center,
        );

        // placeholder is gone from home (it got flushed)
        expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(
          false,
        );
      }
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 234, 'column': 8, 'index': 8756}","it('should flush a home placeholder collapse animation if starting a new drag', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      {
        const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

        expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
        expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
        expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

        expandedMouse.powerDrop(handle);
        // placeholder still here + animating closed
        expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);
        const placeholder: HTMLElement = getPlaceholder(
          preset.home.descriptor.id,
          container,
        );
        // animating height closed
        expect(placeholder.style.height).toBe('0px');
      }
      {
        const handle: HTMLElement = getByTestId(
          preset.inForeign1.descriptor.id,
        );

        // using raw power lift as we don't want to combine renders
        // (we need a render to flush the placeholder out)
        expandedMouse.rawPowerLift(
          handle,
          preset.inForeign1.client.borderBox.center,
        );

        // placeholder is gone from home (it got flushed)
        expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(
          false,
        );
      }
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 266, 'column': 6, 'index': 9863}","it('should animate a placeholder closed when no longer dragging over', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 273, 'column': 6, 'index': 10130}","it('should animate a placeholder closed when no longer dragging over', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 292, 'column': 6, 'index': 10854}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 293, 'column': 6, 'index': 10919}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 293, 'column': 6, 'index': 10919}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 299, 'column': 6, 'index': 11121}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 311, 'column': 6, 'index': 11528}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 311, 'column': 6, 'index': 11528}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Duplicate Assert,"{'line': 324, 'column': 6, 'index': 11969}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Eager Test,"{'line': 77, 'column': 13, 'index': 2740}","it('should remove all placeholders if an error occurs while dragging', () => {
  withPoorBoardDimensions((preset) => {
    toDroppableList(preset.droppables).forEach((droppable) => {
      const { container, getByTestId, unmount } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);
      const box0 = preset.inHome1.client.borderBox;

      expandedMouse.powerLift(handle, box0.center);
      expandedMouse.move(handle, droppable.client.borderBox.center);

      expect(isDragging(handle)).toBe(true);
      expect(isOver(handle)).toBe(droppable.descriptor.id);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

      withWarn(() => {
        const event: Event = new Event('error');
        fireEvent(window, event);
      });

      expect(isDragging(handle)).toBe(false);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(false);

      unmount();
    });
  });
})",steel
/test/unit/integration/droppable/placeholder.spec.js,Eager Test,"{'line': 78, 'column': 13, 'index': 2785}","it('should remove all placeholders if an error occurs while dragging', () => {
  withPoorBoardDimensions((preset) => {
    toDroppableList(preset.droppables).forEach((droppable) => {
      const { container, getByTestId, unmount } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);
      const box0 = preset.inHome1.client.borderBox;

      expandedMouse.powerLift(handle, box0.center);
      expandedMouse.move(handle, droppable.client.borderBox.center);

      expect(isDragging(handle)).toBe(true);
      expect(isOver(handle)).toBe(droppable.descriptor.id);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

      withWarn(() => {
        const event: Event = new Event('error');
        fireEvent(window, event);
      });

      expect(isDragging(handle)).toBe(false);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(false);

      unmount();
    });
  });
})",steel
/test/unit/integration/droppable/placeholder.spec.js,Eager Test,"{'line': 86, 'column': 13, 'index': 3040}","it('should remove all placeholders if an error occurs while dragging', () => {
  withPoorBoardDimensions((preset) => {
    toDroppableList(preset.droppables).forEach((droppable) => {
      const { container, getByTestId, unmount } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);
      const box0 = preset.inHome1.client.borderBox;

      expandedMouse.powerLift(handle, box0.center);
      expandedMouse.move(handle, droppable.client.borderBox.center);

      expect(isDragging(handle)).toBe(true);
      expect(isOver(handle)).toBe(droppable.descriptor.id);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

      withWarn(() => {
        const event: Event = new Event('error');
        fireEvent(window, event);
      });

      expect(isDragging(handle)).toBe(false);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(false);

      unmount();
    });
  });
})",steel
/test/unit/integration/droppable/placeholder.spec.js,Eager Test,"{'line': 166, 'column': 13, 'index': 6270}","it('should animate the home placeholder closed after dropping into a foreign list', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

      expandedMouse.startDrop(handle);
      // foreign placeholder remaining in place
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );
      // home placeholder remaining in place
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // gone after drop finished
      expandedMouse.finishDrop(handle);

      // foreign placeholder is now gone
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
      // home placeholder is still around and will now animate closed
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder is now collapsing
      const placeholder: HTMLElement = getPlaceholder(
        preset.home.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // faking a transition end
      fireEvent(placeholder, getTransitionEnd('height'));

      // placeholder is gone
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Eager Test,"{'line': 194, 'column': 29, 'index': 7272}","it('should animate the home placeholder closed after dropping into a foreign list', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

      expandedMouse.startDrop(handle);
      // foreign placeholder remaining in place
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );
      // home placeholder remaining in place
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // gone after drop finished
      expandedMouse.finishDrop(handle);

      // foreign placeholder is now gone
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
      // home placeholder is still around and will now animate closed
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder is now collapsing
      const placeholder: HTMLElement = getPlaceholder(
        preset.home.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // faking a transition end
      fireEvent(placeholder, getTransitionEnd('height'));

      // placeholder is gone
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Eager Test,"{'line': 266, 'column': 13, 'index': 9870}","it('should animate a placeholder closed when no longer dragging over', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Eager Test,"{'line': 273, 'column': 13, 'index': 10137}","it('should animate a placeholder closed when no longer dragging over', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Eager Test,"{'line': 292, 'column': 13, 'index': 10861}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Eager Test,"{'line': 299, 'column': 13, 'index': 11128}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Eager Test,"{'line': 322, 'column': 13, 'index': 11869}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Eager Test,"{'line': 323, 'column': 13, 'index': 11914}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Lazy Test,"{'line': 59, 'column': 13, 'index': 2062}","it('should render a placeholder when dragging over', () => {
  withPoorBoardDimensions((preset) => {
    toDroppableList(preset.droppables).forEach((droppable) => {
      const { container, getByTestId, unmount } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);
      const box0 = preset.inHome1.client.borderBox;

      expandedMouse.powerLift(handle, box0.center);
      expandedMouse.move(handle, droppable.client.borderBox.center);

      expect(isOver(handle)).toBe(droppable.descriptor.id);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

      unmount();
    });
  });
})",steel
/test/unit/integration/droppable/placeholder.spec.js,Lazy Test,"{'line': 77, 'column': 13, 'index': 2740}","it('should remove all placeholders if an error occurs while dragging', () => {
  withPoorBoardDimensions((preset) => {
    toDroppableList(preset.droppables).forEach((droppable) => {
      const { container, getByTestId, unmount } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);
      const box0 = preset.inHome1.client.borderBox;

      expandedMouse.powerLift(handle, box0.center);
      expandedMouse.move(handle, droppable.client.borderBox.center);

      expect(isDragging(handle)).toBe(true);
      expect(isOver(handle)).toBe(droppable.descriptor.id);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

      withWarn(() => {
        const event: Event = new Event('error');
        fireEvent(window, event);
      });

      expect(isDragging(handle)).toBe(false);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(false);

      unmount();
    });
  });
})",steel
/test/unit/integration/droppable/placeholder.spec.js,Lazy Test,"{'line': 78, 'column': 13, 'index': 2785}","it('should remove all placeholders if an error occurs while dragging', () => {
  withPoorBoardDimensions((preset) => {
    toDroppableList(preset.droppables).forEach((droppable) => {
      const { container, getByTestId, unmount } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);
      const box0 = preset.inHome1.client.borderBox;

      expandedMouse.powerLift(handle, box0.center);
      expandedMouse.move(handle, droppable.client.borderBox.center);

      expect(isDragging(handle)).toBe(true);
      expect(isOver(handle)).toBe(droppable.descriptor.id);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

      withWarn(() => {
        const event: Event = new Event('error');
        fireEvent(window, event);
      });

      expect(isDragging(handle)).toBe(false);
      expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(false);

      unmount();
    });
  });
})",steel
/test/unit/integration/droppable/placeholder.spec.js,Lazy Test,"{'line': 106, 'column': 15, 'index': 3781}","it('should always render a placeholder while dragging', () => {
    withPoorBoardDimensions((preset) => {
      toDroppableList(preset.droppables).forEach((droppable) => {
        const { container, getByTestId, unmount } = render(<Board />);
        const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);
        const box0 = preset.inHome1.client.borderBox;

        expandedMouse.powerLift(handle, box0.center);
        expandedMouse.move(handle, droppable.client.borderBox.center);

        // doesn't matter what we are over
        expect(isOver(handle)).toBe(droppable.descriptor.id);
        // there is always a placeholder in home
        expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

        unmount();
      });
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Lazy Test,"{'line': 123, 'column': 15, 'index': 4521}","it('should immediately remove the home placeholder after dropping into any list', () => {
    withPoorBoardDimensions((preset) => {
      toDroppableList(preset.droppables).forEach((droppable) => {
        const { container, getByTestId, unmount } = render(<Board />);
        const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

        expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
        expandedMouse.move(handle, droppable.client.borderBox.center);
        expect(isOver(handle)).toBe(droppable.descriptor.id);

        expandedMouse.startDrop(handle);
        expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(true);

        // placeholder removed straight after drop
        expandedMouse.finishDrop(handle);
        expect(hasPlaceholder(droppable.descriptor.id, container)).toBe(false);

        unmount();
      });
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Lazy Test,"{'line': 144, 'column': 13, 'index': 5324}","it('should immediately remove the home placeholder after dropping nowhere', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, { x: 10000, y: 10000 });
      expect(isOver(handle)).toBe(null);

      // placeholder present when over nothing
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder present when drop started
      expandedMouse.startDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder gone after drop finished
      expandedMouse.finishDrop(handle);
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Lazy Test,"{'line': 166, 'column': 13, 'index': 6270}","it('should animate the home placeholder closed after dropping into a foreign list', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

      expandedMouse.startDrop(handle);
      // foreign placeholder remaining in place
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );
      // home placeholder remaining in place
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // gone after drop finished
      expandedMouse.finishDrop(handle);

      // foreign placeholder is now gone
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
      // home placeholder is still around and will now animate closed
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);

      // placeholder is now collapsing
      const placeholder: HTMLElement = getPlaceholder(
        preset.home.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // faking a transition end
      fireEvent(placeholder, getTransitionEnd('height'));

      // placeholder is gone
      expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(false);
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Lazy Test,"{'line': 209, 'column': 15, 'index': 7881}","it('should flush a home placeholder collapse animation if starting a new drag', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      {
        const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

        expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
        expandedMouse.move(handle, preset.inForeign1.client.borderBox.center);
        expect(isOver(handle)).toBe(preset.foreign.descriptor.id);

        expandedMouse.powerDrop(handle);
        // placeholder still here + animating closed
        expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(true);
        const placeholder: HTMLElement = getPlaceholder(
          preset.home.descriptor.id,
          container,
        );
        // animating height closed
        expect(placeholder.style.height).toBe('0px');
      }
      {
        const handle: HTMLElement = getByTestId(
          preset.inForeign1.descriptor.id,
        );

        // using raw power lift as we don't want to combine renders
        // (we need a render to flush the placeholder out)
        expandedMouse.rawPowerLift(
          handle,
          preset.inForeign1.client.borderBox.center,
        );

        // placeholder is gone from home (it got flushed)
        expect(hasPlaceholder(preset.home.descriptor.id, container)).toBe(
          false,
        );
      }
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Lazy Test,"{'line': 251, 'column': 13, 'index': 9278}","it('should not render a placeholder if not dragging over', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);
      const box0 = preset.inHome1.client.borderBox;

      expandedMouse.powerLift(handle, box0.center);

      expect(isOver(handle)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Lazy Test,"{'line': 266, 'column': 13, 'index': 9870}","it('should animate a placeholder closed when no longer dragging over', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Lazy Test,"{'line': 292, 'column': 13, 'index': 10861}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/placeholder.spec.js,Lazy Test,"{'line': 322, 'column': 13, 'index': 11869}","it('should flush a foreign list collapsing animation if a new drag starts', () => {
    withPoorBoardDimensions((preset) => {
      const { container, getByTestId } = render(<Board />);
      const handle: HTMLElement = getByTestId(preset.inHome1.descriptor.id);

      expandedMouse.powerLift(handle, preset.inHome1.client.borderBox.center);
      expandedMouse.move(handle, preset.foreign.client.borderBox.center);

      expect(isOver(handle)).toBe(preset.foreign.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      // moving back over home
      expandedMouse.move(handle, preset.home.client.borderBox.center);
      expect(isOver(handle)).toBe(preset.home.descriptor.id);

      // foreign placeholder is now animating closed
      const placeholder: HTMLElement = getPlaceholder(
        preset.foreign.descriptor.id,
        container,
      );
      expect(placeholder.style.height).toBe('0px');

      // starting a drop into home
      expandedMouse.startDrop(handle);
      // placeholder still in foreign list
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        true,
      );

      const second: HTMLElement = getByTestId(preset.inHome2.descriptor.id);

      // lifting item 2 while item 1 is dropping
      expandedMouse.rawPowerLift(
        second,
        preset.inHome2.client.borderBox.center,
      );
      expect(isDragging(second)).toBe(true);
      expect(isOver(second)).toBe(preset.home.descriptor.id);
      expect(hasPlaceholder(preset.foreign.descriptor.id, container)).toBe(
        false,
      );
    });
  })",steel
/test/unit/integration/droppable/clone.spec.js,Duplicate Assert,"{'line': 52, 'column': 4, 'index': 1689}","it('should render a dragging item into the container', () => {
  const body = getBodyElement();
  // default location is the body
  {
    const { unmount, getByTestId } = render(<App useClone />);
    simpleLift(keyboard, getByTestId('0'));
    expect(getByTestId('0').parentElement).toBe(body);
    unmount();
  }
  {
    const element: HTMLElement = document.createElement('div');
    body.appendChild(element);
    const { unmount, getByTestId } = render(
      <App useClone getContainerForClone={() => element} />,
    );
    simpleLift(keyboard, getByTestId('0'));
    expect(getByTestId('0').parentElement).toBe(element);
    unmount();
  }
})",steel
/test/unit/integration/droppable/clone.spec.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 2019}","it('should render a dragging item into the container', () => {
  const body = getBodyElement();
  // default location is the body
  {
    const { unmount, getByTestId } = render(<App useClone />);
    simpleLift(keyboard, getByTestId('0'));
    expect(getByTestId('0').parentElement).toBe(body);
    unmount();
  }
  {
    const element: HTMLElement = document.createElement('div');
    body.appendChild(element);
    const { unmount, getByTestId } = render(
      <App useClone getContainerForClone={() => element} />,
    );
    simpleLift(keyboard, getByTestId('0'));
    expect(getByTestId('0').parentElement).toBe(element);
    unmount();
  }
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 28, 'column': 4, 'index': 933}","it('should no longer render the original draggable while dragging', () => {
  const { getByTestId } = render(<App useClone />);

  // doing this in a loop to ensure that multiple reorders is fine
  Array.from({ length: 4 }).forEach(() => {
    const beforeLift = getByTestId('0');
    simpleLift(keyboard, beforeLift);
    expect(isClone(beforeLift)).toBe(false);

    // after lift there is still only one item - but it is different
    const clone = getByTestId('0');
    expect(clone).not.toBe(beforeLift);
    expect(isDragging(clone)).toBe(true);
    expect(isClone(clone)).toBe(true);

    keyboard.drop(clone);

    const finished = getByTestId('0');
    expect(finished).not.toBe(clone);
    expect(isClone(finished)).toBe(false);
    expect(isDragging(finished)).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 29, 'column': 11, 'index': 978}","it('should no longer render the original draggable while dragging', () => {
  const { getByTestId } = render(<App useClone />);

  // doing this in a loop to ensure that multiple reorders is fine
  Array.from({ length: 4 }).forEach(() => {
    const beforeLift = getByTestId('0');
    simpleLift(keyboard, beforeLift);
    expect(isClone(beforeLift)).toBe(false);

    // after lift there is still only one item - but it is different
    const clone = getByTestId('0');
    expect(clone).not.toBe(beforeLift);
    expect(isDragging(clone)).toBe(true);
    expect(isClone(clone)).toBe(true);

    keyboard.drop(clone);

    const finished = getByTestId('0');
    expect(finished).not.toBe(clone);
    expect(isClone(finished)).toBe(false);
    expect(isDragging(finished)).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 34, 'column': 11, 'index': 1169}","it('should no longer render the original draggable while dragging', () => {
  const { getByTestId } = render(<App useClone />);

  // doing this in a loop to ensure that multiple reorders is fine
  Array.from({ length: 4 }).forEach(() => {
    const beforeLift = getByTestId('0');
    simpleLift(keyboard, beforeLift);
    expect(isClone(beforeLift)).toBe(false);

    // after lift there is still only one item - but it is different
    const clone = getByTestId('0');
    expect(clone).not.toBe(beforeLift);
    expect(isDragging(clone)).toBe(true);
    expect(isClone(clone)).toBe(true);

    keyboard.drop(clone);

    const finished = getByTestId('0');
    expect(finished).not.toBe(clone);
    expect(isClone(finished)).toBe(false);
    expect(isDragging(finished)).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 35, 'column': 11, 'index': 1211}","it('should no longer render the original draggable while dragging', () => {
  const { getByTestId } = render(<App useClone />);

  // doing this in a loop to ensure that multiple reorders is fine
  Array.from({ length: 4 }).forEach(() => {
    const beforeLift = getByTestId('0');
    simpleLift(keyboard, beforeLift);
    expect(isClone(beforeLift)).toBe(false);

    // after lift there is still only one item - but it is different
    const clone = getByTestId('0');
    expect(clone).not.toBe(beforeLift);
    expect(isDragging(clone)).toBe(true);
    expect(isClone(clone)).toBe(true);

    keyboard.drop(clone);

    const finished = getByTestId('0');
    expect(finished).not.toBe(clone);
    expect(isClone(finished)).toBe(false);
    expect(isDragging(finished)).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 41, 'column': 11, 'index': 1355}","it('should no longer render the original draggable while dragging', () => {
  const { getByTestId } = render(<App useClone />);

  // doing this in a loop to ensure that multiple reorders is fine
  Array.from({ length: 4 }).forEach(() => {
    const beforeLift = getByTestId('0');
    simpleLift(keyboard, beforeLift);
    expect(isClone(beforeLift)).toBe(false);

    // after lift there is still only one item - but it is different
    const clone = getByTestId('0');
    expect(clone).not.toBe(beforeLift);
    expect(isDragging(clone)).toBe(true);
    expect(isClone(clone)).toBe(true);

    keyboard.drop(clone);

    const finished = getByTestId('0');
    expect(finished).not.toBe(clone);
    expect(isClone(finished)).toBe(false);
    expect(isDragging(finished)).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 42, 'column': 11, 'index': 1398}","it('should no longer render the original draggable while dragging', () => {
  const { getByTestId } = render(<App useClone />);

  // doing this in a loop to ensure that multiple reorders is fine
  Array.from({ length: 4 }).forEach(() => {
    const beforeLift = getByTestId('0');
    simpleLift(keyboard, beforeLift);
    expect(isClone(beforeLift)).toBe(false);

    // after lift there is still only one item - but it is different
    const clone = getByTestId('0');
    expect(clone).not.toBe(beforeLift);
    expect(isDragging(clone)).toBe(true);
    expect(isClone(clone)).toBe(true);

    keyboard.drop(clone);

    const finished = getByTestId('0');
    expect(finished).not.toBe(clone);
    expect(isClone(finished)).toBe(false);
    expect(isDragging(finished)).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 51, 'column': 4, 'index': 1645}","it('should render a dragging item into the container', () => {
  const body = getBodyElement();
  // default location is the body
  {
    const { unmount, getByTestId } = render(<App useClone />);
    simpleLift(keyboard, getByTestId('0'));
    expect(getByTestId('0').parentElement).toBe(body);
    unmount();
  }
  {
    const element: HTMLElement = document.createElement('div');
    body.appendChild(element);
    const { unmount, getByTestId } = render(
      <App useClone getContainerForClone={() => element} />,
    );
    simpleLift(keyboard, getByTestId('0'));
    expect(getByTestId('0').parentElement).toBe(element);
    unmount();
  }
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 61, 'column': 4, 'index': 1975}","it('should render a dragging item into the container', () => {
  const body = getBodyElement();
  // default location is the body
  {
    const { unmount, getByTestId } = render(<App useClone />);
    simpleLift(keyboard, getByTestId('0'));
    expect(getByTestId('0').parentElement).toBe(body);
    unmount();
  }
  {
    const element: HTMLElement = document.createElement('div');
    body.appendChild(element);
    const { unmount, getByTestId } = render(
      <App useClone getContainerForClone={() => element} />,
    );
    simpleLift(keyboard, getByTestId('0'));
    expect(getByTestId('0').parentElement).toBe(element);
    unmount();
  }
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 72, 'column': 2, 'index': 2315}","it('should give the clone the starting location', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);
  const { getByTestId } = render(<App renderItem={renderItem} useClone />);

  simpleLift(keyboard, getByTestId('1'));

  const last: ?Call = getLast(getCallsFor('1', spy));
  invariant(last);
  const expected: DraggableStateSnapshot = {
    isClone: true,
    isDragging: true,
    isDropAnimating: false,
    dropAnimation: null,
    combineTargetFor: null,
    combineWith: null,
    draggingOver: 'droppable',
    mode: 'SNAP',
  };
  expect(last[1]).toEqual(expected);
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 74, 'column': 22, 'index': 2378}","it('should give the clone the starting location', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);
  const { getByTestId } = render(<App renderItem={renderItem} useClone />);

  simpleLift(keyboard, getByTestId('1'));

  const last: ?Call = getLast(getCallsFor('1', spy));
  invariant(last);
  const expected: DraggableStateSnapshot = {
    isClone: true,
    isDragging: true,
    isDropAnimating: false,
    dropAnimation: null,
    combineTargetFor: null,
    combineWith: null,
    draggingOver: 'droppable',
    mode: 'SNAP',
  };
  expect(last[1]).toEqual(expected);
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 75, 'column': 2, 'index': 2412}","it('should give the clone the starting location', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);
  const { getByTestId } = render(<App renderItem={renderItem} useClone />);

  simpleLift(keyboard, getByTestId('1'));

  const last: ?Call = getLast(getCallsFor('1', spy));
  invariant(last);
  const expected: DraggableStateSnapshot = {
    isClone: true,
    isDragging: true,
    isDropAnimating: false,
    dropAnimation: null,
    combineTargetFor: null,
    combineWith: null,
    draggingOver: 'droppable',
    mode: 'SNAP',
  };
  expect(last[1]).toEqual(expected);
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 99, 'column': 11, 'index': 3183}","it('should allow reordering other items when dropping', () => {
  withPoorDimensionMocks((preset) => {
    const { getByTestId } = render(<App useClone />);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    expandedMouse.powerLift(getByTestId('0'), box0.center);

    const clone: HTMLElement = getByTestId('0');
    expect(isClone(clone)).toBe(true);
    expect(isDragging(clone)).toBe(true);

    // move item 0 to index 1
    expandedMouse.move(clone, box1.center);

    // drop started, but still occurring
    expandedMouse.startDrop(clone);
    expect(isDropAnimating(clone)).toBe(true);

    // starting a new drag with item 1 (which is in index 0 visually now)
    // using box0.center as the lifting point
    // we are relying on a sync render from a dispatched action
    // act(() => {}); is joining the two into one update which is
    // causing unexpected mounting behaviour
    withError(() => {
      expandedMouse.rawPowerLift(getByTestId('1'), box0.center);
    });

    expect(isDragging(getByTestId('1'))).toBe(true);
    expect(isDragging(getByTestId('0'))).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 100, 'column': 11, 'index': 3222}","it('should allow reordering other items when dropping', () => {
  withPoorDimensionMocks((preset) => {
    const { getByTestId } = render(<App useClone />);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    expandedMouse.powerLift(getByTestId('0'), box0.center);

    const clone: HTMLElement = getByTestId('0');
    expect(isClone(clone)).toBe(true);
    expect(isDragging(clone)).toBe(true);

    // move item 0 to index 1
    expandedMouse.move(clone, box1.center);

    // drop started, but still occurring
    expandedMouse.startDrop(clone);
    expect(isDropAnimating(clone)).toBe(true);

    // starting a new drag with item 1 (which is in index 0 visually now)
    // using box0.center as the lifting point
    // we are relying on a sync render from a dispatched action
    // act(() => {}); is joining the two into one update which is
    // causing unexpected mounting behaviour
    withError(() => {
      expandedMouse.rawPowerLift(getByTestId('1'), box0.center);
    });

    expect(isDragging(getByTestId('1'))).toBe(true);
    expect(isDragging(getByTestId('0'))).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 107, 'column': 11, 'index': 3417}","it('should allow reordering other items when dropping', () => {
  withPoorDimensionMocks((preset) => {
    const { getByTestId } = render(<App useClone />);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    expandedMouse.powerLift(getByTestId('0'), box0.center);

    const clone: HTMLElement = getByTestId('0');
    expect(isClone(clone)).toBe(true);
    expect(isDragging(clone)).toBe(true);

    // move item 0 to index 1
    expandedMouse.move(clone, box1.center);

    // drop started, but still occurring
    expandedMouse.startDrop(clone);
    expect(isDropAnimating(clone)).toBe(true);

    // starting a new drag with item 1 (which is in index 0 visually now)
    // using box0.center as the lifting point
    // we are relying on a sync render from a dispatched action
    // act(() => {}); is joining the two into one update which is
    // causing unexpected mounting behaviour
    withError(() => {
      expandedMouse.rawPowerLift(getByTestId('1'), box0.center);
    });

    expect(isDragging(getByTestId('1'))).toBe(true);
    expect(isDragging(getByTestId('0'))).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 118, 'column': 11, 'index': 3856}","it('should allow reordering other items when dropping', () => {
  withPoorDimensionMocks((preset) => {
    const { getByTestId } = render(<App useClone />);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    expandedMouse.powerLift(getByTestId('0'), box0.center);

    const clone: HTMLElement = getByTestId('0');
    expect(isClone(clone)).toBe(true);
    expect(isDragging(clone)).toBe(true);

    // move item 0 to index 1
    expandedMouse.move(clone, box1.center);

    // drop started, but still occurring
    expandedMouse.startDrop(clone);
    expect(isDropAnimating(clone)).toBe(true);

    // starting a new drag with item 1 (which is in index 0 visually now)
    // using box0.center as the lifting point
    // we are relying on a sync render from a dispatched action
    // act(() => {}); is joining the two into one update which is
    // causing unexpected mounting behaviour
    withError(() => {
      expandedMouse.rawPowerLift(getByTestId('1'), box0.center);
    });

    expect(isDragging(getByTestId('1'))).toBe(true);
    expect(isDragging(getByTestId('0'))).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Eager Test,"{'line': 119, 'column': 11, 'index': 3909}","it('should allow reordering other items when dropping', () => {
  withPoorDimensionMocks((preset) => {
    const { getByTestId } = render(<App useClone />);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    expandedMouse.powerLift(getByTestId('0'), box0.center);

    const clone: HTMLElement = getByTestId('0');
    expect(isClone(clone)).toBe(true);
    expect(isDragging(clone)).toBe(true);

    // move item 0 to index 1
    expandedMouse.move(clone, box1.center);

    // drop started, but still occurring
    expandedMouse.startDrop(clone);
    expect(isDropAnimating(clone)).toBe(true);

    // starting a new drag with item 1 (which is in index 0 visually now)
    // using box0.center as the lifting point
    // we are relying on a sync render from a dispatched action
    // act(() => {}); is joining the two into one update which is
    // causing unexpected mounting behaviour
    withError(() => {
      expandedMouse.rawPowerLift(getByTestId('1'), box0.center);
    });

    expect(isDragging(getByTestId('1'))).toBe(true);
    expect(isDragging(getByTestId('0'))).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Lazy Test,"{'line': 28, 'column': 4, 'index': 933}","it('should no longer render the original draggable while dragging', () => {
  const { getByTestId } = render(<App useClone />);

  // doing this in a loop to ensure that multiple reorders is fine
  Array.from({ length: 4 }).forEach(() => {
    const beforeLift = getByTestId('0');
    simpleLift(keyboard, beforeLift);
    expect(isClone(beforeLift)).toBe(false);

    // after lift there is still only one item - but it is different
    const clone = getByTestId('0');
    expect(clone).not.toBe(beforeLift);
    expect(isDragging(clone)).toBe(true);
    expect(isClone(clone)).toBe(true);

    keyboard.drop(clone);

    const finished = getByTestId('0');
    expect(finished).not.toBe(clone);
    expect(isClone(finished)).toBe(false);
    expect(isDragging(finished)).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Lazy Test,"{'line': 29, 'column': 11, 'index': 978}","it('should no longer render the original draggable while dragging', () => {
  const { getByTestId } = render(<App useClone />);

  // doing this in a loop to ensure that multiple reorders is fine
  Array.from({ length: 4 }).forEach(() => {
    const beforeLift = getByTestId('0');
    simpleLift(keyboard, beforeLift);
    expect(isClone(beforeLift)).toBe(false);

    // after lift there is still only one item - but it is different
    const clone = getByTestId('0');
    expect(clone).not.toBe(beforeLift);
    expect(isDragging(clone)).toBe(true);
    expect(isClone(clone)).toBe(true);

    keyboard.drop(clone);

    const finished = getByTestId('0');
    expect(finished).not.toBe(clone);
    expect(isClone(finished)).toBe(false);
    expect(isDragging(finished)).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Lazy Test,"{'line': 34, 'column': 11, 'index': 1169}","it('should no longer render the original draggable while dragging', () => {
  const { getByTestId } = render(<App useClone />);

  // doing this in a loop to ensure that multiple reorders is fine
  Array.from({ length: 4 }).forEach(() => {
    const beforeLift = getByTestId('0');
    simpleLift(keyboard, beforeLift);
    expect(isClone(beforeLift)).toBe(false);

    // after lift there is still only one item - but it is different
    const clone = getByTestId('0');
    expect(clone).not.toBe(beforeLift);
    expect(isDragging(clone)).toBe(true);
    expect(isClone(clone)).toBe(true);

    keyboard.drop(clone);

    const finished = getByTestId('0');
    expect(finished).not.toBe(clone);
    expect(isClone(finished)).toBe(false);
    expect(isDragging(finished)).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Lazy Test,"{'line': 51, 'column': 4, 'index': 1645}","it('should render a dragging item into the container', () => {
  const body = getBodyElement();
  // default location is the body
  {
    const { unmount, getByTestId } = render(<App useClone />);
    simpleLift(keyboard, getByTestId('0'));
    expect(getByTestId('0').parentElement).toBe(body);
    unmount();
  }
  {
    const element: HTMLElement = document.createElement('div');
    body.appendChild(element);
    const { unmount, getByTestId } = render(
      <App useClone getContainerForClone={() => element} />,
    );
    simpleLift(keyboard, getByTestId('0'));
    expect(getByTestId('0').parentElement).toBe(element);
    unmount();
  }
})",steel
/test/unit/integration/droppable/clone.spec.js,Lazy Test,"{'line': 72, 'column': 2, 'index': 2315}","it('should give the clone the starting location', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);
  const { getByTestId } = render(<App renderItem={renderItem} useClone />);

  simpleLift(keyboard, getByTestId('1'));

  const last: ?Call = getLast(getCallsFor('1', spy));
  invariant(last);
  const expected: DraggableStateSnapshot = {
    isClone: true,
    isDragging: true,
    isDropAnimating: false,
    dropAnimation: null,
    combineTargetFor: null,
    combineWith: null,
    draggingOver: 'droppable',
    mode: 'SNAP',
  };
  expect(last[1]).toEqual(expected);
})",steel
/test/unit/integration/droppable/clone.spec.js,Lazy Test,"{'line': 99, 'column': 11, 'index': 3183}","it('should allow reordering other items when dropping', () => {
  withPoorDimensionMocks((preset) => {
    const { getByTestId } = render(<App useClone />);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    expandedMouse.powerLift(getByTestId('0'), box0.center);

    const clone: HTMLElement = getByTestId('0');
    expect(isClone(clone)).toBe(true);
    expect(isDragging(clone)).toBe(true);

    // move item 0 to index 1
    expandedMouse.move(clone, box1.center);

    // drop started, but still occurring
    expandedMouse.startDrop(clone);
    expect(isDropAnimating(clone)).toBe(true);

    // starting a new drag with item 1 (which is in index 0 visually now)
    // using box0.center as the lifting point
    // we are relying on a sync render from a dispatched action
    // act(() => {}); is joining the two into one update which is
    // causing unexpected mounting behaviour
    withError(() => {
      expandedMouse.rawPowerLift(getByTestId('1'), box0.center);
    });

    expect(isDragging(getByTestId('1'))).toBe(true);
    expect(isDragging(getByTestId('0'))).toBe(false);
  });
})",steel
/test/unit/integration/droppable/clone.spec.js,Lazy Test,"{'line': 100, 'column': 11, 'index': 3222}","it('should allow reordering other items when dropping', () => {
  withPoorDimensionMocks((preset) => {
    const { getByTestId } = render(<App useClone />);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    expandedMouse.powerLift(getByTestId('0'), box0.center);

    const clone: HTMLElement = getByTestId('0');
    expect(isClone(clone)).toBe(true);
    expect(isDragging(clone)).toBe(true);

    // move item 0 to index 1
    expandedMouse.move(clone, box1.center);

    // drop started, but still occurring
    expandedMouse.startDrop(clone);
    expect(isDropAnimating(clone)).toBe(true);

    // starting a new drag with item 1 (which is in index 0 visually now)
    // using box0.center as the lifting point
    // we are relying on a sync render from a dispatched action
    // act(() => {}); is joining the two into one update which is
    // causing unexpected mounting behaviour
    withError(() => {
      expandedMouse.rawPowerLift(getByTestId('1'), box0.center);
    });

    expect(isDragging(getByTestId('1'))).toBe(true);
    expect(isDragging(getByTestId('0'))).toBe(false);
  });
})",steel
/test/unit/integration/draggable/validation.spec.js,Conditional Test Logic,"{'line': 55, 'column': 28, 'index': 1441}","it('should log an error if draggableId is not a string', () => {
  [1, undefined, false, {}].forEach((value: mixed) => {
    const { unmount } = render(
      <WithCustomProps draggableId={value} index={0} />,
    );

    expect(error).toHaveBeenCalled();

    unmount();
    error.mockClear();
  });
})",steel
/test/unit/integration/draggable/validation.spec.js,Conditional Test Logic,"{'line': 68, 'column': 36, 'index': 1751}","it('should log an error if index is not an integer', () => {
  ['1', 1.33, undefined, false, {}].forEach((value: mixed) => {
    const { unmount } = render(
      <WithCustomProps draggableId=""draggable"" index={value} />,
    );

    expect(error).toHaveBeenCalled();

    unmount();
    error.mockClear();
  });
})",steel
/test/unit/integration/draggable/resting.spec.js,Magic Number,"{'line': 29, 'column': 33, 'index': 858}","it('should have a resting snapshot', () => {
  const snapshotSpy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(snapshotSpy);

  render(<App renderItem={renderItem} />);

  const snapshots = getSnapshotsFor('0', snapshotSpy);
  expect(snapshots).toHaveLength(1);
  expect(snapshots[0]).toEqual(atRest);
})",steel
/test/unit/integration/draggable/resting.spec.js,Magic Number,"{'line': 53, 'column': 33, 'index': 1515}","it('should be provided with its rubric', () => {
  const watcher = jest.fn();
  const items = Array.from({ length: 3 }, (v, k): Item => ({
    id: `${k}`,
  }));
  const renderItem: RenderItem = renderItemAndSpy(watcher);

  render(<App renderItem={renderItem} items={items} />);

  items.forEach((item: Item, index: number) => {
    const expected: DraggableRubric = {
      draggableId: item.id,
      type: 'DEFAULT',
      source: {
        droppableId: 'droppable',
        index,
      },
    };
    const rubrics: DraggableRubric[] = getRubricsFor(item.id, watcher);

    expect(rubrics).toHaveLength(1);
    expect(rubrics[0]).toEqual(expected);
  });
})",steel
/test/unit/integration/draggable/portal.spec.js,Conditional Test Logic,"{'line': 37, 'column': 2, 'index': 954}",Unknown,steel
/test/unit/integration/draggable/portal.spec.js,Eager Test,"{'line': 50, 'column': 9, 'index': 1314}","it('should allow consumers to use their own portal', () => {
  const { getByTestId } = render(<App renderItem={renderItem} />);
  const before: HTMLElement = getByTestId('0');

  // not in portal yet
  expect(before.parentElement).not.toBe(portal);
  expect(isDragging(before)).toBe(false);

  // moved to portal after lift
  simpleLift(mouse, before);
  const inPortal: HTMLElement = getByTestId('0');
  expect(inPortal.parentElement).toBe(portal);
  expect(before).not.toBe(inPortal);
  expect(isDragging(inPortal)).toBe(true);

  // out of portal after drop
  mouse.drop(inPortal);
  const after: HTMLElement = getByTestId('0');
  expect(after.parentElement).not.toBe(portal);
  expect(after).not.toBe(inPortal);
  expect(isDragging(after)).toBe(false);
})",steel
/test/unit/integration/draggable/portal.spec.js,Eager Test,"{'line': 53, 'column': 2, 'index': 1382}","it('should allow consumers to use their own portal', () => {
  const { getByTestId } = render(<App renderItem={renderItem} />);
  const before: HTMLElement = getByTestId('0');

  // not in portal yet
  expect(before.parentElement).not.toBe(portal);
  expect(isDragging(before)).toBe(false);

  // moved to portal after lift
  simpleLift(mouse, before);
  const inPortal: HTMLElement = getByTestId('0');
  expect(inPortal.parentElement).toBe(portal);
  expect(before).not.toBe(inPortal);
  expect(isDragging(inPortal)).toBe(true);

  // out of portal after drop
  mouse.drop(inPortal);
  const after: HTMLElement = getByTestId('0');
  expect(after.parentElement).not.toBe(portal);
  expect(after).not.toBe(inPortal);
  expect(isDragging(after)).toBe(false);
})",steel
/test/unit/integration/draggable/portal.spec.js,Eager Test,"{'line': 57, 'column': 9, 'index': 1552}","it('should allow consumers to use their own portal', () => {
  const { getByTestId } = render(<App renderItem={renderItem} />);
  const before: HTMLElement = getByTestId('0');

  // not in portal yet
  expect(before.parentElement).not.toBe(portal);
  expect(isDragging(before)).toBe(false);

  // moved to portal after lift
  simpleLift(mouse, before);
  const inPortal: HTMLElement = getByTestId('0');
  expect(inPortal.parentElement).toBe(portal);
  expect(before).not.toBe(inPortal);
  expect(isDragging(inPortal)).toBe(true);

  // out of portal after drop
  mouse.drop(inPortal);
  const after: HTMLElement = getByTestId('0');
  expect(after.parentElement).not.toBe(portal);
  expect(after).not.toBe(inPortal);
  expect(isDragging(after)).toBe(false);
})",steel
/test/unit/integration/draggable/portal.spec.js,Eager Test,"{'line': 64, 'column': 9, 'index': 1781}","it('should allow consumers to use their own portal', () => {
  const { getByTestId } = render(<App renderItem={renderItem} />);
  const before: HTMLElement = getByTestId('0');

  // not in portal yet
  expect(before.parentElement).not.toBe(portal);
  expect(isDragging(before)).toBe(false);

  // moved to portal after lift
  simpleLift(mouse, before);
  const inPortal: HTMLElement = getByTestId('0');
  expect(inPortal.parentElement).toBe(portal);
  expect(before).not.toBe(inPortal);
  expect(isDragging(inPortal)).toBe(true);

  // out of portal after drop
  mouse.drop(inPortal);
  const after: HTMLElement = getByTestId('0');
  expect(after.parentElement).not.toBe(portal);
  expect(after).not.toBe(inPortal);
  expect(isDragging(after)).toBe(false);
})",steel
/test/unit/integration/draggable/moving-out-of-the-way.spec.js,Duplicate Assert,"{'line': 33, 'column': 4, 'index': 1078}","it('should move out of the way when requested', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem = renderItemAndSpy(spy);
    const { getByText } = render(<App renderItem={renderItem} />);
    const before: HTMLElement = getByText('item: 0');
    const critical: HTMLElement = getByText('item: 1');
    const after: HTMLElement = getByText('item: 2');
    const criticalBox = preset.inHome2.client.borderBox;
    const afterBox = preset.inHome3.client.borderBox;

    expandedMouse.powerLift(critical, criticalBox.center);
    expect(isDragging(critical)).toBe(true);

    // before critical
    expect(before.style.transform).toBe('');

    // no movement yet so no transform
    expect(critical.style.transform).toBe('');

    // after critical is moved forward
    expect(after.style.transform).toBe(
      `translate(0px, ${preset.inHome2.displaceBy.y}px)`,
    );

    expandedMouse.move(critical, afterBox.center);

    // still not moved
    expect(after.style.transform).toBe('');

    // critical has now moved
    expect(critical.style.transform.startsWith('translate')).toBe(true);

    // after no longer displaced (moved backwards)
    expect(after.style.transform).toBe('');
  });
})",steel
/test/unit/integration/draggable/moving-out-of-the-way.spec.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1259}","it('should move out of the way when requested', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem = renderItemAndSpy(spy);
    const { getByText } = render(<App renderItem={renderItem} />);
    const before: HTMLElement = getByText('item: 0');
    const critical: HTMLElement = getByText('item: 1');
    const after: HTMLElement = getByText('item: 2');
    const criticalBox = preset.inHome2.client.borderBox;
    const afterBox = preset.inHome3.client.borderBox;

    expandedMouse.powerLift(critical, criticalBox.center);
    expect(isDragging(critical)).toBe(true);

    // before critical
    expect(before.style.transform).toBe('');

    // no movement yet so no transform
    expect(critical.style.transform).toBe('');

    // after critical is moved forward
    expect(after.style.transform).toBe(
      `translate(0px, ${preset.inHome2.displaceBy.y}px)`,
    );

    expandedMouse.move(critical, afterBox.center);

    // still not moved
    expect(after.style.transform).toBe('');

    // critical has now moved
    expect(critical.style.transform.startsWith('translate')).toBe(true);

    // after no longer displaced (moved backwards)
    expect(after.style.transform).toBe('');
  });
})",steel
/test/unit/integration/draggable/moving-out-of-the-way.spec.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1259}","it('should move out of the way when requested', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem = renderItemAndSpy(spy);
    const { getByText } = render(<App renderItem={renderItem} />);
    const before: HTMLElement = getByText('item: 0');
    const critical: HTMLElement = getByText('item: 1');
    const after: HTMLElement = getByText('item: 2');
    const criticalBox = preset.inHome2.client.borderBox;
    const afterBox = preset.inHome3.client.borderBox;

    expandedMouse.powerLift(critical, criticalBox.center);
    expect(isDragging(critical)).toBe(true);

    // before critical
    expect(before.style.transform).toBe('');

    // no movement yet so no transform
    expect(critical.style.transform).toBe('');

    // after critical is moved forward
    expect(after.style.transform).toBe(
      `translate(0px, ${preset.inHome2.displaceBy.y}px)`,
    );

    expandedMouse.move(critical, afterBox.center);

    // still not moved
    expect(after.style.transform).toBe('');

    // critical has now moved
    expect(critical.style.transform.startsWith('translate')).toBe(true);

    // after no longer displaced (moved backwards)
    expect(after.style.transform).toBe('');
  });
})",steel
/test/unit/integration/draggable/moving-out-of-the-way.spec.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1459}","it('should move out of the way when requested', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem = renderItemAndSpy(spy);
    const { getByText } = render(<App renderItem={renderItem} />);
    const before: HTMLElement = getByText('item: 0');
    const critical: HTMLElement = getByText('item: 1');
    const after: HTMLElement = getByText('item: 2');
    const criticalBox = preset.inHome2.client.borderBox;
    const afterBox = preset.inHome3.client.borderBox;

    expandedMouse.powerLift(critical, criticalBox.center);
    expect(isDragging(critical)).toBe(true);

    // before critical
    expect(before.style.transform).toBe('');

    // no movement yet so no transform
    expect(critical.style.transform).toBe('');

    // after critical is moved forward
    expect(after.style.transform).toBe(
      `translate(0px, ${preset.inHome2.displaceBy.y}px)`,
    );

    expandedMouse.move(critical, afterBox.center);

    // still not moved
    expect(after.style.transform).toBe('');

    // critical has now moved
    expect(critical.style.transform.startsWith('translate')).toBe(true);

    // after no longer displaced (moved backwards)
    expect(after.style.transform).toBe('');
  });
})",steel
/test/unit/integration/draggable/moving-out-of-the-way.spec.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1459}","it('should move out of the way when requested', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem = renderItemAndSpy(spy);
    const { getByText } = render(<App renderItem={renderItem} />);
    const before: HTMLElement = getByText('item: 0');
    const critical: HTMLElement = getByText('item: 1');
    const after: HTMLElement = getByText('item: 2');
    const criticalBox = preset.inHome2.client.borderBox;
    const afterBox = preset.inHome3.client.borderBox;

    expandedMouse.powerLift(critical, criticalBox.center);
    expect(isDragging(critical)).toBe(true);

    // before critical
    expect(before.style.transform).toBe('');

    // no movement yet so no transform
    expect(critical.style.transform).toBe('');

    // after critical is moved forward
    expect(after.style.transform).toBe(
      `translate(0px, ${preset.inHome2.displaceBy.y}px)`,
    );

    expandedMouse.move(critical, afterBox.center);

    // still not moved
    expect(after.style.transform).toBe('');

    // critical has now moved
    expect(critical.style.transform.startsWith('translate')).toBe(true);

    // after no longer displaced (moved backwards)
    expect(after.style.transform).toBe('');
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 40, 'column': 2, 'index': 1029}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 41, 'column': 2, 'index': 1075}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 45, 'column': 2, 'index': 1209}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 50, 'column': 2, 'index': 1421}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 52, 'column': 2, 'index': 1492}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 54, 'column': 2, 'index': 1565}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 63, 'column': 2, 'index': 1874}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 67, 'column': 2, 'index': 1998}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 142, 'column': 6, 'index': 4142}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 142, 'column': 6, 'index': 4142}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 143, 'column': 6, 'index': 4184}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 144, 'column': 6, 'index': 4252}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 145, 'column': 6, 'index': 4320}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 164, 'column': 6, 'index': 4828}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 164, 'column': 6, 'index': 4828}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 165, 'column': 6, 'index': 4870}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 166, 'column': 6, 'index': 4915}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 167, 'column': 6, 'index': 4963}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 183, 'column': 2, 'index': 5377}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 183, 'column': 2, 'index': 5377}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 191, 'column': 2, 'index': 5595}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 191, 'column': 2, 'index': 5595}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 203, 'column': 2, 'index': 5960}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 203, 'column': 2, 'index': 5960}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 204, 'column': 2, 'index': 6001}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 204, 'column': 2, 'index': 6001}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 207, 'column': 2, 'index': 6071}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 207, 'column': 2, 'index': 6071}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 208, 'column': 2, 'index': 6112}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 208, 'column': 2, 'index': 6112}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 211, 'column': 2, 'index': 6189}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 211, 'column': 2, 'index': 6189}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 212, 'column': 2, 'index': 6230}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 215, 'column': 2, 'index': 6318}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 216, 'column': 2, 'index': 6360}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Duplicate Assert,"{'line': 216, 'column': 2, 'index': 6360}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 33, 'column': 2, 'index': 888}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 34, 'column': 9, 'index': 924}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 40, 'column': 9, 'index': 1036}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 49, 'column': 20, 'index': 1398}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 50, 'column': 9, 'index': 1428}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 65, 'column': 2, 'index': 1928}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 66, 'column': 9, 'index': 1964}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 73, 'column': 9, 'index': 2129}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 75, 'column': 19, 'index': 2186}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 113, 'column': 11, 'index': 3284}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 117, 'column': 11, 'index': 3398}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 122, 'column': 23, 'index': 3499}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 153, 'column': 23, 'index': 4509}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 176, 'column': 2, 'index': 5236}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 177, 'column': 9, 'index': 5272}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 183, 'column': 9, 'index': 5384}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 185, 'column': 23, 'index': 5445}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 191, 'column': 9, 'index': 5602}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 199, 'column': 20, 'index': 5873}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 202, 'column': 20, 'index': 5937}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 203, 'column': 9, 'index': 5967}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 204, 'column': 9, 'index': 6008}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 207, 'column': 9, 'index': 6078}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 208, 'column': 9, 'index': 6119}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 211, 'column': 9, 'index': 6196}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 212, 'column': 9, 'index': 6237}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 214, 'column': 20, 'index': 6295}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 215, 'column': 9, 'index': 6325}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Eager Test,"{'line': 216, 'column': 9, 'index': 6367}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 33, 'column': 2, 'index': 888}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 34, 'column': 9, 'index': 924}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 40, 'column': 9, 'index': 1036}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 49, 'column': 20, 'index': 1398}","it('should animate a drop to the required offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);
  expect(handle.style.position).toBe('fixed');

  // moving back to origin so no transform
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.drop(timings.minDropTime));
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dropAnimating}`);

  // completing drop
  fireEvent(handle, getTransitionEnd());
  expect(isDropAnimating(handle)).toBe(false);
  // transition cleared
  expect(handle.style.transition).toBe('');
  // position: fixed cleared
  expect(handle.style.position).toBe('');
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 65, 'column': 2, 'index': 1928}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 66, 'column': 9, 'index': 1964}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 73, 'column': 9, 'index': 2129}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 75, 'column': 19, 'index': 2186}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 113, 'column': 11, 'index': 3284}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 122, 'column': 23, 'index': 3499}","it('should animate scale and opacity when combining', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box0 = preset.inHome1.client.borderBox;
    const box1 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    // lift
    expandedMouse.powerLift(handle, box0.center);
    expect(isDragging(handle)).toBe(true);

    // move into combine
    expandedMouse.move(handle, box1.center);
    expect(isCombining(handle)).toBe(true);

    expandedMouse.startDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const dropping: DropAnimation = {
        // force cast to number :D
        duration: ((expect.any(Number): any): number),
        curve: curves.drop,
        // will be moving to center
        moveTo: ((expect.any(Object): any): Position),
        opacity: 0,
        scale: combine.scale.drop,
      };
      const expected: DraggableStateSnapshot = {
        isDragging: true,
        isDropAnimating: true,
        isClone: false,
        dropAnimation: dropping,
        draggingOver: 'droppable',
        combineWith: '1',
        combineTargetFor: null,
        mode: 'FLUID',
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe(`${combine.opacity.drop}`);
      expect(handle.style.transition).toBe(transitions.drop(0.33));
      expect(handle.style.transform).toEqual(
        expect.stringContaining(`scale(${combine.scale.drop})`),
      );
    }

    expandedMouse.finishDrop(handle);

    {
      const snapshot = getLast(getSnapshotsFor('0', spy));
      const expected: DraggableStateSnapshot = {
        isDragging: false,
        isDropAnimating: false,
        isClone: false,
        dropAnimation: null,
        draggingOver: null,
        combineWith: null,
        combineTargetFor: null,
        mode: null,
      };
      expect(snapshot).toEqual(expected);
      expect(handle.style.opacity).toBe('');
      expect(handle.style.transition).toBe('');
      expect(handle.style.transform).toEqual('');
    }
  });
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 176, 'column': 2, 'index': 5236}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 177, 'column': 9, 'index': 5272}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 183, 'column': 9, 'index': 5384}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 185, 'column': 23, 'index': 5445}","it('should not trigger a drop animation finished if a transitionend occurs that is a non-primary property', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const event: Event = getTransitionEnd();
  // $FlowFixMe - unknown property
  event.propertyName = 'background';
  fireEvent(handle, event);

  // still drop animating!
  expect(isDropAnimating(handle)).toBe(true);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 199, 'column': 20, 'index': 5873}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 203, 'column': 9, 'index': 5967}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Lazy Test,"{'line': 204, 'column': 9, 'index': 6008}","it('should not trigger a drop if a transitionend event occurs when not dropping', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  mouse.preLift(handle);
  fireEvent(handle, getTransitionEnd());

  mouse.lift(handle);
  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  mouse.move(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(false);

  fireEvent.mouseUp(handle);
  expect(isDragging(handle)).toBe(true);
  expect(isDropAnimating(handle)).toBe(true);

  fireEvent(handle, getTransitionEnd());
  expect(isDragging(handle)).toBe(false);
  expect(isDropAnimating(handle)).toBe(false);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Magic Number,"{'line': 63, 'column': 49, 'index': 1921}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",steel
/test/unit/integration/draggable/dropping.spec.js,Magic Number,"{'line': 67, 'column': 49, 'index': 2045}","it('should provide the correct snapshot to consumers', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  mouse.move(handle);

  // start a drop
  fireEvent.mouseUp(handle);
  expect(isDropAnimating(handle)).toBe(true);

  const snapshot = getLast(getSnapshotsFor('0', spy));

  const dropping: DropAnimation = {
    duration: timings.minDropTime,
    curve: curves.drop,
    moveTo: { x: 0, y: 0 },
    opacity: null,
    scale: null,
  };
  const expected: DraggableStateSnapshot = {
    isDragging: true,
    isDropAnimating: true,
    isClone: false,
    dropAnimation: dropping,
    // due to the movement we are no longer over a droppable due
    // do not dimensions being set
    draggingOver: null,
    combineWith: null,
    combineTargetFor: null,
    mode: 'FLUID',
  };
  expect(snapshot).toEqual(expected);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 26, 'column': 2, 'index': 840}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 27, 'column': 2, 'index': 883}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 27, 'column': 2, 'index': 883}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 28, 'column': 2, 'index': 942}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 28, 'column': 2, 'index': 942}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 32, 'column': 2, 'index': 1031}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 33, 'column': 2, 'index': 1093}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 33, 'column': 2, 'index': 1093}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 34, 'column': 2, 'index': 1152}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 34, 'column': 2, 'index': 1152}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 43, 'column': 2, 'index': 1463}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 47, 'column': 2, 'index': 1587}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 61, 'column': 4, 'index': 1966}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/dragging.spec.js,Duplicate Assert,"{'line': 80, 'column': 4, 'index': 2449}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/dragging.spec.js,Eager Test,"{'line': 22, 'column': 2, 'index': 725}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Eager Test,"{'line': 23, 'column': 9, 'index': 761}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Eager Test,"{'line': 45, 'column': 2, 'index': 1517}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/dragging.spec.js,Eager Test,"{'line': 46, 'column': 9, 'index': 1553}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/dragging.spec.js,Eager Test,"{'line': 50, 'column': 21, 'index': 1664}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/dragging.spec.js,Eager Test,"{'line': 67, 'column': 21, 'index': 2051}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/dragging.spec.js,Eager Test,"{'line': 88, 'column': 2, 'index': 2643}","it('should animate movements when in snap mode', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);

  expect(isDragging(handle)).toBe(true);
  expect(handle.style.transition).toBe(transitions.snap);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Eager Test,"{'line': 90, 'column': 9, 'index': 2683}","it('should animate movements when in snap mode', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);

  expect(isDragging(handle)).toBe(true);
  expect(handle.style.transition).toBe(transitions.snap);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Lazy Test,"{'line': 22, 'column': 2, 'index': 725}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Lazy Test,"{'line': 23, 'column': 9, 'index': 761}","it('should move to a provided offset', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // no transform as we are at {x: 0, y: 0}
  expect(handle.style.transform).toBe('');
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);

  mouse.move(handle);

  expect(handle.style.transform).toBe(`translate(0px, 1px)`);
  expect(handle.style.transition).toBe(transitions.fluid);
  expect(handle.style.zIndex).toBe(`${zIndexOptions.dragging}`);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Lazy Test,"{'line': 45, 'column': 2, 'index': 1517}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/dragging.spec.js,Lazy Test,"{'line': 46, 'column': 9, 'index': 1553}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/dragging.spec.js,Lazy Test,"{'line': 50, 'column': 21, 'index': 1664}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/dragging.spec.js,Lazy Test,"{'line': 88, 'column': 2, 'index': 2643}","it('should animate movements when in snap mode', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);

  expect(isDragging(handle)).toBe(true);
  expect(handle.style.transition).toBe(transitions.snap);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Lazy Test,"{'line': 90, 'column': 9, 'index': 2683}","it('should animate movements when in snap mode', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);

  expect(isDragging(handle)).toBe(true);
  expect(handle.style.transition).toBe(transitions.snap);
})",steel
/test/unit/integration/draggable/dragging.spec.js,Lazy Test,"{'line': 111, 'column': 21, 'index': 3405}","it('should update the snapshot and opacity when combining with another item', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const box1 = preset.inHome1.client.borderBox;
    const box2 = preset.inHome2.client.borderBox;

    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const handle: HTMLElement = getByText('item: 0');

    expandedMouse.powerLift(handle, box1.center);

    // this will combine with the second item
    expandedMouse.move(handle, box2.center);

    const snapshot = getLast(getSnapshotsFor('0', spy));

    const expected: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      // combining with #1
      combineWith: '1',
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(expected);
    expect(handle.style.opacity).toBe(`${combine.opacity.combining}`);
  });
})",steel
/test/unit/integration/draggable/dragging.spec.js,Magic Number,"{'line': 43, 'column': 49, 'index': 1510}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/dragging.spec.js,Magic Number,"{'line': 47, 'column': 49, 'index': 1634}","it('should pass on the snapshot', () => {
  const spy = jest.fn();
  const renderItem: RenderItem = renderItemAndSpy(spy);

  const { getByText } = render(<App renderItem={renderItem} />);
  const handle: HTMLElement = getByText('item: 0');
  expect(getSnapshotsFor('0', spy)).toHaveLength(1);

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);
  expect(getSnapshotsFor('0', spy)).toHaveLength(2);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const lift: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: 'droppable',
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(lift);
  }

  mouse.move(handle);

  {
    const snapshot = getLast(getSnapshotsFor('0', spy));
    const move: DraggableStateSnapshot = {
      isDragging: true,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      // cleared because we are not setting any dimensions and we are
      // no longer over anything
      draggingOver: null,
      combineWith: null,
      combineTargetFor: null,
      mode: 'FLUID',
    };
    expect(snapshot).toEqual(move);
  }
})",steel
/test/unit/integration/draggable/combined-with.spec.js,Eager Test,"{'line': 30, 'column': 11, 'index': 996}","it('should update the snapshot of an item being combined with', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const critical: HTMLElement = getByText('item: 0');
    const after: HTMLElement = getByText('item: 1');
    const criticalBox = preset.inHome1.client.borderBox;
    const afterBox = preset.inHome2.client.borderBox;

    expandedMouse.powerLift(critical, criticalBox.center);
    expect(isDragging(critical)).toBe(true);

    // will now be combining
    expandedMouse.move(critical, afterBox.center);

    expect(isCombining(critical)).toBe(true);
    expect(isCombineTarget(after)).toBe(true);

    const snapshot = getLast(getSnapshotsFor('1', spy));
    const expected: DraggableStateSnapshot = {
      isDragging: false,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: null,
      combineWith: null,
      combineTargetFor: '0',
      mode: null,
    };
    expect(snapshot).toEqual(expected);
  });
})",steel
/test/unit/integration/draggable/combined-with.spec.js,Eager Test,"{'line': 35, 'column': 11, 'index': 1123}","it('should update the snapshot of an item being combined with', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const critical: HTMLElement = getByText('item: 0');
    const after: HTMLElement = getByText('item: 1');
    const criticalBox = preset.inHome1.client.borderBox;
    const afterBox = preset.inHome2.client.borderBox;

    expandedMouse.powerLift(critical, criticalBox.center);
    expect(isDragging(critical)).toBe(true);

    // will now be combining
    expandedMouse.move(critical, afterBox.center);

    expect(isCombining(critical)).toBe(true);
    expect(isCombineTarget(after)).toBe(true);

    const snapshot = getLast(getSnapshotsFor('1', spy));
    const expected: DraggableStateSnapshot = {
      isDragging: false,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: null,
      combineWith: null,
      combineTargetFor: '0',
      mode: null,
    };
    expect(snapshot).toEqual(expected);
  });
})",steel
/test/unit/integration/draggable/combined-with.spec.js,Eager Test,"{'line': 36, 'column': 11, 'index': 1169}","it('should update the snapshot of an item being combined with', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const critical: HTMLElement = getByText('item: 0');
    const after: HTMLElement = getByText('item: 1');
    const criticalBox = preset.inHome1.client.borderBox;
    const afterBox = preset.inHome2.client.borderBox;

    expandedMouse.powerLift(critical, criticalBox.center);
    expect(isDragging(critical)).toBe(true);

    // will now be combining
    expandedMouse.move(critical, afterBox.center);

    expect(isCombining(critical)).toBe(true);
    expect(isCombineTarget(after)).toBe(true);

    const snapshot = getLast(getSnapshotsFor('1', spy));
    const expected: DraggableStateSnapshot = {
      isDragging: false,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: null,
      combineWith: null,
      combineTargetFor: '0',
      mode: null,
    };
    expect(snapshot).toEqual(expected);
  });
})",steel
/test/unit/integration/draggable/combined-with.spec.js,Eager Test,"{'line': 38, 'column': 21, 'index': 1227}","it('should update the snapshot of an item being combined with', () => {
  withPoorDimensionMocks((preset) => {
    const spy = jest.fn();
    const renderItem: RenderItem = renderItemAndSpy(spy);
    const { getByText } = render(
      <App renderItem={renderItem} isCombineEnabled />,
    );
    const critical: HTMLElement = getByText('item: 0');
    const after: HTMLElement = getByText('item: 1');
    const criticalBox = preset.inHome1.client.borderBox;
    const afterBox = preset.inHome2.client.borderBox;

    expandedMouse.powerLift(critical, criticalBox.center);
    expect(isDragging(critical)).toBe(true);

    // will now be combining
    expandedMouse.move(critical, afterBox.center);

    expect(isCombining(critical)).toBe(true);
    expect(isCombineTarget(after)).toBe(true);

    const snapshot = getLast(getSnapshotsFor('1', spy));
    const expected: DraggableStateSnapshot = {
      isDragging: false,
      isDropAnimating: false,
      isClone: false,
      dropAnimation: null,
      draggingOver: null,
      combineWith: null,
      combineTargetFor: '0',
      mode: null,
    };
    expect(snapshot).toEqual(expected);
  });
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Conditional Test Logic,"{'line': 60, 'column': 65, 'index': 1946}","it('should not prevent the default behaviour for an indirect cancel', () => {
  ['orientationchange', 'keydown', 'resize', supportedEventName].forEach(
    (eventName: string) => {
      const onDragEnd = jest.fn();
      const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
      const handle: HTMLElement = getByText('item: 0');

      simpleLift(touch, handle);

      const event: Event = new Event(eventName, {
        bubbles: true,
        cancelable: true,
        target: handle,
      });

      fireEvent(handle, event);

      // not an explicit cancel
      expect(event.defaultPrevented).toBe(false);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      unmount();
    },
  );
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 17, 'column': 2, 'index': 684}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  const event: Event = createEvent.touchEnd(handle);
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 23, 'column': 9, 'index': 848}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  const event: Event = createEvent.touchEnd(handle);
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 31, 'column': 2, 'index': 1098}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 39, 'column': 9, 'index': 1298}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 47, 'column': 2, 'index': 1548}","it('should prevent default on a touchcancel', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  const event: Event = new Event('touchcancel', {
    bubbles: true,
    cancelable: true,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 56, 'column': 9, 'index': 1756}","it('should prevent default on a touchcancel', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  const event: Event = new Event('touchcancel', {
    bubbles: true,
    cancelable: true,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 66, 'column': 6, 'index': 2158}","it('should not prevent the default behaviour for an indirect cancel', () => {
  ['orientationchange', 'keydown', 'resize', supportedEventName].forEach(
    (eventName: string) => {
      const onDragEnd = jest.fn();
      const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
      const handle: HTMLElement = getByText('item: 0');

      simpleLift(touch, handle);

      const event: Event = new Event(eventName, {
        bubbles: true,
        cancelable: true,
        target: handle,
      });

      fireEvent(handle, event);

      // not an explicit cancel
      expect(event.defaultPrevented).toBe(false);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      unmount();
    },
  );
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 78, 'column': 13, 'index': 2448}","it('should not prevent the default behaviour for an indirect cancel', () => {
  ['orientationchange', 'keydown', 'resize', supportedEventName].forEach(
    (eventName: string) => {
      const onDragEnd = jest.fn();
      const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
      const handle: HTMLElement = getByText('item: 0');

      simpleLift(touch, handle);

      const event: Event = new Event(eventName, {
        bubbles: true,
        cancelable: true,
        target: handle,
      });

      fireEvent(handle, event);

      // not an explicit cancel
      expect(event.defaultPrevented).toBe(false);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      unmount();
    },
  );
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 17, 'column': 2, 'index': 684}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  const event: Event = createEvent.touchEnd(handle);
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 23, 'column': 9, 'index': 848}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  const event: Event = createEvent.touchEnd(handle);
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 31, 'column': 2, 'index': 1098}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 39, 'column': 9, 'index': 1298}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 47, 'column': 2, 'index': 1548}","it('should prevent default on a touchcancel', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  const event: Event = new Event('touchcancel', {
    bubbles: true,
    cancelable: true,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 56, 'column': 9, 'index': 1756}","it('should prevent default on a touchcancel', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  const event: Event = new Event('touchcancel', {
    bubbles: true,
    cancelable: true,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 66, 'column': 6, 'index': 2158}","it('should not prevent the default behaviour for an indirect cancel', () => {
  ['orientationchange', 'keydown', 'resize', supportedEventName].forEach(
    (eventName: string) => {
      const onDragEnd = jest.fn();
      const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
      const handle: HTMLElement = getByText('item: 0');

      simpleLift(touch, handle);

      const event: Event = new Event(eventName, {
        bubbles: true,
        cancelable: true,
        target: handle,
      });

      fireEvent(handle, event);

      // not an explicit cancel
      expect(event.defaultPrevented).toBe(false);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      unmount();
    },
  );
})",steel
/test/unit/integration/drag-handle/touch-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 78, 'column': 13, 'index': 2448}","it('should not prevent the default behaviour for an indirect cancel', () => {
  ['orientationchange', 'keydown', 'resize', supportedEventName].forEach(
    (eventName: string) => {
      const onDragEnd = jest.fn();
      const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
      const handle: HTMLElement = getByText('item: 0');

      simpleLift(touch, handle);

      const event: Event = new Event(eventName, {
        bubbles: true,
        cancelable: true,
        target: handle,
      });

      fireEvent(handle, event);

      // not an explicit cancel
      expect(event.defaultPrevented).toBe(false);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      unmount();
    },
  );
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Duplicate Assert,"{'line': 27, 'column': 2, 'index': 871}","it('should start dragging after a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.runOnlyPendingTimers();

  // now dragging
  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Duplicate Assert,"{'line': 33, 'column': 2, 'index': 993}","it('should start dragging after a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.runOnlyPendingTimers();

  // now dragging
  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Duplicate Assert,"{'line': 47, 'column': 2, 'index': 1458}","it('should not start dragging if finished before a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.advanceTimersByTime(timeForLongPress - 1);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  const touchEnd: Event = createEvent.touchEnd(handle);
  fireEvent(handle, touchEnd);

  // not a direct cancel
  expect(touchEnd.defaultPrevented).toBe(false);

  // flushing any timers
  jest.runOnlyPendingTimers();

  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Duplicate Assert,"{'line': 47, 'column': 2, 'index': 1458}","it('should not start dragging if finished before a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.advanceTimersByTime(timeForLongPress - 1);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  const touchEnd: Event = createEvent.touchEnd(handle);
  fireEvent(handle, touchEnd);

  // not a direct cancel
  expect(touchEnd.defaultPrevented).toBe(false);

  // flushing any timers
  jest.runOnlyPendingTimers();

  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Duplicate Assert,"{'line': 53, 'column': 2, 'index': 1603}","it('should not start dragging if finished before a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.advanceTimersByTime(timeForLongPress - 1);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  const touchEnd: Event = createEvent.touchEnd(handle);
  fireEvent(handle, touchEnd);

  // not a direct cancel
  expect(touchEnd.defaultPrevented).toBe(false);

  // flushing any timers
  jest.runOnlyPendingTimers();

  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Duplicate Assert,"{'line': 53, 'column': 2, 'index': 1603}","it('should not start dragging if finished before a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.advanceTimersByTime(timeForLongPress - 1);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  const touchEnd: Event = createEvent.touchEnd(handle);
  fireEvent(handle, touchEnd);

  // not a direct cancel
  expect(touchEnd.defaultPrevented).toBe(false);

  // flushing any timers
  jest.runOnlyPendingTimers();

  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Duplicate Assert,"{'line': 64, 'column': 2, 'index': 1866}","it('should not start dragging if finished before a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.advanceTimersByTime(timeForLongPress - 1);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  const touchEnd: Event = createEvent.touchEnd(handle);
  fireEvent(handle, touchEnd);

  // not a direct cancel
  expect(touchEnd.defaultPrevented).toBe(false);

  // flushing any timers
  jest.runOnlyPendingTimers();

  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Duplicate Assert,"{'line': 64, 'column': 2, 'index': 1866}","it('should not start dragging if finished before a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.advanceTimersByTime(timeForLongPress - 1);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  const touchEnd: Event = createEvent.touchEnd(handle);
  fireEvent(handle, touchEnd);

  // not a direct cancel
  expect(touchEnd.defaultPrevented).toBe(false);

  // flushing any timers
  jest.runOnlyPendingTimers();

  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Duplicate Assert,"{'line': 75, 'column': 2, 'index': 2216}","it('should allow a false start', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  // a first attempt that is not successful
  fireEvent(handle, getTouchStart(handle));
  jest.advanceTimersByTime(timeForLongPress - 1);
  fireEvent.touchEnd(handle);
  expect(isDragging(handle)).toBe(false);

  // Let's try again - this time we will wait

  fireEvent(handle, getTouchStart(handle));
  jest.advanceTimersByTime(timeForLongPress);
  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Duplicate Assert,"{'line': 81, 'column': 2, 'index': 2396}","it('should allow a false start', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  // a first attempt that is not successful
  fireEvent(handle, getTouchStart(handle));
  jest.advanceTimersByTime(timeForLongPress - 1);
  fireEvent.touchEnd(handle);
  expect(isDragging(handle)).toBe(false);

  // Let's try again - this time we will wait

  fireEvent(handle, getTouchStart(handle));
  jest.advanceTimersByTime(timeForLongPress);
  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Eager Test,"{'line': 27, 'column': 9, 'index': 878}","it('should start dragging after a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.runOnlyPendingTimers();

  // now dragging
  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Eager Test,"{'line': 33, 'column': 9, 'index': 1000}","it('should start dragging after a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.runOnlyPendingTimers();

  // now dragging
  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Eager Test,"{'line': 47, 'column': 9, 'index': 1465}","it('should not start dragging if finished before a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.advanceTimersByTime(timeForLongPress - 1);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  const touchEnd: Event = createEvent.touchEnd(handle);
  fireEvent(handle, touchEnd);

  // not a direct cancel
  expect(touchEnd.defaultPrevented).toBe(false);

  // flushing any timers
  jest.runOnlyPendingTimers();

  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Eager Test,"{'line': 53, 'column': 9, 'index': 1610}","it('should not start dragging if finished before a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.advanceTimersByTime(timeForLongPress - 1);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  const touchEnd: Event = createEvent.touchEnd(handle);
  fireEvent(handle, touchEnd);

  // not a direct cancel
  expect(touchEnd.defaultPrevented).toBe(false);

  // flushing any timers
  jest.runOnlyPendingTimers();

  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Eager Test,"{'line': 64, 'column': 9, 'index': 1873}","it('should not start dragging if finished before a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.advanceTimersByTime(timeForLongPress - 1);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  const touchEnd: Event = createEvent.touchEnd(handle);
  fireEvent(handle, touchEnd);

  // not a direct cancel
  expect(touchEnd.defaultPrevented).toBe(false);

  // flushing any timers
  jest.runOnlyPendingTimers();

  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Eager Test,"{'line': 75, 'column': 9, 'index': 2223}","it('should allow a false start', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  // a first attempt that is not successful
  fireEvent(handle, getTouchStart(handle));
  jest.advanceTimersByTime(timeForLongPress - 1);
  fireEvent.touchEnd(handle);
  expect(isDragging(handle)).toBe(false);

  // Let's try again - this time we will wait

  fireEvent(handle, getTouchStart(handle));
  jest.advanceTimersByTime(timeForLongPress);
  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Eager Test,"{'line': 81, 'column': 9, 'index': 2403}","it('should allow a false start', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  // a first attempt that is not successful
  fireEvent(handle, getTouchStart(handle));
  jest.advanceTimersByTime(timeForLongPress - 1);
  fireEvent.touchEnd(handle);
  expect(isDragging(handle)).toBe(false);

  // Let's try again - this time we will wait

  fireEvent(handle, getTouchStart(handle));
  jest.advanceTimersByTime(timeForLongPress);
  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Lazy Test,"{'line': 27, 'column': 9, 'index': 878}","it('should start dragging after a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.runOnlyPendingTimers();

  // now dragging
  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Lazy Test,"{'line': 47, 'column': 9, 'index': 1465}","it('should not start dragging if finished before a long press', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');
  const touchStart: Event = getTouchStart(handle);

  fireEvent(handle, touchStart);
  // not calling event.preventDefault() to allow
  // as many browser interactions as possible
  expect(touchStart.defaultPrevented).toBe(false);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  // allow long press to run
  jest.advanceTimersByTime(timeForLongPress - 1);

  // not dragging yet
  expect(isDragging(handle)).toBe(false);

  const touchEnd: Event = createEvent.touchEnd(handle);
  fireEvent(handle, touchEnd);

  // not a direct cancel
  expect(touchEnd.defaultPrevented).toBe(false);

  // flushing any timers
  jest.runOnlyPendingTimers();

  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/starting-a-drag.spec.js,Lazy Test,"{'line': 75, 'column': 9, 'index': 2223}","it('should allow a false start', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  // a first attempt that is not successful
  fireEvent(handle, getTouchStart(handle));
  jest.advanceTimersByTime(timeForLongPress - 1);
  fireEvent.touchEnd(handle);
  expect(isDragging(handle)).toBe(false);

  // Let's try again - this time we will wait

  fireEvent(handle, getTouchStart(handle));
  jest.advanceTimersByTime(timeForLongPress);
  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Duplicate Assert,"{'line': 76, 'column': 4, 'index': 2300}","it('prevent a force press when dragging', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    touch.preLift(handle);

    const first: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, first);
    expect(first.defaultPrevented).toBe(false);

    touch.lift(handle);
    expect(isDragging(handle)).toBe(true);

    // this force press will be prevented
    const second: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, second);
    expect(second.defaultPrevented).toBe(true);

    // force presses did not abort the drag
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Duplicate Assert,"{'line': 76, 'column': 4, 'index': 2300}","it('prevent a force press when dragging', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    touch.preLift(handle);

    const first: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, first);
    expect(first.defaultPrevented).toBe(false);

    touch.lift(handle);
    expect(isDragging(handle)).toBe(true);

    // this force press will be prevented
    const second: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, second);
    expect(second.defaultPrevented).toBe(true);

    // force presses did not abort the drag
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Duplicate Assert,"{'line': 84, 'column': 4, 'index': 2573}","it('prevent a force press when dragging', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    touch.preLift(handle);

    const first: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, first);
    expect(first.defaultPrevented).toBe(false);

    touch.lift(handle);
    expect(isDragging(handle)).toBe(true);

    // this force press will be prevented
    const second: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, second);
    expect(second.defaultPrevented).toBe(true);

    // force presses did not abort the drag
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Duplicate Assert,"{'line': 84, 'column': 4, 'index': 2573}","it('prevent a force press when dragging', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    touch.preLift(handle);

    const first: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, first);
    expect(first.defaultPrevented).toBe(false);

    touch.lift(handle);
    expect(isDragging(handle)).toBe(true);

    // this force press will be prevented
    const second: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, second);
    expect(second.defaultPrevented).toBe(true);

    // force presses did not abort the drag
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Eager Test,"{'line': 76, 'column': 11, 'index': 2307}","it('prevent a force press when dragging', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    touch.preLift(handle);

    const first: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, first);
    expect(first.defaultPrevented).toBe(false);

    touch.lift(handle);
    expect(isDragging(handle)).toBe(true);

    // this force press will be prevented
    const second: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, second);
    expect(second.defaultPrevented).toBe(true);

    // force presses did not abort the drag
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Eager Test,"{'line': 84, 'column': 11, 'index': 2580}","it('prevent a force press when dragging', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    touch.preLift(handle);

    const first: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, first);
    expect(first.defaultPrevented).toBe(false);

    touch.lift(handle);
    expect(isDragging(handle)).toBe(true);

    // this force press will be prevented
    const second: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, second);
    expect(second.defaultPrevented).toBe(true);

    // force presses did not abort the drag
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Eager Test,"{'line': 111, 'column': 4, 'index': 3401}","it('should cancel a drag if a force press is registered', () => {
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(touch, handle);

    // indirect cancel so event is not consumed
    const press: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, press);
    expect(press.defaultPrevented).toBe(false);

    // drag is no more
    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Eager Test,"{'line': 119, 'column': 11, 'index': 3652}","it('should cancel a drag if a force press is registered', () => {
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(touch, handle);

    // indirect cancel so event is not consumed
    const press: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, press);
    expect(press.defaultPrevented).toBe(false);

    // drag is no more
    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Eager Test,"{'line': 126, 'column': 4, 'index': 3894}","it('should abort a force press if dragging and some movement has occurred', () => {
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(touch, handle);

    fireEvent.touchMove(handle, { touches: [{ clientX: 0, clientY: 0 }] });

    // consuming event and not cancelling after movement
    const press: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, press);
    expect(press.defaultPrevented).toBe(true);

    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Eager Test,"{'line': 135, 'column': 11, 'index': 4207}","it('should abort a force press if dragging and some movement has occurred', () => {
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(touch, handle);

    fireEvent.touchMove(handle, { touches: [{ clientX: 0, clientY: 0 }] });

    // consuming event and not cancelling after movement
    const press: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, press);
    expect(press.defaultPrevented).toBe(true);

    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Eager Test,"{'line': 145, 'column': 2, 'index': 4539}","it('should not listen to force press changes after a drag has started', () => {
  const withForcePress: Item[] = [{ id: '0', shouldRespectForcePress: true }];

  const { getByText, rerender } = render(<App items={withForcePress} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  // changing
  const withoutForcePress: Item[] = [
    { id: '0', shouldRespectForcePress: false },
  ];
  rerender(<App items={withoutForcePress} />);

  // even though the shouldRespectForcePress value has changed it will still use the original
  // this is important as during a drag the dragging item can be removed from the registry and we
  // don't want to look it up
  fireEvent(handle, getForceChange(forcePressThreshold));

  // drag is no more
  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Eager Test,"{'line': 159, 'column': 9, 'index': 5032}","it('should not listen to force press changes after a drag has started', () => {
  const withForcePress: Item[] = [{ id: '0', shouldRespectForcePress: true }];

  const { getByText, rerender } = render(<App items={withForcePress} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  // changing
  const withoutForcePress: Item[] = [
    { id: '0', shouldRespectForcePress: false },
  ];
  rerender(<App items={withoutForcePress} />);

  // even though the shouldRespectForcePress value has changed it will still use the original
  // this is important as during a drag the dragging item can be removed from the registry and we
  // don't want to look it up
  fireEvent(handle, getForceChange(forcePressThreshold));

  // drag is no more
  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Lazy Test,"{'line': 47, 'column': 11, 'index': 1463}","it('should not abort presses that do not have enought pressure', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    touch.preLift(handle);

    const first: Event = getForceChange(forcePressThreshold - 1);
    fireEvent(handle, first);
    expect(first.defaultPrevented).toBe(false);

    touch.lift(handle);

    const second: Event = getForceChange(forcePressThreshold - 1);
    fireEvent(handle, second);
    expect(second.defaultPrevented).toBe(false);

    // force presses did not abort the pending or actual drag
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Lazy Test,"{'line': 62, 'column': 11, 'index': 1914}","it('should not prevent a force press when pending (strange I know)', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    touch.preLift(handle);

    const first: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, first);
    expect(first.defaultPrevented).toBe(false);

    touch.lift(handle);
    // did not prevent lifting
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Lazy Test,"{'line': 76, 'column': 11, 'index': 2307}","it('prevent a force press when dragging', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    touch.preLift(handle);

    const first: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, first);
    expect(first.defaultPrevented).toBe(false);

    touch.lift(handle);
    expect(isDragging(handle)).toBe(true);

    // this force press will be prevented
    const second: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, second);
    expect(second.defaultPrevented).toBe(true);

    // force presses did not abort the drag
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Lazy Test,"{'line': 104, 'column': 11, 'index': 3177}","it('should cancel a pending drag if a force press is registered', () => {
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    touch.preLift(handle);

    // indirect cancel so event is not consumed
    const press: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, press);
    expect(press.defaultPrevented).toBe(false);

    touch.lift(handle);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Lazy Test,"{'line': 111, 'column': 4, 'index': 3401}","it('should cancel a drag if a force press is registered', () => {
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(touch, handle);

    // indirect cancel so event is not consumed
    const press: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, press);
    expect(press.defaultPrevented).toBe(false);

    // drag is no more
    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Lazy Test,"{'line': 119, 'column': 11, 'index': 3652}","it('should cancel a drag if a force press is registered', () => {
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(touch, handle);

    // indirect cancel so event is not consumed
    const press: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, press);
    expect(press.defaultPrevented).toBe(false);

    // drag is no more
    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Lazy Test,"{'line': 126, 'column': 4, 'index': 3894}","it('should abort a force press if dragging and some movement has occurred', () => {
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(touch, handle);

    fireEvent.touchMove(handle, { touches: [{ clientX: 0, clientY: 0 }] });

    // consuming event and not cancelling after movement
    const press: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, press);
    expect(press.defaultPrevented).toBe(true);

    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Lazy Test,"{'line': 135, 'column': 11, 'index': 4207}","it('should abort a force press if dragging and some movement has occurred', () => {
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(touch, handle);

    fireEvent.touchMove(handle, { touches: [{ clientX: 0, clientY: 0 }] });

    // consuming event and not cancelling after movement
    const press: Event = getForceChange(forcePressThreshold);
    fireEvent(handle, press);
    expect(press.defaultPrevented).toBe(true);

    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Lazy Test,"{'line': 145, 'column': 2, 'index': 4539}","it('should not listen to force press changes after a drag has started', () => {
  const withForcePress: Item[] = [{ id: '0', shouldRespectForcePress: true }];

  const { getByText, rerender } = render(<App items={withForcePress} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  // changing
  const withoutForcePress: Item[] = [
    { id: '0', shouldRespectForcePress: false },
  ];
  rerender(<App items={withoutForcePress} />);

  // even though the shouldRespectForcePress value has changed it will still use the original
  // this is important as during a drag the dragging item can be removed from the registry and we
  // don't want to look it up
  fireEvent(handle, getForceChange(forcePressThreshold));

  // drag is no more
  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/touch-sensor/force-press.spec.js,Lazy Test,"{'line': 159, 'column': 9, 'index': 5032}","it('should not listen to force press changes after a drag has started', () => {
  const withForcePress: Item[] = [{ id: '0', shouldRespectForcePress: true }];

  const { getByText, rerender } = render(<App items={withForcePress} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(touch, handle);

  // changing
  const withoutForcePress: Item[] = [
    { id: '0', shouldRespectForcePress: false },
  ];
  rerender(<App items={withoutForcePress} />);

  // even though the shouldRespectForcePress value has changed it will still use the original
  // this is important as during a drag the dragging item can be removed from the registry and we
  // don't want to look it up
  fireEvent(handle, getForceChange(forcePressThreshold));

  // drag is no more
  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 19, 'column': 6, 'index': 667}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 19, 'column': 6, 'index': 667}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 22, 'column': 6, 'index': 742}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 22, 'column': 6, 'index': 742}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 30, 'column': 6, 'index': 944}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 30, 'column': 6, 'index': 944}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 33, 'column': 6, 'index': 1004}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 36, 'column': 6, 'index': 1081}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 36, 'column': 6, 'index': 1081}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 38, 'column': 6, 'index': 1128}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 55, 'column': 6, 'index': 1639}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 55, 'column': 6, 'index': 1639}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 58, 'column': 6, 'index': 1714}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 58, 'column': 6, 'index': 1714}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 66, 'column': 6, 'index': 1916}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 66, 'column': 6, 'index': 1916}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 70, 'column': 6, 'index': 1993}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Duplicate Assert,"{'line': 70, 'column': 6, 'index': 1993}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Eager Test,"{'line': 19, 'column': 13, 'index': 674}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Eager Test,"{'line': 22, 'column': 13, 'index': 749}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Eager Test,"{'line': 30, 'column': 13, 'index': 951}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Eager Test,"{'line': 36, 'column': 13, 'index': 1088}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Eager Test,"{'line': 39, 'column': 13, 'index': 1185}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Eager Test,"{'line': 55, 'column': 13, 'index': 1646}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Eager Test,"{'line': 58, 'column': 13, 'index': 1721}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Eager Test,"{'line': 66, 'column': 13, 'index': 1923}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Eager Test,"{'line': 70, 'column': 13, 'index': 2000}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Eager Test,"{'line': 72, 'column': 13, 'index': 2096}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Lazy Test,"{'line': 19, 'column': 13, 'index': 674}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Lazy Test,"{'line': 39, 'column': 13, 'index': 1185}","it('should control a successful drag through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      // drop
      expect(onDragEnd).not.toHaveBeenCalled();

      control.drop(handle);
      expect(isDragging(handle)).toBe(false);

      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('DROP');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Lazy Test,"{'line': 55, 'column': 13, 'index': 1646}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/validate-controls.spec.js,Lazy Test,"{'line': 72, 'column': 13, 'index': 2096}","it('should control a cancel through the sensor', () => {
    const onDragStart = jest.fn();
    const onDragEnd = jest.fn();
    const { getByText } = render(
      <App onDragStart={onDragStart} onDragEnd={onDragEnd} />,
    );
    const handle: HTMLElement = getByText('item: 0');

    Array.from({ length: 4 }).forEach(() => {
      control.preLift(handle);
      expect(isDragging(handle)).toBe(false);

      control.lift(handle);
      expect(isDragging(handle)).toBe(true);

      // on drag start is async
      jest.runOnlyPendingTimers();
      expect(onDragStart).toHaveBeenCalled();

      // move
      control.move(handle);
      expect(isDragging(handle)).toBe(true);

      control.cancel(handle);

      expect(isDragging(handle)).toBe(false);
      expect(onDragEnd).toHaveBeenCalledTimes(1);
      expect(getDropReason(onDragEnd)).toBe('CANCEL');

      onDragEnd.mockClear();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/parent-rendering-should-not-kill-drag.spec.js,Duplicate Assert,"{'line': 14, 'column': 4, 'index': 497}","it('should not abort a drag if a parent render occurs', () => {
    const { getByText, rerender } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    rerender(<App />);

    // handle element is unchanged
    expect(getByText('item: 0')).toBe(handle);
    // it is still dragging
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/parent-rendering-should-not-kill-drag.spec.js,Duplicate Assert,"{'line': 14, 'column': 4, 'index': 497}","it('should not abort a drag if a parent render occurs', () => {
    const { getByText, rerender } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    rerender(<App />);

    // handle element is unchanged
    expect(getByText('item: 0')).toBe(handle);
    // it is still dragging
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/parent-rendering-should-not-kill-drag.spec.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 675}","it('should not abort a drag if a parent render occurs', () => {
    const { getByText, rerender } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    rerender(<App />);

    // handle element is unchanged
    expect(getByText('item: 0')).toBe(handle);
    // it is still dragging
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/parent-rendering-should-not-kill-drag.spec.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 675}","it('should not abort a drag if a parent render occurs', () => {
    const { getByText, rerender } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    rerender(<App />);

    // handle element is unchanged
    expect(getByText('item: 0')).toBe(handle);
    // it is still dragging
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/parent-rendering-should-not-kill-drag.spec.js,Eager Test,"{'line': 13, 'column': 4, 'index': 464}","it('should not abort a drag if a parent render occurs', () => {
    const { getByText, rerender } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    rerender(<App />);

    // handle element is unchanged
    expect(getByText('item: 0')).toBe(handle);
    // it is still dragging
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/parent-rendering-should-not-kill-drag.spec.js,Eager Test,"{'line': 14, 'column': 11, 'index': 504}","it('should not abort a drag if a parent render occurs', () => {
    const { getByText, rerender } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    rerender(<App />);

    // handle element is unchanged
    expect(getByText('item: 0')).toBe(handle);
    // it is still dragging
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/parent-rendering-should-not-kill-drag.spec.js,Eager Test,"{'line': 21, 'column': 11, 'index': 682}","it('should not abort a drag if a parent render occurs', () => {
    const { getByText, rerender } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    rerender(<App />);

    // handle element is unchanged
    expect(getByText('item: 0')).toBe(handle);
    // it is still dragging
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/no-dragging-svgs.spec.js,Eager Test,"{'line': 37, 'column': 4, 'index': 1175}","it('should not start a drag from an SVG', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`draggable-${item.id}`}
      >
        <svg {...provided.dragHandleProps} data-testid={`handle-${item.id}`} />
      </div>
    );

    let api;
    // this is a setup problem: a drag handle cannot be a svg
    withWarn(() => {
      withError(() => {
        api = render(<App renderItem={renderItem} />);
      });
    });
    invariant(api);
    const draggable = api.getByTestId('draggable-0');
    const handle = api.getByTestId('handle-0');

    withWarn(() => {
      simpleLift(control, handle);
    });

    expect(isDragging(draggable)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/no-dragging-svgs.spec.js,Eager Test,"{'line': 42, 'column': 6, 'index': 1321}","it('should not start a drag from an SVG', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`draggable-${item.id}`}
      >
        <svg {...provided.dragHandleProps} data-testid={`handle-${item.id}`} />
      </div>
    );

    let api;
    // this is a setup problem: a drag handle cannot be a svg
    withWarn(() => {
      withError(() => {
        api = render(<App renderItem={renderItem} />);
      });
    });
    invariant(api);
    const draggable = api.getByTestId('draggable-0');
    const handle = api.getByTestId('handle-0');

    withWarn(() => {
      simpleLift(control, handle);
    });

    expect(isDragging(draggable)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/no-dragging-svgs.spec.js,Eager Test,"{'line': 45, 'column': 11, 'index': 1370}","it('should not start a drag from an SVG', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`draggable-${item.id}`}
      >
        <svg {...provided.dragHandleProps} data-testid={`handle-${item.id}`} />
      </div>
    );

    let api;
    // this is a setup problem: a drag handle cannot be a svg
    withWarn(() => {
      withError(() => {
        api = render(<App renderItem={renderItem} />);
      });
    });
    invariant(api);
    const draggable = api.getByTestId('draggable-0');
    const handle = api.getByTestId('handle-0');

    withWarn(() => {
      simpleLift(control, handle);
    });

    expect(isDragging(draggable)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/no-dragging-svgs.spec.js,Eager Test,"{'line': 67, 'column': 4, 'index': 2048}","it('should allow an SVG within a draggable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`draggable-${item.id}`}
      >
        <svg data-testid={`svg-${item.id}`} />
      </div>
    );
    const { getByTestId } = render(<App renderItem={renderItem} />);
    const draggable = getByTestId('draggable-0');
    const startFrom = getByTestId('svg-0');

    simpleLift(control, startFrom);

    expect(isDragging(draggable)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/no-dragging-svgs.spec.js,Eager Test,"{'line': 69, 'column': 11, 'index': 2092}","it('should allow an SVG within a draggable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`draggable-${item.id}`}
      >
        <svg data-testid={`svg-${item.id}`} />
      </div>
    );
    const { getByTestId } = render(<App renderItem={renderItem} />);
    const draggable = getByTestId('draggable-0');
    const startFrom = getByTestId('svg-0');

    simpleLift(control, startFrom);

    expect(isDragging(draggable)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/no-dragging-svgs.spec.js,Lazy Test,"{'line': 42, 'column': 6, 'index': 1321}","it('should not start a drag from an SVG', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`draggable-${item.id}`}
      >
        <svg {...provided.dragHandleProps} data-testid={`handle-${item.id}`} />
      </div>
    );

    let api;
    // this is a setup problem: a drag handle cannot be a svg
    withWarn(() => {
      withError(() => {
        api = render(<App renderItem={renderItem} />);
      });
    });
    invariant(api);
    const draggable = api.getByTestId('draggable-0');
    const handle = api.getByTestId('handle-0');

    withWarn(() => {
      simpleLift(control, handle);
    });

    expect(isDragging(draggable)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/no-dragging-svgs.spec.js,Lazy Test,"{'line': 45, 'column': 11, 'index': 1370}","it('should not start a drag from an SVG', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`draggable-${item.id}`}
      >
        <svg {...provided.dragHandleProps} data-testid={`handle-${item.id}`} />
      </div>
    );

    let api;
    // this is a setup problem: a drag handle cannot be a svg
    withWarn(() => {
      withError(() => {
        api = render(<App renderItem={renderItem} />);
      });
    });
    invariant(api);
    const draggable = api.getByTestId('draggable-0');
    const handle = api.getByTestId('handle-0');

    withWarn(() => {
      simpleLift(control, handle);
    });

    expect(isDragging(draggable)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/no-dragging-svgs.spec.js,Lazy Test,"{'line': 67, 'column': 4, 'index': 2048}","it('should allow an SVG within a draggable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`draggable-${item.id}`}
      >
        <svg data-testid={`svg-${item.id}`} />
      </div>
    );
    const { getByTestId } = render(<App renderItem={renderItem} />);
    const draggable = getByTestId('draggable-0');
    const startFrom = getByTestId('svg-0');

    simpleLift(control, startFrom);

    expect(isDragging(draggable)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/no-dragging-svgs.spec.js,Lazy Test,"{'line': 69, 'column': 11, 'index': 2092}","it('should allow an SVG within a draggable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`draggable-${item.id}`}
      >
        <svg data-testid={`svg-${item.id}`} />
      </div>
    );
    const { getByTestId } = render(<App renderItem={renderItem} />);
    const draggable = getByTestId('draggable-0');
    const startFrom = getByTestId('svg-0');

    simpleLift(control, startFrom);

    expect(isDragging(draggable)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/nested-handles.spec.js,Eager Test,"{'line': 14, 'column': 4, 'index': 567}","it('should not start a drag on a parent if a child drag handle has already received the event', () => {
    const { getByTestId } = render(<Board />);
    const cardHandle: HTMLElement = getByTestId('inhome1');
    const columnHandle: HTMLElement = getByTestId('home');

    simpleLift(control, cardHandle);

    expect(isDragging(cardHandle)).toBe(true);
    expect(isDragging(columnHandle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/nested-handles.spec.js,Eager Test,"{'line': 16, 'column': 11, 'index': 612}","it('should not start a drag on a parent if a child drag handle has already received the event', () => {
    const { getByTestId } = render(<Board />);
    const cardHandle: HTMLElement = getByTestId('inhome1');
    const columnHandle: HTMLElement = getByTestId('home');

    simpleLift(control, cardHandle);

    expect(isDragging(cardHandle)).toBe(true);
    expect(isDragging(columnHandle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/nested-handles.spec.js,Eager Test,"{'line': 17, 'column': 11, 'index': 659}","it('should not start a drag on a parent if a child drag handle has already received the event', () => {
    const { getByTestId } = render(<Board />);
    const cardHandle: HTMLElement = getByTestId('inhome1');
    const columnHandle: HTMLElement = getByTestId('home');

    simpleLift(control, cardHandle);

    expect(isDragging(cardHandle)).toBe(true);
    expect(isDragging(columnHandle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/nested-handles.spec.js,Eager Test,"{'line': 24, 'column': 4, 'index': 959}","it('should start a drag on a pare~nt the event is trigged on the parent', () => {
    const { getByTestId } = render(<Board />);
    const cardHandle: HTMLElement = getByTestId('inhome1');
    const columnHandle: HTMLElement = getByTestId('home');

    simpleLift(control, columnHandle);

    expect(isDragging(columnHandle)).toBe(true);
    expect(isDragging(cardHandle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/nested-handles.spec.js,Eager Test,"{'line': 26, 'column': 11, 'index': 1006}","it('should start a drag on a pare~nt the event is trigged on the parent', () => {
    const { getByTestId } = render(<Board />);
    const cardHandle: HTMLElement = getByTestId('inhome1');
    const columnHandle: HTMLElement = getByTestId('home');

    simpleLift(control, columnHandle);

    expect(isDragging(columnHandle)).toBe(true);
    expect(isDragging(cardHandle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/nested-handles.spec.js,Eager Test,"{'line': 27, 'column': 11, 'index': 1055}","it('should start a drag on a pare~nt the event is trigged on the parent', () => {
    const { getByTestId } = render(<Board />);
    const cardHandle: HTMLElement = getByTestId('inhome1');
    const columnHandle: HTMLElement = getByTestId('home');

    simpleLift(control, columnHandle);

    expect(isDragging(columnHandle)).toBe(true);
    expect(isDragging(cardHandle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/nested-handles.spec.js,Lazy Test,"{'line': 14, 'column': 4, 'index': 567}","it('should not start a drag on a parent if a child drag handle has already received the event', () => {
    const { getByTestId } = render(<Board />);
    const cardHandle: HTMLElement = getByTestId('inhome1');
    const columnHandle: HTMLElement = getByTestId('home');

    simpleLift(control, cardHandle);

    expect(isDragging(cardHandle)).toBe(true);
    expect(isDragging(columnHandle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/nested-handles.spec.js,Lazy Test,"{'line': 16, 'column': 11, 'index': 612}","it('should not start a drag on a parent if a child drag handle has already received the event', () => {
    const { getByTestId } = render(<Board />);
    const cardHandle: HTMLElement = getByTestId('inhome1');
    const columnHandle: HTMLElement = getByTestId('home');

    simpleLift(control, cardHandle);

    expect(isDragging(cardHandle)).toBe(true);
    expect(isDragging(columnHandle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/nested-handles.spec.js,Lazy Test,"{'line': 24, 'column': 4, 'index': 959}","it('should start a drag on a pare~nt the event is trigged on the parent', () => {
    const { getByTestId } = render(<Board />);
    const cardHandle: HTMLElement = getByTestId('inhome1');
    const columnHandle: HTMLElement = getByTestId('home');

    simpleLift(control, columnHandle);

    expect(isDragging(columnHandle)).toBe(true);
    expect(isDragging(cardHandle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/nested-handles.spec.js,Lazy Test,"{'line': 26, 'column': 11, 'index': 1006}","it('should start a drag on a pare~nt the event is trigged on the parent', () => {
    const { getByTestId } = render(<Board />);
    const cardHandle: HTMLElement = getByTestId('inhome1');
    const columnHandle: HTMLElement = getByTestId('home');

    simpleLift(control, columnHandle);

    expect(isDragging(columnHandle)).toBe(true);
    expect(isDragging(cardHandle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Conditional Test Logic,"{'line': 12, 'column': 2, 'index': 443}",Unknown,steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 891}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 891}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 935}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Duplicate Assert,"{'line': 30, 'column': 4, 'index': 935}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1007}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1007}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1051}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1192}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1192}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1236}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Eager Test,"{'line': 24, 'column': 4, 'index': 796}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Eager Test,"{'line': 30, 'column': 11, 'index': 942}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Eager Test,"{'line': 34, 'column': 11, 'index': 1014}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Eager Test,"{'line': 38, 'column': 4, 'index': 1159}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-pre-drag.spec.js,Eager Test,"{'line': 40, 'column': 11, 'index': 1243}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    control.preLift(handle);

    // lock is claimed but not dragging yet
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(false);

    api.tryReleaseLock();

    expect(isDragging(handle)).toBe(false);
    expect(api.isLockClaimed()).toBe(false);

    // a lift after a released lock can get the lock all good
    simpleLift(control, handle);
    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 767}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Duplicate Assert,"{'line': 23, 'column': 4, 'index': 767}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Duplicate Assert,"{'line': 24, 'column': 4, 'index': 811}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Duplicate Assert,"{'line': 24, 'column': 4, 'index': 811}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 882}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 927}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1039}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Duplicate Assert,"{'line': 34, 'column': 4, 'index': 1039}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1083}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Duplicate Assert,"{'line': 35, 'column': 4, 'index': 1083}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Eager Test,"{'line': 19, 'column': 4, 'index': 712}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Eager Test,"{'line': 21, 'column': 4, 'index': 733}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Eager Test,"{'line': 24, 'column': 11, 'index': 818}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Eager Test,"{'line': 29, 'column': 11, 'index': 934}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Eager Test,"{'line': 32, 'column': 4, 'index': 1005}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/lock-released-mid-drag.spec.js,Eager Test,"{'line': 35, 'column': 11, 'index': 1090}","it('should cleanup a drag if a lock is forceably released mid drag', () => {
    let api: SensorAPI;
    const sensor: Sensor = (value: SensorAPI) => {
      api = value;
    };

    const { getByText } = render(<App sensors={[sensor]} />);
    const handle: HTMLElement = getByText('item: 0');
    invariant(api);

    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);

    api.tryReleaseLock();

    expect(api.isLockClaimed()).toBe(false);
    expect(isDragging(handle)).toBe(false);

    // allowing reclaiming after
    simpleLift(control, handle);

    expect(api.isLockClaimed()).toBe(true);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Eager Test,"{'line': 52, 'column': 6, 'index': 1701}","it('should not drag if the handle is an interactive element', () => {
    forEachTagName((tagName: string) => {
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <TagName
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={item.id}
          />
        );
      };

      const { unmount, getByTestId } = render(<App renderItem={renderItem} />);
      const handle: HTMLElement = getByTestId('0');

      simpleLift(control, handle);

      expect(isDragging(handle)).toBe(false);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Eager Test,"{'line': 54, 'column': 13, 'index': 1744}","it('should not drag if the handle is an interactive element', () => {
    forEachTagName((tagName: string) => {
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <TagName
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={item.id}
          />
        );
      };

      const { unmount, getByTestId } = render(<App renderItem={renderItem} />);
      const handle: HTMLElement = getByTestId('0');

      simpleLift(control, handle);

      expect(isDragging(handle)).toBe(false);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Eager Test,"{'line': 84, 'column': 6, 'index': 2644}","it('should allow dragging from an interactive handle if instructed', () => {
    mixedCase(interactiveTagNames).forEach((tagName: string) => {
      const items: Item[] = [{ id: '0', canDragInteractiveElements: true }];
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <TagName
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={item.id}
          />
        );
      };

      const { unmount, getByTestId } = render(
        <App items={items} renderItem={renderItem} />,
      );
      const handle: HTMLElement = getByTestId('0');

      simpleLift(control, handle);

      expect(isDragging(handle)).toBe(true);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Eager Test,"{'line': 86, 'column': 13, 'index': 2687}","it('should allow dragging from an interactive handle if instructed', () => {
    mixedCase(interactiveTagNames).forEach((tagName: string) => {
      const items: Item[] = [{ id: '0', canDragInteractiveElements: true }];
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <TagName
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={item.id}
          />
        );
      };

      const { unmount, getByTestId } = render(
        <App items={items} renderItem={renderItem} />,
      );
      const handle: HTMLElement = getByTestId('0');

      simpleLift(control, handle);

      expect(isDragging(handle)).toBe(true);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Eager Test,"{'line': 116, 'column': 6, 'index': 3589}","it('should not start a drag if the parent is interactive', () => {
    forEachTagName((tagName: string) => {
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <div
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={`handle-${item.id}`}
          >
            <TagName data-testid={`inner-${item.id}`} />
          </div>
        );
      };

      const { unmount, getByTestId } = render(<App renderItem={renderItem} />);
      const inner: HTMLElement = getByTestId('inner-0');
      const handle: HTMLElement = getByTestId('handle-0');

      simpleLift(control, inner);

      expect(isDragging(handle)).toBe(false);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Eager Test,"{'line': 118, 'column': 13, 'index': 3631}","it('should not start a drag if the parent is interactive', () => {
    forEachTagName((tagName: string) => {
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <div
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={`handle-${item.id}`}
          >
            <TagName data-testid={`inner-${item.id}`} />
          </div>
        );
      };

      const { unmount, getByTestId } = render(<App renderItem={renderItem} />);
      const inner: HTMLElement = getByTestId('inner-0');
      const handle: HTMLElement = getByTestId('handle-0');

      simpleLift(control, inner);

      expect(isDragging(handle)).toBe(false);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Eager Test,"{'line': 151, 'column': 6, 'index': 4657}","it('should allow dragging from with an interactive parent if instructed', () => {
    forEachTagName((tagName: string) => {
      const items: Item[] = [{ id: '0', canDragInteractiveElements: true }];
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <div
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={`handle-${item.id}`}
          >
            <TagName data-testid={`inner-${item.id}`} />
          </div>
        );
      };

      const { unmount, getByTestId } = render(
        <App items={items} renderItem={renderItem} />,
      );
      const handle: HTMLElement = getByTestId('handle-0');
      const inner: HTMLElement = getByTestId('inner-0');

      simpleLift(control, inner);

      expect(isDragging(handle)).toBe(true);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Eager Test,"{'line': 153, 'column': 13, 'index': 4699}","it('should allow dragging from with an interactive parent if instructed', () => {
    forEachTagName((tagName: string) => {
      const items: Item[] = [{ id: '0', canDragInteractiveElements: true }];
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <div
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={`handle-${item.id}`}
          >
            <TagName data-testid={`inner-${item.id}`} />
          </div>
        );
      };

      const { unmount, getByTestId } = render(
        <App items={items} renderItem={renderItem} />,
      );
      const handle: HTMLElement = getByTestId('handle-0');
      const inner: HTMLElement = getByTestId('inner-0');

      simpleLift(control, inner);

      expect(isDragging(handle)).toBe(true);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Lazy Test,"{'line': 52, 'column': 6, 'index': 1701}","it('should not drag if the handle is an interactive element', () => {
    forEachTagName((tagName: string) => {
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <TagName
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={item.id}
          />
        );
      };

      const { unmount, getByTestId } = render(<App renderItem={renderItem} />);
      const handle: HTMLElement = getByTestId('0');

      simpleLift(control, handle);

      expect(isDragging(handle)).toBe(false);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Lazy Test,"{'line': 54, 'column': 13, 'index': 1744}","it('should not drag if the handle is an interactive element', () => {
    forEachTagName((tagName: string) => {
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <TagName
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={item.id}
          />
        );
      };

      const { unmount, getByTestId } = render(<App renderItem={renderItem} />);
      const handle: HTMLElement = getByTestId('0');

      simpleLift(control, handle);

      expect(isDragging(handle)).toBe(false);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Lazy Test,"{'line': 84, 'column': 6, 'index': 2644}","it('should allow dragging from an interactive handle if instructed', () => {
    mixedCase(interactiveTagNames).forEach((tagName: string) => {
      const items: Item[] = [{ id: '0', canDragInteractiveElements: true }];
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <TagName
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={item.id}
          />
        );
      };

      const { unmount, getByTestId } = render(
        <App items={items} renderItem={renderItem} />,
      );
      const handle: HTMLElement = getByTestId('0');

      simpleLift(control, handle);

      expect(isDragging(handle)).toBe(true);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Lazy Test,"{'line': 86, 'column': 13, 'index': 2687}","it('should allow dragging from an interactive handle if instructed', () => {
    mixedCase(interactiveTagNames).forEach((tagName: string) => {
      const items: Item[] = [{ id: '0', canDragInteractiveElements: true }];
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <TagName
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={item.id}
          />
        );
      };

      const { unmount, getByTestId } = render(
        <App items={items} renderItem={renderItem} />,
      );
      const handle: HTMLElement = getByTestId('0');

      simpleLift(control, handle);

      expect(isDragging(handle)).toBe(true);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Lazy Test,"{'line': 116, 'column': 6, 'index': 3589}","it('should not start a drag if the parent is interactive', () => {
    forEachTagName((tagName: string) => {
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <div
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={`handle-${item.id}`}
          >
            <TagName data-testid={`inner-${item.id}`} />
          </div>
        );
      };

      const { unmount, getByTestId } = render(<App renderItem={renderItem} />);
      const inner: HTMLElement = getByTestId('inner-0');
      const handle: HTMLElement = getByTestId('handle-0');

      simpleLift(control, inner);

      expect(isDragging(handle)).toBe(false);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Lazy Test,"{'line': 118, 'column': 13, 'index': 3631}","it('should not start a drag if the parent is interactive', () => {
    forEachTagName((tagName: string) => {
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <div
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={`handle-${item.id}`}
          >
            <TagName data-testid={`inner-${item.id}`} />
          </div>
        );
      };

      const { unmount, getByTestId } = render(<App renderItem={renderItem} />);
      const inner: HTMLElement = getByTestId('inner-0');
      const handle: HTMLElement = getByTestId('handle-0');

      simpleLift(control, inner);

      expect(isDragging(handle)).toBe(false);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Lazy Test,"{'line': 151, 'column': 6, 'index': 4657}","it('should allow dragging from with an interactive parent if instructed', () => {
    forEachTagName((tagName: string) => {
      const items: Item[] = [{ id: '0', canDragInteractiveElements: true }];
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <div
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={`handle-${item.id}`}
          >
            <TagName data-testid={`inner-${item.id}`} />
          </div>
        );
      };

      const { unmount, getByTestId } = render(
        <App items={items} renderItem={renderItem} />,
      );
      const handle: HTMLElement = getByTestId('handle-0');
      const inner: HTMLElement = getByTestId('inner-0');

      simpleLift(control, inner);

      expect(isDragging(handle)).toBe(true);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/interactive-elements.spec.js,Lazy Test,"{'line': 153, 'column': 13, 'index': 4699}","it('should allow dragging from with an interactive parent if instructed', () => {
    forEachTagName((tagName: string) => {
      const items: Item[] = [{ id: '0', canDragInteractiveElements: true }];
      const renderItem = (item: Item) => (
        provided: DraggableProvided,
        snapshot: DraggableStateSnapshot,
      ) => {
        const TagName = tagName;
        return (
          <div
            {...provided.draggableProps}
            {...provided.dragHandleProps}
            ref={provided.innerRef}
            data-is-dragging={snapshot.isDragging}
            data-testid={`handle-${item.id}`}
          >
            <TagName data-testid={`inner-${item.id}`} />
          </div>
        );
      };

      const { unmount, getByTestId } = render(
        <App items={items} renderItem={renderItem} />,
      );
      const handle: HTMLElement = getByTestId('handle-0');
      const inner: HTMLElement = getByTestId('inner-0');

      simpleLift(control, inner);

      expect(isDragging(handle)).toBe(true);

      unmount();
    });
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/disable-default-sensors.spec.js,Eager Test,"{'line': 13, 'column': 4, 'index': 495}","it('should be able to start a drag if default sensors is disabled', () => {
    const { getByText } = render(<App enableDefaultSensors={false} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/disable-default-sensors.spec.js,Eager Test,"{'line': 14, 'column': 11, 'index': 535}","it('should be able to start a drag if default sensors is disabled', () => {
    const { getByText } = render(<App enableDefaultSensors={false} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Eager Test,"{'line': 40, 'column': 4, 'index': 1213}","it('should block the drag if the drag handle is itself contenteditable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={item.id}
        contentEditable
      />
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const handle: HTMLElement = getByTestId('0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Eager Test,"{'line': 42, 'column': 11, 'index': 1254}","it('should block the drag if the drag handle is itself contenteditable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={item.id}
        contentEditable
      />
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const handle: HTMLElement = getByTestId('0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Eager Test,"{'line': 65, 'column': 4, 'index': 1989}","it('should block the drag if originated from a child contenteditable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`handle-${item.id}`}
      >
        <div data-testid={`inner-${item.id}`} contentEditable />
      </div>
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const inner: HTMLElement = getByTestId('inner-0');
    const handle: HTMLElement = getByTestId('handle-0');

    simpleLift(control, inner);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Eager Test,"{'line': 67, 'column': 11, 'index': 2029}","it('should block the drag if originated from a child contenteditable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`handle-${item.id}`}
      >
        <div data-testid={`inner-${item.id}`} contentEditable />
      </div>
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const inner: HTMLElement = getByTestId('inner-0');
    const handle: HTMLElement = getByTestId('handle-0');

    simpleLift(control, inner);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Eager Test,"{'line': 93, 'column': 4, 'index': 2849}","it('should block the drag if originated from a child of a child contenteditable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`handle-${item.id}`}
      >
        <div contentEditable>
          <p>hello there</p>
          <span data-testid={`inner-${item.id}`}>Edit me!</span>
        </div>
      </div>
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const inner: HTMLElement = getByTestId('inner-0');
    const handle: HTMLElement = getByTestId('handle-0');

    simpleLift(control, inner);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Eager Test,"{'line': 95, 'column': 11, 'index': 2889}","it('should block the drag if originated from a child of a child contenteditable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`handle-${item.id}`}
      >
        <div contentEditable>
          <p>hello there</p>
          <span data-testid={`inner-${item.id}`}>Edit me!</span>
        </div>
      </div>
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const inner: HTMLElement = getByTestId('inner-0');
    const handle: HTMLElement = getByTestId('handle-0');

    simpleLift(control, inner);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Eager Test,"{'line': 116, 'column': 4, 'index': 3492}","it('should not block if contenteditable is set to false', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={item.id}
        contentEditable=""false""
      />
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const handle: HTMLElement = getByTestId('0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Eager Test,"{'line': 118, 'column': 11, 'index': 3533}","it('should not block if contenteditable is set to false', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={item.id}
        contentEditable=""false""
      />
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const handle: HTMLElement = getByTestId('0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Eager Test,"{'line': 143, 'column': 4, 'index': 4246}","it('should not block a drag if dragging interactive elements is allowed', () => {
    const items: Item[] = [{ id: '0', canDragInteractiveElements: true }];

    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={item.id}
        contentEditable
      />
    );

    const { getByTestId } = render(
      <App items={items} renderItem={renderItem} />,
    );
    const handle: HTMLElement = getByTestId('0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Eager Test,"{'line': 145, 'column': 11, 'index': 4287}","it('should not block a drag if dragging interactive elements is allowed', () => {
    const items: Item[] = [{ id: '0', canDragInteractiveElements: true }];

    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={item.id}
        contentEditable
      />
    );

    const { getByTestId } = render(
      <App items={items} renderItem={renderItem} />,
    );
    const handle: HTMLElement = getByTestId('0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Lazy Test,"{'line': 40, 'column': 4, 'index': 1213}","it('should block the drag if the drag handle is itself contenteditable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={item.id}
        contentEditable
      />
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const handle: HTMLElement = getByTestId('0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Lazy Test,"{'line': 42, 'column': 11, 'index': 1254}","it('should block the drag if the drag handle is itself contenteditable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={item.id}
        contentEditable
      />
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const handle: HTMLElement = getByTestId('0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Lazy Test,"{'line': 65, 'column': 4, 'index': 1989}","it('should block the drag if originated from a child contenteditable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`handle-${item.id}`}
      >
        <div data-testid={`inner-${item.id}`} contentEditable />
      </div>
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const inner: HTMLElement = getByTestId('inner-0');
    const handle: HTMLElement = getByTestId('handle-0');

    simpleLift(control, inner);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Lazy Test,"{'line': 67, 'column': 11, 'index': 2029}","it('should block the drag if originated from a child contenteditable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`handle-${item.id}`}
      >
        <div data-testid={`inner-${item.id}`} contentEditable />
      </div>
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const inner: HTMLElement = getByTestId('inner-0');
    const handle: HTMLElement = getByTestId('handle-0');

    simpleLift(control, inner);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Lazy Test,"{'line': 93, 'column': 4, 'index': 2849}","it('should block the drag if originated from a child of a child contenteditable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`handle-${item.id}`}
      >
        <div contentEditable>
          <p>hello there</p>
          <span data-testid={`inner-${item.id}`}>Edit me!</span>
        </div>
      </div>
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const inner: HTMLElement = getByTestId('inner-0');
    const handle: HTMLElement = getByTestId('handle-0');

    simpleLift(control, inner);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Lazy Test,"{'line': 95, 'column': 11, 'index': 2889}","it('should block the drag if originated from a child of a child contenteditable', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={`handle-${item.id}`}
      >
        <div contentEditable>
          <p>hello there</p>
          <span data-testid={`inner-${item.id}`}>Edit me!</span>
        </div>
      </div>
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const inner: HTMLElement = getByTestId('inner-0');
    const handle: HTMLElement = getByTestId('handle-0');

    simpleLift(control, inner);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Lazy Test,"{'line': 116, 'column': 4, 'index': 3492}","it('should not block if contenteditable is set to false', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={item.id}
        contentEditable=""false""
      />
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const handle: HTMLElement = getByTestId('0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Lazy Test,"{'line': 118, 'column': 11, 'index': 3533}","it('should not block if contenteditable is set to false', () => {
    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={item.id}
        contentEditable=""false""
      />
    );

    const { getByTestId } = render(<App renderItem={renderItem} />);
    const handle: HTMLElement = getByTestId('0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Lazy Test,"{'line': 143, 'column': 4, 'index': 4246}","it('should not block a drag if dragging interactive elements is allowed', () => {
    const items: Item[] = [{ id: '0', canDragInteractiveElements: true }];

    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={item.id}
        contentEditable
      />
    );

    const { getByTestId } = render(
      <App items={items} renderItem={renderItem} />,
    );
    const handle: HTMLElement = getByTestId('0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/contenteditable.spec.js,Lazy Test,"{'line': 145, 'column': 11, 'index': 4287}","it('should not block a drag if dragging interactive elements is allowed', () => {
    const items: Item[] = [{ id: '0', canDragInteractiveElements: true }];

    const renderItem = (item: Item) => (
      provided: DraggableProvided,
      snapshot: DraggableStateSnapshot,
    ) => (
      <div
        {...provided.draggableProps}
        {...provided.dragHandleProps}
        ref={provided.innerRef}
        data-is-dragging={snapshot.isDragging}
        data-testid={item.id}
        contentEditable
      />
    );

    const { getByTestId } = render(
      <App items={items} renderItem={renderItem} />,
    );
    const handle: HTMLElement = getByTestId('0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cleanup.spec.js,Eager Test,"{'line': 34, 'column': 4, 'index': 997}","it('should remove all window listeners when unmounting mid drag', () => {
    jest.spyOn(window, 'addEventListener');
    jest.spyOn(window, 'removeEventListener');

    const { unmount, getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    // mid drag
    simpleLift(control, handle);
    expect(isDragging(handle)).toEqual(true);

    unmount();

    expect(getCallCount(window.addEventListener)).toEqual(
      getCallCount(window.removeEventListener),
    );
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cleanup.spec.js,Eager Test,"{'line': 35, 'column': 11, 'index': 1037}","it('should remove all window listeners when unmounting mid drag', () => {
    jest.spyOn(window, 'addEventListener');
    jest.spyOn(window, 'removeEventListener');

    const { unmount, getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    // mid drag
    simpleLift(control, handle);
    expect(isDragging(handle)).toEqual(true);

    unmount();

    expect(getCallCount(window.addEventListener)).toEqual(
      getCallCount(window.removeEventListener),
    );
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cannot-start-when-unmounted.spec.js,Eager Test,"{'line': 15, 'column': 4, 'index': 485}","it('should not allow starting after the handle is unmounted', () => {
    const { getByText, unmount } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    unmount();

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cannot-start-when-unmounted.spec.js,Eager Test,"{'line': 17, 'column': 11, 'index': 526}","it('should not allow starting after the handle is unmounted', () => {
    const { getByText, unmount } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    unmount();

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cannot-start-when-something-else-has-lock.spec.js,Eager Test,"{'line': 19, 'column': 4, 'index': 684}","it('should not start a drag if another sensor is capturing', () => {
    let api: SensorAPI;
    function greedy(value: SensorAPI) {
      api = value;
    }
    const { getByText } = render(<App sensors={[greedy]} />);
    const handle: HTMLElement = getByText('item: 0');

    invariant(api, 'Expected function to be set');
    api.tryGetLock('0');

    // won't be able to lift as the lock is already claimed
    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cannot-start-when-something-else-has-lock.spec.js,Eager Test,"{'line': 23, 'column': 4, 'index': 821}","it('should not start a drag if another sensor is capturing', () => {
    let api: SensorAPI;
    function greedy(value: SensorAPI) {
      api = value;
    }
    const { getByText } = render(<App sensors={[greedy]} />);
    const handle: HTMLElement = getByText('item: 0');

    invariant(api, 'Expected function to be set');
    api.tryGetLock('0');

    // won't be able to lift as the lock is already claimed
    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cannot-start-when-something-else-has-lock.spec.js,Eager Test,"{'line': 25, 'column': 11, 'index': 862}","it('should not start a drag if another sensor is capturing', () => {
    let api: SensorAPI;
    function greedy(value: SensorAPI) {
      api = value;
    }
    const { getByText } = render(<App sensors={[greedy]} />);
    const handle: HTMLElement = getByText('item: 0');

    invariant(api, 'Expected function to be set');
    api.tryGetLock('0');

    // won't be able to lift as the lock is already claimed
    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cannot-start-when-disabled.spec.js,Eager Test,"{'line': 15, 'column': 4, 'index': 529}","it('should not start a drag if disabled', () => {
    const items: Item[] = [{ id: '0', isEnabled: false }];

    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cannot-start-when-disabled.spec.js,Eager Test,"{'line': 17, 'column': 11, 'index': 570}","it('should not start a drag if disabled', () => {
    const items: Item[] = [{ id: '0', isEnabled: false }];

    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Duplicate Assert,"{'line': 17, 'column': 4, 'index': 756}","it('should cancel when pressing escape', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = createEvent.keyDown(handle, {
      keyCode: keyCodes.escape,
    });

    fireEvent(handle, event);

    // event consumed
    expect(event.defaultPrevented).toBe(true);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Duplicate Assert,"{'line': 29, 'column': 4, 'index': 1028}","it('should cancel when pressing escape', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = createEvent.keyDown(handle, {
      keyCode: keyCodes.escape,
    });

    fireEvent(handle, event);

    // event consumed
    expect(event.defaultPrevented).toBe(true);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Duplicate Assert,"{'line': 39, 'column': 4, 'index': 1380}","it('should cancel when window is resized', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event('resize', {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Duplicate Assert,"{'line': 52, 'column': 4, 'index': 1690}","it('should cancel when window is resized', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event('resize', {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Duplicate Assert,"{'line': 62, 'column': 4, 'index': 2053}","it('should cancel when there is a visibility change', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event(supportedEventName, {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Duplicate Assert,"{'line': 75, 'column': 4, 'index': 2373}","it('should cancel when there is a visibility change', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event(supportedEventName, {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Eager Test,"{'line': 16, 'column': 4, 'index': 723}","it('should cancel when pressing escape', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = createEvent.keyDown(handle, {
      keyCode: keyCodes.escape,
    });

    fireEvent(handle, event);

    // event consumed
    expect(event.defaultPrevented).toBe(true);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Eager Test,"{'line': 17, 'column': 11, 'index': 763}","it('should cancel when pressing escape', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = createEvent.keyDown(handle, {
      keyCode: keyCodes.escape,
    });

    fireEvent(handle, event);

    // event consumed
    expect(event.defaultPrevented).toBe(true);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Eager Test,"{'line': 29, 'column': 11, 'index': 1035}","it('should cancel when pressing escape', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = createEvent.keyDown(handle, {
      keyCode: keyCodes.escape,
    });

    fireEvent(handle, event);

    // event consumed
    expect(event.defaultPrevented).toBe(true);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Eager Test,"{'line': 38, 'column': 4, 'index': 1347}","it('should cancel when window is resized', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event('resize', {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Eager Test,"{'line': 39, 'column': 11, 'index': 1387}","it('should cancel when window is resized', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event('resize', {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Eager Test,"{'line': 52, 'column': 11, 'index': 1697}","it('should cancel when window is resized', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event('resize', {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Eager Test,"{'line': 61, 'column': 4, 'index': 2020}","it('should cancel when there is a visibility change', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event(supportedEventName, {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Eager Test,"{'line': 62, 'column': 11, 'index': 2060}","it('should cancel when there is a visibility change', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event(supportedEventName, {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Eager Test,"{'line': 75, 'column': 11, 'index': 2380}","it('should cancel when there is a visibility change', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event(supportedEventName, {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Eager Test,"{'line': 76, 'column': 11, 'index': 2424}","it('should cancel when there is a visibility change', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event(supportedEventName, {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Lazy Test,"{'line': 16, 'column': 4, 'index': 723}","it('should cancel when pressing escape', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = createEvent.keyDown(handle, {
      keyCode: keyCodes.escape,
    });

    fireEvent(handle, event);

    // event consumed
    expect(event.defaultPrevented).toBe(true);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Lazy Test,"{'line': 17, 'column': 11, 'index': 763}","it('should cancel when pressing escape', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = createEvent.keyDown(handle, {
      keyCode: keyCodes.escape,
    });

    fireEvent(handle, event);

    // event consumed
    expect(event.defaultPrevented).toBe(true);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Lazy Test,"{'line': 38, 'column': 4, 'index': 1347}","it('should cancel when window is resized', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event('resize', {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Lazy Test,"{'line': 39, 'column': 11, 'index': 1387}","it('should cancel when window is resized', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event('resize', {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(onDragEnd.mock.calls[0][0].reason).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Lazy Test,"{'line': 61, 'column': 4, 'index': 2020}","it('should cancel when there is a visibility change', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event(supportedEventName, {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/cancel-while-dragging.spec.js,Lazy Test,"{'line': 62, 'column': 11, 'index': 2060}","it('should cancel when there is a visibility change', () => {
    const onDragEnd = jest.fn();
    const { getByText } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    // cancel
    const event: Event = new Event(supportedEventName, {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(handle, event);

    // event not consumed as it is an indirect cancel
    expect(event.defaultPrevented).toBe(false);
    // drag ended
    expect(isDragging(handle)).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Conditional Test Logic,"{'line': 27, 'column': 2, 'index': 814}",Unknown,steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Eager Test,"{'line': 66, 'column': 14, 'index': 1632}","it('should abort a drag if an invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() =>
              invariant(false, 'Do not pass go, do not collect $200')
            }
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    thrower.execute();

    const newHandle: HTMLElement = getByText('item: 0');
    // handle is now a new element
    expect(handle).not.toBe(newHandle);
    expect(isDragging(newHandle)).toBe(false);

    // moving the handles around
    expect(() => {
      control.move(handle);
      control.move(newHandle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
      expect(getOffset(newHandle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Eager Test,"{'line': 75, 'column': 4, 'index': 1851}","it('should abort a drag if an invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() =>
              invariant(false, 'Do not pass go, do not collect $200')
            }
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    thrower.execute();

    const newHandle: HTMLElement = getByText('item: 0');
    // handle is now a new element
    expect(handle).not.toBe(newHandle);
    expect(isDragging(newHandle)).toBe(false);

    // moving the handles around
    expect(() => {
      control.move(handle);
      control.move(newHandle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
      expect(getOffset(newHandle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Eager Test,"{'line': 76, 'column': 11, 'index': 1891}","it('should abort a drag if an invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() =>
              invariant(false, 'Do not pass go, do not collect $200')
            }
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    thrower.execute();

    const newHandle: HTMLElement = getByText('item: 0');
    // handle is now a new element
    expect(handle).not.toBe(newHandle);
    expect(isDragging(newHandle)).toBe(false);

    // moving the handles around
    expect(() => {
      control.move(handle);
      control.move(newHandle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
      expect(getOffset(newHandle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Eager Test,"{'line': 83, 'column': 11, 'index': 2091}","it('should abort a drag if an invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() =>
              invariant(false, 'Do not pass go, do not collect $200')
            }
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    thrower.execute();

    const newHandle: HTMLElement = getByText('item: 0');
    // handle is now a new element
    expect(handle).not.toBe(newHandle);
    expect(isDragging(newHandle)).toBe(false);

    // moving the handles around
    expect(() => {
      control.move(handle);
      control.move(newHandle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
      expect(getOffset(newHandle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Eager Test,"{'line': 89, 'column': 13, 'index': 2252}","it('should abort a drag if an invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() =>
              invariant(false, 'Do not pass go, do not collect $200')
            }
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    thrower.execute();

    const newHandle: HTMLElement = getByText('item: 0');
    // handle is now a new element
    expect(handle).not.toBe(newHandle);
    expect(isDragging(newHandle)).toBe(false);

    // moving the handles around
    expect(() => {
      control.move(handle);
      control.move(newHandle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
      expect(getOffset(newHandle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Eager Test,"{'line': 90, 'column': 13, 'index': 2309}","it('should abort a drag if an invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() =>
              invariant(false, 'Do not pass go, do not collect $200')
            }
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    thrower.execute();

    const newHandle: HTMLElement = getByText('item: 0');
    // handle is now a new element
    expect(handle).not.toBe(newHandle);
    expect(isDragging(newHandle)).toBe(false);

    // moving the handles around
    expect(() => {
      control.move(handle);
      control.move(newHandle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
      expect(getOffset(newHandle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Eager Test,"{'line': 110, 'column': 4, 'index': 2857}","it('should abort a drag if an a non-invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText, queryByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              throw new Error('Raw error throw');
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    expect(() => {
      thrower.execute();
    }).toThrow();

    // handle is gone
    expect(queryByText('item: 0')).toBe(null);

    // strange - but firing events on old handle
    expect(() => {
      control.move(handle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Eager Test,"{'line': 111, 'column': 11, 'index': 2897}","it('should abort a drag if an a non-invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText, queryByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              throw new Error('Raw error throw');
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    expect(() => {
      thrower.execute();
    }).toThrow();

    // handle is gone
    expect(queryByText('item: 0')).toBe(null);

    // strange - but firing events on old handle
    expect(() => {
      control.move(handle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Eager Test,"{'line': 123, 'column': 13, 'index': 3172}","it('should abort a drag if an a non-invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText, queryByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              throw new Error('Raw error throw');
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    expect(() => {
      thrower.execute();
    }).toThrow();

    // handle is gone
    expect(queryByText('item: 0')).toBe(null);

    // strange - but firing events on old handle
    expect(() => {
      control.move(handle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Eager Test,"{'line': 143, 'column': 4, 'index': 3661}","it('should abort a drag if a runtime error occurs', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              causeRuntimeError();
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    withWarn(() => {
      thrower.execute();
    });

    expect(isDragging(getByText('item: 0'))).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Eager Test,"{'line': 144, 'column': 11, 'index': 3701}","it('should abort a drag if a runtime error occurs', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              causeRuntimeError();
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    withWarn(() => {
      thrower.execute();
    });

    expect(isDragging(getByText('item: 0'))).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Eager Test,"{'line': 150, 'column': 11, 'index': 3800}","it('should abort a drag if a runtime error occurs', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              causeRuntimeError();
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    withWarn(() => {
      thrower.execute();
    });

    expect(isDragging(getByText('item: 0'))).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Exception Handling,"{'line': 101, 'column': 14, 'index': 2657}","it('should abort a drag if an a non-invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText, queryByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              throw new Error('Raw error throw');
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    expect(() => {
      thrower.execute();
    }).toThrow();

    // handle is gone
    expect(queryByText('item: 0')).toBe(null);

    // strange - but firing events on old handle
    expect(() => {
      control.move(handle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Lazy Test,"{'line': 75, 'column': 4, 'index': 1851}","it('should abort a drag if an invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() =>
              invariant(false, 'Do not pass go, do not collect $200')
            }
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    thrower.execute();

    const newHandle: HTMLElement = getByText('item: 0');
    // handle is now a new element
    expect(handle).not.toBe(newHandle);
    expect(isDragging(newHandle)).toBe(false);

    // moving the handles around
    expect(() => {
      control.move(handle);
      control.move(newHandle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
      expect(getOffset(newHandle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Lazy Test,"{'line': 76, 'column': 11, 'index': 1891}","it('should abort a drag if an invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() =>
              invariant(false, 'Do not pass go, do not collect $200')
            }
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    thrower.execute();

    const newHandle: HTMLElement = getByText('item: 0');
    // handle is now a new element
    expect(handle).not.toBe(newHandle);
    expect(isDragging(newHandle)).toBe(false);

    // moving the handles around
    expect(() => {
      control.move(handle);
      control.move(newHandle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
      expect(getOffset(newHandle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Lazy Test,"{'line': 89, 'column': 13, 'index': 2252}","it('should abort a drag if an invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() =>
              invariant(false, 'Do not pass go, do not collect $200')
            }
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    thrower.execute();

    const newHandle: HTMLElement = getByText('item: 0');
    // handle is now a new element
    expect(handle).not.toBe(newHandle);
    expect(isDragging(newHandle)).toBe(false);

    // moving the handles around
    expect(() => {
      control.move(handle);
      control.move(newHandle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
      expect(getOffset(newHandle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Lazy Test,"{'line': 110, 'column': 4, 'index': 2857}","it('should abort a drag if an a non-invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText, queryByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              throw new Error('Raw error throw');
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    expect(() => {
      thrower.execute();
    }).toThrow();

    // handle is gone
    expect(queryByText('item: 0')).toBe(null);

    // strange - but firing events on old handle
    expect(() => {
      control.move(handle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Lazy Test,"{'line': 111, 'column': 11, 'index': 2897}","it('should abort a drag if an a non-invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText, queryByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              throw new Error('Raw error throw');
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    expect(() => {
      thrower.execute();
    }).toThrow();

    // handle is gone
    expect(queryByText('item: 0')).toBe(null);

    // strange - but firing events on old handle
    expect(() => {
      control.move(handle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Lazy Test,"{'line': 123, 'column': 13, 'index': 3172}","it('should abort a drag if an a non-invariant error occurs in the application', () => {
    const thrower: Thrower = getThrower();
    const { getByText, queryByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              throw new Error('Raw error throw');
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    expect(() => {
      thrower.execute();
    }).toThrow();

    // handle is gone
    expect(queryByText('item: 0')).toBe(null);

    // strange - but firing events on old handle
    expect(() => {
      control.move(handle);
      expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
    }).not.toThrow();
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Lazy Test,"{'line': 143, 'column': 4, 'index': 3661}","it('should abort a drag if a runtime error occurs', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              causeRuntimeError();
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    withWarn(() => {
      thrower.execute();
    });

    expect(isDragging(getByText('item: 0'))).toBe(false);
  })",steel
/test/unit/integration/drag-handle/shared-behaviours/abort-on-error.spec.js,Lazy Test,"{'line': 144, 'column': 11, 'index': 3701}","it('should abort a drag if a runtime error occurs', () => {
    const thrower: Thrower = getThrower();
    const { getByText } = render(
      <App
        anotherChild={
          <Vomit
            throw={() => {
              causeRuntimeError();
            }}
            setForceThrow={thrower.setForceThrow}
          />
        }
      />,
    );
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(control, handle);
    expect(isDragging(handle)).toBe(true);

    withWarn(() => {
      thrower.execute();
    });

    expect(isDragging(getByText('item: 0'))).toBe(false);
  })",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Duplicate Assert,"{'line': 33, 'column': 2, 'index': 809}","it('should not allow pre drag actions when in a dragging phase', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  // it is currently active
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();

  // pre drag now outdated
  expect(preDrag.isActive()).toBe(false);
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );

  // drag is active - not aborted by preDrag
  expect(drag.isActive()).toBe(true);

  // ending drag
  warn.mockClear();
  act(() => drag.drop());
  expect(warn).not.toHaveBeenCalled();

  // preDrag is still out of date
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Duplicate Assert,"{'line': 38, 'column': 2, 'index': 931}","it('should not allow pre drag actions when in a dragging phase', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  // it is currently active
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();

  // pre drag now outdated
  expect(preDrag.isActive()).toBe(false);
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );

  // drag is active - not aborted by preDrag
  expect(drag.isActive()).toBe(true);

  // ending drag
  warn.mockClear();
  act(() => drag.drop());
  expect(warn).not.toHaveBeenCalled();

  // preDrag is still out of date
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Duplicate Assert,"{'line': 40, 'column': 2, 'index': 992}","it('should not allow pre drag actions when in a dragging phase', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  // it is currently active
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();

  // pre drag now outdated
  expect(preDrag.isActive()).toBe(false);
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );

  // drag is active - not aborted by preDrag
  expect(drag.isActive()).toBe(true);

  // ending drag
  warn.mockClear();
  act(() => drag.drop());
  expect(warn).not.toHaveBeenCalled();

  // preDrag is still out of date
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Duplicate Assert,"{'line': 40, 'column': 2, 'index': 992}","it('should not allow pre drag actions when in a dragging phase', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  // it is currently active
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();

  // pre drag now outdated
  expect(preDrag.isActive()).toBe(false);
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );

  // drag is active - not aborted by preDrag
  expect(drag.isActive()).toBe(true);

  // ending drag
  warn.mockClear();
  act(() => drag.drop());
  expect(warn).not.toHaveBeenCalled();

  // preDrag is still out of date
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Duplicate Assert,"{'line': 54, 'column': 2, 'index': 1333}","it('should not allow pre drag actions when in a dragging phase', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  // it is currently active
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();

  // pre drag now outdated
  expect(preDrag.isActive()).toBe(false);
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );

  // drag is active - not aborted by preDrag
  expect(drag.isActive()).toBe(true);

  // ending drag
  warn.mockClear();
  act(() => drag.drop());
  expect(warn).not.toHaveBeenCalled();

  // preDrag is still out of date
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Duplicate Assert,"{'line': 54, 'column': 2, 'index': 1333}","it('should not allow pre drag actions when in a dragging phase', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  // it is currently active
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();

  // pre drag now outdated
  expect(preDrag.isActive()).toBe(false);
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );

  // drag is active - not aborted by preDrag
  expect(drag.isActive()).toBe(true);

  // ending drag
  warn.mockClear();
  act(() => drag.drop());
  expect(warn).not.toHaveBeenCalled();

  // preDrag is still out of date
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Duplicate Assert,"{'line': 72, 'column': 2, 'index': 1843}","it('should not allow drag actions after a drop', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();
  expect(drag.isActive()).toBe(true);

  act(() => drag.cancel());

  // no longer active
  expect(drag.isActive()).toBe(false);
  expect(warn).not.toHaveBeenCalled();

  drag.moveUp();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Duplicate Assert,"{'line': 77, 'column': 2, 'index': 1933}","it('should not allow drag actions after a drop', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();
  expect(drag.isActive()).toBe(true);

  act(() => drag.cancel());

  // no longer active
  expect(drag.isActive()).toBe(false);
  expect(warn).not.toHaveBeenCalled();

  drag.moveUp();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Duplicate Assert,"{'line': 96, 'column': 2, 'index': 2470}","it('should not allow drag actions after lock lost', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { unmount } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected first to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  expect(preDrag.isActive()).toBe(true);

  // will cause all lock to be lost
  unmount();

  expect(preDrag.isActive()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Duplicate Assert,"{'line': 101, 'column': 2, 'index': 2562}","it('should not allow drag actions after lock lost', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { unmount } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected first to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  expect(preDrag.isActive()).toBe(true);

  // will cause all lock to be lost
  unmount();

  expect(preDrag.isActive()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Eager Test,"{'line': 28, 'column': 2, 'index': 658}","it('should not allow pre drag actions when in a dragging phase', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  // it is currently active
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();

  // pre drag now outdated
  expect(preDrag.isActive()).toBe(false);
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );

  // drag is active - not aborted by preDrag
  expect(drag.isActive()).toBe(true);

  // ending drag
  warn.mockClear();
  act(() => drag.drop());
  expect(warn).not.toHaveBeenCalled();

  // preDrag is still out of date
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Eager Test,"{'line': 31, 'column': 2, 'index': 759}","it('should not allow pre drag actions when in a dragging phase', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  // it is currently active
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();

  // pre drag now outdated
  expect(preDrag.isActive()).toBe(false);
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );

  // drag is active - not aborted by preDrag
  expect(drag.isActive()).toBe(true);

  // ending drag
  warn.mockClear();
  act(() => drag.drop());
  expect(warn).not.toHaveBeenCalled();

  // preDrag is still out of date
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Eager Test,"{'line': 65, 'column': 2, 'index': 1626}","it('should not allow drag actions after a drop', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();
  expect(drag.isActive()).toBe(true);

  act(() => drag.cancel());

  // no longer active
  expect(drag.isActive()).toBe(false);
  expect(warn).not.toHaveBeenCalled();

  drag.moveUp();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Eager Test,"{'line': 68, 'column': 2, 'index': 1727}","it('should not allow drag actions after a drop', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();
  expect(drag.isActive()).toBe(true);

  act(() => drag.cancel());

  // no longer active
  expect(drag.isActive()).toBe(false);
  expect(warn).not.toHaveBeenCalled();

  drag.moveUp();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Eager Test,"{'line': 92, 'column': 2, 'index': 2345}","it('should not allow drag actions after lock lost', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { unmount } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected first to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  expect(preDrag.isActive()).toBe(true);

  // will cause all lock to be lost
  unmount();

  expect(preDrag.isActive()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Eager Test,"{'line': 95, 'column': 2, 'index': 2448}","it('should not allow drag actions after lock lost', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { unmount } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected first to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  expect(preDrag.isActive()).toBe(true);

  // will cause all lock to be lost
  unmount();

  expect(preDrag.isActive()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Lazy Test,"{'line': 28, 'column': 2, 'index': 658}","it('should not allow pre drag actions when in a dragging phase', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  // it is currently active
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();

  // pre drag now outdated
  expect(preDrag.isActive()).toBe(false);
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );

  // drag is active - not aborted by preDrag
  expect(drag.isActive()).toBe(true);

  // ending drag
  warn.mockClear();
  act(() => drag.drop());
  expect(warn).not.toHaveBeenCalled();

  // preDrag is still out of date
  preDrag.abort();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Lazy Test,"{'line': 65, 'column': 2, 'index': 1626}","it('should not allow drag actions after a drop', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected api to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();
  expect(drag.isActive()).toBe(true);

  act(() => drag.cancel());

  // no longer active
  expect(drag.isActive()).toBe(false);
  expect(warn).not.toHaveBeenCalled();

  drag.moveUp();
  expect(warn.mock.calls[0][0]).toEqual(
    expect.stringContaining('Cannot perform action'),
  );
})",steel
/test/unit/integration/drag-handle/sensor-marshal/outdated-locks.spec.js,Lazy Test,"{'line': 92, 'column': 2, 'index': 2345}","it('should not allow drag actions after lock lost', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { unmount } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected first to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  expect(preDrag.isActive()).toBe(true);

  // will cause all lock to be lost
  unmount();

  expect(preDrag.isActive()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Conditional Test Logic,"{'line': 137, 'column': 21, 'index': 3923}","it('should release a lock when cancelling or dropping a drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  ['cancel', 'drop'].forEach((property: string) => {
    const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
    invariant(preDrag, 'Expected to get lock');
    expect(preDrag.isActive()).toBe(true);

    const drag: SnapDragActions = preDrag.snapLift();
    expect(drag.isActive()).toBe(true);

    // cannot get another lock
    const second: ?PreDragActions = api.tryGetLock('1', noop);
    expect(second).toBe(null);

    // calling cancel or drop
    act(() => {
      drag[property]();
    });

    // can now get another lock
    const third: ?PreDragActions = api.tryGetLock('1', noop);
    expect(third).toBeTruthy();
    // need to try to release it
    invariant(third);
    third.abort();
  });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Duplicate Assert,"{'line': 33, 'column': 2, 'index': 811}","it('should allow an exclusive lock for drag actions', () => {
  let first: SensorAPI;
  let second: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(<App sensors={[a, b]} />);
  invariant(first, 'expected first to be set');
  invariant(second, 'expected second to be set');

  // first can get a lock
  expect(first.tryGetLock('0')).toBeTruthy();

  // second cannot get a lock
  expect(second.tryGetLock('0')).toBe(null);

  // first cannot get another lock on the same element
  expect(first.tryGetLock('0')).toBe(null);

  // nothing cannot get lock on a different element
  expect(first.tryGetLock('1')).toBe(null);
  expect(second.tryGetLock('1')).toBe(null);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Duplicate Assert,"{'line': 39, 'column': 2, 'index': 989}","it('should allow an exclusive lock for drag actions', () => {
  let first: SensorAPI;
  let second: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(<App sensors={[a, b]} />);
  invariant(first, 'expected first to be set');
  invariant(second, 'expected second to be set');

  // first can get a lock
  expect(first.tryGetLock('0')).toBeTruthy();

  // second cannot get a lock
  expect(second.tryGetLock('0')).toBe(null);

  // first cannot get another lock on the same element
  expect(first.tryGetLock('0')).toBe(null);

  // nothing cannot get lock on a different element
  expect(first.tryGetLock('1')).toBe(null);
  expect(second.tryGetLock('1')).toBe(null);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Duplicate Assert,"{'line': 82, 'column': 2, 'index': 2254}","it('should not allow a sensor to obtain a on a dropping item, but can claim one on something else while dragging', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');

  // drag not started yet
  expect(isDragging(handle)).toBe(false);
  // start a drag
  const actions: FluidDragActions = preDrag.fluidLift({ x: 0, y: 0 });
  expect(isDragging(handle)).toBe(true);

  // release the movement
  actions.move({ x: 100, y: 100 });
  requestAnimationFrame.flush();

  actions.drop();
  expect(isDropAnimating(handle)).toBe(true);

  // lock is no longer active
  expect(actions.isActive()).toBe(false);
  expect(preDrag.isActive()).toBe(false);

  // cannot get a new lock while still dropping
  expect(api.tryGetLock('0', noop)).toBe(null);

  // can get a lock on a handle that is not dropping - while the other is dropping
  expect(api.tryGetLock('1', noop)).toBeTruthy();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Duplicate Assert,"{'line': 85, 'column': 2, 'index': 2385}","it('should not allow a sensor to obtain a on a dropping item, but can claim one on something else while dragging', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');

  // drag not started yet
  expect(isDragging(handle)).toBe(false);
  // start a drag
  const actions: FluidDragActions = preDrag.fluidLift({ x: 0, y: 0 });
  expect(isDragging(handle)).toBe(true);

  // release the movement
  actions.move({ x: 100, y: 100 });
  requestAnimationFrame.flush();

  actions.drop();
  expect(isDropAnimating(handle)).toBe(true);

  // lock is no longer active
  expect(actions.isActive()).toBe(false);
  expect(preDrag.isActive()).toBe(false);

  // cannot get a new lock while still dropping
  expect(api.tryGetLock('0', noop)).toBe(null);

  // can get a lock on a handle that is not dropping - while the other is dropping
  expect(api.tryGetLock('1', noop)).toBeTruthy();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Duplicate Assert,"{'line': 115, 'column': 2, 'index': 3286}","it('should release a lock when aborting a pre drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');
  expect(preDrag.isActive()).toBe(true);
  // should release the lock
  preDrag.abort();
  expect(preDrag.isActive()).toBe(false);

  // can get another lock
  const second: ?PreDragActions = api.tryGetLock('1', noop);
  expect(second).toBeTruthy();
  invariant(second);
  // need to release this one :)
  second.abort();
  expect(second.isActive()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Duplicate Assert,"{'line': 118, 'column': 2, 'index': 3375}","it('should release a lock when aborting a pre drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');
  expect(preDrag.isActive()).toBe(true);
  // should release the lock
  preDrag.abort();
  expect(preDrag.isActive()).toBe(false);

  // can get another lock
  const second: ?PreDragActions = api.tryGetLock('1', noop);
  expect(second).toBeTruthy();
  invariant(second);
  // need to release this one :)
  second.abort();
  expect(second.isActive()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 29, 'column': 2, 'index': 686}","it('should allow an exclusive lock for drag actions', () => {
  let first: SensorAPI;
  let second: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(<App sensors={[a, b]} />);
  invariant(first, 'expected first to be set');
  invariant(second, 'expected second to be set');

  // first can get a lock
  expect(first.tryGetLock('0')).toBeTruthy();

  // second cannot get a lock
  expect(second.tryGetLock('0')).toBe(null);

  // first cannot get another lock on the same element
  expect(first.tryGetLock('0')).toBe(null);

  // nothing cannot get lock on a different element
  expect(first.tryGetLock('1')).toBe(null);
  expect(second.tryGetLock('1')).toBe(null);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 30, 'column': 2, 'index': 734}","it('should allow an exclusive lock for drag actions', () => {
  let first: SensorAPI;
  let second: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(<App sensors={[a, b]} />);
  invariant(first, 'expected first to be set');
  invariant(second, 'expected second to be set');

  // first can get a lock
  expect(first.tryGetLock('0')).toBeTruthy();

  // second cannot get a lock
  expect(second.tryGetLock('0')).toBe(null);

  // first cannot get another lock on the same element
  expect(first.tryGetLock('0')).toBe(null);

  // nothing cannot get lock on a different element
  expect(first.tryGetLock('1')).toBe(null);
  expect(second.tryGetLock('1')).toBe(null);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 53, 'column': 2, 'index': 1361}","it('should allow a lock to be released', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };

  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  Array.from({ length: 4 }).forEach(() => {
    // get the lock
    const lock: ?PreDragActions = api.tryGetLock('0', noop);
    expect(lock).toBeTruthy();
    invariant(lock, 'Expected lock to be set');

    // cannot get another lock
    expect(api.tryGetLock('0')).toBe(null);

    // release the lock
    lock.abort();
  });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 59, 'column': 4, 'index': 1567}","it('should allow a lock to be released', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };

  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  Array.from({ length: 4 }).forEach(() => {
    // get the lock
    const lock: ?PreDragActions = api.tryGetLock('0', noop);
    expect(lock).toBeTruthy();
    invariant(lock, 'Expected lock to be set');

    // cannot get another lock
    expect(api.tryGetLock('0')).toBe(null);

    // release the lock
    lock.abort();
  });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 75, 'column': 2, 'index': 2019}","it('should not allow a sensor to obtain a on a dropping item, but can claim one on something else while dragging', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');

  // drag not started yet
  expect(isDragging(handle)).toBe(false);
  // start a drag
  const actions: FluidDragActions = preDrag.fluidLift({ x: 0, y: 0 });
  expect(isDragging(handle)).toBe(true);

  // release the movement
  actions.move({ x: 100, y: 100 });
  requestAnimationFrame.flush();

  actions.drop();
  expect(isDropAnimating(handle)).toBe(true);

  // lock is no longer active
  expect(actions.isActive()).toBe(false);
  expect(preDrag.isActive()).toBe(false);

  // cannot get a new lock while still dropping
  expect(api.tryGetLock('0', noop)).toBe(null);

  // can get a lock on a handle that is not dropping - while the other is dropping
  expect(api.tryGetLock('1', noop)).toBeTruthy();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 79, 'column': 2, 'index': 2181}","it('should not allow a sensor to obtain a on a dropping item, but can claim one on something else while dragging', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');

  // drag not started yet
  expect(isDragging(handle)).toBe(false);
  // start a drag
  const actions: FluidDragActions = preDrag.fluidLift({ x: 0, y: 0 });
  expect(isDragging(handle)).toBe(true);

  // release the movement
  actions.move({ x: 100, y: 100 });
  requestAnimationFrame.flush();

  actions.drop();
  expect(isDropAnimating(handle)).toBe(true);

  // lock is no longer active
  expect(actions.isActive()).toBe(false);
  expect(preDrag.isActive()).toBe(false);

  // cannot get a new lock while still dropping
  expect(api.tryGetLock('0', noop)).toBe(null);

  // can get a lock on a handle that is not dropping - while the other is dropping
  expect(api.tryGetLock('1', noop)).toBeTruthy();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 82, 'column': 9, 'index': 2261}","it('should not allow a sensor to obtain a on a dropping item, but can claim one on something else while dragging', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');

  // drag not started yet
  expect(isDragging(handle)).toBe(false);
  // start a drag
  const actions: FluidDragActions = preDrag.fluidLift({ x: 0, y: 0 });
  expect(isDragging(handle)).toBe(true);

  // release the movement
  actions.move({ x: 100, y: 100 });
  requestAnimationFrame.flush();

  actions.drop();
  expect(isDropAnimating(handle)).toBe(true);

  // lock is no longer active
  expect(actions.isActive()).toBe(false);
  expect(preDrag.isActive()).toBe(false);

  // cannot get a new lock while still dropping
  expect(api.tryGetLock('0', noop)).toBe(null);

  // can get a lock on a handle that is not dropping - while the other is dropping
  expect(api.tryGetLock('1', noop)).toBeTruthy();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 85, 'column': 9, 'index': 2392}","it('should not allow a sensor to obtain a on a dropping item, but can claim one on something else while dragging', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');

  // drag not started yet
  expect(isDragging(handle)).toBe(false);
  // start a drag
  const actions: FluidDragActions = preDrag.fluidLift({ x: 0, y: 0 });
  expect(isDragging(handle)).toBe(true);

  // release the movement
  actions.move({ x: 100, y: 100 });
  requestAnimationFrame.flush();

  actions.drop();
  expect(isDropAnimating(handle)).toBe(true);

  // lock is no longer active
  expect(actions.isActive()).toBe(false);
  expect(preDrag.isActive()).toBe(false);

  // cannot get a new lock while still dropping
  expect(api.tryGetLock('0', noop)).toBe(null);

  // can get a lock on a handle that is not dropping - while the other is dropping
  expect(api.tryGetLock('1', noop)).toBeTruthy();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 92, 'column': 9, 'index': 2548}","it('should not allow a sensor to obtain a on a dropping item, but can claim one on something else while dragging', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');

  // drag not started yet
  expect(isDragging(handle)).toBe(false);
  // start a drag
  const actions: FluidDragActions = preDrag.fluidLift({ x: 0, y: 0 });
  expect(isDragging(handle)).toBe(true);

  // release the movement
  actions.move({ x: 100, y: 100 });
  requestAnimationFrame.flush();

  actions.drop();
  expect(isDropAnimating(handle)).toBe(true);

  // lock is no longer active
  expect(actions.isActive()).toBe(false);
  expect(preDrag.isActive()).toBe(false);

  // cannot get a new lock while still dropping
  expect(api.tryGetLock('0', noop)).toBe(null);

  // can get a lock on a handle that is not dropping - while the other is dropping
  expect(api.tryGetLock('1', noop)).toBeTruthy();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 111, 'column': 2, 'index': 3130}","it('should release a lock when aborting a pre drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');
  expect(preDrag.isActive()).toBe(true);
  // should release the lock
  preDrag.abort();
  expect(preDrag.isActive()).toBe(false);

  // can get another lock
  const second: ?PreDragActions = api.tryGetLock('1', noop);
  expect(second).toBeTruthy();
  invariant(second);
  // need to release this one :)
  second.abort();
  expect(second.isActive()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 114, 'column': 2, 'index': 3240}","it('should release a lock when aborting a pre drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');
  expect(preDrag.isActive()).toBe(true);
  // should release the lock
  preDrag.abort();
  expect(preDrag.isActive()).toBe(false);

  // can get another lock
  const second: ?PreDragActions = api.tryGetLock('1', noop);
  expect(second).toBeTruthy();
  invariant(second);
  // need to release this one :)
  second.abort();
  expect(second.isActive()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 123, 'column': 2, 'index': 3536}","it('should release a lock when aborting a pre drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');
  expect(preDrag.isActive()).toBe(true);
  // should release the lock
  preDrag.abort();
  expect(preDrag.isActive()).toBe(false);

  // can get another lock
  const second: ?PreDragActions = api.tryGetLock('1', noop);
  expect(second).toBeTruthy();
  invariant(second);
  // need to release this one :)
  second.abort();
  expect(second.isActive()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 135, 'column': 2, 'index': 3856}","it('should release a lock when cancelling or dropping a drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  ['cancel', 'drop'].forEach((property: string) => {
    const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
    invariant(preDrag, 'Expected to get lock');
    expect(preDrag.isActive()).toBe(true);

    const drag: SnapDragActions = preDrag.snapLift();
    expect(drag.isActive()).toBe(true);

    // cannot get another lock
    const second: ?PreDragActions = api.tryGetLock('1', noop);
    expect(second).toBe(null);

    // calling cancel or drop
    act(() => {
      drag[property]();
    });

    // can now get another lock
    const third: ?PreDragActions = api.tryGetLock('1', noop);
    expect(third).toBeTruthy();
    // need to try to release it
    invariant(third);
    third.abort();
  });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 139, 'column': 4, 'index': 4023}","it('should release a lock when cancelling or dropping a drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  ['cancel', 'drop'].forEach((property: string) => {
    const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
    invariant(preDrag, 'Expected to get lock');
    expect(preDrag.isActive()).toBe(true);

    const drag: SnapDragActions = preDrag.snapLift();
    expect(drag.isActive()).toBe(true);

    // cannot get another lock
    const second: ?PreDragActions = api.tryGetLock('1', noop);
    expect(second).toBe(null);

    // calling cancel or drop
    act(() => {
      drag[property]();
    });

    // can now get another lock
    const third: ?PreDragActions = api.tryGetLock('1', noop);
    expect(third).toBeTruthy();
    // need to try to release it
    invariant(third);
    third.abort();
  });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Eager Test,"{'line': 158, 'column': 4, 'index': 4574}","it('should release a lock when cancelling or dropping a drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  ['cancel', 'drop'].forEach((property: string) => {
    const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
    invariant(preDrag, 'Expected to get lock');
    expect(preDrag.isActive()).toBe(true);

    const drag: SnapDragActions = preDrag.snapLift();
    expect(drag.isActive()).toBe(true);

    // cannot get another lock
    const second: ?PreDragActions = api.tryGetLock('1', noop);
    expect(second).toBe(null);

    // calling cancel or drop
    act(() => {
      drag[property]();
    });

    // can now get another lock
    const third: ?PreDragActions = api.tryGetLock('1', noop);
    expect(third).toBeTruthy();
    // need to try to release it
    invariant(third);
    third.abort();
  });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Lazy Test,"{'line': 29, 'column': 2, 'index': 686}","it('should allow an exclusive lock for drag actions', () => {
  let first: SensorAPI;
  let second: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(<App sensors={[a, b]} />);
  invariant(first, 'expected first to be set');
  invariant(second, 'expected second to be set');

  // first can get a lock
  expect(first.tryGetLock('0')).toBeTruthy();

  // second cannot get a lock
  expect(second.tryGetLock('0')).toBe(null);

  // first cannot get another lock on the same element
  expect(first.tryGetLock('0')).toBe(null);

  // nothing cannot get lock on a different element
  expect(first.tryGetLock('1')).toBe(null);
  expect(second.tryGetLock('1')).toBe(null);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Lazy Test,"{'line': 53, 'column': 2, 'index': 1361}","it('should allow a lock to be released', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };

  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  Array.from({ length: 4 }).forEach(() => {
    // get the lock
    const lock: ?PreDragActions = api.tryGetLock('0', noop);
    expect(lock).toBeTruthy();
    invariant(lock, 'Expected lock to be set');

    // cannot get another lock
    expect(api.tryGetLock('0')).toBe(null);

    // release the lock
    lock.abort();
  });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Lazy Test,"{'line': 75, 'column': 2, 'index': 2019}","it('should not allow a sensor to obtain a on a dropping item, but can claim one on something else while dragging', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');

  // drag not started yet
  expect(isDragging(handle)).toBe(false);
  // start a drag
  const actions: FluidDragActions = preDrag.fluidLift({ x: 0, y: 0 });
  expect(isDragging(handle)).toBe(true);

  // release the movement
  actions.move({ x: 100, y: 100 });
  requestAnimationFrame.flush();

  actions.drop();
  expect(isDropAnimating(handle)).toBe(true);

  // lock is no longer active
  expect(actions.isActive()).toBe(false);
  expect(preDrag.isActive()).toBe(false);

  // cannot get a new lock while still dropping
  expect(api.tryGetLock('0', noop)).toBe(null);

  // can get a lock on a handle that is not dropping - while the other is dropping
  expect(api.tryGetLock('1', noop)).toBeTruthy();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Lazy Test,"{'line': 111, 'column': 2, 'index': 3130}","it('should release a lock when aborting a pre drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag, 'Expected to get lock');
  expect(preDrag.isActive()).toBe(true);
  // should release the lock
  preDrag.abort();
  expect(preDrag.isActive()).toBe(false);

  // can get another lock
  const second: ?PreDragActions = api.tryGetLock('1', noop);
  expect(second).toBeTruthy();
  invariant(second);
  // need to release this one :)
  second.abort();
  expect(second.isActive()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/obtaining-lock.spec.js,Lazy Test,"{'line': 135, 'column': 2, 'index': 3856}","it('should release a lock when cancelling or dropping a drag', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');

  ['cancel', 'drop'].forEach((property: string) => {
    const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
    invariant(preDrag, 'Expected to get lock');
    expect(preDrag.isActive()).toBe(true);

    const drag: SnapDragActions = preDrag.snapLift();
    expect(drag.isActive()).toBe(true);

    // cannot get another lock
    const second: ?PreDragActions = api.tryGetLock('1', noop);
    expect(second).toBe(null);

    // calling cancel or drop
    act(() => {
      drag[property]();
    });

    // can now get another lock
    const third: ?PreDragActions = api.tryGetLock('1', noop);
    expect(third).toBeTruthy();
    // need to try to release it
    invariant(third);
    third.abort();
  });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/no-double-lift.spec.js,Eager Test,"{'line': 19, 'column': 2, 'index': 456}","it('should not allow double lifting', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[a]} />);
  invariant(api, 'expected first to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  // it is currently active
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();

  expect(() => preDrag.fluidLift({ x: 0, y: 0 })).toThrow();
  // original lock is gone
  expect(drag.isActive()).toBe(false);

  // yolo
  expect(() => preDrag.snapLift()).toThrow();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/no-double-lift.spec.js,Eager Test,"{'line': 22, 'column': 2, 'index': 559}","it('should not allow double lifting', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  render(<App sensors={[a]} />);
  invariant(api, 'expected first to be set');

  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  // it is currently active
  expect(preDrag.isActive()).toBe(true);

  const drag: SnapDragActions = preDrag.snapLift();

  expect(() => preDrag.fluidLift({ x: 0, y: 0 })).toThrow();
  // original lock is gone
  expect(drag.isActive()).toBe(false);

  // yolo
  expect(() => preDrag.snapLift()).toThrow();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Duplicate Assert,"{'line': 33, 'column': 2, 'index': 1000}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Duplicate Assert,"{'line': 33, 'column': 2, 'index': 1000}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Duplicate Assert,"{'line': 41, 'column': 2, 'index': 1233}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Duplicate Assert,"{'line': 41, 'column': 2, 'index': 1233}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Duplicate Assert,"{'line': 45, 'column': 2, 'index': 1342}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Duplicate Assert,"{'line': 63, 'column': 2, 'index': 1919}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Duplicate Assert,"{'line': 63, 'column': 2, 'index': 1919}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Duplicate Assert,"{'line': 68, 'column': 2, 'index': 2073}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Duplicate Assert,"{'line': 68, 'column': 2, 'index': 2073}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Duplicate Assert,"{'line': 74, 'column': 2, 'index': 2206}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Duplicate Assert,"{'line': 74, 'column': 2, 'index': 2206}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Eager Test,"{'line': 24, 'column': 2, 'index': 684}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Eager Test,"{'line': 28, 'column': 2, 'index': 846}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Eager Test,"{'line': 33, 'column': 9, 'index': 1007}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Eager Test,"{'line': 41, 'column': 9, 'index': 1240}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Eager Test,"{'line': 45, 'column': 9, 'index': 1349}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Eager Test,"{'line': 54, 'column': 2, 'index': 1606}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Eager Test,"{'line': 58, 'column': 2, 'index': 1765}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Eager Test,"{'line': 63, 'column': 9, 'index': 1926}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Eager Test,"{'line': 68, 'column': 9, 'index': 2080}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Eager Test,"{'line': 74, 'column': 9, 'index': 2213}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Lazy Test,"{'line': 24, 'column': 2, 'index': 684}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Lazy Test,"{'line': 33, 'column': 9, 'index': 1007}","it('should throttle move events by request animation frame', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[sensor]} />);
  invariant(api, 'expected getter to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));
  actions.move(add(initial, offset));

  // still not moved
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  // moved after frame
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual(offset);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Lazy Test,"{'line': 54, 'column': 2, 'index': 1606}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/move-throttling.spec.js,Lazy Test,"{'line': 63, 'column': 9, 'index': 1926}","it('should cancel any pending moves after a lock is released', () => {
  let api: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };
  const { getByText } = render(<App sensors={[a]} />);
  invariant(api, 'expected api to be set');
  const handle: HTMLElement = getByText('item: 0');

  const preDrag: ?PreDragActions = api.tryGetLock('0', noop);
  invariant(preDrag);

  const initial: Position = { x: 2, y: 3 };
  const actions: FluidDragActions = preDrag.fluidLift(initial);
  // has not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  const offset: Position = { x: 1, y: 5 };
  actions.move(add(initial, offset));
  // not moved yet
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });

  actions.cancel();

  // will not do anything
  requestAnimationFrame.step();
  expect(getOffset(handle)).toEqual({ x: 0, y: 0 });
})",steel
/test/unit/integration/drag-handle/sensor-marshal/lock-context-isolation.spec.js,Eager Test,"{'line': 32, 'column': 2, 'index': 856}","it('should allow different locks in different DragDropContexts', () => {
  let first: SensorAPI;
  let second: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  const { getAllByText } = render(
    <React.Fragment>
      <App sensors={[a]} />
      <App sensors={[b]} />
    </React.Fragment>,
  );

  const items: HTMLElement[] = getAllByText('item: 0');
  expect(items).toHaveLength(2);
  const [inFirst, inSecond] = items;
  expect(inFirst).not.toBe(inSecond);

  // each sensor can get a different lock
  invariant(first, 'expected first to be set');
  invariant(second, 'expected second to be set');
  expect(first.tryGetLock('0')).toBeTruthy();
  expect(second.tryGetLock('0')).toBeTruthy();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/lock-context-isolation.spec.js,Eager Test,"{'line': 33, 'column': 2, 'index': 904}","it('should allow different locks in different DragDropContexts', () => {
  let first: SensorAPI;
  let second: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  const { getAllByText } = render(
    <React.Fragment>
      <App sensors={[a]} />
      <App sensors={[b]} />
    </React.Fragment>,
  );

  const items: HTMLElement[] = getAllByText('item: 0');
  expect(items).toHaveLength(2);
  const [inFirst, inSecond] = items;
  expect(inFirst).not.toBe(inSecond);

  // each sensor can get a different lock
  invariant(first, 'expected first to be set');
  invariant(second, 'expected second to be set');
  expect(first.tryGetLock('0')).toBeTruthy();
  expect(second.tryGetLock('0')).toBeTruthy();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/lock-context-isolation.spec.js,Magic Number,"{'line': 27, 'column': 29, 'index': 732}","it('should allow different locks in different DragDropContexts', () => {
  let first: SensorAPI;
  let second: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  const { getAllByText } = render(
    <React.Fragment>
      <App sensors={[a]} />
      <App sensors={[b]} />
    </React.Fragment>,
  );

  const items: HTMLElement[] = getAllByText('item: 0');
  expect(items).toHaveLength(2);
  const [inFirst, inSecond] = items;
  expect(inFirst).not.toBe(inSecond);

  // each sensor can get a different lock
  invariant(first, 'expected first to be set');
  invariant(second, 'expected second to be set');
  expect(first.tryGetLock('0')).toBeTruthy();
  expect(second.tryGetLock('0')).toBeTruthy();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/is-lock-claimed.spec.js,Duplicate Assert,"{'line': 30, 'column': 2, 'index': 693}","it('should correctly state whether a lock is claimed', () => {
  let first: SensorAPI;
  let second: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(
    <React.Fragment>
      <App sensors={[a, b]} />
    </React.Fragment>,
  );
  invariant(first && second);

  // both sensors know that the lock is not claimed
  expect(first.isLockClaimed()).toBe(false);
  expect(second.isLockClaimed()).toBe(false);

  const preDrag: ?PreDragActions = first.tryGetLock('0');
  expect(preDrag).toBeTruthy();

  // both sensors can know if the lock is claimed
  expect(first.isLockClaimed()).toBe(true);
  expect(second.isLockClaimed()).toBe(true);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/is-lock-claimed.spec.js,Duplicate Assert,"{'line': 31, 'column': 2, 'index': 738}","it('should correctly state whether a lock is claimed', () => {
  let first: SensorAPI;
  let second: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(
    <React.Fragment>
      <App sensors={[a, b]} />
    </React.Fragment>,
  );
  invariant(first && second);

  // both sensors know that the lock is not claimed
  expect(first.isLockClaimed()).toBe(false);
  expect(second.isLockClaimed()).toBe(false);

  const preDrag: ?PreDragActions = first.tryGetLock('0');
  expect(preDrag).toBeTruthy();

  // both sensors can know if the lock is claimed
  expect(first.isLockClaimed()).toBe(true);
  expect(second.isLockClaimed()).toBe(true);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/is-lock-claimed.spec.js,Duplicate Assert,"{'line': 37, 'column': 2, 'index': 926}","it('should correctly state whether a lock is claimed', () => {
  let first: SensorAPI;
  let second: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(
    <React.Fragment>
      <App sensors={[a, b]} />
    </React.Fragment>,
  );
  invariant(first && second);

  // both sensors know that the lock is not claimed
  expect(first.isLockClaimed()).toBe(false);
  expect(second.isLockClaimed()).toBe(false);

  const preDrag: ?PreDragActions = first.tryGetLock('0');
  expect(preDrag).toBeTruthy();

  // both sensors can know if the lock is claimed
  expect(first.isLockClaimed()).toBe(true);
  expect(second.isLockClaimed()).toBe(true);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/is-lock-claimed.spec.js,Duplicate Assert,"{'line': 38, 'column': 2, 'index': 970}","it('should correctly state whether a lock is claimed', () => {
  let first: SensorAPI;
  let second: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };

  render(
    <React.Fragment>
      <App sensors={[a, b]} />
    </React.Fragment>,
  );
  invariant(first && second);

  // both sensors know that the lock is not claimed
  expect(first.isLockClaimed()).toBe(false);
  expect(second.isLockClaimed()).toBe(false);

  const preDrag: ?PreDragActions = first.tryGetLock('0');
  expect(preDrag).toBeTruthy();

  // both sensors can know if the lock is claimed
  expect(first.isLockClaimed()).toBe(true);
  expect(second.isLockClaimed()).toBe(true);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/force-releasing-locks.spec.js,Duplicate Assert,"{'line': 33, 'column': 2, 'index': 788}","it('should correctly state whether a lock is claimed', () => {
  let first: SensorAPI;
  let second: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };
  const onForceStop = jest.fn();

  render(
    <React.Fragment>
      <App sensors={[a, b]} />
    </React.Fragment>,
  );
  invariant(first);
  invariant(second);

  const preDrag: ?PreDragActions = first.tryGetLock('0', onForceStop);
  expect(preDrag).toBeTruthy();
  expect(second.isLockClaimed()).toBe(true);

  second.tryReleaseLock();
  expect(onForceStop).toHaveBeenCalled();
  // lock is gone
  expect(second.isLockClaimed()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/force-releasing-locks.spec.js,Duplicate Assert,"{'line': 38, 'column': 2, 'index': 921}","it('should correctly state whether a lock is claimed', () => {
  let first: SensorAPI;
  let second: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };
  const onForceStop = jest.fn();

  render(
    <React.Fragment>
      <App sensors={[a, b]} />
    </React.Fragment>,
  );
  invariant(first);
  invariant(second);

  const preDrag: ?PreDragActions = first.tryGetLock('0', onForceStop);
  expect(preDrag).toBeTruthy();
  expect(second.isLockClaimed()).toBe(true);

  second.tryReleaseLock();
  expect(onForceStop).toHaveBeenCalled();
  // lock is gone
  expect(second.isLockClaimed()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/force-releasing-locks.spec.js,Eager Test,"{'line': 28, 'column': 2, 'index': 643}","it('should correctly state whether a lock is claimed', () => {
  let first: SensorAPI;
  let second: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };
  const onForceStop = jest.fn();

  render(
    <React.Fragment>
      <App sensors={[a, b]} />
    </React.Fragment>,
  );
  invariant(first);
  invariant(second);

  const preDrag: ?PreDragActions = first.tryGetLock('0', onForceStop);
  expect(preDrag).toBeTruthy();
  expect(second.isLockClaimed()).toBe(true);

  second.tryReleaseLock();
  expect(onForceStop).toHaveBeenCalled();
  // lock is gone
  expect(second.isLockClaimed()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/force-releasing-locks.spec.js,Eager Test,"{'line': 29, 'column': 2, 'index': 663}","it('should correctly state whether a lock is claimed', () => {
  let first: SensorAPI;
  let second: SensorAPI;
  const a: Sensor = (value: SensorAPI) => {
    first = value;
  };
  const b: Sensor = (value: SensorAPI) => {
    second = value;
  };
  const onForceStop = jest.fn();

  render(
    <React.Fragment>
      <App sensors={[a, b]} />
    </React.Fragment>,
  );
  invariant(first);
  invariant(second);

  const preDrag: ?PreDragActions = first.tryGetLock('0', onForceStop);
  expect(preDrag).toBeTruthy();
  expect(second.isLockClaimed()).toBe(true);

  second.tryReleaseLock();
  expect(onForceStop).toHaveBeenCalled();
  // lock is gone
  expect(second.isLockClaimed()).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/click-blocking.spec.js,Eager Test,"{'line': 26, 'column': 2, 'index': 672}","it('should block a single click if requested', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };

  const { getByText } = render(
    <React.Fragment>
      <App sensors={[sensor]} />
    </React.Fragment>,
  );
  const handle: HTMLElement = getByText('item: 0');
  invariant(api);

  // trigger a drop
  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  const drag: SnapDragActions = preDrag.snapLift();
  act(() => drag.drop({ shouldBlockNextClick: true }));

  // fire click
  const first: MouseEvent = createEvent.click(handle);
  const second: MouseEvent = createEvent.click(handle);
  fireEvent(handle, first);
  fireEvent(handle, second);

  // only first click is prevented
  expect(first.defaultPrevented).toBe(true);
  expect(second.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/click-blocking.spec.js,Eager Test,"{'line': 30, 'column': 2, 'index': 767}","it('should block a single click if requested', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };

  const { getByText } = render(
    <React.Fragment>
      <App sensors={[sensor]} />
    </React.Fragment>,
  );
  const handle: HTMLElement = getByText('item: 0');
  invariant(api);

  // trigger a drop
  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  const drag: SnapDragActions = preDrag.snapLift();
  act(() => drag.drop({ shouldBlockNextClick: true }));

  // fire click
  const first: MouseEvent = createEvent.click(handle);
  const second: MouseEvent = createEvent.click(handle);
  fireEvent(handle, first);
  fireEvent(handle, second);

  // only first click is prevented
  expect(first.defaultPrevented).toBe(true);
  expect(second.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/click-blocking.spec.js,Eager Test,"{'line': 58, 'column': 2, 'index': 1525}","it('should not block any clicks if not requested', () => {
  let api: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };

  const { getByText } = render(
    <React.Fragment>
      <App sensors={[a]} />
    </React.Fragment>,
  );
  const handle: HTMLElement = getByText('item: 0');
  invariant(api);

  // trigger a drop
  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  const drag: SnapDragActions = preDrag.snapLift();
  act(() => drag.drop({ shouldBlockNextClick: false }));

  // fire click
  const first: MouseEvent = createEvent.click(handle);
  fireEvent(handle, first);

  // click not prevented
  expect(first.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/click-blocking.spec.js,Eager Test,"{'line': 62, 'column': 2, 'index': 1620}","it('should not block any clicks if not requested', () => {
  let api: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };

  const { getByText } = render(
    <React.Fragment>
      <App sensors={[a]} />
    </React.Fragment>,
  );
  const handle: HTMLElement = getByText('item: 0');
  invariant(api);

  // trigger a drop
  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  const drag: SnapDragActions = preDrag.snapLift();
  act(() => drag.drop({ shouldBlockNextClick: false }));

  // fire click
  const first: MouseEvent = createEvent.click(handle);
  fireEvent(handle, first);

  // click not prevented
  expect(first.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/click-blocking.spec.js,Eager Test,"{'line': 88, 'column': 2, 'index': 2271}","it('should not block any clicks after a timeout', () => {
  jest.useFakeTimers();

  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };

  const { getByText } = render(
    <React.Fragment>
      <App sensors={[sensor]} />
    </React.Fragment>,
  );
  const handle: HTMLElement = getByText('item: 0');
  invariant(api);

  // trigger a drop
  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  const drag: SnapDragActions = preDrag.snapLift();
  act(() => drag.drop({ shouldBlockNextClick: true }));

  jest.runTimersToTime(1);

  // fire click
  const first: MouseEvent = createEvent.click(handle);
  fireEvent(handle, first);

  // click not prevented
  expect(first.defaultPrevented).toBe(false);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/click-blocking.spec.js,Eager Test,"{'line': 92, 'column': 2, 'index': 2366}","it('should not block any clicks after a timeout', () => {
  jest.useFakeTimers();

  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };

  const { getByText } = render(
    <React.Fragment>
      <App sensors={[sensor]} />
    </React.Fragment>,
  );
  const handle: HTMLElement = getByText('item: 0');
  invariant(api);

  // trigger a drop
  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  const drag: SnapDragActions = preDrag.snapLift();
  act(() => drag.drop({ shouldBlockNextClick: true }));

  jest.runTimersToTime(1);

  // fire click
  const first: MouseEvent = createEvent.click(handle);
  fireEvent(handle, first);

  // click not prevented
  expect(first.defaultPrevented).toBe(false);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-handle/sensor-marshal/click-blocking.spec.js,Lazy Test,"{'line': 26, 'column': 2, 'index': 672}","it('should block a single click if requested', () => {
  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };

  const { getByText } = render(
    <React.Fragment>
      <App sensors={[sensor]} />
    </React.Fragment>,
  );
  const handle: HTMLElement = getByText('item: 0');
  invariant(api);

  // trigger a drop
  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  const drag: SnapDragActions = preDrag.snapLift();
  act(() => drag.drop({ shouldBlockNextClick: true }));

  // fire click
  const first: MouseEvent = createEvent.click(handle);
  const second: MouseEvent = createEvent.click(handle);
  fireEvent(handle, first);
  fireEvent(handle, second);

  // only first click is prevented
  expect(first.defaultPrevented).toBe(true);
  expect(second.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/click-blocking.spec.js,Lazy Test,"{'line': 58, 'column': 2, 'index': 1525}","it('should not block any clicks if not requested', () => {
  let api: SensorAPI;

  const a: Sensor = (value: SensorAPI) => {
    api = value;
  };

  const { getByText } = render(
    <React.Fragment>
      <App sensors={[a]} />
    </React.Fragment>,
  );
  const handle: HTMLElement = getByText('item: 0');
  invariant(api);

  // trigger a drop
  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  const drag: SnapDragActions = preDrag.snapLift();
  act(() => drag.drop({ shouldBlockNextClick: false }));

  // fire click
  const first: MouseEvent = createEvent.click(handle);
  fireEvent(handle, first);

  // click not prevented
  expect(first.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-handle/sensor-marshal/click-blocking.spec.js,Lazy Test,"{'line': 88, 'column': 2, 'index': 2271}","it('should not block any clicks after a timeout', () => {
  jest.useFakeTimers();

  let api: SensorAPI;
  const sensor: Sensor = (value: SensorAPI) => {
    api = value;
  };

  const { getByText } = render(
    <React.Fragment>
      <App sensors={[sensor]} />
    </React.Fragment>,
  );
  const handle: HTMLElement = getByText('item: 0');
  invariant(api);

  // trigger a drop
  const preDrag: ?PreDragActions = api.tryGetLock('0');
  invariant(preDrag);
  const drag: SnapDragActions = preDrag.snapLift();
  act(() => drag.drop({ shouldBlockNextClick: true }));

  jest.runTimersToTime(1);

  // fire click
  const first: MouseEvent = createEvent.click(handle);
  fireEvent(handle, first);

  // click not prevented
  expect(first.defaultPrevented).toBe(false);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Conditional Test Logic,"{'line': 41, 'column': 33, 'index': 1432}","it('should not prevent the default behaviour for an indirect cancel', () => {
  ['resize', supportedEventName].forEach((eventName: string) => {
    const onDragEnd = jest.fn();
    const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(mouse, handle);

    const event: Event = new Event(eventName, {
      bubbles: true,
      cancelable: true,
      target: handle,
    });

    fireEvent(handle, event);

    // not an explicit cancel
    expect(event.defaultPrevented).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 15, 'column': 2, 'index': 661}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);

  const event: Event = createEvent.mouseUp(handle);
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 21, 'column': 9, 'index': 824}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);

  const event: Event = createEvent.mouseUp(handle);
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 29, 'column': 2, 'index': 1074}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 37, 'column': 9, 'index': 1274}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 46, 'column': 4, 'index': 1631}","it('should not prevent the default behaviour for an indirect cancel', () => {
  ['resize', supportedEventName].forEach((eventName: string) => {
    const onDragEnd = jest.fn();
    const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(mouse, handle);

    const event: Event = new Event(eventName, {
      bubbles: true,
      cancelable: true,
      target: handle,
    });

    fireEvent(handle, event);

    // not an explicit cancel
    expect(event.defaultPrevented).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 58, 'column': 11, 'index': 1903}","it('should not prevent the default behaviour for an indirect cancel', () => {
  ['resize', supportedEventName].forEach((eventName: string) => {
    const onDragEnd = jest.fn();
    const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(mouse, handle);

    const event: Event = new Event(eventName, {
      bubbles: true,
      cancelable: true,
      target: handle,
    });

    fireEvent(handle, event);

    // not an explicit cancel
    expect(event.defaultPrevented).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 69, 'column': 2, 'index': 2235}","it('should cancel and prevent default on mousedown during a drag as it might be from a different button', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);

  const event: Event = createEvent.mouseDown(handle);
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 75, 'column': 9, 'index': 2400}","it('should cancel and prevent default on mousedown during a drag as it might be from a different button', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);

  const event: Event = createEvent.mouseDown(handle);
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 15, 'column': 2, 'index': 661}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);

  const event: Event = createEvent.mouseUp(handle);
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 21, 'column': 9, 'index': 824}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);

  const event: Event = createEvent.mouseUp(handle);
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 29, 'column': 2, 'index': 1074}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 37, 'column': 9, 'index': 1274}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 46, 'column': 4, 'index': 1631}","it('should not prevent the default behaviour for an indirect cancel', () => {
  ['resize', supportedEventName].forEach((eventName: string) => {
    const onDragEnd = jest.fn();
    const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(mouse, handle);

    const event: Event = new Event(eventName, {
      bubbles: true,
      cancelable: true,
      target: handle,
    });

    fireEvent(handle, event);

    // not an explicit cancel
    expect(event.defaultPrevented).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 58, 'column': 11, 'index': 1903}","it('should not prevent the default behaviour for an indirect cancel', () => {
  ['resize', supportedEventName].forEach((eventName: string) => {
    const onDragEnd = jest.fn();
    const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(mouse, handle);

    const event: Event = new Event(eventName, {
      bubbles: true,
      cancelable: true,
      target: handle,
    });

    fireEvent(handle, event);

    // not an explicit cancel
    expect(event.defaultPrevented).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 69, 'column': 2, 'index': 2235}","it('should cancel and prevent default on mousedown during a drag as it might be from a different button', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);

  const event: Event = createEvent.mouseDown(handle);
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/mouse-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 75, 'column': 9, 'index': 2400}","it('should cancel and prevent default on mousedown during a drag as it might be from a different button', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);

  const event: Event = createEvent.mouseDown(handle);
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Duplicate Assert,"{'line': 40, 'column': 4, 'index': 1293}","it('should start a drag after sufficient movement', () => {
  const valid: Position[] = [
    { x: 0, y: sloppyClickThreshold },
    { x: 0, y: -sloppyClickThreshold },
    { x: sloppyClickThreshold, y: 0 },
    { x: -sloppyClickThreshold, y: 0 },
  ];

  valid.forEach((point: Position) => {
    const { getByText, unmount } = render(<App />);

    const handle: HTMLElement = getByText('item: 0');

    const mouseDown: MouseEvent = createEvent.mouseDown(handle);

    fireEvent(handle, mouseDown);
    // important that this is called to prevent focus
    expect(mouseDown.defaultPrevented).toBe(true);

    // not dragging yet
    expect(isDragging(handle)).toBe(false);

    // mouse move to start drag

    const mouseMove: MouseEvent = createEvent.mouseMove(handle, {
      clientX: point.x,
      clientY: point.y,
    });
    fireEvent(window, mouseMove);
    // we are using the event - so prevent default is called
    expect(mouseMove.defaultPrevented).toBe(true);

    // now dragging
    expect(isDragging(handle)).toBe(true);

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1660}","it('should start a drag after sufficient movement', () => {
  const valid: Position[] = [
    { x: 0, y: sloppyClickThreshold },
    { x: 0, y: -sloppyClickThreshold },
    { x: sloppyClickThreshold, y: 0 },
    { x: -sloppyClickThreshold, y: 0 },
  ];

  valid.forEach((point: Position) => {
    const { getByText, unmount } = render(<App />);

    const handle: HTMLElement = getByText('item: 0');

    const mouseDown: MouseEvent = createEvent.mouseDown(handle);

    fireEvent(handle, mouseDown);
    // important that this is called to prevent focus
    expect(mouseDown.defaultPrevented).toBe(true);

    // not dragging yet
    expect(isDragging(handle)).toBe(false);

    // mouse move to start drag

    const mouseMove: MouseEvent = createEvent.mouseMove(handle, {
      clientX: point.x,
      clientY: point.y,
    });
    fireEvent(window, mouseMove);
    // we are using the event - so prevent default is called
    expect(mouseMove.defaultPrevented).toBe(true);

    // now dragging
    expect(isDragging(handle)).toBe(true);

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Duplicate Assert,"{'line': 109, 'column': 4, 'index': 3209}","it('should allow multiple false starts', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  Array.from({ length: 5 }).forEach(() => {
    fireEvent.mouseDown(handle);
    fireEvent.mouseUp(handle);

    expect(isDragging(handle)).toBe(false);
  });

  fireEvent.mouseDown(handle);
  fireEvent.mouseMove(handle, {
    clientX: 0,
    clientY: sloppyClickThreshold,
  });

  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Duplicate Assert,"{'line': 118, 'column': 2, 'index': 3379}","it('should allow multiple false starts', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  Array.from({ length: 5 }).forEach(() => {
    fireEvent.mouseDown(handle);
    fireEvent.mouseUp(handle);

    expect(isDragging(handle)).toBe(false);
  });

  fireEvent.mouseDown(handle);
  fireEvent.mouseMove(handle, {
    clientX: 0,
    clientY: sloppyClickThreshold,
  });

  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Eager Test,"{'line': 40, 'column': 11, 'index': 1300}","it('should start a drag after sufficient movement', () => {
  const valid: Position[] = [
    { x: 0, y: sloppyClickThreshold },
    { x: 0, y: -sloppyClickThreshold },
    { x: sloppyClickThreshold, y: 0 },
    { x: -sloppyClickThreshold, y: 0 },
  ];

  valid.forEach((point: Position) => {
    const { getByText, unmount } = render(<App />);

    const handle: HTMLElement = getByText('item: 0');

    const mouseDown: MouseEvent = createEvent.mouseDown(handle);

    fireEvent(handle, mouseDown);
    // important that this is called to prevent focus
    expect(mouseDown.defaultPrevented).toBe(true);

    // not dragging yet
    expect(isDragging(handle)).toBe(false);

    // mouse move to start drag

    const mouseMove: MouseEvent = createEvent.mouseMove(handle, {
      clientX: point.x,
      clientY: point.y,
    });
    fireEvent(window, mouseMove);
    // we are using the event - so prevent default is called
    expect(mouseMove.defaultPrevented).toBe(true);

    // now dragging
    expect(isDragging(handle)).toBe(true);

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Eager Test,"{'line': 53, 'column': 11, 'index': 1667}","it('should start a drag after sufficient movement', () => {
  const valid: Position[] = [
    { x: 0, y: sloppyClickThreshold },
    { x: 0, y: -sloppyClickThreshold },
    { x: sloppyClickThreshold, y: 0 },
    { x: -sloppyClickThreshold, y: 0 },
  ];

  valid.forEach((point: Position) => {
    const { getByText, unmount } = render(<App />);

    const handle: HTMLElement = getByText('item: 0');

    const mouseDown: MouseEvent = createEvent.mouseDown(handle);

    fireEvent(handle, mouseDown);
    // important that this is called to prevent focus
    expect(mouseDown.defaultPrevented).toBe(true);

    // not dragging yet
    expect(isDragging(handle)).toBe(false);

    // mouse move to start drag

    const mouseMove: MouseEvent = createEvent.mouseMove(handle, {
      clientX: point.x,
      clientY: point.y,
    });
    fireEvent(window, mouseMove);
    // we are using the event - so prevent default is called
    expect(mouseMove.defaultPrevented).toBe(true);

    // now dragging
    expect(isDragging(handle)).toBe(true);

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Eager Test,"{'line': 109, 'column': 11, 'index': 3216}","it('should allow multiple false starts', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  Array.from({ length: 5 }).forEach(() => {
    fireEvent.mouseDown(handle);
    fireEvent.mouseUp(handle);

    expect(isDragging(handle)).toBe(false);
  });

  fireEvent.mouseDown(handle);
  fireEvent.mouseMove(handle, {
    clientX: 0,
    clientY: sloppyClickThreshold,
  });

  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Eager Test,"{'line': 118, 'column': 9, 'index': 3386}","it('should allow multiple false starts', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  Array.from({ length: 5 }).forEach(() => {
    fireEvent.mouseDown(handle);
    fireEvent.mouseUp(handle);

    expect(isDragging(handle)).toBe(false);
  });

  fireEvent.mouseDown(handle);
  fireEvent.mouseMove(handle, {
    clientX: 0,
    clientY: sloppyClickThreshold,
  });

  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Lazy Test,"{'line': 40, 'column': 11, 'index': 1300}","it('should start a drag after sufficient movement', () => {
  const valid: Position[] = [
    { x: 0, y: sloppyClickThreshold },
    { x: 0, y: -sloppyClickThreshold },
    { x: sloppyClickThreshold, y: 0 },
    { x: -sloppyClickThreshold, y: 0 },
  ];

  valid.forEach((point: Position) => {
    const { getByText, unmount } = render(<App />);

    const handle: HTMLElement = getByText('item: 0');

    const mouseDown: MouseEvent = createEvent.mouseDown(handle);

    fireEvent(handle, mouseDown);
    // important that this is called to prevent focus
    expect(mouseDown.defaultPrevented).toBe(true);

    // not dragging yet
    expect(isDragging(handle)).toBe(false);

    // mouse move to start drag

    const mouseMove: MouseEvent = createEvent.mouseMove(handle, {
      clientX: point.x,
      clientY: point.y,
    });
    fireEvent(window, mouseMove);
    // we are using the event - so prevent default is called
    expect(mouseMove.defaultPrevented).toBe(true);

    // now dragging
    expect(isDragging(handle)).toBe(true);

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Lazy Test,"{'line': 87, 'column': 9, 'index': 2512}","it('should not call preventDefault on mouse movements while we are not sure if a drag is starting', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  // start pending
  fireEvent.mouseDown(handle, {
    clientX: 0,
    clientY: 0,
    button: primaryButton,
  });

  // not dragging yet
  const mouseMove: MouseEvent = createEvent.mouseMove(handle, {
    clientX: 0,
    clientY: sloppyClickThreshold - 1,
  });
  fireEvent(handle, mouseMove);

  expect(isDragging(handle)).toBe(false);
  expect(mouseMove.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Lazy Test,"{'line': 109, 'column': 11, 'index': 3216}","it('should allow multiple false starts', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  Array.from({ length: 5 }).forEach(() => {
    fireEvent.mouseDown(handle);
    fireEvent.mouseUp(handle);

    expect(isDragging(handle)).toBe(false);
  });

  fireEvent.mouseDown(handle);
  fireEvent.mouseMove(handle, {
    clientX: 0,
    clientY: sloppyClickThreshold,
  });

  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Lazy Test,"{'line': 131, 'column': 9, 'index': 3752}","it('should not start a drag if there was too little mouse movement while mouse was pressed', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  fireEvent.mouseDown(handle);
  fireEvent.mouseMove(handle, {
    clientX: 0,
    clientY: sloppyClickThreshold - 1,
  });

  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Lazy Test,"{'line': 147, 'column': 9, 'index': 4187}","it('should not start a drag if not using the primary mouse button', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  const mouseDown: Event = createEvent.mouseDown(handle, {
    button: primaryButton + 1,
  });
  fireEvent(handle, mouseDown);
  fireEvent.mouseMove(handle, {
    clientX: 0,
    clientY: sloppyClickThreshold,
  });

  expect(isDragging(handle)).toBe(false);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/starting-a-dragging.spec.js,Lazy Test,"{'line': 166, 'column': 11, 'index': 4835}","it('should not start a drag if a modifier key was used while pressing the mouse down', () => {
  // if any drag is started with these keys pressed then we do not start a drag
  const keys: string[] = ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'];
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  keys.forEach((key: string) => {
    const mouseDown: MouseEvent = createEvent.mouseDown(handle, {
      [key]: true,
    });
    fireEvent(handle, mouseDown);
    fireEvent.mouseMove(handle, {
      clientX: 0,
      clientY: sloppyClickThreshold,
    });

    expect(isDragging(handle)).toBe(false);
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/prevent-standard-keys-while-dragging.spec.js,Conditional Test Logic,"{'line': 16, 'column': 33, 'index': 581}","it('should prevent enter or tab being pressed during a drag', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  [keyCodes.enter, keyCodes.tab].forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(true);
    expect(isDragging(handle)).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/prevent-standard-keys-while-dragging.spec.js,Duplicate Assert,"{'line': 14, 'column': 2, 'index': 508}","it('should prevent enter or tab being pressed during a drag', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  [keyCodes.enter, keyCodes.tab].forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(true);
    expect(isDragging(handle)).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/prevent-standard-keys-while-dragging.spec.js,Duplicate Assert,"{'line': 14, 'column': 2, 'index': 508}","it('should prevent enter or tab being pressed during a drag', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  [keyCodes.enter, keyCodes.tab].forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(true);
    expect(isDragging(handle)).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/prevent-standard-keys-while-dragging.spec.js,Duplicate Assert,"{'line': 20, 'column': 4, 'index': 760}","it('should prevent enter or tab being pressed during a drag', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  [keyCodes.enter, keyCodes.tab].forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(true);
    expect(isDragging(handle)).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/prevent-standard-keys-while-dragging.spec.js,Duplicate Assert,"{'line': 20, 'column': 4, 'index': 760}","it('should prevent enter or tab being pressed during a drag', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  [keyCodes.enter, keyCodes.tab].forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(true);
    expect(isDragging(handle)).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/prevent-standard-keys-while-dragging.spec.js,Eager Test,"{'line': 13, 'column': 2, 'index': 479}","it('should prevent enter or tab being pressed during a drag', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  [keyCodes.enter, keyCodes.tab].forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(true);
    expect(isDragging(handle)).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/prevent-standard-keys-while-dragging.spec.js,Eager Test,"{'line': 14, 'column': 9, 'index': 515}","it('should prevent enter or tab being pressed during a drag', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  [keyCodes.enter, keyCodes.tab].forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(true);
    expect(isDragging(handle)).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/prevent-standard-keys-while-dragging.spec.js,Eager Test,"{'line': 20, 'column': 11, 'index': 767}","it('should prevent enter or tab being pressed during a drag', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  [keyCodes.enter, keyCodes.tab].forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(true);
    expect(isDragging(handle)).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Duplicate Assert,"{'line': 93, 'column': 4, 'index': 2953}","it('should cancel an active drag with a webkitmouseforcedown event', () => {
    const items: Item[] = [{ id: '0', shouldRespectForcePress: true }];
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(mouse, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event('webkitmouseforcedown', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(false);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Duplicate Assert,"{'line': 102, 'column': 4, 'index': 3190}","it('should cancel an active drag with a webkitmouseforcedown event', () => {
    const items: Item[] = [{ id: '0', shouldRespectForcePress: true }];
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(mouse, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event('webkitmouseforcedown', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(false);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Eager Test,"{'line': 22, 'column': 4, 'index': 709}","it('should prevent the default of a `webkitmouseforcewillbegin` event', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    const event: Event = new Event('webkitmouseforcewillbegin', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, event);

    expect(event.defaultPrevented).toBe(true);

    // lift not prevented
    simpleLift(mouse, handle);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Eager Test,"{'line': 23, 'column': 11, 'index': 747}","it('should prevent the default of a `webkitmouseforcewillbegin` event', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    const event: Event = new Event('webkitmouseforcewillbegin', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, event);

    expect(event.defaultPrevented).toBe(true);

    // lift not prevented
    simpleLift(mouse, handle);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Eager Test,"{'line': 92, 'column': 4, 'index': 2922}","it('should cancel an active drag with a webkitmouseforcedown event', () => {
    const items: Item[] = [{ id: '0', shouldRespectForcePress: true }];
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(mouse, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event('webkitmouseforcedown', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(false);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Eager Test,"{'line': 93, 'column': 11, 'index': 2960}","it('should cancel an active drag with a webkitmouseforcedown event', () => {
    const items: Item[] = [{ id: '0', shouldRespectForcePress: true }];
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(mouse, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event('webkitmouseforcedown', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(false);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Eager Test,"{'line': 102, 'column': 11, 'index': 3197}","it('should cancel an active drag with a webkitmouseforcedown event', () => {
    const items: Item[] = [{ id: '0', shouldRespectForcePress: true }];
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(mouse, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event('webkitmouseforcedown', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(false);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Lazy Test,"{'line': 22, 'column': 4, 'index': 709}","it('should prevent the default of a `webkitmouseforcewillbegin` event', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    const event: Event = new Event('webkitmouseforcewillbegin', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, event);

    expect(event.defaultPrevented).toBe(true);

    // lift not prevented
    simpleLift(mouse, handle);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Lazy Test,"{'line': 23, 'column': 11, 'index': 747}","it('should prevent the default of a `webkitmouseforcewillbegin` event', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    const event: Event = new Event('webkitmouseforcewillbegin', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, event);

    expect(event.defaultPrevented).toBe(true);

    // lift not prevented
    simpleLift(mouse, handle);
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Lazy Test,"{'line': 49, 'column': 11, 'index': 1481}","it('should prevent the default of a `webkitmouseforcedown` event', () => {
    const { getByText } = render(<App />);
    const handle: HTMLElement = getByText('item: 0');

    // while pending
    mouse.preLift(handle);
    const first: Event = new Event('webkitmouseforcedown', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, first);
    expect(first.defaultPrevented).toBe(true);

    // while dragging
    mouse.lift(handle);
    const second: Event = new Event('webkitmouseforcedown', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, second);
    expect(second.defaultPrevented).toBe(true);

    // dragging not aborted
    expect(isDragging(handle)).toBe(true);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Lazy Test,"{'line': 84, 'column': 11, 'index': 2615}","it('should cancel a pending drag with a webkitmouseforcedown event', () => {
    const items: Item[] = [{ id: '0', shouldRespectForcePress: true }];
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    // while pending
    mouse.preLift(handle);
    const event: Event = new Event('webkitmouseforcedown', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(false);
    // pre drag will be aborted

    mouse.lift(handle);
    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Lazy Test,"{'line': 92, 'column': 4, 'index': 2922}","it('should cancel an active drag with a webkitmouseforcedown event', () => {
    const items: Item[] = [{ id: '0', shouldRespectForcePress: true }];
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(mouse, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event('webkitmouseforcedown', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(false);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/force-press.spec.js,Lazy Test,"{'line': 93, 'column': 11, 'index': 2960}","it('should cancel an active drag with a webkitmouseforcedown event', () => {
    const items: Item[] = [{ id: '0', shouldRespectForcePress: true }];
    const { getByText } = render(<App items={items} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(mouse, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event('webkitmouseforcedown', {
      bubbles: true,
      cancelable: true,
    });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(false);

    expect(isDragging(handle)).toBe(false);
  })",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Duplicate Assert,"{'line': 40, 'column': 2, 'index': 1277}","it('should prevent a subsequent click if cancelling a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.keyDown(handle, { keyCode: keyCodes.escape });

  // drag cancelled
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Duplicate Assert,"{'line': 47, 'column': 2, 'index': 1462}","it('should prevent a subsequent click if cancelling a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.keyDown(handle, { keyCode: keyCodes.escape });

  // drag cancelled
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Duplicate Assert,"{'line': 61, 'column': 2, 'index': 1903}","it('should prevent a subsequent click if dropping a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.mouseUp(handle);

  expect(getDropReason(onDragEnd)).toBe('DROP');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Duplicate Assert,"{'line': 67, 'column': 2, 'index': 2036}","it('should prevent a subsequent click if dropping a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.mouseUp(handle);

  expect(getDropReason(onDragEnd)).toBe('DROP');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Eager Test,"{'line': 39, 'column': 2, 'index': 1248}","it('should prevent a subsequent click if cancelling a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.keyDown(handle, { keyCode: keyCodes.escape });

  // drag cancelled
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Eager Test,"{'line': 40, 'column': 9, 'index': 1284}","it('should prevent a subsequent click if cancelling a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.keyDown(handle, { keyCode: keyCodes.escape });

  // drag cancelled
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Eager Test,"{'line': 46, 'column': 9, 'index': 1418}","it('should prevent a subsequent click if cancelling a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.keyDown(handle, { keyCode: keyCodes.escape });

  // drag cancelled
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Eager Test,"{'line': 47, 'column': 9, 'index': 1469}","it('should prevent a subsequent click if cancelling a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.keyDown(handle, { keyCode: keyCodes.escape });

  // drag cancelled
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Eager Test,"{'line': 60, 'column': 2, 'index': 1874}","it('should prevent a subsequent click if dropping a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.mouseUp(handle);

  expect(getDropReason(onDragEnd)).toBe('DROP');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Eager Test,"{'line': 61, 'column': 9, 'index': 1910}","it('should prevent a subsequent click if dropping a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.mouseUp(handle);

  expect(getDropReason(onDragEnd)).toBe('DROP');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Eager Test,"{'line': 66, 'column': 9, 'index': 1994}","it('should prevent a subsequent click if dropping a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.mouseUp(handle);

  expect(getDropReason(onDragEnd)).toBe('DROP');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Eager Test,"{'line': 67, 'column': 9, 'index': 2043}","it('should prevent a subsequent click if dropping a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.mouseUp(handle);

  expect(getDropReason(onDragEnd)).toBe('DROP');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Lazy Test,"{'line': 26, 'column': 9, 'index': 866}","it('should not prevent a subsequent click if aborting during a pending drag', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  fireEvent.mouseDown(handle);

  // abort
  fireEvent.keyDown(handle, { keyCode: keyCodes.escape });

  // would normally start
  fireEvent.mouseMove(handle, {
    clientX: 0,
    clientY: sloppyClickThreshold,
  });

  // drag not started
  expect(isDragging(handle)).toBe(false);

  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);

  expect(click.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Lazy Test,"{'line': 39, 'column': 2, 'index': 1248}","it('should prevent a subsequent click if cancelling a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.keyDown(handle, { keyCode: keyCodes.escape });

  // drag cancelled
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Lazy Test,"{'line': 40, 'column': 9, 'index': 1284}","it('should prevent a subsequent click if cancelling a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.keyDown(handle, { keyCode: keyCodes.escape });

  // drag cancelled
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Lazy Test,"{'line': 46, 'column': 9, 'index': 1418}","it('should prevent a subsequent click if cancelling a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.keyDown(handle, { keyCode: keyCodes.escape });

  // drag cancelled
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Lazy Test,"{'line': 60, 'column': 2, 'index': 1874}","it('should prevent a subsequent click if dropping a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.mouseUp(handle);

  expect(getDropReason(onDragEnd)).toBe('DROP');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Lazy Test,"{'line': 61, 'column': 9, 'index': 1910}","it('should prevent a subsequent click if dropping a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.mouseUp(handle);

  expect(getDropReason(onDragEnd)).toBe('DROP');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/mouse-sensor/click-blocking.spec.js,Lazy Test,"{'line': 66, 'column': 9, 'index': 1994}","it('should prevent a subsequent click if dropping a drag', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(mouse, handle);
  expect(isDragging(handle)).toBe(true);

  // cancel
  fireEvent.mouseUp(handle);

  expect(getDropReason(onDragEnd)).toBe('DROP');
  expect(isDragging(handle)).toBe(false);

  // click event prevented
  const click: Event = createEvent.click(handle);
  fireEvent(handle, click);
  expect(click.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Conditional Test Logic,"{'line': 51, 'column': 4, 'index': 1653}","it('should not prevent the default behaviour for an indirect cancel', () => {
  [
    'mousedown',
    'mouseup',
    'click',
    'touchstart',
    'resize',
    'wheel',
    supportedEventName,
  ].forEach((eventName: string) => {
    const onDragEnd = jest.fn();
    const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(keyboard, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event(eventName, {
      bubbles: true,
      cancelable: true,
      target: handle,
    });

    fireEvent(handle, event);

    // not an explicit cancel
    expect(event.defaultPrevented).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 15, 'column': 2, 'index': 676}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  const event: Event = createEvent.keyDown(handle, { keyCode: keyCodes.space });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 16, 'column': 9, 'index': 715}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  const event: Event = createEvent.keyDown(handle, { keyCode: keyCodes.space });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 22, 'column': 9, 'index': 912}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  const event: Event = createEvent.keyDown(handle, { keyCode: keyCodes.space });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 30, 'column': 2, 'index': 1162}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 31, 'column': 9, 'index': 1201}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 39, 'column': 9, 'index': 1406}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 56, 'column': 4, 'index': 1852}","it('should not prevent the default behaviour for an indirect cancel', () => {
  [
    'mousedown',
    'mouseup',
    'click',
    'touchstart',
    'resize',
    'wheel',
    supportedEventName,
  ].forEach((eventName: string) => {
    const onDragEnd = jest.fn();
    const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(keyboard, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event(eventName, {
      bubbles: true,
      cancelable: true,
      target: handle,
    });

    fireEvent(handle, event);

    // not an explicit cancel
    expect(event.defaultPrevented).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 57, 'column': 11, 'index': 1893}","it('should not prevent the default behaviour for an indirect cancel', () => {
  [
    'mousedown',
    'mouseup',
    'click',
    'touchstart',
    'resize',
    'wheel',
    supportedEventName,
  ].forEach((eventName: string) => {
    const onDragEnd = jest.fn();
    const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(keyboard, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event(eventName, {
      bubbles: true,
      cancelable: true,
      target: handle,
    });

    fireEvent(handle, event);

    // not an explicit cancel
    expect(event.defaultPrevented).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Eager Test,"{'line': 69, 'column': 11, 'index': 2170}","it('should not prevent the default behaviour for an indirect cancel', () => {
  [
    'mousedown',
    'mouseup',
    'click',
    'touchstart',
    'resize',
    'wheel',
    supportedEventName,
  ].forEach((eventName: string) => {
    const onDragEnd = jest.fn();
    const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(keyboard, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event(eventName, {
      bubbles: true,
      cancelable: true,
      target: handle,
    });

    fireEvent(handle, event);

    // not an explicit cancel
    expect(event.defaultPrevented).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 15, 'column': 2, 'index': 676}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  const event: Event = createEvent.keyDown(handle, { keyCode: keyCodes.space });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 16, 'column': 9, 'index': 715}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  const event: Event = createEvent.keyDown(handle, { keyCode: keyCodes.space });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 22, 'column': 9, 'index': 912}","it('should prevent default on the event that causes a drop', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  const event: Event = createEvent.keyDown(handle, { keyCode: keyCodes.space });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('DROP');
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 30, 'column': 2, 'index': 1162}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 31, 'column': 9, 'index': 1201}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 39, 'column': 9, 'index': 1406}","it('should prevent default on an escape press', () => {
  const onDragEnd = jest.fn();
  const { getByText } = render(<App onDragEnd={onDragEnd} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.escape,
  });
  fireEvent(handle, event);

  expect(event.defaultPrevented).toBe(true);
  expect(getDropReason(onDragEnd)).toBe('CANCEL');
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 56, 'column': 4, 'index': 1852}","it('should not prevent the default behaviour for an indirect cancel', () => {
  [
    'mousedown',
    'mouseup',
    'click',
    'touchstart',
    'resize',
    'wheel',
    supportedEventName,
  ].forEach((eventName: string) => {
    const onDragEnd = jest.fn();
    const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(keyboard, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event(eventName, {
      bubbles: true,
      cancelable: true,
      target: handle,
    });

    fireEvent(handle, event);

    // not an explicit cancel
    expect(event.defaultPrevented).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 57, 'column': 11, 'index': 1893}","it('should not prevent the default behaviour for an indirect cancel', () => {
  [
    'mousedown',
    'mouseup',
    'click',
    'touchstart',
    'resize',
    'wheel',
    supportedEventName,
  ].forEach((eventName: string) => {
    const onDragEnd = jest.fn();
    const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(keyboard, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event(eventName, {
      bubbles: true,
      cancelable: true,
      target: handle,
    });

    fireEvent(handle, event);

    // not an explicit cancel
    expect(event.defaultPrevented).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/stopping-a-drag.spec.js,Lazy Test,"{'line': 69, 'column': 11, 'index': 2170}","it('should not prevent the default behaviour for an indirect cancel', () => {
  [
    'mousedown',
    'mouseup',
    'click',
    'touchstart',
    'resize',
    'wheel',
    supportedEventName,
  ].forEach((eventName: string) => {
    const onDragEnd = jest.fn();
    const { getByText, unmount } = render(<App onDragEnd={onDragEnd} />);
    const handle: HTMLElement = getByText('item: 0');

    simpleLift(keyboard, handle);
    expect(isDragging(handle)).toBe(true);

    const event: Event = new Event(eventName, {
      bubbles: true,
      cancelable: true,
      target: handle,
    });

    fireEvent(handle, event);

    // not an explicit cancel
    expect(event.defaultPrevented).toBe(false);
    expect(getDropReason(onDragEnd)).toBe('CANCEL');

    unmount();
  });
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/prevent-standard-keys-while-dragging.spec.js,Conditional Test Logic,"{'line': 16, 'column': 33, 'index': 587}","it('should prevent enter or tab being pressed during a drag', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  [keyCodes.enter, keyCodes.tab].forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/prevent-standard-keys-while-dragging.spec.js,Eager Test,"{'line': 13, 'column': 2, 'index': 482}","it('should prevent enter or tab being pressed during a drag', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  [keyCodes.enter, keyCodes.tab].forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/prevent-standard-keys-while-dragging.spec.js,Eager Test,"{'line': 14, 'column': 9, 'index': 521}","it('should prevent enter or tab being pressed during a drag', () => {
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);
  expect(isDragging(handle)).toBe(true);

  [keyCodes.enter, keyCodes.tab].forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);
    expect(event.defaultPrevented).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/prevent-keyboard-scroll.spec.js,Eager Test,"{'line': 19, 'column': 2, 'index': 593}","it('should prevent using keyboard keys that modify scroll', () => {
  const keys: number[] = [
    keyCodes.pageUp,
    keyCodes.pageDown,
    keyCodes.home,
    keyCodes.end,
  ];
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);

  keys.forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);

    expect(event.defaultPrevented).toBe(true);
    expect(isDragging(handle)).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/prevent-keyboard-scroll.spec.js,Eager Test,"{'line': 26, 'column': 11, 'index': 818}","it('should prevent using keyboard keys that modify scroll', () => {
  const keys: number[] = [
    keyCodes.pageUp,
    keyCodes.pageDown,
    keyCodes.home,
    keyCodes.end,
  ];
  const { getByText } = render(<App />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);

  keys.forEach((keyCode: number) => {
    const event: Event = createEvent.keyDown(handle, { keyCode });
    fireEvent(handle, event);

    expect(event.defaultPrevented).toBe(true);
    expect(isDragging(handle)).toBe(true);
  });
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/directional-movement.spec.js,Lazy Test,"{'line': 15, 'column': 2, 'index': 504}","it('should move up when pressing the up arrow', () => {
  const onDragUpdate = jest.fn();
  const { getByText } = render(<App onDragUpdate={onDragUpdate} />);
  const handle: HTMLElement = getByText('item: 1');

  simpleLift(keyboard, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.arrowUp,
  });
  fireEvent(handle, event);

  // flush async responder
  jest.runOnlyPendingTimers();
  expect(onDragUpdate).toHaveBeenCalled();
  expect(onDragUpdate.mock.calls[0][0].destination.index).toBe(0);

  // event consumed
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/directional-movement.spec.js,Lazy Test,"{'line': 36, 'column': 2, 'index': 1111}","it('should move down when pressing the down arrow', () => {
  const onDragUpdate = jest.fn();
  const { getByText } = render(<App onDragUpdate={onDragUpdate} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.arrowDown,
  });
  fireEvent(handle, event);

  // flush async responder
  jest.runOnlyPendingTimers();
  expect(onDragUpdate).toHaveBeenCalled();
  expect(onDragUpdate.mock.calls[0][0].destination.index).toBe(1);

  // event consumed
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/directional-movement.spec.js,Lazy Test,"{'line': 59, 'column': 2, 'index': 1754}","it('should move right when pressing the right arrow', () => {
  const onDragUpdate = jest.fn();
  const { getByText } = render(
    <App onDragUpdate={onDragUpdate} direction=""horizontal"" />,
  );
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.arrowRight,
  });
  fireEvent(handle, event);

  // flush async responder
  jest.runOnlyPendingTimers();
  expect(onDragUpdate).toHaveBeenCalled();
  expect(onDragUpdate.mock.calls[0][0].destination.index).toBe(1);

  // event consumed
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/directional-movement.spec.js,Lazy Test,"{'line': 82, 'column': 2, 'index': 2396}","it('should move left when pressing the left arrow', () => {
  const onDragUpdate = jest.fn();
  const { getByText } = render(
    <App onDragUpdate={onDragUpdate} direction=""horizontal"" />,
  );
  const handle: HTMLElement = getByText('item: 1');

  simpleLift(keyboard, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.arrowLeft,
  });
  fireEvent(handle, event);

  // flush async responder
  jest.runOnlyPendingTimers();
  expect(onDragUpdate).toHaveBeenCalled();
  expect(onDragUpdate.mock.calls[0][0].destination.index).toBe(0);

  // event consumed
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/directional-movement.spec.js,Magic Number,"{'line': 25, 'column': 63, 'index': 818}","it('should move up when pressing the up arrow', () => {
  const onDragUpdate = jest.fn();
  const { getByText } = render(<App onDragUpdate={onDragUpdate} />);
  const handle: HTMLElement = getByText('item: 1');

  simpleLift(keyboard, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.arrowUp,
  });
  fireEvent(handle, event);

  // flush async responder
  jest.runOnlyPendingTimers();
  expect(onDragUpdate).toHaveBeenCalled();
  expect(onDragUpdate.mock.calls[0][0].destination.index).toBe(0);

  // event consumed
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/directional-movement.spec.js,Magic Number,"{'line': 46, 'column': 63, 'index': 1427}","it('should move down when pressing the down arrow', () => {
  const onDragUpdate = jest.fn();
  const { getByText } = render(<App onDragUpdate={onDragUpdate} />);
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.arrowDown,
  });
  fireEvent(handle, event);

  // flush async responder
  jest.runOnlyPendingTimers();
  expect(onDragUpdate).toHaveBeenCalled();
  expect(onDragUpdate.mock.calls[0][0].destination.index).toBe(1);

  // event consumed
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/directional-movement.spec.js,Magic Number,"{'line': 69, 'column': 63, 'index': 2071}","it('should move right when pressing the right arrow', () => {
  const onDragUpdate = jest.fn();
  const { getByText } = render(
    <App onDragUpdate={onDragUpdate} direction=""horizontal"" />,
  );
  const handle: HTMLElement = getByText('item: 0');

  simpleLift(keyboard, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.arrowRight,
  });
  fireEvent(handle, event);

  // flush async responder
  jest.runOnlyPendingTimers();
  expect(onDragUpdate).toHaveBeenCalled();
  expect(onDragUpdate.mock.calls[0][0].destination.index).toBe(1);

  // event consumed
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-handle/keyboard-sensor/directional-movement.spec.js,Magic Number,"{'line': 92, 'column': 63, 'index': 2712}","it('should move left when pressing the left arrow', () => {
  const onDragUpdate = jest.fn();
  const { getByText } = render(
    <App onDragUpdate={onDragUpdate} direction=""horizontal"" />,
  );
  const handle: HTMLElement = getByText('item: 1');

  simpleLift(keyboard, handle);

  const event: Event = createEvent.keyDown(handle, {
    keyCode: keyCodes.arrowLeft,
  });
  fireEvent(handle, event);

  // flush async responder
  jest.runOnlyPendingTimers();
  expect(onDragUpdate).toHaveBeenCalled();
  expect(onDragUpdate.mock.calls[0][0].destination.index).toBe(0);

  // event consumed
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-drop-context/reset-server-context.spec.js,Duplicate Assert,"{'line': 14, 'column': 2, 'index': 486}","it('should reset the style marshal context', () => {
  expect(doesStyleElementExist(1)).toBe(false);

  const wrapper1 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(0)).toBe(true);

  const wrapper2 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(1)).toBe(true);

  // not created yet
  expect(doesStyleElementExist(2)).toBe(false);

  // clearing away the old wrappers
  wrapper1.unmount();
  wrapper2.unmount();
  resetServerContext();

  // a new wrapper after the reset
  const wrapper3 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  // now only '0' exists
  expect(doesStyleElementExist(0)).toBe(true);
  expect(doesStyleElementExist(1)).toBe(false);

  wrapper3.unmount();
})",steel
/test/unit/integration/drag-drop-context/reset-server-context.spec.js,Duplicate Assert,"{'line': 14, 'column': 2, 'index': 486}","it('should reset the style marshal context', () => {
  expect(doesStyleElementExist(1)).toBe(false);

  const wrapper1 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(0)).toBe(true);

  const wrapper2 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(1)).toBe(true);

  // not created yet
  expect(doesStyleElementExist(2)).toBe(false);

  // clearing away the old wrappers
  wrapper1.unmount();
  wrapper2.unmount();
  resetServerContext();

  // a new wrapper after the reset
  const wrapper3 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  // now only '0' exists
  expect(doesStyleElementExist(0)).toBe(true);
  expect(doesStyleElementExist(1)).toBe(false);

  wrapper3.unmount();
})",steel
/test/unit/integration/drag-drop-context/reset-server-context.spec.js,Duplicate Assert,"{'line': 19, 'column': 2, 'index': 635}","it('should reset the style marshal context', () => {
  expect(doesStyleElementExist(1)).toBe(false);

  const wrapper1 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(0)).toBe(true);

  const wrapper2 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(1)).toBe(true);

  // not created yet
  expect(doesStyleElementExist(2)).toBe(false);

  // clearing away the old wrappers
  wrapper1.unmount();
  wrapper2.unmount();
  resetServerContext();

  // a new wrapper after the reset
  const wrapper3 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  // now only '0' exists
  expect(doesStyleElementExist(0)).toBe(true);
  expect(doesStyleElementExist(1)).toBe(false);

  wrapper3.unmount();
})",steel
/test/unit/integration/drag-drop-context/reset-server-context.spec.js,Duplicate Assert,"{'line': 19, 'column': 2, 'index': 635}","it('should reset the style marshal context', () => {
  expect(doesStyleElementExist(1)).toBe(false);

  const wrapper1 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(0)).toBe(true);

  const wrapper2 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(1)).toBe(true);

  // not created yet
  expect(doesStyleElementExist(2)).toBe(false);

  // clearing away the old wrappers
  wrapper1.unmount();
  wrapper2.unmount();
  resetServerContext();

  // a new wrapper after the reset
  const wrapper3 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  // now only '0' exists
  expect(doesStyleElementExist(0)).toBe(true);
  expect(doesStyleElementExist(1)).toBe(false);

  wrapper3.unmount();
})",steel
/test/unit/integration/drag-drop-context/reset-server-context.spec.js,Duplicate Assert,"{'line': 24, 'column': 2, 'index': 783}","it('should reset the style marshal context', () => {
  expect(doesStyleElementExist(1)).toBe(false);

  const wrapper1 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(0)).toBe(true);

  const wrapper2 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(1)).toBe(true);

  // not created yet
  expect(doesStyleElementExist(2)).toBe(false);

  // clearing away the old wrappers
  wrapper1.unmount();
  wrapper2.unmount();
  resetServerContext();

  // a new wrapper after the reset
  const wrapper3 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  // now only '0' exists
  expect(doesStyleElementExist(0)).toBe(true);
  expect(doesStyleElementExist(1)).toBe(false);

  wrapper3.unmount();
})",steel
/test/unit/integration/drag-drop-context/reset-server-context.spec.js,Duplicate Assert,"{'line': 40, 'column': 2, 'index': 1167}","it('should reset the style marshal context', () => {
  expect(doesStyleElementExist(1)).toBe(false);

  const wrapper1 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(0)).toBe(true);

  const wrapper2 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(1)).toBe(true);

  // not created yet
  expect(doesStyleElementExist(2)).toBe(false);

  // clearing away the old wrappers
  wrapper1.unmount();
  wrapper2.unmount();
  resetServerContext();

  // a new wrapper after the reset
  const wrapper3 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  // now only '0' exists
  expect(doesStyleElementExist(0)).toBe(true);
  expect(doesStyleElementExist(1)).toBe(false);

  wrapper3.unmount();
})",steel
/test/unit/integration/drag-drop-context/reset-server-context.spec.js,Duplicate Assert,"{'line': 40, 'column': 2, 'index': 1167}","it('should reset the style marshal context', () => {
  expect(doesStyleElementExist(1)).toBe(false);

  const wrapper1 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(0)).toBe(true);

  const wrapper2 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(1)).toBe(true);

  // not created yet
  expect(doesStyleElementExist(2)).toBe(false);

  // clearing away the old wrappers
  wrapper1.unmount();
  wrapper2.unmount();
  resetServerContext();

  // a new wrapper after the reset
  const wrapper3 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  // now only '0' exists
  expect(doesStyleElementExist(0)).toBe(true);
  expect(doesStyleElementExist(1)).toBe(false);

  wrapper3.unmount();
})",steel
/test/unit/integration/drag-drop-context/reset-server-context.spec.js,Duplicate Assert,"{'line': 41, 'column': 2, 'index': 1214}","it('should reset the style marshal context', () => {
  expect(doesStyleElementExist(1)).toBe(false);

  const wrapper1 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(0)).toBe(true);

  const wrapper2 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(1)).toBe(true);

  // not created yet
  expect(doesStyleElementExist(2)).toBe(false);

  // clearing away the old wrappers
  wrapper1.unmount();
  wrapper2.unmount();
  resetServerContext();

  // a new wrapper after the reset
  const wrapper3 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  // now only '0' exists
  expect(doesStyleElementExist(0)).toBe(true);
  expect(doesStyleElementExist(1)).toBe(false);

  wrapper3.unmount();
})",steel
/test/unit/integration/drag-drop-context/reset-server-context.spec.js,Duplicate Assert,"{'line': 41, 'column': 2, 'index': 1214}","it('should reset the style marshal context', () => {
  expect(doesStyleElementExist(1)).toBe(false);

  const wrapper1 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(0)).toBe(true);

  const wrapper2 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );
  expect(doesStyleElementExist(1)).toBe(true);

  // not created yet
  expect(doesStyleElementExist(2)).toBe(false);

  // clearing away the old wrappers
  wrapper1.unmount();
  wrapper2.unmount();
  resetServerContext();

  // a new wrapper after the reset
  const wrapper3 = render(
    <DragDropContext onDragEnd={() => {}}>{null}</DragDropContext>,
  );

  // now only '0' exists
  expect(doesStyleElementExist(0)).toBe(true);
  expect(doesStyleElementExist(1)).toBe(false);

  wrapper3.unmount();
})",steel
/test/unit/integration/drag-drop-context/check-react-version.spec.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 688}","it('should pass if the react peer dep version is passed', () => {
  // patch
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.3.5';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
  // minor
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.4.0';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
  // major
  {
    const peerDep: string = '1.3.4';
    const actual: string = '2.0.0';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
})",steel
/test/unit/integration/drag-drop-context/check-react-version.spec.js,Duplicate Assert,"{'line': 28, 'column': 4, 'index': 688}","it('should pass if the react peer dep version is passed', () => {
  // patch
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.3.5';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
  // minor
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.4.0';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
  // major
  {
    const peerDep: string = '1.3.4';
    const actual: string = '2.0.0';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
})",steel
/test/unit/integration/drag-drop-context/check-react-version.spec.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 863}","it('should pass if the react peer dep version is passed', () => {
  // patch
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.3.5';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
  // minor
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.4.0';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
  // major
  {
    const peerDep: string = '1.3.4';
    const actual: string = '2.0.0';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
})",steel
/test/unit/integration/drag-drop-context/check-react-version.spec.js,Duplicate Assert,"{'line': 37, 'column': 4, 'index': 863}","it('should pass if the react peer dep version is passed', () => {
  // patch
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.3.5';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
  // minor
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.4.0';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
  // major
  {
    const peerDep: string = '1.3.4';
    const actual: string = '2.0.0';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
})",steel
/test/unit/integration/drag-drop-context/check-react-version.spec.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1038}","it('should pass if the react peer dep version is passed', () => {
  // patch
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.3.5';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
  // minor
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.4.0';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
  // major
  {
    const peerDep: string = '1.3.4';
    const actual: string = '2.0.0';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
})",steel
/test/unit/integration/drag-drop-context/check-react-version.spec.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1038}","it('should pass if the react peer dep version is passed', () => {
  // patch
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.3.5';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
  // minor
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.4.0';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
  // major
  {
    const peerDep: string = '1.3.4';
    const actual: string = '2.0.0';

    checkReactVersion(peerDep, actual);

    expect(warn).not.toHaveBeenCalled();
  }
})",steel
/test/unit/integration/drag-drop-context/check-react-version.spec.js,Duplicate Assert,"{'line': 58, 'column': 4, 'index': 1293}","it('should fail if the react peer dep version is not met', () => {
  // patch not met
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.3.3';

    checkReactVersion(peerDep, actual);

    expect(warn).toHaveBeenCalledTimes(1);
    warn.mockClear();
  }
  // minor not met
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.2.4';

    checkReactVersion(peerDep, actual);

    expect(warn).toHaveBeenCalledTimes(1);
    warn.mockClear();
  }
  // major not met
  {
    const peerDep: string = '1.3.4';
    const actual: string = '0.3.4';

    checkReactVersion(peerDep, actual);

    expect(warn).toHaveBeenCalledTimes(1);
    warn.mockClear();
  }
})",steel
/test/unit/integration/drag-drop-context/check-react-version.spec.js,Duplicate Assert,"{'line': 68, 'column': 4, 'index': 1500}","it('should fail if the react peer dep version is not met', () => {
  // patch not met
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.3.3';

    checkReactVersion(peerDep, actual);

    expect(warn).toHaveBeenCalledTimes(1);
    warn.mockClear();
  }
  // minor not met
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.2.4';

    checkReactVersion(peerDep, actual);

    expect(warn).toHaveBeenCalledTimes(1);
    warn.mockClear();
  }
  // major not met
  {
    const peerDep: string = '1.3.4';
    const actual: string = '0.3.4';

    checkReactVersion(peerDep, actual);

    expect(warn).toHaveBeenCalledTimes(1);
    warn.mockClear();
  }
})",steel
/test/unit/integration/drag-drop-context/check-react-version.spec.js,Duplicate Assert,"{'line': 78, 'column': 4, 'index': 1707}","it('should fail if the react peer dep version is not met', () => {
  // patch not met
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.3.3';

    checkReactVersion(peerDep, actual);

    expect(warn).toHaveBeenCalledTimes(1);
    warn.mockClear();
  }
  // minor not met
  {
    const peerDep: string = '1.3.4';
    const actual: string = '1.2.4';

    checkReactVersion(peerDep, actual);

    expect(warn).toHaveBeenCalledTimes(1);
    warn.mockClear();
  }
  // major not met
  {
    const peerDep: string = '1.3.4';
    const actual: string = '0.3.4';

    checkReactVersion(peerDep, actual);

    expect(warn).toHaveBeenCalledTimes(1);
    warn.mockClear();
  }
})",steel
/test/unit/integration/drag-drop-context/on-before-capture/removals.spec.js,Duplicate Assert,"{'line': 72, 'column': 2, 'index': 2235}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['first', 'second']);
    function onBeforeCapture() {
      // removing the first item
      setItems(['second']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const second: HTMLElement = getByTestId('second');

  // initially it had an index of 1
  expect(getIndex(second)).toBe(1);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(getByTestId('second'), { x: 0, y: 0 });
  });

  // act(() => rerender());
  // first item has been removed
  expect(queryByTestId('first')).toBe(null);
  // second is now dragging
  expect(isDragging(second)).toBe(true);
  // second index accounts for removal
  expect(getIndex(second)).toBe(0);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'second',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 0,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-drop-context/on-before-capture/removals.spec.js,Duplicate Assert,"{'line': 86, 'column': 2, 'index': 2691}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['first', 'second']);
    function onBeforeCapture() {
      // removing the first item
      setItems(['second']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const second: HTMLElement = getByTestId('second');

  // initially it had an index of 1
  expect(getIndex(second)).toBe(1);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(getByTestId('second'), { x: 0, y: 0 });
  });

  // act(() => rerender());
  // first item has been removed
  expect(queryByTestId('first')).toBe(null);
  // second is now dragging
  expect(isDragging(second)).toBe(true);
  // second index accounts for removal
  expect(getIndex(second)).toBe(0);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'second',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 0,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-drop-context/on-before-capture/removals.spec.js,Magic Number,"{'line': 72, 'column': 32, 'index': 2265}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['first', 'second']);
    function onBeforeCapture() {
      // removing the first item
      setItems(['second']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const second: HTMLElement = getByTestId('second');

  // initially it had an index of 1
  expect(getIndex(second)).toBe(1);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(getByTestId('second'), { x: 0, y: 0 });
  });

  // act(() => rerender());
  // first item has been removed
  expect(queryByTestId('first')).toBe(null);
  // second is now dragging
  expect(isDragging(second)).toBe(true);
  // second index accounts for removal
  expect(getIndex(second)).toBe(0);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'second',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 0,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-drop-context/on-before-capture/removals.spec.js,Magic Number,"{'line': 86, 'column': 32, 'index': 2721}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['first', 'second']);
    function onBeforeCapture() {
      // removing the first item
      setItems(['second']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const second: HTMLElement = getByTestId('second');

  // initially it had an index of 1
  expect(getIndex(second)).toBe(1);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(getByTestId('second'), { x: 0, y: 0 });
  });

  // act(() => rerender());
  // first item has been removed
  expect(queryByTestId('first')).toBe(null);
  // second is now dragging
  expect(isDragging(second)).toBe(true);
  // second index accounts for removal
  expect(getIndex(second)).toBe(0);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'second',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 0,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-drop-context/on-before-capture/additions.spec.js,Duplicate Assert,"{'line': 127, 'column': 2, 'index': 3700}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['initial']);
    function onBeforeCapture() {
      // adding the first item
      setItems(['first', 'initial']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const initial: HTMLElement = getByTestId('initial');

  // initially it had an index of 1
  expect(getIndex(initial)).toBe(0);
  // first item does not exist yet
  expect(queryByTestId('first')).toBe(null);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(initial, { x: 0, y: 0 });
  });

  // first item has been added
  expect(queryByTestId('first')).toBeTruthy();
  // initial is now dragging
  expect(isDragging(initial)).toBe(true);
  // initial index accounts for addition
  expect(getIndex(initial)).toBe(1);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'initial',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 1,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-drop-context/on-before-capture/additions.spec.js,Duplicate Assert,"{'line': 129, 'column': 2, 'index': 3772}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['initial']);
    function onBeforeCapture() {
      // adding the first item
      setItems(['first', 'initial']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const initial: HTMLElement = getByTestId('initial');

  // initially it had an index of 1
  expect(getIndex(initial)).toBe(0);
  // first item does not exist yet
  expect(queryByTestId('first')).toBe(null);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(initial, { x: 0, y: 0 });
  });

  // first item has been added
  expect(queryByTestId('first')).toBeTruthy();
  // initial is now dragging
  expect(isDragging(initial)).toBe(true);
  // initial index accounts for addition
  expect(getIndex(initial)).toBe(1);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'initial',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 1,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-drop-context/on-before-capture/additions.spec.js,Duplicate Assert,"{'line': 138, 'column': 2, 'index': 4040}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['initial']);
    function onBeforeCapture() {
      // adding the first item
      setItems(['first', 'initial']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const initial: HTMLElement = getByTestId('initial');

  // initially it had an index of 1
  expect(getIndex(initial)).toBe(0);
  // first item does not exist yet
  expect(queryByTestId('first')).toBe(null);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(initial, { x: 0, y: 0 });
  });

  // first item has been added
  expect(queryByTestId('first')).toBeTruthy();
  // initial is now dragging
  expect(isDragging(initial)).toBe(true);
  // initial index accounts for addition
  expect(getIndex(initial)).toBe(1);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'initial',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 1,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-drop-context/on-before-capture/additions.spec.js,Duplicate Assert,"{'line': 142, 'column': 2, 'index': 4199}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['initial']);
    function onBeforeCapture() {
      // adding the first item
      setItems(['first', 'initial']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const initial: HTMLElement = getByTestId('initial');

  // initially it had an index of 1
  expect(getIndex(initial)).toBe(0);
  // first item does not exist yet
  expect(queryByTestId('first')).toBe(null);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(initial, { x: 0, y: 0 });
  });

  // first item has been added
  expect(queryByTestId('first')).toBeTruthy();
  // initial is now dragging
  expect(isDragging(initial)).toBe(true);
  // initial index accounts for addition
  expect(getIndex(initial)).toBe(1);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'initial',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 1,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-drop-context/on-before-capture/additions.spec.js,Lazy Test,"{'line': 67, 'column': 9, 'index': 1834}","it('should allow for additions to be made', () => {
  // adding a new Droppable and Draggable
  function AnotherChunk() {
    return (
      <Droppable droppableId=""addition"">
        {(droppableProvided) => (
          <div
            {...droppableProvided.droppableProps}
            ref={droppableProvided.innerRef}
          >
            <Draggable draggableId=""addition-item"" index={0}>
              {(provided) => (
                <div
                  {...provided.draggableProps}
                  {...provided.dragHandleProps}
                  ref={provided.innerRef}
                >
                  Drag me!
                </div>
              )}
            </Draggable>
            {droppableProvided.placeholder};
          </div>
        )}
      </Droppable>
    );
  }

  function Root() {
    const [showAdditions, setShowAdditions] = useState(false);
    function onBeforeCapture() {
      setShowAdditions(true);
    }

    return (
      <App
        onBeforeCapture={onBeforeCapture}
        anotherChild={showAdditions ? <AnotherChunk /> : null}
      />
    );
  }

  const { getByTestId } = render(<Root />);
  const handle: HTMLElement = getByTestId('0');

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(handle, { x: 0, y: 0 });
  });

  expect(isDragging(handle)).toBe(true);
})",steel
/test/unit/integration/drag-drop-context/on-before-capture/additions.spec.js,Lazy Test,"{'line': 140, 'column': 9, 'index': 4123}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['initial']);
    function onBeforeCapture() {
      // adding the first item
      setItems(['first', 'initial']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const initial: HTMLElement = getByTestId('initial');

  // initially it had an index of 1
  expect(getIndex(initial)).toBe(0);
  // first item does not exist yet
  expect(queryByTestId('first')).toBe(null);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(initial, { x: 0, y: 0 });
  });

  // first item has been added
  expect(queryByTestId('first')).toBeTruthy();
  // initial is now dragging
  expect(isDragging(initial)).toBe(true);
  // initial index accounts for addition
  expect(getIndex(initial)).toBe(1);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'initial',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 1,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-drop-context/on-before-capture/additions.spec.js,Magic Number,"{'line': 127, 'column': 33, 'index': 3731}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['initial']);
    function onBeforeCapture() {
      // adding the first item
      setItems(['first', 'initial']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const initial: HTMLElement = getByTestId('initial');

  // initially it had an index of 1
  expect(getIndex(initial)).toBe(0);
  // first item does not exist yet
  expect(queryByTestId('first')).toBe(null);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(initial, { x: 0, y: 0 });
  });

  // first item has been added
  expect(queryByTestId('first')).toBeTruthy();
  // initial is now dragging
  expect(isDragging(initial)).toBe(true);
  // initial index accounts for addition
  expect(getIndex(initial)).toBe(1);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'initial',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 1,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-drop-context/on-before-capture/additions.spec.js,Magic Number,"{'line': 142, 'column': 33, 'index': 4230}","it('should adjust captured values for any changes that impact that dragging item', () => {
  jest.useFakeTimers();
  // 1. Changing the `type` of the Droppable
  // 2. Adding and item before the dragging item to impact it's index
  const onDragStart = jest.fn();

  function Root() {
    const [items, setItems] = useState(['initial']);
    function onBeforeCapture() {
      // adding the first item
      setItems(['first', 'initial']);
    }

    return (
      <DragDropContext
        onDragEnd={noop}
        onBeforeCapture={onBeforeCapture}
        onDragStart={onDragStart}
      >
        <Droppable droppableId=""droppable"">
          {(droppableProvided) => (
            <div
              {...droppableProvided.droppableProps}
              ref={droppableProvided.innerRef}
            >
              {items.map((item: string, index: number) => (
                <Draggable draggableId={item} index={index} key={item}>
                  {(provided, snapshot) => (
                    <div
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                      data-index={index}
                      data-testid={item}
                      data-is-dragging={snapshot.isDragging}
                      ref={provided.innerRef}
                    >
                      Drag me!
                    </div>
                  )}
                </Draggable>
              ))}
              {droppableProvided.placeholder};
            </div>
          )}
        </Droppable>
      </DragDropContext>
    );
  }

  const { getByTestId, queryByTestId } = render(<Root />);
  const initial: HTMLElement = getByTestId('initial');

  // initially it had an index of 1
  expect(getIndex(initial)).toBe(0);
  // first item does not exist yet
  expect(queryByTestId('first')).toBe(null);

  // act(() => {}); is joining the two into one update which is
  // causing unexpected mounting behaviour
  withError(() => {
    expandedMouse.rawPowerLift(initial, { x: 0, y: 0 });
  });

  // first item has been added
  expect(queryByTestId('first')).toBeTruthy();
  // initial is now dragging
  expect(isDragging(initial)).toBe(true);
  // initial index accounts for addition
  expect(getIndex(initial)).toBe(1);

  // flush onDragStart timer
  jest.runOnlyPendingTimers();

  // onDragStart called with correct new index
  const expected: DragStart = {
    draggableId: 'initial',
    mode: 'FLUID',
    type: 'DEFAULT',
    source: {
      index: 1,
      droppableId: 'droppable',
    },
  };
  expect(onDragStart.mock.calls[0][0]).toEqual(expected);

  jest.useRealTimers();
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Duplicate Assert,"{'line': 22, 'column': 2, 'index': 738}","it('should abort any active drag (rbd error)', () => {
  const { getByTestId } = render(<App />);

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRbdErrorEvent();

  withWarn(() => {
    withError(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event prevented
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Duplicate Assert,"{'line': 32, 'column': 2, 'index': 942}","it('should abort any active drag (rbd error)', () => {
  const { getByTestId } = render(<App />);

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRbdErrorEvent();

  withWarn(() => {
    withError(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event prevented
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Duplicate Assert,"{'line': 40, 'column': 2, 'index': 1215}","it('should abort any active drag (non-rbd error)', () => {
  const { getByTestId } = render(<App />);
  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRuntimeError();

  // not logging the raw error
  withoutError(() => {
    // logging that the drag was aborted
    withWarn(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event not prevented
  expect(event.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Duplicate Assert,"{'line': 52, 'column': 2, 'index': 1493}","it('should abort any active drag (non-rbd error)', () => {
  const { getByTestId } = render(<App />);
  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRuntimeError();

  // not logging the raw error
  withoutError(() => {
    // logging that the drag was aborted
    withWarn(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event not prevented
  expect(event.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Eager Test,"{'line': 21, 'column': 2, 'index': 696}","it('should abort any active drag (rbd error)', () => {
  const { getByTestId } = render(<App />);

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRbdErrorEvent();

  withWarn(() => {
    withError(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event prevented
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Eager Test,"{'line': 22, 'column': 9, 'index': 745}","it('should abort any active drag (rbd error)', () => {
  const { getByTestId } = render(<App />);

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRbdErrorEvent();

  withWarn(() => {
    withError(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event prevented
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Eager Test,"{'line': 32, 'column': 9, 'index': 949}","it('should abort any active drag (rbd error)', () => {
  const { getByTestId } = render(<App />);

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRbdErrorEvent();

  withWarn(() => {
    withError(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event prevented
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Eager Test,"{'line': 39, 'column': 2, 'index': 1173}","it('should abort any active drag (non-rbd error)', () => {
  const { getByTestId } = render(<App />);
  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRuntimeError();

  // not logging the raw error
  withoutError(() => {
    // logging that the drag was aborted
    withWarn(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event not prevented
  expect(event.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Eager Test,"{'line': 40, 'column': 9, 'index': 1222}","it('should abort any active drag (non-rbd error)', () => {
  const { getByTestId } = render(<App />);
  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRuntimeError();

  // not logging the raw error
  withoutError(() => {
    // logging that the drag was aborted
    withWarn(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event not prevented
  expect(event.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Eager Test,"{'line': 41, 'column': 23, 'index': 1287}","it('should abort any active drag (non-rbd error)', () => {
  const { getByTestId } = render(<App />);
  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRuntimeError();

  // not logging the raw error
  withoutError(() => {
    // logging that the drag was aborted
    withWarn(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event not prevented
  expect(event.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Eager Test,"{'line': 52, 'column': 9, 'index': 1500}","it('should abort any active drag (non-rbd error)', () => {
  const { getByTestId } = render(<App />);
  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRuntimeError();

  // not logging the raw error
  withoutError(() => {
    // logging that the drag was aborted
    withWarn(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event not prevented
  expect(event.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Lazy Test,"{'line': 21, 'column': 2, 'index': 696}","it('should abort any active drag (rbd error)', () => {
  const { getByTestId } = render(<App />);

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRbdErrorEvent();

  withWarn(() => {
    withError(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event prevented
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Lazy Test,"{'line': 22, 'column': 9, 'index': 745}","it('should abort any active drag (rbd error)', () => {
  const { getByTestId } = render(<App />);

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRbdErrorEvent();

  withWarn(() => {
    withError(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event prevented
  expect(event.defaultPrevented).toBe(true);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Lazy Test,"{'line': 39, 'column': 2, 'index': 1173}","it('should abort any active drag (non-rbd error)', () => {
  const { getByTestId } = render(<App />);
  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRuntimeError();

  // not logging the raw error
  withoutError(() => {
    // logging that the drag was aborted
    withWarn(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event not prevented
  expect(event.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-on-window.spec.js,Lazy Test,"{'line': 40, 'column': 9, 'index': 1222}","it('should abort any active drag (non-rbd error)', () => {
  const { getByTestId } = render(<App />);
  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);
  const event: Event = getRuntimeError();

  // not logging the raw error
  withoutError(() => {
    // logging that the drag was aborted
    withWarn(() => {
      window.dispatchEvent(event);
    });
  });

  // drag aborted
  expect(isDragging(getByTestId('0'))).toBe(false);
  // error event not prevented
  expect(event.defaultPrevented).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Conditional Test Logic,"{'line': 13, 'column': 4, 'index': 479}","it('should recover from rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      invariant(false, 'throwing');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    rerender(<App anotherChild={<CanThrow shouldThrow />} />);
  });

  expect(isDragging(getByTestId('0'))).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Conditional Test Logic,"{'line': 37, 'column': 4, 'index': 1104}","it('should not recover from non-rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      throw new Error('Boom');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Conditional Test Logic,"{'line': 61, 'column': 4, 'index': 1710}","it('should not recover from runtime errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      // Boom: TypeError
      window.foo();
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Duplicate Assert,"{'line': 25, 'column': 2, 'index': 761}","it('should recover from rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      invariant(false, 'throwing');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    rerender(<App anotherChild={<CanThrow shouldThrow />} />);
  });

  expect(isDragging(getByTestId('0'))).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Duplicate Assert,"{'line': 31, 'column': 2, 'index': 903}","it('should recover from rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      invariant(false, 'throwing');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    rerender(<App anotherChild={<CanThrow shouldThrow />} />);
  });

  expect(isDragging(getByTestId('0'))).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Eager Test,"{'line': 15, 'column': 6, 'index': 548}","it('should recover from rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      invariant(false, 'throwing');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    rerender(<App anotherChild={<CanThrow shouldThrow />} />);
  });

  expect(isDragging(getByTestId('0'))).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Eager Test,"{'line': 24, 'column': 2, 'index': 719}","it('should recover from rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      invariant(false, 'throwing');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    rerender(<App anotherChild={<CanThrow shouldThrow />} />);
  });

  expect(isDragging(getByTestId('0'))).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Eager Test,"{'line': 25, 'column': 9, 'index': 768}","it('should recover from rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      invariant(false, 'throwing');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    rerender(<App anotherChild={<CanThrow shouldThrow />} />);
  });

  expect(isDragging(getByTestId('0'))).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Eager Test,"{'line': 31, 'column': 9, 'index': 910}","it('should recover from rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      invariant(false, 'throwing');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    rerender(<App anotherChild={<CanThrow shouldThrow />} />);
  });

  expect(isDragging(getByTestId('0'))).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Eager Test,"{'line': 48, 'column': 2, 'index': 1339}","it('should not recover from non-rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      throw new Error('Boom');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Eager Test,"{'line': 49, 'column': 9, 'index': 1388}","it('should not recover from non-rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      throw new Error('Boom');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Eager Test,"{'line': 73, 'column': 2, 'index': 1959}","it('should not recover from runtime errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      // Boom: TypeError
      window.foo();
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Eager Test,"{'line': 74, 'column': 9, 'index': 2008}","it('should not recover from runtime errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      // Boom: TypeError
      window.foo();
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Exception Handling,"{'line': 39, 'column': 6, 'index': 1173}","it('should not recover from non-rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      throw new Error('Boom');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Lazy Test,"{'line': 24, 'column': 2, 'index': 719}","it('should recover from rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      invariant(false, 'throwing');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    rerender(<App anotherChild={<CanThrow shouldThrow />} />);
  });

  expect(isDragging(getByTestId('0'))).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Lazy Test,"{'line': 25, 'column': 9, 'index': 768}","it('should recover from rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      invariant(false, 'throwing');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    rerender(<App anotherChild={<CanThrow shouldThrow />} />);
  });

  expect(isDragging(getByTestId('0'))).toBe(false);
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Lazy Test,"{'line': 48, 'column': 2, 'index': 1339}","it('should not recover from non-rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      throw new Error('Boom');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Lazy Test,"{'line': 49, 'column': 9, 'index': 1388}","it('should not recover from non-rbd errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      throw new Error('Boom');
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Lazy Test,"{'line': 73, 'column': 2, 'index': 1959}","it('should not recover from runtime errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      // Boom: TypeError
      window.foo();
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",steel
/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js,Lazy Test,"{'line': 74, 'column': 9, 'index': 2008}","it('should not recover from runtime errors', () => {
  let hasThrown: boolean = false;
  function CanThrow(props: { shouldThrow: boolean }) {
    if (!hasThrown && props.shouldThrow) {
      hasThrown = true;
      // Boom: TypeError
      window.foo();
    }
    return null;
  }

  const { rerender, getByTestId } = render(
    <App anotherChild={<CanThrow shouldThrow={false} />} />,
  );

  simpleLift(keyboard, getByTestId('0'));
  expect(isDragging(getByTestId('0'))).toBe(true);

  withError(() => {
    expect(() => {
      rerender(<App anotherChild={<CanThrow shouldThrow />} />);
    }).toThrow();
  });
})",steel
/test/unit/health/src-file-name-convention.spec.js,Conditional Test Logic,"{'line': 28, 'column': 4, 'index': 791}","it('should have every prettier target following the file name convention', async () => {
  const targets: string[] = pkg.config.prettier_target.split(' ');
  const paths: string[] = await globby(targets);

  invariant(
    paths.length,
    'Could not find files to test against file name convention',
  );

  paths.forEach((filePath: string) => {
    if (exceptions.includes(filePath)) {
      return;
    }

    const isMatching: boolean = isSnakeCase(filePath);

    invariant(
      isMatching,
      `${filePath} does not follow the file path convention (snake-case.js) ${convention.toString()}`,
    );

    expect(isMatching).toBe(true);
  });
})",steel
/test/unit/health/src-file-name-convention.spec.js,Eager Test,"{'line': 22, 'column': 2, 'index': 647}","it('should have every prettier target following the file name convention', async () => {
  const targets: string[] = pkg.config.prettier_target.split(' ');
  const paths: string[] = await globby(targets);

  invariant(
    paths.length,
    'Could not find files to test against file name convention',
  );

  paths.forEach((filePath: string) => {
    if (exceptions.includes(filePath)) {
      return;
    }

    const isMatching: boolean = isSnakeCase(filePath);

    invariant(
      isMatching,
      `${filePath} does not follow the file path convention (snake-case.js) ${convention.toString()}`,
    );

    expect(isMatching).toBe(true);
  });
})",steel
/test/unit/health/src-file-name-convention.spec.js,Eager Test,"{'line': 34, 'column': 4, 'index': 909}","it('should have every prettier target following the file name convention', async () => {
  const targets: string[] = pkg.config.prettier_target.split(' ');
  const paths: string[] = await globby(targets);

  invariant(
    paths.length,
    'Could not find files to test against file name convention',
  );

  paths.forEach((filePath: string) => {
    if (exceptions.includes(filePath)) {
      return;
    }

    const isMatching: boolean = isSnakeCase(filePath);

    invariant(
      isMatching,
      `${filePath} does not follow the file path convention (snake-case.js) ${convention.toString()}`,
    );

    expect(isMatching).toBe(true);
  });
})",steel
/test/unit/docs/no-broken-links.spec.js,Conditional Test Logic,"{'line': 19, 'column': 2, 'index': 483}",Unknown,steel
/test/unit/docs/no-broken-links.spec.js,Conditional Test Logic,"{'line': 28, 'column': 2, 'index': 711}",Unknown,steel
/test/unit/docs/no-broken-links.spec.js,Conditional Test Logic,"{'line': 33, 'column': 2, 'index': 807}",Unknown,steel
/test/unit/docs/no-broken-links.spec.js,Conditional Test Logic,"{'line': 38, 'column': 2, 'index': 897}",Unknown,steel
/test/unit/docs/no-broken-links.spec.js,Conditional Test Logic,"{'line': 49, 'column': 2, 'index': 1140}",Unknown,steel
/test/unit/docs/no-broken-links.spec.js,Conditional Test Logic,"{'line': 62, 'column': 2, 'index': 1390}",Unknown,steel
/test/unit/docs/no-broken-links.spec.js,Conditional Test Logic,"{'line': 65, 'column': 2, 'index': 1464}",Unknown,steel
/test/unit/docs/no-broken-links.spec.js,Conditional Test Logic,"{'line': 74, 'column': 2, 'index': 1734}","it('should use have no dead links', async () => {
  const files: string[] = await globby(['**/*.md', '!node_modules/']);
  expect(files.length).toBeGreaterThan(0);

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    const tokens: Token[] = markdown.parse(contents, {});
    expect(tokens.length).toBeGreaterThan(0);
    tokens.forEach((token: Token) => parse(token, file, files));
  }

  // need at least one assertion
  expect(true).toBe(true);
})",steel
/test/unit/docs/no-broken-links.spec.js,Magic Number,"{'line': 72, 'column': 39, 'index': 1727}","it('should use have no dead links', async () => {
  const files: string[] = await globby(['**/*.md', '!node_modules/']);
  expect(files.length).toBeGreaterThan(0);

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    const tokens: Token[] = markdown.parse(contents, {});
    expect(tokens.length).toBeGreaterThan(0);
    tokens.forEach((token: Token) => parse(token, file, files));
  }

  // need at least one assertion
  expect(true).toBe(true);
})",steel
/test/unit/docs/no-broken-links.spec.js,Magic Number,"{'line': 78, 'column': 42, 'index': 1925}","it('should use have no dead links', async () => {
  const files: string[] = await globby(['**/*.md', '!node_modules/']);
  expect(files.length).toBeGreaterThan(0);

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    const tokens: Token[] = markdown.parse(contents, {});
    expect(tokens.length).toBeGreaterThan(0);
    tokens.forEach((token: Token) => parse(token, file, files));
  }

  // need at least one assertion
  expect(true).toBe(true);
})",steel
/test/unit/docs/no-broken-links.spec.js,Redundant Assertion,"{'column': 2, 'line': 58}",Unknown,steel
/test/unit/docs/no-broken-links.spec.js,Redundant Assertion,"{'column': 2, 'line': 83}","it('should use have no dead links', async () => {
  const files: string[] = await globby(['**/*.md', '!node_modules/']);
  expect(files.length).toBeGreaterThan(0);

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    const tokens: Token[] = markdown.parse(contents, {});
    expect(tokens.length).toBeGreaterThan(0);
    tokens.forEach((token: Token) => parse(token, file, files));
  }

  // need at least one assertion
  expect(true).toBe(true);
})",steel
/test/unit/docs/no-broken-links.spec.js,Resource Optimism,"{'line': 75, 'column': 35, 'index': 1797}","it('should use have no dead links', async () => {
  const files: string[] = await globby(['**/*.md', '!node_modules/']);
  expect(files.length).toBeGreaterThan(0);

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    const tokens: Token[] = markdown.parse(contents, {});
    expect(tokens.length).toBeGreaterThan(0);
    tokens.forEach((token: Token) => parse(token, file, files));
  }

  // need at least one assertion
  expect(true).toBe(true);
})",steel
/test/unit/docs/content.spec.js,Conditional Test Logic,"{'line': 14, 'column': 2, 'index': 510}","it('should end all nested docs with a link back to the documentation root', async () => {
  const files: string[] = await globby('docs/**/*.md');
  expect(files.length).toBeGreaterThan(0);
  const backLink: string =
    '[â† Back to documentation](/README.md#documentation-)';

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    // Printing a nice message to allow for quick fixing
    const endsWithBacklink: boolean = contents.trim().endsWith(backLink);

    if (!endsWithBacklink) {
      expect(`
        File: ""${file}""
        Did not end with back link
      `).toBe(true);
    }

    // need at least one assertion
    expect(true).toBe(true);
  }
})",steel
/test/unit/docs/content.spec.js,Conditional Test Logic,"{'line': 20, 'column': 4, 'index': 737}","it('should end all nested docs with a link back to the documentation root', async () => {
  const files: string[] = await globby('docs/**/*.md');
  expect(files.length).toBeGreaterThan(0);
  const backLink: string =
    '[â† Back to documentation](/README.md#documentation-)';

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    // Printing a nice message to allow for quick fixing
    const endsWithBacklink: boolean = contents.trim().endsWith(backLink);

    if (!endsWithBacklink) {
      expect(`
        File: ""${file}""
        Did not end with back link
      `).toBe(true);
    }

    // need at least one assertion
    expect(true).toBe(true);
  }
})",steel
/test/unit/docs/content.spec.js,Conditional Test Logic,"{'line': 36, 'column': 2, 'index': 1101}","it('should use correct wording', async () => {
  const files: string[] = await globby(['**/*.md', '!node_modules/']);
  expect(files.length).toBeGreaterThan(0);

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    // Expected: <Draggable />, <Droppable />, `<DragDropContext />`
    expect(contents.includes('`Draggable`')).toBe(false);
    expect(contents.includes('`Droppable`')).toBe(false);
    expect(contents.includes('`DragDropContext`')).toBe(false);

    // not enough whitespace
    expect(contents.includes('`<Draggable/>`')).toBe(false);
    expect(contents.includes('`<Droppable/>`')).toBe(false);
    expect(contents.includes('`<DragDropContext/>`')).toBe(false);

    // not a self closing tag
    expect(contents.includes('`<Draggable>`')).toBe(false);
    expect(contents.includes('`<Droppable>`')).toBe(false);
    expect(contents.includes('`<DragDropContext>`')).toBe(false);
  }
})",steel
/test/unit/docs/content.spec.js,Magic Number,"{'line': 10, 'column': 39, 'index': 416}","it('should end all nested docs with a link back to the documentation root', async () => {
  const files: string[] = await globby('docs/**/*.md');
  expect(files.length).toBeGreaterThan(0);
  const backLink: string =
    '[â† Back to documentation](/README.md#documentation-)';

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    // Printing a nice message to allow for quick fixing
    const endsWithBacklink: boolean = contents.trim().endsWith(backLink);

    if (!endsWithBacklink) {
      expect(`
        File: ""${file}""
        Did not end with back link
      `).toBe(true);
    }

    // need at least one assertion
    expect(true).toBe(true);
  }
})",steel
/test/unit/docs/content.spec.js,Magic Number,"{'line': 34, 'column': 39, 'index': 1094}","it('should use correct wording', async () => {
  const files: string[] = await globby(['**/*.md', '!node_modules/']);
  expect(files.length).toBeGreaterThan(0);

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    // Expected: <Draggable />, <Droppable />, `<DragDropContext />`
    expect(contents.includes('`Draggable`')).toBe(false);
    expect(contents.includes('`Droppable`')).toBe(false);
    expect(contents.includes('`DragDropContext`')).toBe(false);

    // not enough whitespace
    expect(contents.includes('`<Draggable/>`')).toBe(false);
    expect(contents.includes('`<Droppable/>`')).toBe(false);
    expect(contents.includes('`<DragDropContext/>`')).toBe(false);

    // not a self closing tag
    expect(contents.includes('`<Draggable>`')).toBe(false);
    expect(contents.includes('`<Droppable>`')).toBe(false);
    expect(contents.includes('`<DragDropContext>`')).toBe(false);
  }
})",steel
/test/unit/docs/content.spec.js,Redundant Assertion,"{'column': 4, 'line': 28}","it('should end all nested docs with a link back to the documentation root', async () => {
  const files: string[] = await globby('docs/**/*.md');
  expect(files.length).toBeGreaterThan(0);
  const backLink: string =
    '[â† Back to documentation](/README.md#documentation-)';

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    // Printing a nice message to allow for quick fixing
    const endsWithBacklink: boolean = contents.trim().endsWith(backLink);

    if (!endsWithBacklink) {
      expect(`
        File: ""${file}""
        Did not end with back link
      `).toBe(true);
    }

    // need at least one assertion
    expect(true).toBe(true);
  }
})",steel
/test/unit/docs/content.spec.js,Resource Optimism,"{'line': 15, 'column': 35, 'index': 573}","it('should end all nested docs with a link back to the documentation root', async () => {
  const files: string[] = await globby('docs/**/*.md');
  expect(files.length).toBeGreaterThan(0);
  const backLink: string =
    '[â† Back to documentation](/README.md#documentation-)';

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    // Printing a nice message to allow for quick fixing
    const endsWithBacklink: boolean = contents.trim().endsWith(backLink);

    if (!endsWithBacklink) {
      expect(`
        File: ""${file}""
        Did not end with back link
      `).toBe(true);
    }

    // need at least one assertion
    expect(true).toBe(true);
  }
})",steel
/test/unit/docs/content.spec.js,Resource Optimism,"{'line': 37, 'column': 35, 'index': 1164}","it('should use correct wording', async () => {
  const files: string[] = await globby(['**/*.md', '!node_modules/']);
  expect(files.length).toBeGreaterThan(0);

  for (const file of files) {
    const contents: string = await fs.readFile(file, 'utf8');

    // Expected: <Draggable />, <Droppable />, `<DragDropContext />`
    expect(contents.includes('`Draggable`')).toBe(false);
    expect(contents.includes('`Droppable`')).toBe(false);
    expect(contents.includes('`DragDropContext`')).toBe(false);

    // not enough whitespace
    expect(contents.includes('`<Draggable/>`')).toBe(false);
    expect(contents.includes('`<Droppable/>`')).toBe(false);
    expect(contents.includes('`<DragDropContext/>`')).toBe(false);

    // not a self closing tag
    expect(contents.includes('`<Draggable>`')).toBe(false);
    expect(contents.includes('`<Droppable>`')).toBe(false);
    expect(contents.includes('`<DragDropContext>`')).toBe(false);
  }
})",steel
/cypress/integration/reorder.spec.js,Eager Test,"{'line': 13, 'column': 11, 'index': 347}","it('should reorder within a list', () => {
    // order: 1, 2
    cy.get(getHandleSelector()).eq(0).as('first').should('contain', 'id:1');
    cy.get(getHandleSelector()).eq(1).should('contain', 'id:2');

    // reorder operation
    cy.get('@first')
      .focus()
      .trigger('keydown', { keyCode: keyCodes.space })
      // need to re-query for a clone
      .get('@first')
      .trigger('keydown', { keyCode: keyCodes.arrowDown, force: true })
      // finishing before the movement time is fine - but this looks nice
      .wait(timings.outOfTheWay * 1000)
      .trigger('keydown', { keyCode: keyCodes.space, force: true });

    // order now 2, 1
    // note: not using get aliases as they where returning incorrect results
    cy.get(getHandleSelector()).eq(0).should('contain', 'id:2');

    cy.get(getHandleSelector()).eq(1).should('contain', 'id:1');

    // element should maintain focus post drag
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/reorder.spec.js,Eager Test,"{'line': 14, 'column': 11, 'index': 424}","it('should reorder within a list', () => {
    // order: 1, 2
    cy.get(getHandleSelector()).eq(0).as('first').should('contain', 'id:1');
    cy.get(getHandleSelector()).eq(1).should('contain', 'id:2');

    // reorder operation
    cy.get('@first')
      .focus()
      .trigger('keydown', { keyCode: keyCodes.space })
      // need to re-query for a clone
      .get('@first')
      .trigger('keydown', { keyCode: keyCodes.arrowDown, force: true })
      // finishing before the movement time is fine - but this looks nice
      .wait(timings.outOfTheWay * 1000)
      .trigger('keydown', { keyCode: keyCodes.space, force: true });

    // order now 2, 1
    // note: not using get aliases as they where returning incorrect results
    cy.get(getHandleSelector()).eq(0).should('contain', 'id:2');

    cy.get(getHandleSelector()).eq(1).should('contain', 'id:1');

    // element should maintain focus post drag
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/reorder.spec.js,Eager Test,"{'line': 29, 'column': 11, 'index': 1020}","it('should reorder within a list', () => {
    // order: 1, 2
    cy.get(getHandleSelector()).eq(0).as('first').should('contain', 'id:1');
    cy.get(getHandleSelector()).eq(1).should('contain', 'id:2');

    // reorder operation
    cy.get('@first')
      .focus()
      .trigger('keydown', { keyCode: keyCodes.space })
      // need to re-query for a clone
      .get('@first')
      .trigger('keydown', { keyCode: keyCodes.arrowDown, force: true })
      // finishing before the movement time is fine - but this looks nice
      .wait(timings.outOfTheWay * 1000)
      .trigger('keydown', { keyCode: keyCodes.space, force: true });

    // order now 2, 1
    // note: not using get aliases as they where returning incorrect results
    cy.get(getHandleSelector()).eq(0).should('contain', 'id:2');

    cy.get(getHandleSelector()).eq(1).should('contain', 'id:1');

    // element should maintain focus post drag
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/reorder.spec.js,Eager Test,"{'line': 31, 'column': 11, 'index': 1086}","it('should reorder within a list', () => {
    // order: 1, 2
    cy.get(getHandleSelector()).eq(0).as('first').should('contain', 'id:1');
    cy.get(getHandleSelector()).eq(1).should('contain', 'id:2');

    // reorder operation
    cy.get('@first')
      .focus()
      .trigger('keydown', { keyCode: keyCodes.space })
      // need to re-query for a clone
      .get('@first')
      .trigger('keydown', { keyCode: keyCodes.arrowDown, force: true })
      // finishing before the movement time is fine - but this looks nice
      .wait(timings.outOfTheWay * 1000)
      .trigger('keydown', { keyCode: keyCodes.space, force: true });

    // order now 2, 1
    // note: not using get aliases as they where returning incorrect results
    cy.get(getHandleSelector()).eq(0).should('contain', 'id:2');

    cy.get(getHandleSelector()).eq(1).should('contain', 'id:1');

    // element should maintain focus post drag
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/reorder-virtual.spec.js,Eager Test,"{'line': 14, 'column': 11, 'index': 371}","it('should reorder within a list', () => {
    const movements: number = 12;

    cy.get(getHandleSelector()).first().as('item');

    cy.get('@item').invoke('attr', 'data-testid').as('item-id');

    cy.get('@item')
      .invoke('attr', 'data-index')
      .as('item-index')
      .should('equal', '0');

    // lift
    cy.get('@item')
      .focus()
      .trigger('keydown', { keyCode: keyCodes.space })
      // need to re-query for a clone
      .get('@item');

    cy.wrap(Array.from({ length: movements })).each(() => {
      cy.get('@item')
        .trigger('keydown', { keyCode: keyCodes.arrowDown, force: true })
        // finishing before the movement time is fine - but this looks nice
        // waiting longer than we should (timings.outOfTheWay * 1000) as electron is being strange
        .wait(timings.outOfTheWay * 1000 * 2);
    });

    // drop
    cy.get('@item').trigger('keydown', {
      keyCode: keyCodes.space,
      force: true,
    });

    // This is setting up a chain of commands and this test will not wait
    // for a 'promise' to resolve. Linting is getting confused by .then
    // eslint-disable-next-line jest/valid-expect-in-promise
    cy.get('@item-id').then((id) => {
      cy.get(getHandleSelector(id))
        .invoke('attr', 'data-index')
        .should('equal', `${movements}`);
    });
  })",steel
/cypress/integration/reorder-virtual.spec.js,Eager Test,"{'line': 48, 'column': 13, 'index': 1508}","it('should reorder within a list', () => {
    const movements: number = 12;

    cy.get(getHandleSelector()).first().as('item');

    cy.get('@item').invoke('attr', 'data-testid').as('item-id');

    cy.get('@item')
      .invoke('attr', 'data-index')
      .as('item-index')
      .should('equal', '0');

    // lift
    cy.get('@item')
      .focus()
      .trigger('keydown', { keyCode: keyCodes.space })
      // need to re-query for a clone
      .get('@item');

    cy.wrap(Array.from({ length: movements })).each(() => {
      cy.get('@item')
        .trigger('keydown', { keyCode: keyCodes.arrowDown, force: true })
        // finishing before the movement time is fine - but this looks nice
        // waiting longer than we should (timings.outOfTheWay * 1000) as electron is being strange
        .wait(timings.outOfTheWay * 1000 * 2);
    });

    // drop
    cy.get('@item').trigger('keydown', {
      keyCode: keyCodes.space,
      force: true,
    });

    // This is setting up a chain of commands and this test will not wait
    // for a 'promise' to resolve. Linting is getting confused by .then
    // eslint-disable-next-line jest/valid-expect-in-promise
    cy.get('@item-id').then((id) => {
      cy.get(getHandleSelector(id))
        .invoke('attr', 'data-index')
        .should('equal', `${movements}`);
    });
  })",steel
/cypress/integration/move-between-lists.spec.js,Eager Test,"{'line': 13, 'column': 11, 'index': 381}","it('should move between lists', () => {
    // first list has item with id:2
    cy.get(getDroppableSelector())
      .eq(1)
      .as('first-list')
      .should('contain', 'id:2');

    // second list does not have item with id:2
    cy.get(getDroppableSelector())
      .eq(2)
      .as('second-list')
      .should('not.contain', 'id:2');

    cy.get('@first-list')
      .find(getHandleSelector())
      .first()
      .should('contain', 'id:2')
      .focus()
      .trigger('keydown', { keyCode: keyCodes.space })
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // finishing before the movement time is fine - but this looks nice
      .wait(timings.outOfTheWay * 1000)
      .trigger('keydown', { keyCode: keyCodes.space, force: true });

    // no longer in the first list
    cy.get('@first-list').should('not.contain', 'id:2');

    // now in the second list
    cy.get('@second-list').should('contain', 'id:2');
  })",steel
/cypress/integration/move-between-lists.spec.js,Eager Test,"{'line': 19, 'column': 11, 'index': 536}","it('should move between lists', () => {
    // first list has item with id:2
    cy.get(getDroppableSelector())
      .eq(1)
      .as('first-list')
      .should('contain', 'id:2');

    // second list does not have item with id:2
    cy.get(getDroppableSelector())
      .eq(2)
      .as('second-list')
      .should('not.contain', 'id:2');

    cy.get('@first-list')
      .find(getHandleSelector())
      .first()
      .should('contain', 'id:2')
      .focus()
      .trigger('keydown', { keyCode: keyCodes.space })
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // finishing before the movement time is fine - but this looks nice
      .wait(timings.outOfTheWay * 1000)
      .trigger('keydown', { keyCode: keyCodes.space, force: true });

    // no longer in the first list
    cy.get('@first-list').should('not.contain', 'id:2');

    // now in the second list
    cy.get('@second-list').should('contain', 'id:2');
  })",steel
/cypress/integration/move-between-lists.spec.js,Eager Test,"{'line': 25, 'column': 12, 'index': 675}","it('should move between lists', () => {
    // first list has item with id:2
    cy.get(getDroppableSelector())
      .eq(1)
      .as('first-list')
      .should('contain', 'id:2');

    // second list does not have item with id:2
    cy.get(getDroppableSelector())
      .eq(2)
      .as('second-list')
      .should('not.contain', 'id:2');

    cy.get('@first-list')
      .find(getHandleSelector())
      .first()
      .should('contain', 'id:2')
      .focus()
      .trigger('keydown', { keyCode: keyCodes.space })
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // finishing before the movement time is fine - but this looks nice
      .wait(timings.outOfTheWay * 1000)
      .trigger('keydown', { keyCode: keyCodes.space, force: true });

    // no longer in the first list
    cy.get('@first-list').should('not.contain', 'id:2');

    // now in the second list
    cy.get('@second-list').should('contain', 'id:2');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 9, 'column': 11, 'index': 333}","it('should not steal focus if not already focused when lifting', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('1')).focus();
    cy.focused().should('contain', 'id:1');

    cy.get(getHandleSelector('2'))
      .as('id:2')
      .trigger('mousedown', { button: 0 })
      .trigger('mousemove', {
        button: 0,
        clientX: 200,
        clientY: 300,
        force: true,
      });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:1');

    cy.get(getHandleSelector('2'))
      .trigger('mouseup', { force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'false',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 12, 'column': 11, 'index': 422}","it('should not steal focus if not already focused when lifting', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('1')).focus();
    cy.focused().should('contain', 'id:1');

    cy.get(getHandleSelector('2'))
      .as('id:2')
      .trigger('mousedown', { button: 0 })
      .trigger('mousemove', {
        button: 0,
        clientX: 200,
        clientY: 300,
        force: true,
      });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:1');

    cy.get(getHandleSelector('2'))
      .trigger('mouseup', { force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'false',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 23, 'column': 11, 'index': 681}","it('should not steal focus if not already focused when lifting', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('1')).focus();
    cy.focused().should('contain', 'id:1');

    cy.get(getHandleSelector('2'))
      .as('id:2')
      .trigger('mousedown', { button: 0 })
      .trigger('mousemove', {
        button: 0,
        clientX: 200,
        clientY: 300,
        force: true,
      });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:1');

    cy.get(getHandleSelector('2'))
      .trigger('mouseup', { force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'false',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 32, 'column': 11, 'index': 860}","it('should not steal focus if not already focused when lifting', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('1')).focus();
    cy.focused().should('contain', 'id:1');

    cy.get(getHandleSelector('2'))
      .as('id:2')
      .trigger('mousedown', { button: 0 })
      .trigger('mousemove', {
        button: 0,
        clientX: 200,
        clientY: 300,
        force: true,
      });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:1');

    cy.get(getHandleSelector('2'))
      .trigger('mouseup', { force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'false',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 38, 'column': 11, 'index': 1046}","it('should not steal focus if not already focused when lifting', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('1')).focus();
    cy.focused().should('contain', 'id:1');

    cy.get(getHandleSelector('2'))
      .as('id:2')
      .trigger('mousedown', { button: 0 })
      .trigger('mousemove', {
        button: 0,
        clientX: 200,
        clientY: 300,
        force: true,
      });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:1');

    cy.get(getHandleSelector('2'))
      .trigger('mouseup', { force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'false',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 51, 'column': 11, 'index': 1381}","it('should maintain focus if dragging a clone', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2'))
      // no longer dragging
      .should('have.attr', 'data-is-dragging', 'false')
      // is in the second column (normally would loose focus moving between lists)
      .closest(getDraggableSelector('BMO'));

    // focus maintained
    cy.focused().should('contain', 'id:2');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 54, 'column': 11, 'index': 1470}","it('should maintain focus if dragging a clone', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2'))
      // no longer dragging
      .should('have.attr', 'data-is-dragging', 'false')
      // is in the second column (normally would loose focus moving between lists)
      .closest(getDraggableSelector('BMO'));

    // focus maintained
    cy.focused().should('contain', 'id:2');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 59, 'column': 11, 'index': 1604}","it('should maintain focus if dragging a clone', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2'))
      // no longer dragging
      .should('have.attr', 'data-is-dragging', 'false')
      // is in the second column (normally would loose focus moving between lists)
      .closest(getDraggableSelector('BMO'));

    // focus maintained
    cy.focused().should('contain', 'id:2');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 68, 'column': 11, 'index': 1783}","it('should maintain focus if dragging a clone', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2'))
      // no longer dragging
      .should('have.attr', 'data-is-dragging', 'false')
      // is in the second column (normally would loose focus moving between lists)
      .closest(getDraggableSelector('BMO'));

    // focus maintained
    cy.focused().should('contain', 'id:2');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 75, 'column': 11, 'index': 2067}","it('should maintain focus if dragging a clone', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2'))
      // no longer dragging
      .should('have.attr', 'data-is-dragging', 'false')
      // is in the second column (normally would loose focus moving between lists)
      .closest(getDraggableSelector('BMO'));

    // focus maintained
    cy.focused().should('contain', 'id:2');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 79, 'column': 15, 'index': 2273}","it('should maintain focus if dragging a clone', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2'))
      // no longer dragging
      .should('have.attr', 'data-is-dragging', 'false')
      // is in the second column (normally would loose focus moving between lists)
      .closest(getDraggableSelector('BMO'));

    // focus maintained
    cy.focused().should('contain', 'id:2');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 87, 'column': 11, 'index': 2511}","it('should give focus to a combine target', () => {
    cy.visit('/iframe.html?id=board--with-combining-and-cloning');
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // combining with item:1
      .trigger('keydown', { keyCode: keyCodes.arrowUp, force: true })
      // dropping
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // focus giving to item:1 the combine target
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 90, 'column': 11, 'index': 2600}","it('should give focus to a combine target', () => {
    cy.visit('/iframe.html?id=board--with-combining-and-cloning');
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // combining with item:1
      .trigger('keydown', { keyCode: keyCodes.arrowUp, force: true })
      // dropping
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // focus giving to item:1 the combine target
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 95, 'column': 11, 'index': 2734}","it('should give focus to a combine target', () => {
    cy.visit('/iframe.html?id=board--with-combining-and-cloning');
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // combining with item:1
      .trigger('keydown', { keyCode: keyCodes.arrowUp, force: true })
      // dropping
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // focus giving to item:1 the combine target
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 104, 'column': 11, 'index': 2913}","it('should give focus to a combine target', () => {
    cy.visit('/iframe.html?id=board--with-combining-and-cloning');
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // combining with item:1
      .trigger('keydown', { keyCode: keyCodes.arrowUp, force: true })
      // dropping
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // focus giving to item:1 the combine target
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 120, 'column': 11, 'index': 3605}","it('should not give focus to a combine target if source did not have focus at start of drag', () => {
    cy.visit('/iframe.html?id=board--with-combining-and-cloning');
    // focusing on something unrelated to the drag
    cy.get(getHandleSelector('3')).focus();

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:3');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // combining with item:1
      .trigger('keydown', { keyCode: keyCodes.arrowUp, force: true })
      // dropping
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // focus not given to the combine target
    cy.focused().should('contain', 'id:3');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 122, 'column': 11, 'index': 3650}","it('should not give focus to a combine target if source did not have focus at start of drag', () => {
    cy.visit('/iframe.html?id=board--with-combining-and-cloning');
    // focusing on something unrelated to the drag
    cy.get(getHandleSelector('3')).focus();

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:3');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // combining with item:1
      .trigger('keydown', { keyCode: keyCodes.arrowUp, force: true })
      // dropping
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // focus not given to the combine target
    cy.focused().should('contain', 'id:3');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 127, 'column': 11, 'index': 3784}","it('should not give focus to a combine target if source did not have focus at start of drag', () => {
    cy.visit('/iframe.html?id=board--with-combining-and-cloning');
    // focusing on something unrelated to the drag
    cy.get(getHandleSelector('3')).focus();

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:3');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // combining with item:1
      .trigger('keydown', { keyCode: keyCodes.arrowUp, force: true })
      // dropping
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // focus not given to the combine target
    cy.focused().should('contain', 'id:3');
  })",steel
/cypress/integration/focus.spec.js,Eager Test,"{'line': 136, 'column': 11, 'index': 3963}","it('should not give focus to a combine target if source did not have focus at start of drag', () => {
    cy.visit('/iframe.html?id=board--with-combining-and-cloning');
    // focusing on something unrelated to the drag
    cy.get(getHandleSelector('3')).focus();

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:3');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // combining with item:1
      .trigger('keydown', { keyCode: keyCodes.arrowUp, force: true })
      // dropping
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // focus not given to the combine target
    cy.focused().should('contain', 'id:3');
  })",steel
/cypress/integration/focus.spec.js,Lazy Test,"{'line': 9, 'column': 11, 'index': 333}","it('should not steal focus if not already focused when lifting', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('1')).focus();
    cy.focused().should('contain', 'id:1');

    cy.get(getHandleSelector('2'))
      .as('id:2')
      .trigger('mousedown', { button: 0 })
      .trigger('mousemove', {
        button: 0,
        clientX: 200,
        clientY: 300,
        force: true,
      });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:1');

    cy.get(getHandleSelector('2'))
      .trigger('mouseup', { force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'false',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/focus.spec.js,Lazy Test,"{'line': 51, 'column': 11, 'index': 1381}","it('should maintain focus if dragging a clone', () => {
    cy.visit('/iframe.html?id=board--dragging-a-clone');
    // focusing on another handle
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // getting post clone handle
    cy.get(getHandleSelector('2'))
      // no longer dragging
      .should('have.attr', 'data-is-dragging', 'false')
      // is in the second column (normally would loose focus moving between lists)
      .closest(getDraggableSelector('BMO'));

    // focus maintained
    cy.focused().should('contain', 'id:2');
  })",steel
/cypress/integration/focus.spec.js,Lazy Test,"{'line': 87, 'column': 11, 'index': 2511}","it('should give focus to a combine target', () => {
    cy.visit('/iframe.html?id=board--with-combining-and-cloning');
    cy.get(getHandleSelector('2')).focus();
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus maintained
    cy.focused().should('contain', 'id:2');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // combining with item:1
      .trigger('keydown', { keyCode: keyCodes.arrowUp, force: true })
      // dropping
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // focus giving to item:1 the combine target
    cy.focused().should('contain', 'id:1');
  })",steel
/cypress/integration/focus.spec.js,Lazy Test,"{'line': 120, 'column': 11, 'index': 3605}","it('should not give focus to a combine target if source did not have focus at start of drag', () => {
    cy.visit('/iframe.html?id=board--with-combining-and-cloning');
    // focusing on something unrelated to the drag
    cy.get(getHandleSelector('3')).focus();

    cy.get(getHandleSelector('2')).trigger('keydown', {
      keyCode: keyCodes.space,
    });

    // asserting id:2 is now dragging
    cy.get(getHandleSelector('2')).should(
      'have.attr',
      'data-is-dragging',
      'true',
    );

    // focus not stolen
    cy.focused().should('contain', 'id:3');

    cy.get(getHandleSelector('2'))
      .trigger('keydown', { keyCode: keyCodes.arrowRight, force: true })
      // combining with item:1
      .trigger('keydown', { keyCode: keyCodes.arrowUp, force: true })
      // dropping
      .trigger('keydown', { keyCode: keyCodes.space, force: true })
      // clone will be unmounting during drop
      .should('not.exist');

    // focus not given to the combine target
    cy.focused().should('contain', 'id:3');
  })",steel
/cypress/integration/content-security-policy.spec.js,Unknown Test,"{'column': 2, 'line': 37}","it('should reorder a list without a nonce', () => {
    commonTest(`http://localhost:${ports.cspServer}`, 'contain');
  })",steel
/cypress/integration/content-security-policy.spec.js,Unknown Test,"{'column': 2, 'line': 41}","it('should reorder a list with a nonce', () => {
    commonTest(`http://localhost:${ports.cspServer}/nonce`, 'contain');
  })",steel
/cypress/integration/content-security-policy.spec.js,Unknown Test,"{'column': 2, 'line': 45}","it('should reorder a list with a wrong nonce', () => {
    commonTest(
      `http://localhost:${ports.cspServer}/wrong-nonce`,
      'not.contain',
    );
  })",steel
