file,type,line,method,source
/test/Model.spec.js,IdenticalTestDescription,"{'startLine':483,'endLine':493}","it(""accepts boolean to disable"", () => {
                let model = new Model({ disableRequestDeduplication: true });
                expect(model._enableRequestDeduplication).toBe(false);

                for (let index = 0; index < notTrue.length; index++) {
                    model = new Model({
                        disableRequestDeduplication: notTrue[index],
                    });
                    expect(model._enableRequestDeduplication).toBe(true);
                }
            })",snuts
/test/Model.spec.js,IdenticalTestDescription,"{'startLine':495,'endLine':501}","it(""is enabled by default"", () => {
                let model = new Model();
                expect(model._enableRequestDeduplication).toBe(true);

                model = new Model({});
                expect(model._enableRequestDeduplication).toBe(true);
            })",snuts
/test/Model.spec.js,IdenticalTestDescription,"{'startLine':503,'endLine':510}","it(""is copied on clone"", () => {
                const model = new Model({ disableRequestDeduplication: true });
                const clone = model._clone();

                expect(clone._enableRequestDeduplication).toBe(
                    model._enableRequestDeduplication
                );
            })",snuts
/test/Model.spec.js,ConditionalTestLogic,"{'startLine':116,'endLine':122}","it(""unsubscribing should cancel DataSource request."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        subscription.dispose();

        if (
            dataSourceGetCalled === 1 &&
            !onNextCalled &&
            unusubscribeCalled === 1 &&
            !onErrorCalled &&
            !onCompletedCalled
        ) {
            done();
        } else {
            done(new Error(""DataSource unsubscribe not called.""));
        }
    })",snuts
/test/Model.spec.js,ConditionalTestLogic,"{'startLine':151,'endLine':161}","it(""unsubscribing should cancel DataSource request."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        subscription.dispose();

        if (
            dataSourceGetCalled === 1 &&
            !onNextCalled &&
            unusubscribeCalled === 1 &&
            !onErrorCalled &&
            !onCompletedCalled
        ) {
            done();
        } else {
            done(new Error(""DataSource unsubscribe not called.""));
        }
    })",snuts
/test/Model.spec.js,ConditionalTestLogic,"{'startLine':194,'endLine':200}","it(""unsubscribing should dispose batched DataSource request."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;
        let onDataSourceGet, onDisposedOrCompleted;

        let model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                onDataSourceGet && onDataSourceGet();
                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }

                                onDisposedOrCompleted &&
                                    onDisposedOrCompleted();
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });
        model = model.batch();

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        onDataSourceGet = function () {
            subscription.dispose();
        };

        onDisposedOrCompleted = function () {
            if (
                dataSourceGetCalled === 1 &&
                !onNextCalled &&
                unusubscribeCalled === 1 &&
                !onErrorCalled &&
                !onCompletedCalled
            ) {
                done();
            } else {
                done(new Error(""DataSource dispose not called.""));
            }
        };
    })",snuts
/test/Model.spec.js,ConditionalTestLogic,"{'startLine':236,'endLine':246}","it(""unsubscribing should dispose batched DataSource request."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;
        let onDataSourceGet, onDisposedOrCompleted;

        let model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                onDataSourceGet && onDataSourceGet();
                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }

                                onDisposedOrCompleted &&
                                    onDisposedOrCompleted();
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });
        model = model.batch();

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        onDataSourceGet = function () {
            subscription.dispose();
        };

        onDisposedOrCompleted = function () {
            if (
                dataSourceGetCalled === 1 &&
                !onNextCalled &&
                unusubscribeCalled === 1 &&
                !onErrorCalled &&
                !onCompletedCalled
            ) {
                done();
            } else {
                done(new Error(""DataSource dispose not called.""));
            }
        };
    })",snuts
/test/Model.spec.js,ConditionalTestLogic,"{'startLine':280,'endLine':286}","it('unsubscribing should ""unsubscribe"" batched DataSource request, if applicable.', (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;
        let onDataSourceGet, onDisposedOrCompleted;

        let model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                onDataSourceGet && onDataSourceGet();
                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }

                                onDisposedOrCompleted &&
                                    onDisposedOrCompleted();
                            });

                            return {
                                unsubscribe() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });
        model = model.batch();

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        onDataSourceGet = function () {
            subscription.dispose();
        };

        onDisposedOrCompleted = function () {
            if (
                dataSourceGetCalled === 1 &&
                !onNextCalled &&
                unusubscribeCalled === 1 &&
                !onErrorCalled &&
                !onCompletedCalled
            ) {
                done();
            } else {
                done(new Error(""DataSource unsubscribe not called.""));
            }
        };
    })",snuts
/test/Model.spec.js,ConditionalTestLogic,"{'startLine':322,'endLine':332}","it('unsubscribing should ""unsubscribe"" batched DataSource request, if applicable.', (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;
        let onDataSourceGet, onDisposedOrCompleted;

        let model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                onDataSourceGet && onDataSourceGet();
                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }

                                onDisposedOrCompleted &&
                                    onDisposedOrCompleted();
                            });

                            return {
                                unsubscribe() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });
        model = model.batch();

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        onDataSourceGet = function () {
            subscription.dispose();
        };

        onDisposedOrCompleted = function () {
            if (
                dataSourceGetCalled === 1 &&
                !onNextCalled &&
                unusubscribeCalled === 1 &&
                !onErrorCalled &&
                !onCompletedCalled
            ) {
                done();
            } else {
                done(new Error(""DataSource unsubscribe not called.""));
            }
        };
    })",snuts
/test/Model.spec.js,ConditionalTestLogic,"{'startLine':364,'endLine':370}","it(""Supports RxJS 5."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });

        const subscription = rxjs.Observable.from(
            model.get(""list[0,1].name"")
        ).subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        subscription.unsubscribe();

        if (
            dataSourceGetCalled === 1 &&
            !onNextCalled &&
            unusubscribeCalled === 1 &&
            !onErrorCalled &&
            !onCompletedCalled
        ) {
            done();
        } else {
            done(new Error(""DataSource unsubscribe not called.""));
        }
    })",snuts
/test/Model.spec.js,ConditionalTestLogic,"{'startLine':401,'endLine':411}","it(""Supports RxJS 5."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });

        const subscription = rxjs.Observable.from(
            model.get(""list[0,1].name"")
        ).subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        subscription.unsubscribe();

        if (
            dataSourceGetCalled === 1 &&
            !onNextCalled &&
            unusubscribeCalled === 1 &&
            !onErrorCalled &&
            !onCompletedCalled
        ) {
            done();
        } else {
            done(new Error(""DataSource unsubscribe not called.""));
        }
    })",snuts
/test/Model.spec.js,NonFunctionalStatement,"{'startLine':518,'endLine':518}","it(""should throw an error on invalid input when calling Model:get"", (done) => {
            const model = new Model();
            model.get('{""foobar"":[]}').subscribe(
                () => {},
                (e) => {
                    expect(e).toBeInstanceOf(Error);
                    expect(e.message).toMatchInlineSnapshot(
                        `""Path syntax validation error -- Unexpected token. -- {\\""""`
                    );
                    done();
                },
                () => {
                    done(
                        new Error(
                            ""Did not receive an error when one was expected""
                        )
                    );
                }
            );
        })",snuts
/test/Model.spec.js,NonFunctionalStatement,"{'startLine':539,'endLine':539}","it(""should throw an error on invalid input when calling Model:set"", (done) => {
            const model = new Model();
            model.set({ path: '{""foobar"":[]}' }).subscribe(
                () => {},
                (e) => {
                    expect(e).toBeInstanceOf(Error);
                    expect(e.message).toMatchInlineSnapshot(
                        `""Path syntax validation error -- Unexpected token. -- {\\""""`
                    );
                    done();
                },
                () => {
                    done(
                        new Error(
                            ""Did not receive an error when one was expected""
                        )
                    );
                }
            );
        })",snuts
/test/Model.spec.js,SubOptimalAssert,"{'startLine':68,'endLine':68}","it(""should construct a new Model when calling the falcor module function"", () => {
        expect(falcor() instanceof falcor.Model).toBe(true);
    })",snuts
/test/response/ModelResponseObserver.spec.js,NonFunctionalStatement,"{'startLine':68,'endLine':68}","it(
        ""should call onError callback max 1 time when no matter how many times onError is called on ModelResponseObserver"",
        function() {
            var onErrorValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function(e) {
                    onErrorValues.push(e);
                }
            );
            modelResponseObserver.onError(1);
            modelResponseObserver.onError(2);

            expect(onErrorValues.length).toBe(1);
            expect(onErrorValues[0]).toBe(1);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,NonFunctionalStatement,"{'startLine':86,'endLine':86}","it(
        ""should call onCompleted callback max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function() {},
                function(value) {
                    onCompletedValues.push(value);
                }
            );
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,NonFunctionalStatement,"{'startLine':87,'endLine':87}","it(
        ""should call onCompleted callback max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function() {},
                function(value) {
                    onCompletedValues.push(value);
                }
            );
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,NonFunctionalStatement,"{'startLine':152,'endLine':152}","it(
        ""should call onError method max 1 time when no matter how many times onError is called on ModelResponseObserver"",
        function() {
            var onErrorValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function(e) {
                    onErrorValues.push(e);
                }
            });
            modelResponseObserver.onError(1);
            modelResponseObserver.onError(2);

            expect(onErrorValues.length).toBe(1);
            expect(onErrorValues[0]).toBe(1);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,NonFunctionalStatement,"{'startLine':170,'endLine':170}","it(
        ""should call onCompleted method max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function() {},
                onCompleted: function(value) {
                    onCompletedValues.push(value);
                }
            });
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,NonFunctionalStatement,"{'startLine':171,'endLine':171}","it(
        ""should call onCompleted method max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function() {},
                onCompleted: function(value) {
                    onCompletedValues.push(value);
                }
            });
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,SubOptimalAssert,"{'startLine':43,'endLine':43}","it(
        ""should suppress onNext callback after ModelResponseObserver is onCompleted"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver(function(
                value
            ) {
                onNextValue = value;
            });
            modelResponseObserver.onCompleted();
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(undefined);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,SubOptimalAssert,"{'startLine':59,'endLine':59}","it(
        ""should suppress onNext callback after ModelResponseObserver is onError'ed"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver(function(
                value
            ) {
                onNextValue = value;
            });
            modelResponseObserver.onError();
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(undefined);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,SubOptimalAssert,"{'startLine':76,'endLine':76}","it(
        ""should call onError callback max 1 time when no matter how many times onError is called on ModelResponseObserver"",
        function() {
            var onErrorValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function(e) {
                    onErrorValues.push(e);
                }
            );
            modelResponseObserver.onError(1);
            modelResponseObserver.onError(2);

            expect(onErrorValues.length).toBe(1);
            expect(onErrorValues[0]).toBe(1);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,SubOptimalAssert,"{'startLine':95,'endLine':95}","it(
        ""should call onCompleted callback max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function() {},
                function(value) {
                    onCompletedValues.push(value);
                }
            );
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,SubOptimalAssert,"{'startLine':96,'endLine':96}","it(
        ""should call onCompleted callback max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function() {},
                function(value) {
                    onCompletedValues.push(value);
                }
            );
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,SubOptimalAssert,"{'startLine':127,'endLine':127}","it(
        ""should suppress onNext method after ModelResponseObserver is onCompleted"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function(value) {
                    onNextValue = value;
                }
            });
            modelResponseObserver.onCompleted();
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(undefined);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,SubOptimalAssert,"{'startLine':143,'endLine':143}","it(
        ""should suppress onNext method after ModelResponseObserver is onError'ed"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function(value) {
                    onNextValue = value;
                }
            });
            modelResponseObserver.onError();
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(undefined);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,SubOptimalAssert,"{'startLine':160,'endLine':160}","it(
        ""should call onError method max 1 time when no matter how many times onError is called on ModelResponseObserver"",
        function() {
            var onErrorValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function(e) {
                    onErrorValues.push(e);
                }
            });
            modelResponseObserver.onError(1);
            modelResponseObserver.onError(2);

            expect(onErrorValues.length).toBe(1);
            expect(onErrorValues[0]).toBe(1);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,SubOptimalAssert,"{'startLine':179,'endLine':179}","it(
        ""should call onCompleted method max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function() {},
                onCompleted: function(value) {
                    onCompletedValues.push(value);
                }
            });
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",snuts
/test/response/ModelResponseObserver.spec.js,SubOptimalAssert,"{'startLine':180,'endLine':180}","it(
        ""should call onCompleted method max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function() {},
                onCompleted: function(value) {
                    onCompletedValues.push(value);
                }
            });
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",snuts
/test/lru/lru.splice.overwrite.spec.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/test/lru/lru.splice.expired.spec.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/test/lru/lru.promote.set.spec.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/test/lru/lru.promote.set.spec.js,VerboseStatement,"{'startLine':182,'endLine':229}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",snuts
/test/lru/lru.promote.get.spec.js,IdenticalTestDescription,"{'startLine':81,'endLine':104}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",snuts
/test/lru/lru.promote.get.spec.js,IdenticalTestDescription,"{'startLine':105,'endLine':128}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",snuts
/test/lru/lru.promote.get.spec.js,IdenticalTestDescription,"{'startLine':130,'endLine':172}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",snuts
/test/lru/lru.promote.get.spec.js,SubOptimalAssert,"{'startLine':98,'endLine':98}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",snuts
/test/lru/lru.promote.get.spec.js,SubOptimalAssert,"{'startLine':103,'endLine':103}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",snuts
/test/lru/lru.promote.get.spec.js,SubOptimalAssert,"{'startLine':122,'endLine':122}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",snuts
/test/lru/lru.promote.get.spec.js,SubOptimalAssert,"{'startLine':127,'endLine':127}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",snuts
/test/lru/lru.promote.get.spec.js,VerboseStatement,"{'startLine':36,'endLine':78}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",snuts
/test/lru/lru.promote.get.spec.js,VerboseStatement,"{'startLine':81,'endLine':104}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",snuts
/test/lru/lru.promote.get.spec.js,VerboseStatement,"{'startLine':105,'endLine':128}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",snuts
/test/lru/lru.promote.get.spec.js,VerboseStatement,"{'startLine':130,'endLine':172}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",snuts
/test/invalidate/pathSets.spec.js,AnonymousTest,"{'startLine':13,'endLine':30}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",snuts
/test/invalidate/pathSets.spec.js,AnonymousTest,"{'startLine':146,'endLine':165}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",snuts
/test/invalidate/pathSets.spec.js,AnonymousTest,"{'startLine':201,'endLine':233}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",snuts
/test/invalidate/pathSets.spec.js,AnonymousTest,"{'startLine':234,'endLine':264}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",snuts
/test/invalidate/pathSets.spec.js,AnonymousTest,"{'startLine':265,'endLine':297}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",snuts
/test/invalidate/pathSets.spec.js,AnonymousTest,"{'startLine':298,'endLine':328}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",snuts
/test/invalidate/pathSets.spec.js,AnonymousTest,"{'startLine':329,'endLine':361}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",snuts
/test/invalidate/pathSets.spec.js,IdenticalTestDescription,"{'startLine':146,'endLine':165}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",snuts
/test/invalidate/pathMaps.spec.js,AnonymousTest,"{'startLine':13,'endLine':30}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",snuts
/test/invalidate/pathMaps.spec.js,AnonymousTest,"{'startLine':146,'endLine':165}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",snuts
/test/invalidate/pathMaps.spec.js,AnonymousTest,"{'startLine':201,'endLine':233}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",snuts
/test/invalidate/pathMaps.spec.js,AnonymousTest,"{'startLine':234,'endLine':264}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",snuts
/test/invalidate/pathMaps.spec.js,AnonymousTest,"{'startLine':265,'endLine':297}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",snuts
/test/invalidate/pathMaps.spec.js,AnonymousTest,"{'startLine':298,'endLine':328}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",snuts
/test/invalidate/pathMaps.spec.js,AnonymousTest,"{'startLine':329,'endLine':361}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",snuts
/test/invalidate/pathMaps.spec.js,IdenticalTestDescription,"{'startLine':146,'endLine':165}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",snuts
/test/invalidate/invalidate.spec.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/test/set/edge-cases.spec.js,ConditionalTestLogic,"{'startLine':98,'endLine':100}","it(""set blows away the cache."", function() {
        var model = new Model({});
        var get = [[""genreList"", 1, 0, ""summary""]];

        // this mimicks the server setting cycle from the router.
        var set = [
            {
                jsonGraph: {""genreList"": {
                    ""0"": { ""$type"": $path, ""value"": [""lists"", ""abcd""] },
                    ""1"": { ""$type"": $path, ""value"": [""lists"", ""my-list""] }
                }},
                paths: [['genreList', {to:1}, 0, 'summary']]
            },
            {
                jsonGraph: {""lists"": {
                    ""abcd"": { ""0"": { ""$type"": $path, ""value"": [""videos"", 1234] } },
                    ""my-list"": { ""$type"": $path, ""value"": [""lists"", ""1x5x""] }
                }},
                paths: [[""genreList"", 1, 0, ""summary""]]
            },
            {
                jsonGraph: {""lists"": {""1x5x"": {
                    ""0"": { ""$type"": $path, ""value"": [""videos"", 553] }
                }}},
                paths: [[""genreList"", 1, 0, ""summary""]]
            },
            {
                jsonGraph: {""videos"": {""553"": {""summary"": {
                    ""$size"": 10,
                    ""$type"": $atom,
                    ""value"": {
                        ""title"": ""Running Man"",
                        ""url"": ""/movies/553""
                    }
                }}}},
                paths: [[""genreList"", 1, 0, ""summary""]]
            }
        ];

        set.forEach(function(s, i) {
            model._setJSONGs(model, [s]);
            if (i === 2) {
                expect(model._root.cache.lists).toBeDefined();
            }
        });

        model._getPathValuesAsPathMap(model, get, function(x) {
            expect(x).toEqual({ json: { genreList: { 1: { 0: { summary: {
                    ""title"": ""Running Man"",
                    ""url"": ""/movies/553""
                } } } } }
            });
        });
    })",snuts
/test/set/edge-cases.spec.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/test/integration/get.spec.js,GeneralFixture,"{'startLine':15,'endLine':15}","beforeEach(function(done) {
        app = express();
        server = app.listen(60002, done);
        serverUrl = 'http://localhost:60002';
        model = new falcor.Model({
            source: new falcor.HttpDataSource(serverUrl + '/model.json')
        });
        onNext = jest.fn();
    })",snuts
/test/integration/get.spec.js,GeneralFixture,"{'startLine':16,'endLine':16}","beforeEach(function(done) {
        app = express();
        server = app.listen(60002, done);
        serverUrl = 'http://localhost:60002';
        model = new falcor.Model({
            source: new falcor.HttpDataSource(serverUrl + '/model.json')
        });
        onNext = jest.fn();
    })",snuts
/test/integration/get.spec.js,GeneralFixture,"{'startLine':17,'endLine':17}","beforeEach(function(done) {
        app = express();
        server = app.listen(60002, done);
        serverUrl = 'http://localhost:60002';
        model = new falcor.Model({
            source: new falcor.HttpDataSource(serverUrl + '/model.json')
        });
        onNext = jest.fn();
    })",snuts
/test/integration/get.spec.js,NonFunctionalStatement,"{'startLine':8,'endLine':8}",Unknown,snuts
/test/integration/express.spec.js,GeneralFixture,"{'startLine':33,'endLine':33}","beforeEach(function(done) {
        var app = express();
        app.use(bodyParser.urlencoded({ extended: false }));

        // Simple middleware to handle get/post
        app.use('/model.json', FalcorServer.dataSourceRoute(function(req, res) {
            return new FalcorRouter([
                {
                    // match a request for the key ""greeting""
                    route: ""greeting"",
                    // respond with a PathValue with the value of ""Hello World.""
                    get: function() {
                        return {path:[""greeting""], value: ""Hello World""};
                    }
                }
            ]);
        }));

        server = app.listen(60001, done);
    })",snuts
/test/integration/express.spec.js,NonFunctionalStatement,"{'startLine':9,'endLine':9}",Unknown,snuts
/test/integration/dedupe.spec.js,AnonymousTest,"{'startLine':71,'endLine':80}","it(""using ranges"", done => {
            const partDone = after(2, () => {
                expect(onGet.mock.calls[1][1]).toEqual([[""things"", [0, 3]]]);

                done();
            });

            model.get([""things"", { from: 1, to: 2 }]).subscribe(noOp, done, partDone);
            model.get([""things"", { from: 0, to: 3 }]).subscribe(noOp, done, partDone);
        })",snuts
/test/integration/dedupe.spec.js,AnonymousTest,"{'startLine':82,'endLine':91}","it(""using arrays"", done => {
            const partDone = after(2, () => {
                expect(onGet.mock.calls[1][1]).toEqual([[""things"", [0, 5]]]);

                done();
            });

            model.get([""things"", [2, 4]]).subscribe(noOp, done, partDone);
            model.get([""things"", [0, 4, 5]]).subscribe(noOp, done, partDone);
        })",snuts
/test/integration/dedupe.spec.js,NonFunctionalStatement,"{'startLine':7,'endLine':7}",Unknown,snuts
/test/integration/call.spec.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/test/hardlink/hardlink.remove.spec.js,IdenticalTestDescription,"{'startLine':43,'endLine':49}","it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                flatMap(function() {
                    return setTest(setJSON, '_toJSONG');
                }).
                subscribe(noOp, done, done);
        })",snuts
/test/hardlink/hardlink.remove.spec.js,IdenticalTestDescription,"{'startLine':50,'endLine':56}","it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                flatMap(function() {
                    return setTest(setJSON, 'toJSON');
                }).
                subscribe(noOp, done, done);
        })",snuts
/test/hardlink/hardlink.remove.spec.js,NonFunctionalStatement,"{'startLine':13,'endLine':13}",Unknown,snuts
/test/hardlink/hardlink.add.spec.js,IdenticalTestDescription,"{'startLine':37,'endLine':40}","it('should perform a hard-link with back references _toJSONG.', function(done) {
            setTest(setPath, '_toJSONG').
                subscribe(noOp, done, done);
        })",snuts
/test/hardlink/hardlink.add.spec.js,IdenticalTestDescription,"{'startLine':41,'endLine':44}","it('should perform a hard-link with back references toJSON.', function(done) {
            setTest(setPath, 'toJSON').
                subscribe(noOp, done, done);
        })",snuts
/test/hardlink/hardlink.add.spec.js,IdenticalTestDescription,"{'startLine':51,'endLine':54}","it('should perform a hard-link with back references _toJSONG.', function(done) {
            setTest(setJSON, '_toJSONG').
                subscribe(noOp, done, done);
        })",snuts
/test/hardlink/hardlink.add.spec.js,IdenticalTestDescription,"{'startLine':55,'endLine':58}","it('should perform a hard-link with back references toJSON.', function(done) {
            setTest(setJSON, 'toJSON').
                subscribe(noOp, done, done);
        })",snuts
/test/hardlink/hardlink.add.spec.js,IdenticalTestDescription,"{'startLine':59,'endLine':62}","it('should perform a hard-link with back references toPathValues.', function(done) {
            setTest(setJSON, 'toPathValues').
                subscribe(noOp, done, done);
        })",snuts
/test/hardlink/hardlink.add.spec.js,NonFunctionalStatement,"{'startLine':13,'endLine':13}",Unknown,snuts
/test/falcor/operations.spec.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/test/falcor/operations.spec.js,SubOptimalAssert,"{'startLine':32,'endLine':32}","it('should return undefined when undefined is passed into falcor.keys', function() {
        expect(falcor.keys()).toBe(undefined);
    })",snuts
/test/get-core/get.cache.spec.js,NonFunctionalStatement,"{'startLine':37,'endLine':37}","it(""serialized cache should not contain internal keys (including $size, on boxedValues)"", function(done) {
        var model = new Model({ cache: cacheGenerator(0, 1) });

        model.get(['lolomo', 0, 0, 'item', 'title']).subscribe(function() {}, done, function() {
            var cache = model.getCache();

            deepExpectations(cache, function(key) {
                expect(isInternalKey(key)).toBe(false);
            });

            done();
        });
    })",snuts
/test/get-core/deref.spec.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/test/internal/request/complement.spec.js,IdenticalTestDescription,"{'startLine':80,'endLine':92}","it(""returns the complement and intersection consisting of paths than can be partially deduped"", () => {
            const partialMatchingRequestedPath = [""videos"", 123, [""title"", ""boxart""]];
            const partialMatchingOptimizedPath = [""some"", ""weird"", ""long"", ""ref"", 456, [""title"", ""boxart""]];
            const pathTree = { some: { weird: { long: { ref: { 456: { title: null } } } } } };

            expect(
                findPartialIntersections(partialMatchingRequestedPath, partialMatchingOptimizedPath, pathTree)
            ).toEqual([
                [[""videos"", 123, ""title""]],
                [[""some"", ""weird"", ""long"", ""ref"", 456, ""boxart""]],
                [[""videos"", 123, ""boxart""]]
            ]);
        })",snuts
/test/internal/request/RequestQueue.get.spec.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':57,'endLine':57}","it(""makes a couple requests and have them batched together"", done => {
        const scheduler = new TimeoutScheduler(1); // To allow batching
        const source = new LocalDataSource(Cache());
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        queue.get([videos1], [videos1], zip);

        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(false);
        expect(queue._requests[0].scheduled).toBe(true);
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':81,'endLine':81}","it(""makes a couple requests and have them batched together"", done => {
        const scheduler = new TimeoutScheduler(1); // To allow batching
        const source = new LocalDataSource(Cache());
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        queue.get([videos1], [videos1], zip);

        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(false);
        expect(queue._requests[0].scheduled).toBe(true);
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':94,'endLine':94}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':113,'endLine':113}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':118,'endLine':118}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':156,'endLine':156}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':161,'endLine':161}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':200,'endLine':200}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':205,'endLine':205}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':234,'endLine':234}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':239,'endLine':239}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':277,'endLine':277}","it(""makes a couple requests where only part of the second request is deduped then disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable2();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':282,'endLine':282}","it(""makes a couple requests where only part of the second request is deduped then disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable2();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':311,'endLine':311}","it(""makes a couple requests where only part of the second request is deduped then both are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
        disposable2();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':316,'endLine':316}","it(""makes a couple requests where only part of the second request is deduped then both are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
        disposable2();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':333,'endLine':333}","it(""does not dedupe requests when request deduplication is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disableRequestDeduplication: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            expect(dsGetSpy).toHaveBeenCalledTimes(2);

            // Paths should still be collapsed
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [[""videos"", { from: 0, to: 1 }, ""title""]], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [[""videos"", { from: 1, to: 2 }, ""title""]], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':357,'endLine':357}","it(""does not collapse paths when path collapse is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disablePathCollapse: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            // Requests should still be deduplicated
            expect(dsGetSpy).toHaveBeenCalledTimes(2);
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos2], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':381,'endLine':381}","it(""does not collapse paths or dedupe requests"", done => {
            const scheduler = new ImmediateScheduler();
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                // No path collapse, no request dedupe
                expect(dsGetSpy).toHaveBeenCalledTimes(2);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
                expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",snuts
/test/internal/request/RequestQueue.get.spec.js,SubOptimalAssert,"{'startLine':404,'endLine':404}","it(""combines batched paths without collapse"", done => {
            const scheduler = new TimeoutScheduler(1); // To allow batching
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                expect(dsGetSpy).toHaveBeenCalledTimes(1);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1, videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",snuts
/test/internal/request/RequestQueue.get.spec.js,VerboseStatement,"{'startLine':123,'endLine':168}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,VerboseStatement,"{'startLine':170,'endLine':210}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,VerboseStatement,"{'startLine':212,'endLine':245}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,VerboseStatement,"{'startLine':247,'endLine':287}","it(""makes a couple requests where only part of the second request is deduped then disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable2();
    })",snuts
/test/internal/request/RequestQueue.get.spec.js,VerboseStatement,"{'startLine':289,'endLine':322}","it(""makes a couple requests where only part of the second request is deduped then both are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
        disposable2();
    })",snuts
/test/internal/request/GetRequest.spec.js,ConditionalTestLogic,"{'startLine':21,'endLine':27}","it(""unsubscribing should cancel DataSource request (sync scheduler)."", () => {
        let unsubscribeSpy;
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            const handle = setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            });

            unsubscribeSpy = jest.fn(() => {
                clearTimeout(handle);
            });

            return {
                dispose: unsubscribeSpy
            };
        });

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        subscription.dispose();

        expect(subscribeSpy).toHaveBeenCalledTimes(1);
        expect(unsubscribeSpy).toHaveBeenCalledTimes(1);
        expect(onNext).not.toHaveBeenCalled();
        expect(onError).not.toHaveBeenCalled();
        expect(onCompleted).not.toHaveBeenCalled();
    })",snuts
/test/internal/request/GetRequest.spec.js,ConditionalTestLogic,"{'startLine':81,'endLine':87}","it(""unsubscribing should cancel DataSource request (async scheduler, unsubscribed immediate)."", () => {
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            });

            // No need to have a spy, if subscribe is called, we fail.
            return {
                dispose() {}
            };
        });

        const model = new Model({
            scheduler: new TimeoutScheduler(1),
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        subscription.dispose();

        expect(subscribeSpy).not.toHaveBeenCalled();
        expect(onNext).not.toHaveBeenCalled();
        expect(onError).not.toHaveBeenCalled();
        expect(onCompleted).not.toHaveBeenCalled();
    })",snuts
/test/internal/request/GetRequest.spec.js,ConditionalTestLogic,"{'startLine':139,'endLine':145}","it(""unsubscribing should cancel DataSource request (async scheduler, unsubscribed after subscribe)."", done => {
        let unsubscribeSpy;
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            const handle = setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            }, 100000);

            unsubscribeSpy = jest.fn(() => {
                clearTimeout(handle);
            });

            return {
                dispose: unsubscribeSpy
            };
        });

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        function waitOrExpect() {
            if (!unsubscribeSpy) {
                setTimeout(waitOrExpect, 0);
                return;
            }
            subscription.dispose();

            expect(subscribeSpy).toHaveBeenCalledTimes(1);
            expect(unsubscribeSpy).toHaveBeenCalledTimes(1);
            expect(onNext).not.toHaveBeenCalled();
            expect(onError).not.toHaveBeenCalled();
            expect(onCompleted).not.toHaveBeenCalled();

            done();
        }

        waitOrExpect();
    })",snuts
/test/internal/request/GetRequest.spec.js,ConditionalTestLogic,"{'startLine':179,'endLine':182}","it(""unsubscribing should cancel DataSource request (async scheduler, unsubscribed after subscribe)."", done => {
        let unsubscribeSpy;
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            const handle = setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            }, 100000);

            unsubscribeSpy = jest.fn(() => {
                clearTimeout(handle);
            });

            return {
                dispose: unsubscribeSpy
            };
        });

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        function waitOrExpect() {
            if (!unsubscribeSpy) {
                setTimeout(waitOrExpect, 0);
                return;
            }
            subscription.dispose();

            expect(subscribeSpy).toHaveBeenCalledTimes(1);
            expect(unsubscribeSpy).toHaveBeenCalledTimes(1);
            expect(onNext).not.toHaveBeenCalled();
            expect(onError).not.toHaveBeenCalled();
            expect(onCompleted).not.toHaveBeenCalled();

            done();
        }

        waitOrExpect();
    })",snuts
/test/internal/request/GetRequest.spec.js,NonFunctionalStatement,"{'startLine':92,'endLine':92}","it(""unsubscribing should cancel DataSource request (async scheduler, unsubscribed immediate)."", () => {
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            });

            // No need to have a spy, if subscribe is called, we fail.
            return {
                dispose() {}
            };
        });

        const model = new Model({
            scheduler: new TimeoutScheduler(1),
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        subscription.dispose();

        expect(subscribeSpy).not.toHaveBeenCalled();
        expect(onNext).not.toHaveBeenCalled();
        expect(onError).not.toHaveBeenCalled();
        expect(onCompleted).not.toHaveBeenCalled();
    })",snuts
/test/internal/request/GetRequest.batch.spec.js,ConditionalTestLogic,"{'startLine':34,'endLine':36}","it(""should make a request to the dataSource with an immediate scheduler"", done => {
        let inlineBoolean = true;
        const scheduler = new ImmediateScheduler();
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        request.batch([videos0], [videos0], (err, data) => {
            if (err) {
                done(err);
            }

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0))
                .doAction(onNext, noOp, () => {
                    expect(inlineBoolean).toBe(true);
                    expect(getSpy).toHaveBeenCalledTimes(1);
                    expect(getSpy.mock.calls[0][1]).toEqual([videos0]);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });
        inlineBoolean = false;
    })",snuts
/test/internal/request/GetRequest.batch.spec.js,ConditionalTestLogic,"{'startLine':73,'endLine':75}","it(""should make a request to the dataSource with an async scheduler."", done => {
        let inlineBoolean = true;
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });
        const callback = jest.fn((err, data) => {
            if (err) {
                done(err);
            }

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0))
                .doAction(onNext, noOp, () => {
                    expect(inlineBoolean).toBe(false);
                    expect(getSpy).toHaveBeenCalledTimes(1);
                    expect(getSpy.mock.calls[0][1]).toEqual([videos0]);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        request.batch([videos0], [videos0], callback);
        inlineBoolean = false;
    })",snuts
/test/internal/request/GetRequest.batch.spec.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/test/internal/request/GetRequest.batch.spec.js,NonFunctionalStatement,"{'startLine':29,'endLine':29}","it(""should make a request to the dataSource with an immediate scheduler"", done => {
        let inlineBoolean = true;
        const scheduler = new ImmediateScheduler();
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        request.batch([videos0], [videos0], (err, data) => {
            if (err) {
                done(err);
            }

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0))
                .doAction(onNext, noOp, () => {
                    expect(inlineBoolean).toBe(true);
                    expect(getSpy).toHaveBeenCalledTimes(1);
                    expect(getSpy.mock.calls[0][1]).toEqual([videos0]);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });
        inlineBoolean = false;
    })",snuts
/test/internal/request/GetRequest.batch.spec.js,NonFunctionalStatement,"{'startLine':69,'endLine':69}","it(""should make a request to the dataSource with an async scheduler."", done => {
        let inlineBoolean = true;
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });
        const callback = jest.fn((err, data) => {
            if (err) {
                done(err);
            }

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0))
                .doAction(onNext, noOp, () => {
                    expect(inlineBoolean).toBe(false);
                    expect(getSpy).toHaveBeenCalledTimes(1);
                    expect(getSpy.mock.calls[0][1]).toEqual([videos0]);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        request.batch([videos0], [videos0], callback);
        inlineBoolean = false;
    })",snuts
/test/internal/request/GetRequest.batch.spec.js,NonFunctionalStatement,"{'startLine':109,'endLine':109}","it(""should batch some requests together."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        request.batch([videos0], [videos0], zip);
        request.batch([videos1], [videos1], zip);
    })",snuts
/test/internal/request/GetRequest.batch.spec.js,NonFunctionalStatement,"{'startLine':146,'endLine':146}","it(""should batch some requests together and dispose the first one."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(
            2,
            callCount => {
                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(callCount).toBe(1);
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );
        const disposable = request.batch([videos0], [videos0], zip);
        request.batch([videos1], [videos1], zip);

        disposable();
    })",snuts
/test/internal/request/GetRequest.batch.spec.js,NonFunctionalStatement,"{'startLine':185,'endLine':185}","it(""should batch some requests together and dispose the second one."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(
            2,
            callCount => {
                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(callCount).toBe(1);
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        request.batch([videos0], [videos0], zip);
        const disposable = request.batch([videos1], [videos1], zip);

        disposable();
    })",snuts
/test/internal/request/GetRequest.add.spec.js,NonFunctionalStatement,"{'startLine':10,'endLine':10}",Unknown,snuts
/test/set/pathValues/primitive.spec.js,AnonymousTest,"{'startLine':24,'endLine':40}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",snuts
/test/set/pathValues/primitive.spec.js,AnonymousTest,"{'startLine':167,'endLine':184}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathValues/primitive.spec.js,AnonymousTest,"{'startLine':218,'endLine':248}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathValues/primitive.spec.js,AnonymousTest,"{'startLine':249,'endLine':276}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathValues/primitive.spec.js,AnonymousTest,"{'startLine':277,'endLine':307}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathValues/primitive.spec.js,AnonymousTest,"{'startLine':308,'endLine':335}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathValues/primitive.spec.js,AnonymousTest,"{'startLine':336,'endLine':366}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathValues/primitive.spec.js,IdenticalTestDescription,"{'startLine':167,'endLine':184}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathValues/expired.spec.js,SubOptimalAssert,"{'startLine':27,'endLine':27}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",snuts
/test/set/pathValues/expired.spec.js,SubOptimalAssert,"{'startLine':51,'endLine':51}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",snuts
/test/set/pathValues/expired.spec.js,SubOptimalAssert,"{'startLine':75,'endLine':75}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",snuts
/test/set/pathValues/branch.spec.js,AnonymousTest,"{'startLine':49,'endLine':63}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",snuts
/test/set/pathValues/branch.spec.js,AnonymousTest,"{'startLine':95,'endLine':109}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",snuts
/test/set/pathValues/branch.spec.js,IdenticalTestDescription,"{'startLine':95,'endLine':109}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",snuts
/test/set/pathValues/branch.spec.js,IdenticalTestDescription,"{'startLine':111,'endLine':136}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",snuts
/test/set/pathValues/atom.spec.js,AnonymousTest,"{'startLine':11,'endLine':35}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",snuts
/test/set/pathValues/atom.spec.js,AnonymousTest,"{'startLine':227,'endLine':244}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathValues/atom.spec.js,AnonymousTest,"{'startLine':278,'endLine':308}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathValues/atom.spec.js,AnonymousTest,"{'startLine':309,'endLine':336}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathValues/atom.spec.js,AnonymousTest,"{'startLine':337,'endLine':367}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathValues/atom.spec.js,AnonymousTest,"{'startLine':368,'endLine':395}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathValues/atom.spec.js,AnonymousTest,"{'startLine':396,'endLine':426}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathValues/atom.spec.js,IdenticalTestDescription,"{'startLine':227,'endLine':244}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathMaps/primitive.spec.js,AnonymousTest,"{'startLine':25,'endLine':41}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",snuts
/test/set/pathMaps/primitive.spec.js,AnonymousTest,"{'startLine':149,'endLine':166}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathMaps/primitive.spec.js,AnonymousTest,"{'startLine':200,'endLine':230}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathMaps/primitive.spec.js,AnonymousTest,"{'startLine':231,'endLine':258}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathMaps/primitive.spec.js,AnonymousTest,"{'startLine':259,'endLine':289}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathMaps/primitive.spec.js,AnonymousTest,"{'startLine':290,'endLine':317}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathMaps/primitive.spec.js,AnonymousTest,"{'startLine':318,'endLine':348}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathMaps/primitive.spec.js,IdenticalTestDescription,"{'startLine':149,'endLine':166}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/pathMaps/expired.spec.js,IdenticalTestDescription,"{'startLine':58,'endLine':80}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",snuts
/test/set/pathMaps/expired.spec.js,SubOptimalAssert,"{'startLine':27,'endLine':27}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",snuts
/test/set/pathMaps/expired.spec.js,SubOptimalAssert,"{'startLine':51,'endLine':51}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",snuts
/test/set/pathMaps/expired.spec.js,SubOptimalAssert,"{'startLine':75,'endLine':75}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",snuts
/test/set/pathMaps/branch.spec.js,AnonymousTest,"{'startLine':12,'endLine':26}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",snuts
/test/set/pathMaps/branch.spec.js,AnonymousTest,"{'startLine':58,'endLine':72}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",snuts
/test/set/pathMaps/branch.spec.js,IdenticalTestDescription,"{'startLine':58,'endLine':72}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",snuts
/test/set/pathMaps/atom.spec.js,AnonymousTest,"{'startLine':11,'endLine':35}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",snuts
/test/set/pathMaps/atom.spec.js,AnonymousTest,"{'startLine':208,'endLine':225}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathMaps/atom.spec.js,AnonymousTest,"{'startLine':259,'endLine':289}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathMaps/atom.spec.js,AnonymousTest,"{'startLine':290,'endLine':317}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathMaps/atom.spec.js,AnonymousTest,"{'startLine':318,'endLine':348}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathMaps/atom.spec.js,AnonymousTest,"{'startLine':349,'endLine':376}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathMaps/atom.spec.js,AnonymousTest,"{'startLine':377,'endLine':407}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/pathMaps/atom.spec.js,IdenticalTestDescription,"{'startLine':208,'endLine':225}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/primitive.spec.js,AnonymousTest,"{'startLine':51,'endLine':70}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",snuts
/test/set/jsonGraphs/primitive.spec.js,AnonymousTest,"{'startLine':206,'endLine':225}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/primitive.spec.js,AnonymousTest,"{'startLine':261,'endLine':293}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/primitive.spec.js,AnonymousTest,"{'startLine':294,'endLine':323}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/primitive.spec.js,AnonymousTest,"{'startLine':324,'endLine':356}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/primitive.spec.js,AnonymousTest,"{'startLine':357,'endLine':386}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/primitive.spec.js,AnonymousTest,"{'startLine':387,'endLine':419}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/primitive.spec.js,IdenticalTestDescription,"{'startLine':206,'endLine':225}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/expired.spec.js,NonFunctionalStatement,"{'startLine':121,'endLine':121}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",snuts
/test/set/jsonGraphs/expired.spec.js,SubOptimalAssert,"{'startLine':31,'endLine':31}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ])]
        );

        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",snuts
/test/set/jsonGraphs/expired.spec.js,SubOptimalAssert,"{'startLine':58,'endLine':58}","it(""sets through an immediately expired reference"", function() {

        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: 0
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",snuts
/test/set/jsonGraphs/expired.spec.js,SubOptimalAssert,"{'startLine':92,'endLine':92}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",snuts
/test/set/jsonGraphs/expired.spec.js,SubOptimalAssert,"{'startLine':132,'endLine':132}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",snuts
/test/set/jsonGraphs/branch.spec.js,AnonymousTest,"{'startLine':51,'endLine':73}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",snuts
/test/set/jsonGraphs/branch.spec.js,AnonymousTest,"{'startLine':110,'endLine':132}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",snuts
/test/set/jsonGraphs/branch.spec.js,IdenticalTestDescription,"{'startLine':110,'endLine':132}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",snuts
/test/set/jsonGraphs/branch.spec.js,IdenticalTestDescription,"{'startLine':134,'endLine':164}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",snuts
/test/set/jsonGraphs/atom.spec.js,AnonymousTest,"{'startLine':13,'endLine':38}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",snuts
/test/set/jsonGraphs/atom.spec.js,AnonymousTest,"{'startLine':220,'endLine':239}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/atom.spec.js,AnonymousTest,"{'startLine':275,'endLine':307}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/atom.spec.js,AnonymousTest,"{'startLine':308,'endLine':337}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/atom.spec.js,AnonymousTest,"{'startLine':338,'endLine':370}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/atom.spec.js,AnonymousTest,"{'startLine':371,'endLine':400}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/atom.spec.js,AnonymousTest,"{'startLine':401,'endLine':433}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/set/jsonGraphs/atom.spec.js,IdenticalTestDescription,"{'startLine':220,'endLine':239}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",snuts
/test/falcor/set/set.pathSyntax.spec.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/test/falcor/set/set.dataSource-only.spec.js,ConditionalTestLogic,"{'startLine':160,'endLine':188}","it(""should report paths progressively."", done => {
        const onSet = function(source, tmpGraph, jsonGraphFromSet) {
            jsonGraphFromSet.jsonGraph.videos[444].rating = 5;
            return jsonGraphFromSet;
        };
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });

        let count = 0;
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            }).
            progressively()).
            doAction(x => {
                if (count === 0) {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 3
                                }
                            }
                        }
                    });
                }

                else {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 5
                                }
                            }
                        }
                    });
                }

                count++;
            }, noOp, () => {
                expect(count === 2).toBe(true);
            }).
            subscribe(noOp, done, done);
    })",snuts
/test/falcor/set/set.dataSource-only.spec.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/test/falcor/set/set.dataSource-only.spec.js,SubOptimalAssert,"{'startLine':192,'endLine':192}","it(""should report paths progressively."", done => {
        const onSet = function(source, tmpGraph, jsonGraphFromSet) {
            jsonGraphFromSet.jsonGraph.videos[444].rating = 5;
            return jsonGraphFromSet;
        };
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });

        let count = 0;
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            }).
            progressively()).
            doAction(x => {
                if (count === 0) {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 3
                                }
                            }
                        }
                    });
                }

                else {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 5
                                }
                            }
                        }
                    });
                }

                count++;
            }, noOp, () => {
                expect(count === 2).toBe(true);
            }).
            subscribe(noOp, done, done);
    })",snuts
/test/falcor/set/set.dataSource-and-cache.spec.js,ConditionalTestLogic,"{'startLine':122,'endLine':130}","it('should perform multiple trips to a dataSource.', function(done) {
            var count = 0;
            var onSet = jest.fn(function(source, tmp, jsongEnv) {
                count++;
                if (count === 1) {

                    // Don't do it this way, it will cause memory leaks.
                    model._root.cache.genreList[1][1] = undefined;
                    return {
                        jsonGraph: jsongEnv.jsonGraph,
                        paths: [jsongEnv.paths[0]]
                    };
                }
                return jsongEnv;
            });
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: onSet
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set(
                    {path: ['genreList', 0, 0, 'summary'], value: 1337},
                    {path: ['genreList', 1, 1, 'summary'], value: 7331})).
                doAction(onNext, noOp, function() {
                    expect(onSet).toHaveBeenCalledTimes(2);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                },
                                1: {
                                    1: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",snuts
/test/falcor/set/set.dataSource-and-cache.spec.js,ConditionalTestLogic,"{'startLine':297,'endLine':300}","it('should throw an error set and project it.', function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            errorSelector: function mapError(path, value) {
                value.$foo = 'bar';
                return value;
            }
        });
        var called = false;
        toObservable(model.
            boxValues().
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(noOp, function(e) {
                called = true;
                testRunner.compare([{
                    path: ['genreList', 0, 0, 'summary'],
                    value: {
                        $type: $error,
                        $foo: 'bar',
                        value: {
                            message: 'Timeout',
                            status: 503
                        }
                    }
                }], e, {strip: ['$size']});
            }, function() {
                done('onNext should not be called.');
            }).
            subscribe(noOp, function(e) {
                if (Array.isArray(e) && e[0].value.$foo === 'bar' && called) {
                    done();
                    return;
                }
                done(e);
            }, noOp);
    })",snuts
/test/falcor/set/set.dataSource-and-cache.spec.js,NonFunctionalStatement,"{'startLine':12,'endLine':12}",Unknown,snuts
/test/falcor/set/set.dataSource-and-bind.spec.js,ConditionalTestLogic,"{'startLine':22,'endLine':29}","it('should perform multiple trips to a dataSource.', function(done) {
        var count = 0;
        var model = new Model({
            cache: M(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    count++;
                    if (count === 1) {
                        // Don't do it this way, it will cause memory leaks.
                        model._root.cache.lists.A[1] = undefined;
                        return {
                            jsonGraph: jsongEnv.jsonGraph,
                            paths: [jsongEnv.paths[0]]
                        };
                    }

                    return jsongEnv;
                }
            })
        });
        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            flatMap(function(x) {
                return model.
                    deref(x.json.lolomo[0]).
                    set(
                        {path: [0, 'item', 'title'], value: 1337},
                        {path: [1, 'item', 'title'], value: 7331});
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(count).toBe(2);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        0: {
                            item: {
                                title: 1337
                            }
                        },
                        1: {
                            item: {
                                title: 7331
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",snuts
/test/falcor/set/set.dataSource-and-bind.spec.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/test/falcor/set/set.change-handler.spec.js,ConditionalTestLogic,"{'startLine':21,'endLine':23}","it(""is called when the root's version changes but before the subscription is disposed."", function () {
        var changed = false;
        var calledBeforeEnsure = false;
        var model = new Model({
            onChange: function () {
                changed = true;
            }
        });

        toObservable(model.
            set({
                path: [""a"", ""b"", ""c""],
                value: ""foo""
            })).
            ensure(function() {
                if(changed === true) {
                    calledBeforeEnsure = true;
                }
            }).
            subscribe();

        expect(changed).toBe(true);
        expect(calledBeforeEnsure).toBe(true);
    })",snuts
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,ConditionalTestLogic,"{'startLine':157,'endLine':160}","it('should throw an error set and project it.', function(done) {
        var model = new Model({
            source: new Model({
                source: new ErrorDataSource(503, ""Timeout""),
                errorSelector: function mapError(path, value) {
                    value.$foo = 'bar';
                    return value;
                }
            }).asDataSource() });
        var called = false;
        toObservable(model.
            boxValues().
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(noOp, function(e) {
                called = true;
                testRunner.compare([{
                    path: ['genreList', 0, 0, 'summary'],
                    value: {
                        $type: $error,
                        $foo: 'bar',
                        value: {
                            message: 'Timeout',
                            status: 503
                        }
                    }
                }], e, {strip: ['$size']});
            }, function() {
                done('onCompleted should not be called.');
            }).
            subscribe(noOp, function(e) {
                if (Array.isArray(e) && e[0].value.$foo === 'bar' && called) {
                    done();
                    return;
                }
                done(e);
            }, noOp);
    })",snuts
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,NonFunctionalStatement,"{'startLine':12,'endLine':12}",Unknown,snuts
/test/falcor/set/set.cache-only.spec.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/test/falcor/set/set.cache-only.spec.js,SubOptimalAssert,"{'startLine':171,'endLine':171}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",snuts
/test/falcor/set/set.cache-only.spec.js,SubOptimalAssert,"{'startLine':211,'endLine':211}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",snuts
/test/falcor/invalidate/invalidate.cache-only.spec.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/test/falcor/get/get.pathSyntax.spec.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/test/falcor/get/get.model.adapter.spec.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/test/falcor/get/get.gen.spec.js,SubOptimalAssert,"{'startLine':9,'endLine':9}","it('should get a version', function() {
        var model = new Model({cache: {hello: 'world'}});
        model._root.unsafeMode = true;
        var version = model.getVersion('hello');
        expect(version >= 0).toBe(true);
    })",snuts
/test/falcor/get/get.gen.spec.js,SubOptimalAssert,"{'startLine':14,'endLine':14}","it('should get a version on the root model', function() {
        var model = new Model({cache: {hello: 'world'}, unsafeMode: true});
        var version = model.getVersion();
        expect(version >= 0).toBe(true);
    })",snuts
/test/falcor/get/get.gen.spec.js,SubOptimalAssert,"{'startLine':20,'endLine':20}","it('should get -1 if no path exists.', function() {
        var model = new Model({cache: {hello: 'world'}});
        model._root.unsafeMode = true;
        var version = model.getVersion('world');
        expect(version === -1).toBe(true);
    })",snuts
/test/falcor/get/get.dataSource-only.spec.js,IdenticalTestDescription,"{'startLine':80,'endLine':91}","it(""should get a value from falcor."", done => {
            const model = new Model({ source: dataSource });
            const onNext = jest.fn();
            toObservable(model.
                get([""videos"", 0, ""title""])).
                doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { videos: { 0: { title: ""Video 0"" } } }
                    });
                }).
                subscribe(noOp, done, done);
        })",snuts
/test/falcor/get/get.dataSource-only.spec.js,IdenticalTestDescription,"{'startLine':118,'endLine':137}","it(""should get a value from falcor."", done => {
            const model = new Model({ source: dataSource });
            const onNext = jest.fn();
            toObservable(model.
                get([""videos"", 0, ""title""]).
                _toJSONG()).
                doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: atom(""Video 0"")
                                }
                            }
                        },
                        paths: [[""videos"", 0, ""title""]]
                    });
                }).
                subscribe(noOp, done, done);
        })",snuts
/test/falcor/get/get.dataSource-only.spec.js,ConditionalTestLogic,"{'startLine':48,'endLine':50}","it(""should perform multiple trips to a dataSource."", done => {
            const get = jest.fn((source, paths) => {
                if (paths.length === 0) {
                    paths.pop();
                }
            });
            const model = new Model({
                source: new LocalDataSource(cacheGenerator(0, 2, [""title"", ""art""]), { onGet: get })

            });
            const onNext = jest.fn();
            const secondOnNext = jest.fn();
            toObservable(model.
                preload([""videos"", 0, ""title""],
                    [""videos"", 1, ""art""])).
                doAction(onNext).
                doAction(noOp, noOp, () => {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(() => {
                    return model.get([""videos"", 0, ""title""]);
                }).
                doAction(secondOnNext).
                doAction(noOp, noOp, () => {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: { videos: { 0: { title: ""Video 0"" } } }
                    });
                }).
                subscribe(noOp, done, done);
        })",snuts
/test/falcor/get/get.dataSource-only.spec.js,ConditionalTestLogic,"{'startLine':160,'endLine':162}","it(""should report errors from a dataSource with _treatDataSourceErrorsAsJSONGraphErrors."", done => {
        const model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new ErrorDataSource(500, ""Oops!"")
        });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, err => {
                expect(err).toEqual([{
                    path: [""videos"", 0, ""title""],
                    value: {
                        message: ""Oops!"",
                        status: 500
                    }
                }]);
            }, () => {
                throw new Error(""On Completed was called. "" +
                    ""OnError should have been called."");
            }).
            subscribe(noOp, err => {
                // ensure its the same error
                if (Array.isArray(err) && isPathValue(err[0])) {
                    return done();
                }
                return done(err);
            });
    })",snuts
/test/falcor/get/get.dataSource-only.spec.js,ConditionalTestLogic,"{'startLine':187,'endLine':192}","it(""should report errors from a dataSource."", done => {
        let outputError = null;
        const model = new Model({
            source: new ErrorDataSource(500, ""Oops!"")
        });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, err => {
                outputError = err;
                expect(err).toEqual({
                    $type: ""error"",
                    value: {
                        message: ""Oops!"",
                        status: 500
                    }
                });
            }, () => {
                throw new Error(""On Completed was called. "" +
                    ""OnError should have been called."");
            }).
            subscribe(noOp, err => {
                if (err === outputError) {
                    return done();
                }
                else {
                    return done(err);
                }
            });
    })",snuts
/test/falcor/get/get.dataSource-only.spec.js,ConditionalTestLogic,"{'startLine':409,'endLine':411}","it(""should onError a MaxRetryExceededError when data source is sync."", done => {
        const model = new Model({ source: new LocalDataSource({}) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",snuts
/test/falcor/get/get.dataSource-only.spec.js,ConditionalTestLogic,"{'startLine':424,'endLine':426}","it(""should onError a MaxRetryExceededError when data source is async."", done => {
        const model = new Model({ source: asyncifyDataSource(new LocalDataSource({})) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",snuts
/test/falcor/get/get.dataSource-only.spec.js,ConditionalTestLogic,"{'startLine':458,'endLine':460}","it(""should return missing optimized paths with MaxRetryExceededError"", done => {
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({})),
            cache: {
                lolomo: {
                    0: {
                        $type: ""ref"",
                        value: [""videos"", 1]
                    }
                },
                videos: {
                    0: {
                        title: ""Revolutionary Road""
                    }
                }
            }
        });
        toObservable(model.
            get([""lolomo"", 0, ""title""], ""videos[0].title"", ""hall[0].ween"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
                expect(e.missingOptimizedPaths).toEqual([
                    [""videos"", 1, ""title""],
                    [""hall"", 0, ""ween""]
                ]);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",snuts
/test/falcor/get/get.dataSource-only.spec.js,ConditionalTestLogic,"{'startLine':480,'endLine':480}","it(""should throw MaxRetryExceededError after retrying said times"", done => {
        const onGet = jest.fn();
        const model = new Model({
            maxRetries: 5,
            source: asyncifyDataSource(new LocalDataSource({}, {
                onGet
            }))
        });
        toObservable(model.
            get(""some.path"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected"").toBe(true);
                expect(onGet).toHaveBeenCalledTimes(5);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) { return done(e); }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",snuts
/test/falcor/get/get.dataSource-only.spec.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/test/falcor/get/get.dataSource-and-cache.spec.js,IdenticalTestDescription,"{'startLine':199,'endLine':226}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",snuts
/test/falcor/get/get.dataSource-and-cache.spec.js,IdenticalTestDescription,"{'startLine':322,'endLine':339}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",snuts
/test/falcor/get/get.dataSource-and-cache.spec.js,ConditionalTestLogic,"{'startLine':43,'endLine':53}","it('should onNext only once even if a subset of the requested values is found in the cache', function(done) {
        var model = new Model({
            cache: {
                paths: {
                    0: 'test',
                    1: 'test'
                }
            },
            source: new LocalDataSource({
                paths: {
                    2: Model.atom('test'),
                    3: Model.atom(undefined)
                }
            }, {materialize: true})
        });

        var onNextCount = 0;
        toObservable(model.
            get(['paths', {to:3}])).
            doAction(function(value) {

                onNextCount++;

                if (onNextCount === 1){
                    expect(strip(value)).toEqual({
                        json: {
                            paths: {
                                0: 'test',
                                1: 'test',
                                2: 'test'
                            }
                        }
                    });
                }
            }).subscribe(noOp, done, function(){
                expect(onNextCount).toBe(1);
                done();
            });
    })",snuts
/test/falcor/get/get.dataSource-and-cache.spec.js,ConditionalTestLogic,"{'startLine':365,'endLine':385}","it('should onNext twice if at least one value found in the cache - even if it is an atom of undefined', function(done) {
            var model = new Model({
                cache: {
                    paths: {
                        0: 'test',
                        1: 'test'
                    }
                },
                source: new LocalDataSource({
                    paths: {
                        2: Model.atom('test'),
                        3: Model.atom(undefined)
                    }
                }, {materialize: true})
            });

            var onNextCount = 0;
            toObservable(model.
                get(['paths', {to:3}]).
                progressively()).
                doAction(function(value) {

                    onNextCount++;
                    if (onNextCount === 1){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test'
                                }
                            }
                        });
                    }
                    else if (onNextCount === 2){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test',
                                    2: 'test'
                                }
                            }
                        });
                    }
                }).subscribe(noOp, done, function(){
                    expect(onNextCount).toBe(2);
                    done();
                });
        })",snuts
/test/falcor/get/get.dataSource-and-cache.spec.js,ConditionalTestLogic,"{'startLine':375,'endLine':385}","it('should onNext twice if at least one value found in the cache - even if it is an atom of undefined', function(done) {
            var model = new Model({
                cache: {
                    paths: {
                        0: 'test',
                        1: 'test'
                    }
                },
                source: new LocalDataSource({
                    paths: {
                        2: Model.atom('test'),
                        3: Model.atom(undefined)
                    }
                }, {materialize: true})
            });

            var onNextCount = 0;
            toObservable(model.
                get(['paths', {to:3}]).
                progressively()).
                doAction(function(value) {

                    onNextCount++;
                    if (onNextCount === 1){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test'
                                }
                            }
                        });
                    }
                    else if (onNextCount === 2){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test',
                                    2: 'test'
                                }
                            }
                        });
                    }
                }).subscribe(noOp, done, function(){
                    expect(onNextCount).toBe(2);
                    done();
                });
        })",snuts
/test/falcor/get/get.dataSource-and-cache.spec.js,ConditionalTestLogic,"{'startLine':400,'endLine':433}","it('should get multiple arguments with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",snuts
/test/falcor/get/get.dataSource-and-cache.spec.js,ConditionalTestLogic,"{'startLine':448,'endLine':481}","it('should get complex path with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",snuts
/test/falcor/get/get.dataSource-and-cache.spec.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/test/falcor/get/get.dataSource-and-cache.spec.js,SubOptimalAssert,"{'startLine':497,'endLine':497}","it('should get different response objects with multiple trips to the dataSource.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var revisions = [];
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    revisions.push(x);
                }, noOp, function() {
                    expect(revisions.length).toBe(2);
                    expect(revisions[1]).not.toBe(revisions[0]);
                    expect(revisions[1].json.lolomo[0]).not.toBe(revisions[0].json.lolomo[0]);
                    expect(revisions[1].json.lolomo[0][0]).toBe(revisions[0].json.lolomo[0][0]);

                }).
                subscribe(noOp, done, done);
        })",snuts
/test/falcor/get/get.dataSource-and-cache.spec.js,SubOptimalAssert,"{'startLine':570,'endLine':570}","it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",snuts
/test/falcor/get/get.dataSource-and-cache.spec.js,SubOptimalAssert,"{'startLine':618,'endLine':618}","it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",snuts
/test/falcor/get/get.dataSource-and-cache.spec.js,SubOptimalAssert,"{'startLine':662,'endLine':662}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",snuts
/test/falcor/get/get.dataSource-and-bind.spec.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/test/falcor/get/get.clone.spec.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/test/falcor/get/get.cacheAsDataSource.spec.js,IdenticalTestDescription,"{'startLine':55,'endLine':81}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: atom('Video 0')
                                }
                            }
                        },
                        paths: [
                            ['videos', 0, 'title']
                        ]
                    });
                }).
                subscribe(noOp, done, done);
        })",snuts
/test/falcor/get/get.cacheAsDataSource.spec.js,ConditionalTestLogic,"{'startLine':103,'endLine':107}","it('should report errors from a dataSource with _treatDataSourceErrorsAsJSONGraphErrors.', function(done) {
        var model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new Model({
                source: new ErrorDataSource(500, 'Oops!')
            }).asDataSource()
        });
        toObservable(model.
            get(['videos', 1234, 'summary'])).
            doAction(noOp, function(err) {
                expect(err).toEqual([{
                    path: ['videos', 1234, 'summary'],
                    value: {
                        message: 'Oops!',
                        status: 500
                    }
                }]);
            }).
            subscribe(noOp, function(err) {
                // ensure its the same error
                if (Array.isArray(err) && isPathValue(err[0])) {
                    done();
                } else {
                    done(err);
                }
            }, function() {
                done('On Completed was called. ' +
                     'OnError should have been called.');
            });
    })",snuts
/test/falcor/get/get.cacheAsDataSource.spec.js,ConditionalTestLogic,"{'startLine':134,'endLine':138}","it('should report errors from a dataSource.', function(done) {
        var outputError;
        var model = new Model({
            source: new Model({
                source: new ErrorDataSource(500, 'Oops!')
            }).asDataSource()
        });
        toObservable(model.
            get(['videos', 1234, 'summary'])).
            doAction(noOp, function(err) {
                outputError = err;
                expect(err).toEqual({
                    $type: ""error"",
                    value: {
                        message: 'Oops!',
                        status: 500
                    }
                });
            }).
            subscribe(noOp, function(err) {
                // ensure its the same error
                if (outputError === err) {
                    done();
                } else {
                    done(err);
                }
            }, function() {
                done('On Completed was called. ' +
                     'OnError should have been called.');
            });
    })",snuts
/test/falcor/get/get.cacheAsDataSource.spec.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/test/falcor/get/get.cache-only.spec.js,IdenticalTestDescription,"{'startLine':96,'endLine':113}","it(""should get a value from falcor."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 30),
            });
            const onNext = jest.fn();
            toObservable(
                model.get([""lolomo"", 0, 0, ""item"", ""title""])._toJSONG()
            )
                .doAction(onNext, noOp, () => {
                    const out = clean(onNext.mock.calls[0][0]);
                    const expected = clean({
                        jsonGraph: cacheGenerator(0, 1),
                        paths: [[""lolomo"", 0, 0, ""item"", ""title""]],
                    });
                    expect(out).toEqual(expected);
                })
                .subscribe(noOp, done, done);
        })",snuts
/test/falcor/get/get.cache-only.spec.js,ConditionalTestLogic,"{'startLine':74,'endLine':76}","it(""should use a promise to get request."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            const onError = jest.fn();
            model
                .get([""videos"", 0, ""title""])
                .then(onNext, onError)
                .then(() => {
                    if (onError.mock.calls[0]) {
                        throw onError.mock.calls[0][0];
                    }

                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0"",
                                },
                            },
                        },
                    });
                })
                .then(() => {
                    done();
                }, done);
        })",snuts
/test/falcor/get/get.cache-only.spec.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/test/falcor/deref/deref.spec.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/test/falcor/deref/deref.hasValidParentReference.spec.js,OvercommentedTest,"{'startLine':115,'endLine':183}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",snuts
/test/falcor/deref/deref.hasValidParentReference.spec.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/test/falcor/deref/deref.hasValidParentReference.spec.js,VerboseStatement,"{'startLine':115,'endLine':183}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",snuts
/test/falcor/deref/deref.errors.spec.js,ConditionalTestLogic,"{'startLine':42,'endLine':44}","it('should error on a shorted deref path.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);
                model.
                    set({
                        json: {
                            lolomos: 'ohh no'
                        }
                    }).
                    subscribe();

                toObservable(lolomoModel.
                    get([0, 0, 'item', 'title'])).
                    doAction(onNext, function(err) {
                        expect(onNext).toHaveBeenCalledTimes(1);
                        expect(err.name).toBe(InvalidModelError.name);
                    }).
                    subscribe(
                        noOp,
                        function(err) {
                            if (isAssertionError(err)) {
                                return done(err);
                            }
                            done();
                        },
                        done.bind(null, new Error('onCompleted shouldnt be called')));
            });
    })",snuts
/test/falcor/deref/deref.errors.spec.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/test/falcor/call/call.spec.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/test/falcor/error/error.spec.js,ConditionalTestLogic,"{'startLine':65,'endLine':69}","it(""should get a hard error from the DataSource with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            _treatDataSourceErrorsAsJSONGraphErrors: true
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {},
                            2: {},
                            3: {},
                            4: {},
                            5: {}
                        }
                    }
                });
                expect(err.length).toBe(6);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",snuts
/test/falcor/error/error.spec.js,ConditionalTestLogic,"{'startLine':96,'endLine':100}","it(""should get a hard error from the DataSource."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout"")
        });
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(noOp, function(err) {
                // not in boxValue mode
                var expected = {
                    $type: ""error"",
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };

                expect(err).toEqual(expected);
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",snuts
/test/falcor/error/error.spec.js,ConditionalTestLogic,"{'startLine':323,'endLine':325}","it('should allow for dataSources to immediately throw an error (set)', function(done) {
        var routes = {
            set: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            set({
                paths: [['titlesById', 242, 'rating']],
                jsonGraph: {
                    titlesById: {
                        242: {
                            rating: 5
                        }
                    }
                }
            })).
            doAction(onNext, onError).
            doAction(noOp, function() {
                expect(onNext).not.toHaveBeenCalled();
                expect(onError).toHaveBeenCalledTimes(1);
                expect(onError.mock.calls[0][0].name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",snuts
/test/falcor/error/error.spec.js,ConditionalTestLogic,"{'startLine':351,'endLine':353}","it('should allow for dataSources to immediately throw an error (get)', function(done) {
        var routes = {
            get: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            get(['path', 'to', 'value'])).
            doAction(onNext, function(e) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                })
                expect(e.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",snuts
/test/falcor/error/error.spec.js,ConditionalTestLogic,"{'startLine':374,'endLine':376}","it('should allow for dataSources to immediately throw an error (call)', function(done) {
        var routes = {
            call: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        toObservable(model.
            call(['videos', 1234, 'rating'], 5)).
            doAction(onNext).
            doAction(noOp, function(err) {
                expect(onNext).not.toHaveBeenCalled();
                expect(err.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",snuts
/test/falcor/error/error.spec.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/test/falcor/error/error.spec.js,SubOptimalAssert,"{'startLine':49,'endLine':49}","it(""should get a hard error from the DataSource with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            _treatDataSourceErrorsAsJSONGraphErrors: true
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {},
                            2: {},
                            3: {},
                            4: {},
                            5: {}
                        }
                    }
                });
                expect(err.length).toBe(6);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",snuts
/test/falcor/error/error.spec.js,SubOptimalAssert,"{'startLine':129,'endLine':129}","it(""should get a hard error from the DataSource with some data found in the cache with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new ErrorDataSource(503, ""Timeout""),
            cache: {
                test: {
                    0: {
                        summary: ""in cache""
                    },
                    5: {
                        summary: ""in cache""
                    }
                }
            }
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                // Ensure onNext is called correctly
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(err.length).toBe(4);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i + 1, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",snuts
/test/testRunner.js,NonFunctionalStatement,"{'startLine':7,'endLine':7}",Unknown,snuts
/test/getTestRunner.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/performance/testRunner.js,NonFunctionalStatement,"{'startLine':19,'endLine':19}",Unknown,snuts
/test/data/ErrorDataSource.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/performance/tests/request/request-queue.js,NonFunctionalStatement,"{'startLine':4,'endLine':4}",Unknown,snuts
/performance/tests/request/request-queue.js,NonFunctionalStatement,"{'startLine':59,'endLine':59}",Unknown,snuts
/performance/tests/request/request-queue.js,NonFunctionalStatement,"{'startLine':64,'endLine':64}",Unknown,snuts
/performance/tests/request/request-queue.js,NonFunctionalStatement,"{'startLine':69,'endLine':69}",Unknown,snuts
/performance/tests/request/request-queue.js,NonFunctionalStatement,"{'startLine':70,'endLine':70}",Unknown,snuts
/performance/tests/request/request-queue.js,NonFunctionalStatement,"{'startLine':75,'endLine':75}",Unknown,snuts
/performance/tests/request/request-queue.js,NonFunctionalStatement,"{'startLine':76,'endLine':76}",Unknown,snuts
/performance/tests/request/request-queue.js,NonFunctionalStatement,"{'startLine':81,'endLine':81}",Unknown,snuts
/performance/tests/request/request-queue.js,NonFunctionalStatement,"{'startLine':82,'endLine':82}",Unknown,snuts
/performance/tests/request/request-queue.js,NonFunctionalStatement,"{'startLine':87,'endLine':87}",Unknown,snuts
/performance/tests/request/request-queue.js,NonFunctionalStatement,"{'startLine':88,'endLine':88}",Unknown,snuts
/performance/tests/set/set.json-graph.perf.js,NonFunctionalStatement,"{'startLine':2,'endLine':2}",Unknown,snuts
/performance/tests/get/get.perf.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/performance/tests/get/get.perf.js,NonFunctionalStatement,"{'startLine':60,'endLine':61}",Unknown,snuts
/performance/tests/get/get.core.perf.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/performance/tests/deref/index.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/test/Model.spec.js,Conditional Test Logic,"{'line': 116, 'column': 32, 'index': 3654}","it(""unsubscribing should cancel DataSource request."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        subscription.dispose();

        if (
            dataSourceGetCalled === 1 &&
            !onNextCalled &&
            unusubscribeCalled === 1 &&
            !onErrorCalled &&
            !onCompletedCalled
        ) {
            done();
        } else {
            done(new Error(""DataSource unsubscribe not called.""));
        }
    })",steel
/test/Model.spec.js,Conditional Test Logic,"{'line': 151, 'column': 8, 'index': 4759}","it(""unsubscribing should cancel DataSource request."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        subscription.dispose();

        if (
            dataSourceGetCalled === 1 &&
            !onNextCalled &&
            unusubscribeCalled === 1 &&
            !onErrorCalled &&
            !onCompletedCalled
        ) {
            done();
        } else {
            done(new Error(""DataSource unsubscribe not called.""));
        }
    })",steel
/test/Model.spec.js,Conditional Test Logic,"{'line': 194, 'column': 32, 'index': 6292}","it(""unsubscribing should dispose batched DataSource request."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;
        let onDataSourceGet, onDisposedOrCompleted;

        let model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                onDataSourceGet && onDataSourceGet();
                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }

                                onDisposedOrCompleted &&
                                    onDisposedOrCompleted();
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });
        model = model.batch();

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        onDataSourceGet = function () {
            subscription.dispose();
        };

        onDisposedOrCompleted = function () {
            if (
                dataSourceGetCalled === 1 &&
                !onNextCalled &&
                unusubscribeCalled === 1 &&
                !onErrorCalled &&
                !onCompletedCalled
            ) {
                done();
            } else {
                done(new Error(""DataSource dispose not called.""));
            }
        };
    })",steel
/test/Model.spec.js,Conditional Test Logic,"{'line': 236, 'column': 12, 'index': 7652}","it(""unsubscribing should dispose batched DataSource request."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;
        let onDataSourceGet, onDisposedOrCompleted;

        let model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                onDataSourceGet && onDataSourceGet();
                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }

                                onDisposedOrCompleted &&
                                    onDisposedOrCompleted();
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });
        model = model.batch();

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        onDataSourceGet = function () {
            subscription.dispose();
        };

        onDisposedOrCompleted = function () {
            if (
                dataSourceGetCalled === 1 &&
                !onNextCalled &&
                unusubscribeCalled === 1 &&
                !onErrorCalled &&
                !onCompletedCalled
            ) {
                done();
            } else {
                done(new Error(""DataSource dispose not called.""));
            }
        };
    })",steel
/test/Model.spec.js,Conditional Test Logic,"{'line': 280, 'column': 32, 'index': 9253}","it('unsubscribing should ""unsubscribe"" batched DataSource request, if applicable.', (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;
        let onDataSourceGet, onDisposedOrCompleted;

        let model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                onDataSourceGet && onDataSourceGet();
                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }

                                onDisposedOrCompleted &&
                                    onDisposedOrCompleted();
                            });

                            return {
                                unsubscribe() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });
        model = model.batch();

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        onDataSourceGet = function () {
            subscription.dispose();
        };

        onDisposedOrCompleted = function () {
            if (
                dataSourceGetCalled === 1 &&
                !onNextCalled &&
                unusubscribeCalled === 1 &&
                !onErrorCalled &&
                !onCompletedCalled
            ) {
                done();
            } else {
                done(new Error(""DataSource unsubscribe not called.""));
            }
        };
    })",steel
/test/Model.spec.js,Conditional Test Logic,"{'line': 322, 'column': 12, 'index': 10617}","it('unsubscribing should ""unsubscribe"" batched DataSource request, if applicable.', (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;
        let onDataSourceGet, onDisposedOrCompleted;

        let model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                onDataSourceGet && onDataSourceGet();
                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }

                                onDisposedOrCompleted &&
                                    onDisposedOrCompleted();
                            });

                            return {
                                unsubscribe() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });
        model = model.batch();

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        onDataSourceGet = function () {
            subscription.dispose();
        };

        onDisposedOrCompleted = function () {
            if (
                dataSourceGetCalled === 1 &&
                !onNextCalled &&
                unusubscribeCalled === 1 &&
                !onErrorCalled &&
                !onCompletedCalled
            ) {
                done();
            } else {
                done(new Error(""DataSource unsubscribe not called.""));
            }
        };
    })",steel
/test/Model.spec.js,Conditional Test Logic,"{'line': 364, 'column': 32, 'index': 12041}","it(""Supports RxJS 5."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });

        const subscription = rxjs.Observable.from(
            model.get(""list[0,1].name"")
        ).subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        subscription.unsubscribe();

        if (
            dataSourceGetCalled === 1 &&
            !onNextCalled &&
            unusubscribeCalled === 1 &&
            !onErrorCalled &&
            !onCompletedCalled
        ) {
            done();
        } else {
            done(new Error(""DataSource unsubscribe not called.""));
        }
    })",steel
/test/Model.spec.js,Conditional Test Logic,"{'line': 401, 'column': 8, 'index': 13194}","it(""Supports RxJS 5."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });

        const subscription = rxjs.Observable.from(
            model.get(""list[0,1].name"")
        ).subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        subscription.unsubscribe();

        if (
            dataSourceGetCalled === 1 &&
            !onNextCalled &&
            unusubscribeCalled === 1 &&
            !onErrorCalled &&
            !onCompletedCalled
        ) {
            done();
        } else {
            done(new Error(""DataSource unsubscribe not called.""));
        }
    })",steel
/test/Model.spec.js,Conditional Test Logic,"{'line': 458, 'column': 16, 'index': 15017}","it(""accepts boolean to disable"", () => {
                let model = new Model({ disablePathCollapse: true });
                expect(model._enablePathCollapse).toBe(false);

                for (let index = 0; index < notTrue.length; index++) {
                    model = new Model({ disablePathCollapse: notTrue[index] });
                    expect(model._enablePathCollapse).toBe(true);
                }
            })",steel
/test/Model.spec.js,Conditional Test Logic,"{'line': 487, 'column': 16, 'index': 16116}","it(""accepts boolean to disable"", () => {
                let model = new Model({ disableRequestDeduplication: true });
                expect(model._enableRequestDeduplication).toBe(false);

                for (let index = 0; index < notTrue.length; index++) {
                    model = new Model({
                        disableRequestDeduplication: notTrue[index],
                    });
                    expect(model._enableRequestDeduplication).toBe(true);
                }
            })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 423, 'column': 8, 'index': 13783}","it(""setMaxSize to a lower value forces a collect"", () => {
        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
        });
        const cache = model._root.cache;
        expect(cache.$size).toBeGreaterThan(0);
        model._setMaxSize(0);
        expect(cache.$size).toBe(0);
    })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 425, 'column': 8, 'index': 13861}","it(""setMaxSize to a lower value forces a collect"", () => {
        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
        });
        const cache = model._root.cache;
        expect(cache.$size).toBeGreaterThan(0);
        model._setMaxSize(0);
        expect(cache.$size).toBe(0);
    })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 456, 'column': 16, 'index': 14953}","it(""accepts boolean to disable"", () => {
                let model = new Model({ disablePathCollapse: true });
                expect(model._enablePathCollapse).toBe(false);

                for (let index = 0; index < notTrue.length; index++) {
                    model = new Model({ disablePathCollapse: notTrue[index] });
                    expect(model._enablePathCollapse).toBe(true);
                }
            })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 460, 'column': 20, 'index': 15172}","it(""accepts boolean to disable"", () => {
                let model = new Model({ disablePathCollapse: true });
                expect(model._enablePathCollapse).toBe(false);

                for (let index = 0; index < notTrue.length; index++) {
                    model = new Model({ disablePathCollapse: notTrue[index] });
                    expect(model._enablePathCollapse).toBe(true);
                }
            })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 466, 'column': 16, 'index': 15358}","it(""is enabled by default"", () => {
                let model = new Model();
                expect(model._enablePathCollapse).toBe(true);

                model = new Model({});
                expect(model._enablePathCollapse).toBe(true);
            })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 466, 'column': 16, 'index': 15358}","it(""is enabled by default"", () => {
                let model = new Model();
                expect(model._enablePathCollapse).toBe(true);

                model = new Model({});
                expect(model._enablePathCollapse).toBe(true);
            })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 469, 'column': 16, 'index': 15460}","it(""is enabled by default"", () => {
                let model = new Model();
                expect(model._enablePathCollapse).toBe(true);

                model = new Model({});
                expect(model._enablePathCollapse).toBe(true);
            })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 469, 'column': 16, 'index': 15460}","it(""is enabled by default"", () => {
                let model = new Model();
                expect(model._enablePathCollapse).toBe(true);

                model = new Model({});
                expect(model._enablePathCollapse).toBe(true);
            })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 485, 'column': 16, 'index': 16044}","it(""accepts boolean to disable"", () => {
                let model = new Model({ disableRequestDeduplication: true });
                expect(model._enableRequestDeduplication).toBe(false);

                for (let index = 0; index < notTrue.length; index++) {
                    model = new Model({
                        disableRequestDeduplication: notTrue[index],
                    });
                    expect(model._enableRequestDeduplication).toBe(true);
                }
            })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 491, 'column': 20, 'index': 16324}","it(""accepts boolean to disable"", () => {
                let model = new Model({ disableRequestDeduplication: true });
                expect(model._enableRequestDeduplication).toBe(false);

                for (let index = 0; index < notTrue.length; index++) {
                    model = new Model({
                        disableRequestDeduplication: notTrue[index],
                    });
                    expect(model._enableRequestDeduplication).toBe(true);
                }
            })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 497, 'column': 16, 'index': 16518}","it(""is enabled by default"", () => {
                let model = new Model();
                expect(model._enableRequestDeduplication).toBe(true);

                model = new Model({});
                expect(model._enableRequestDeduplication).toBe(true);
            })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 497, 'column': 16, 'index': 16518}","it(""is enabled by default"", () => {
                let model = new Model();
                expect(model._enableRequestDeduplication).toBe(true);

                model = new Model({});
                expect(model._enableRequestDeduplication).toBe(true);
            })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 500, 'column': 16, 'index': 16628}","it(""is enabled by default"", () => {
                let model = new Model();
                expect(model._enableRequestDeduplication).toBe(true);

                model = new Model({});
                expect(model._enableRequestDeduplication).toBe(true);
            })",steel
/test/Model.spec.js,Duplicate Assert,"{'line': 500, 'column': 16, 'index': 16628}","it(""is enabled by default"", () => {
                let model = new Model();
                expect(model._enableRequestDeduplication).toBe(true);

                model = new Model({});
                expect(model._enableRequestDeduplication).toBe(true);
            })",steel
/test/Model.spec.js,Magic Number,"{'line': 423, 'column': 44, 'index': 13819}","it(""setMaxSize to a lower value forces a collect"", () => {
        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
        });
        const cache = model._root.cache;
        expect(cache.$size).toBeGreaterThan(0);
        model._setMaxSize(0);
        expect(cache.$size).toBe(0);
    })",steel
/test/Model.spec.js,Magic Number,"{'line': 425, 'column': 33, 'index': 13886}","it(""setMaxSize to a lower value forces a collect"", () => {
        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
        });
        const cache = model._root.cache;
        expect(cache.$size).toBeGreaterThan(0);
        model._setMaxSize(0);
        expect(cache.$size).toBe(0);
    })",steel
/test/Model.spec.js,Magic Number,"{'line': 433, 'column': 39, 'index': 14141}","it(""maxRetries option is carried over to cloned Model instance"", () => {
        const model = new Model({
            maxRetries: 10,
        });
        expect(model._maxRetries).toBe(10);
        const batchingModel = model.batch(100);
        expect(batchingModel._maxRetries).toBe(10);
    })",steel
/test/Model.spec.js,Magic Number,"{'line': 435, 'column': 47, 'index': 14241}","it(""maxRetries option is carried over to cloned Model instance"", () => {
        const model = new Model({
            maxRetries: 10,
        });
        expect(model._maxRetries).toBe(10);
        const batchingModel = model.batch(100);
        expect(batchingModel._maxRetries).toBe(10);
    })",steel
/test/Model.spec.js,Sleepy Test,"{'line': 106, 'column': 43, 'index': 3200}","it(""unsubscribing should cancel DataSource request."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        subscription.dispose();

        if (
            dataSourceGetCalled === 1 &&
            !onNextCalled &&
            unusubscribeCalled === 1 &&
            !onErrorCalled &&
            !onCompletedCalled
        ) {
            done();
        } else {
            done(new Error(""DataSource unsubscribe not called.""));
        }
    })",steel
/test/Model.spec.js,Sleepy Test,"{'line': 183, 'column': 43, 'index': 5768}","it(""unsubscribing should dispose batched DataSource request."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;
        let onDataSourceGet, onDisposedOrCompleted;

        let model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                onDataSourceGet && onDataSourceGet();
                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }

                                onDisposedOrCompleted &&
                                    onDisposedOrCompleted();
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });
        model = model.batch();

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        onDataSourceGet = function () {
            subscription.dispose();
        };

        onDisposedOrCompleted = function () {
            if (
                dataSourceGetCalled === 1 &&
                !onNextCalled &&
                unusubscribeCalled === 1 &&
                !onErrorCalled &&
                !onCompletedCalled
            ) {
                done();
            } else {
                done(new Error(""DataSource dispose not called.""));
            }
        };
    })",steel
/test/Model.spec.js,Sleepy Test,"{'line': 269, 'column': 43, 'index': 8729}","it('unsubscribing should ""unsubscribe"" batched DataSource request, if applicable.', (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;
        let onDataSourceGet, onDisposedOrCompleted;

        let model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                onDataSourceGet && onDataSourceGet();
                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }

                                onDisposedOrCompleted &&
                                    onDisposedOrCompleted();
                            });

                            return {
                                unsubscribe() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });
        model = model.batch();

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        onDataSourceGet = function () {
            subscription.dispose();
        };

        onDisposedOrCompleted = function () {
            if (
                dataSourceGetCalled === 1 &&
                !onNextCalled &&
                unusubscribeCalled === 1 &&
                !onErrorCalled &&
                !onCompletedCalled
            ) {
                done();
            } else {
                done(new Error(""DataSource unsubscribe not called.""));
            }
        };
    })",steel
/test/Model.spec.js,Sleepy Test,"{'line': 354, 'column': 43, 'index': 11587}","it(""Supports RxJS 5."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });

        const subscription = rxjs.Observable.from(
            model.get(""list[0,1].name"")
        ).subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        subscription.unsubscribe();

        if (
            dataSourceGetCalled === 1 &&
            !onNextCalled &&
            unusubscribeCalled === 1 &&
            !onErrorCalled &&
            !onCompletedCalled
        ) {
            done();
        } else {
            done(new Error(""DataSource unsubscribe not called.""));
        }
    })",steel
/test/Model.spec.js,Unknown Test,"{'column': 4, 'line': 63}","it(""should construct a new Model"", () => {
        new Model();
    })",steel
/test/Model.spec.js,Unknown Test,"{'column': 4, 'line': 71}","it(""should have access to static helper methods."", () => {
        const ref = [""a"", ""b"", ""c""];
        const err = { ohhh: ""no!"" };

        let out = Model.ref(ref);
        testRunner.compare({ $type: $ref, value: ref }, out);

        out = Model.ref(""a.b.c"");
        testRunner.compare({ $type: $ref, value: ref }, out);

        out = Model.error(err);
        testRunner.compare({ $type: $error, value: err }, out);

        out = Model.atom(1337);
        testRunner.compare({ $type: $atom, value: 1337 }, out);
    })",steel
/test/Model.spec.js,Unknown Test,"{'column': 4, 'line': 88}","it(""unsubscribing should cancel DataSource request."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        subscription.dispose();

        if (
            dataSourceGetCalled === 1 &&
            !onNextCalled &&
            unusubscribeCalled === 1 &&
            !onErrorCalled &&
            !onCompletedCalled
        ) {
            done();
        } else {
            done(new Error(""DataSource unsubscribe not called.""));
        }
    })",steel
/test/Model.spec.js,Unknown Test,"{'column': 4, 'line': 164}","it(""unsubscribing should dispose batched DataSource request."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;
        let onDataSourceGet, onDisposedOrCompleted;

        let model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                onDataSourceGet && onDataSourceGet();
                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }

                                onDisposedOrCompleted &&
                                    onDisposedOrCompleted();
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });
        model = model.batch();

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        onDataSourceGet = function () {
            subscription.dispose();
        };

        onDisposedOrCompleted = function () {
            if (
                dataSourceGetCalled === 1 &&
                !onNextCalled &&
                unusubscribeCalled === 1 &&
                !onErrorCalled &&
                !onCompletedCalled
            ) {
                done();
            } else {
                done(new Error(""DataSource dispose not called.""));
            }
        };
    })",steel
/test/Model.spec.js,Unknown Test,"{'column': 4, 'line': 250}","it('unsubscribing should ""unsubscribe"" batched DataSource request, if applicable.', (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;
        let onDataSourceGet, onDisposedOrCompleted;

        let model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                onDataSourceGet && onDataSourceGet();
                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }

                                onDisposedOrCompleted &&
                                    onDisposedOrCompleted();
                            });

                            return {
                                unsubscribe() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });
        model = model.batch();

        const subscription = model.get(""list[0,1].name"").subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        onDataSourceGet = function () {
            subscription.dispose();
        };

        onDisposedOrCompleted = function () {
            if (
                dataSourceGetCalled === 1 &&
                !onNextCalled &&
                unusubscribeCalled === 1 &&
                !onErrorCalled &&
                !onCompletedCalled
            ) {
                done();
            } else {
                done(new Error(""DataSource unsubscribe not called.""));
            }
        };
    })",steel
/test/Model.spec.js,Unknown Test,"{'column': 4, 'line': 336}","it(""Supports RxJS 5."", (done) => {
        let onNextCalled = 0,
            onErrorCalled = 0,
            onCompletedCalled = 0,
            unusubscribeCalled = 0,
            dataSourceGetCalled = 0;

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" },
                },
            },
            source: {
                get() {
                    return {
                        subscribe(observerOrOnNext, onError, onCompleted) {
                            dataSourceGetCalled++;
                            const handle = setTimeout(() => {
                                const response = {
                                    jsonGraph: {
                                        list: {
                                            1: { name: ""another test"" },
                                        },
                                    },
                                    paths: [""list"", 1, ""name""],
                                };

                                if (typeof observerOrOnNext === ""function"") {
                                    observerOrOnNext(response);
                                    onCompleted();
                                } else {
                                    observerOrOnNext.onNext(response);
                                    observerOrOnNext.onCompleted();
                                }
                            });

                            return {
                                dispose() {
                                    unusubscribeCalled++;
                                    clearTimeout(handle);
                                },
                            };
                        },
                    };
                },
            },
        });

        const subscription = rxjs.Observable.from(
            model.get(""list[0,1].name"")
        ).subscribe(
            (value) => {
                onNextCalled++;
            },
            (error) => {
                onErrorCalled++;
            },
            () => {
                onCompletedCalled++;
            }
        );

        subscription.unsubscribe();

        if (
            dataSourceGetCalled === 1 &&
            !onNextCalled &&
            unusubscribeCalled === 1 &&
            !onErrorCalled &&
            !onCompletedCalled
        ) {
            done();
        } else {
            done(new Error(""DataSource unsubscribe not called.""));
        }
    })",steel
/test/set/edge-cases.spec.js,Conditional Test Logic,"{'line': 98, 'column': 12, 'index': 3459}","it(""set blows away the cache."", function() {
        var model = new Model({});
        var get = [[""genreList"", 1, 0, ""summary""]];

        // this mimicks the server setting cycle from the router.
        var set = [
            {
                jsonGraph: {""genreList"": {
                    ""0"": { ""$type"": $path, ""value"": [""lists"", ""abcd""] },
                    ""1"": { ""$type"": $path, ""value"": [""lists"", ""my-list""] }
                }},
                paths: [['genreList', {to:1}, 0, 'summary']]
            },
            {
                jsonGraph: {""lists"": {
                    ""abcd"": { ""0"": { ""$type"": $path, ""value"": [""videos"", 1234] } },
                    ""my-list"": { ""$type"": $path, ""value"": [""lists"", ""1x5x""] }
                }},
                paths: [[""genreList"", 1, 0, ""summary""]]
            },
            {
                jsonGraph: {""lists"": {""1x5x"": {
                    ""0"": { ""$type"": $path, ""value"": [""videos"", 553] }
                }}},
                paths: [[""genreList"", 1, 0, ""summary""]]
            },
            {
                jsonGraph: {""videos"": {""553"": {""summary"": {
                    ""$size"": 10,
                    ""$type"": $atom,
                    ""value"": {
                        ""title"": ""Running Man"",
                        ""url"": ""/movies/553""
                    }
                }}}},
                paths: [[""genreList"", 1, 0, ""summary""]]
            }
        ];

        set.forEach(function(s, i) {
            model._setJSONGs(model, [s]);
            if (i === 2) {
                expect(model._root.cache.lists).toBeDefined();
            }
        });

        model._getPathValuesAsPathMap(model, get, function(x) {
            expect(x).toEqual({ json: { genreList: { 1: { 0: { summary: {
                    ""title"": ""Running Man"",
                    ""url"": ""/movies/553""
                } } } } }
            });
        });
    })",steel
/test/set/edge-cases.spec.js,Eager Test,"{'line': 55, 'column': 15, 'index': 1858}","it('should set the cache in.', function() {
        var model = new Model();
        var cache = model._root.cache;
        var edgeCaseCache = {
            jsonGraph: {
                user: {
                    name: {$type: $atom, value: ""Jim""},
                    location: {$type: ""error"", value: ""Something broke!""},
                    age: {$type: $atom}
                }
            },
            paths: [
                ['user', ['name', 'location', 'age']]
            ]
        };

        model._setJSONGs(model, [edgeCaseCache]);
        expect(strip(cache)).toEqual(strip(edgeCaseCache.jsonGraph));
    })",steel
/test/set/edge-cases.spec.js,Eager Test,"{'line': 55, 'column': 37, 'index': 1880}","it('should set the cache in.', function() {
        var model = new Model();
        var cache = model._root.cache;
        var edgeCaseCache = {
            jsonGraph: {
                user: {
                    name: {$type: $atom, value: ""Jim""},
                    location: {$type: ""error"", value: ""Something broke!""},
                    age: {$type: $atom}
                }
            },
            paths: [
                ['user', ['name', 'location', 'age']]
            ]
        };

        model._setJSONGs(model, [edgeCaseCache]);
        expect(strip(cache)).toEqual(strip(edgeCaseCache.jsonGraph));
    })",steel
/test/set/edge-cases.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 38}",Unknown,steel
/test/set/edge-cases.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 157}",Unknown,steel
/test/set/edge-cases.spec.js,Global Variable,"{'line': 7, 'column': 0, 'index': 207}",Unknown,steel
/test/set/edge-cases.spec.js,Global Variable,"{'line': 18, 'column': 8, 'index': 661}","it('should set in an array and the length should be set in.', function(done) {
        var model = new Model();
        var onNext = jest.fn();
        toObservable(model.
            set({
                json: {
                    foo: ['bar']
                }
            })).
            flatMap(function() {
                return model.get('foo.length');
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(cleanStrip(onNext.mock.calls[0][0])).toEqual({
                    json: {foo: { length: 1 } }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/set/edge-cases.spec.js,Global Variable,"{'line': 19, 'column': 8, 'index': 694}","it('should set in an array and the length should be set in.', function(done) {
        var model = new Model();
        var onNext = jest.fn();
        toObservable(model.
            set({
                json: {
                    foo: ['bar']
                }
            })).
            flatMap(function() {
                return model.get('foo.length');
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(cleanStrip(onNext.mock.calls[0][0])).toEqual({
                    json: {foo: { length: 1 } }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/set/edge-cases.spec.js,Global Variable,"{'line': 39, 'column': 8, 'index': 1345}","it('should set the cache in.', function() {
        var model = new Model();
        var cache = model._root.cache;
        var edgeCaseCache = {
            jsonGraph: {
                user: {
                    name: {$type: $atom, value: ""Jim""},
                    location: {$type: ""error"", value: ""Something broke!""},
                    age: {$type: $atom}
                }
            },
            paths: [
                ['user', ['name', 'location', 'age']]
            ]
        };

        model._setJSONGs(model, [edgeCaseCache]);
        expect(strip(cache)).toEqual(strip(edgeCaseCache.jsonGraph));
    })",steel
/test/set/edge-cases.spec.js,Global Variable,"{'line': 40, 'column': 8, 'index': 1378}","it('should set the cache in.', function() {
        var model = new Model();
        var cache = model._root.cache;
        var edgeCaseCache = {
            jsonGraph: {
                user: {
                    name: {$type: $atom, value: ""Jim""},
                    location: {$type: ""error"", value: ""Something broke!""},
                    age: {$type: $atom}
                }
            },
            paths: [
                ['user', ['name', 'location', 'age']]
            ]
        };

        model._setJSONGs(model, [edgeCaseCache]);
        expect(strip(cache)).toEqual(strip(edgeCaseCache.jsonGraph));
    })",steel
/test/set/edge-cases.spec.js,Global Variable,"{'line': 41, 'column': 8, 'index': 1417}","it('should set the cache in.', function() {
        var model = new Model();
        var cache = model._root.cache;
        var edgeCaseCache = {
            jsonGraph: {
                user: {
                    name: {$type: $atom, value: ""Jim""},
                    location: {$type: ""error"", value: ""Something broke!""},
                    age: {$type: $atom}
                }
            },
            paths: [
                ['user', ['name', 'location', 'age']]
            ]
        };

        model._setJSONGs(model, [edgeCaseCache]);
        expect(strip(cache)).toEqual(strip(edgeCaseCache.jsonGraph));
    })",steel
/test/set/edge-cases.spec.js,Global Variable,"{'line': 58, 'column': 8, 'index': 1978}","it(""set blows away the cache."", function() {
        var model = new Model({});
        var get = [[""genreList"", 1, 0, ""summary""]];

        // this mimicks the server setting cycle from the router.
        var set = [
            {
                jsonGraph: {""genreList"": {
                    ""0"": { ""$type"": $path, ""value"": [""lists"", ""abcd""] },
                    ""1"": { ""$type"": $path, ""value"": [""lists"", ""my-list""] }
                }},
                paths: [['genreList', {to:1}, 0, 'summary']]
            },
            {
                jsonGraph: {""lists"": {
                    ""abcd"": { ""0"": { ""$type"": $path, ""value"": [""videos"", 1234] } },
                    ""my-list"": { ""$type"": $path, ""value"": [""lists"", ""1x5x""] }
                }},
                paths: [[""genreList"", 1, 0, ""summary""]]
            },
            {
                jsonGraph: {""lists"": {""1x5x"": {
                    ""0"": { ""$type"": $path, ""value"": [""videos"", 553] }
                }}},
                paths: [[""genreList"", 1, 0, ""summary""]]
            },
            {
                jsonGraph: {""videos"": {""553"": {""summary"": {
                    ""$size"": 10,
                    ""$type"": $atom,
                    ""value"": {
                        ""title"": ""Running Man"",
                        ""url"": ""/movies/553""
                    }
                }}}},
                paths: [[""genreList"", 1, 0, ""summary""]]
            }
        ];

        set.forEach(function(s, i) {
            model._setJSONGs(model, [s]);
            if (i === 2) {
                expect(model._root.cache.lists).toBeDefined();
            }
        });

        model._getPathValuesAsPathMap(model, get, function(x) {
            expect(x).toEqual({ json: { genreList: { 1: { 0: { summary: {
                    ""title"": ""Running Man"",
                    ""url"": ""/movies/553""
                } } } } }
            });
        });
    })",steel
/test/set/edge-cases.spec.js,Global Variable,"{'line': 59, 'column': 8, 'index': 2013}","it(""set blows away the cache."", function() {
        var model = new Model({});
        var get = [[""genreList"", 1, 0, ""summary""]];

        // this mimicks the server setting cycle from the router.
        var set = [
            {
                jsonGraph: {""genreList"": {
                    ""0"": { ""$type"": $path, ""value"": [""lists"", ""abcd""] },
                    ""1"": { ""$type"": $path, ""value"": [""lists"", ""my-list""] }
                }},
                paths: [['genreList', {to:1}, 0, 'summary']]
            },
            {
                jsonGraph: {""lists"": {
                    ""abcd"": { ""0"": { ""$type"": $path, ""value"": [""videos"", 1234] } },
                    ""my-list"": { ""$type"": $path, ""value"": [""lists"", ""1x5x""] }
                }},
                paths: [[""genreList"", 1, 0, ""summary""]]
            },
            {
                jsonGraph: {""lists"": {""1x5x"": {
                    ""0"": { ""$type"": $path, ""value"": [""videos"", 553] }
                }}},
                paths: [[""genreList"", 1, 0, ""summary""]]
            },
            {
                jsonGraph: {""videos"": {""553"": {""summary"": {
                    ""$size"": 10,
                    ""$type"": $atom,
                    ""value"": {
                        ""title"": ""Running Man"",
                        ""url"": ""/movies/553""
                    }
                }}}},
                paths: [[""genreList"", 1, 0, ""summary""]]
            }
        ];

        set.forEach(function(s, i) {
            model._setJSONGs(model, [s]);
            if (i === 2) {
                expect(model._root.cache.lists).toBeDefined();
            }
        });

        model._getPathValuesAsPathMap(model, get, function(x) {
            expect(x).toEqual({ json: { genreList: { 1: { 0: { summary: {
                    ""title"": ""Running Man"",
                    ""url"": ""/movies/553""
                } } } } }
            });
        });
    })",steel
/test/set/edge-cases.spec.js,Global Variable,"{'line': 62, 'column': 8, 'index': 2132}","it(""set blows away the cache."", function() {
        var model = new Model({});
        var get = [[""genreList"", 1, 0, ""summary""]];

        // this mimicks the server setting cycle from the router.
        var set = [
            {
                jsonGraph: {""genreList"": {
                    ""0"": { ""$type"": $path, ""value"": [""lists"", ""abcd""] },
                    ""1"": { ""$type"": $path, ""value"": [""lists"", ""my-list""] }
                }},
                paths: [['genreList', {to:1}, 0, 'summary']]
            },
            {
                jsonGraph: {""lists"": {
                    ""abcd"": { ""0"": { ""$type"": $path, ""value"": [""videos"", 1234] } },
                    ""my-list"": { ""$type"": $path, ""value"": [""lists"", ""1x5x""] }
                }},
                paths: [[""genreList"", 1, 0, ""summary""]]
            },
            {
                jsonGraph: {""lists"": {""1x5x"": {
                    ""0"": { ""$type"": $path, ""value"": [""videos"", 553] }
                }}},
                paths: [[""genreList"", 1, 0, ""summary""]]
            },
            {
                jsonGraph: {""videos"": {""553"": {""summary"": {
                    ""$size"": 10,
                    ""$type"": $atom,
                    ""value"": {
                        ""title"": ""Running Man"",
                        ""url"": ""/movies/553""
                    }
                }}}},
                paths: [[""genreList"", 1, 0, ""summary""]]
            }
        ];

        set.forEach(function(s, i) {
            model._setJSONGs(model, [s]);
            if (i === 2) {
                expect(model._root.cache.lists).toBeDefined();
            }
        });

        model._getPathValuesAsPathMap(model, get, function(x) {
            expect(x).toEqual({ json: { genreList: { 1: { 0: { summary: {
                    ""title"": ""Running Man"",
                    ""url"": ""/movies/553""
                } } } } }
            });
        });
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 18, 'column': 12, 'index': 590}","it(""throws with a `null` key in a branch position"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        expect(() =>
            setPathValues(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
            ])).toThrow(NullInPathError);
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 19, 'column': 16, 'index': 621}","it(""throws with a `null` key in a branch position"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        expect(() =>
            setPathValues(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
            ])).toThrow(NullInPathError);
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 28, 'column': 8, 'index': 908}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 29, 'column': 12, 'index': 935}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 33, 'column': 15, 'index': 1084}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 33, 'column': 37, 'index': 1106}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 46, 'column': 8, 'index': 1397}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 47, 'column': 12, 'index': 1424}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 55, 'column': 8, 'index': 1789}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 56, 'column': 12, 'index': 1816}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 61, 'column': 15, 'index': 1980}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 61, 'column': 37, 'index': 2002}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 77, 'column': 8, 'index': 2452}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 78, 'column': 12, 'index': 2479}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 87, 'column': 15, 'index': 2906}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 87, 'column': 37, 'index': 2928}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 104, 'column': 8, 'index': 3366}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 105, 'column': 12, 'index': 3393}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 113, 'column': 15, 'index': 3753}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 113, 'column': 37, 'index': 3775}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 129, 'column': 8, 'index': 4230}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 130, 'column': 12, 'index': 4257}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 138, 'column': 15, 'index': 4619}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 138, 'column': 37, 'index': 4641}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 150, 'column': 8, 'index': 5043}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], ""foo-value-1""),
                $pathValue([""foo"", ""value"", null], ""foo-value-2"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 151, 'column': 12, 'index': 5070}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], ""foo-value-1""),
                $pathValue([""foo"", ""value"", null], ""foo-value-2"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 159, 'column': 15, 'index': 5415}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], ""foo-value-1""),
                $pathValue([""foo"", ""value"", null], ""foo-value-2"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 159, 'column': 37, 'index': 5437}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], ""foo-value-1""),
                $pathValue([""foo"", ""value"", null], ""foo-value-2"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 171, 'column': 16, 'index': 5777}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 172, 'column': 20, 'index': 5812}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 177, 'column': 23, 'index': 6051}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 177, 'column': 45, 'index': 6073}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 189, 'column': 16, 'index': 6592}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 190, 'column': 20, 'index': 6627}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 201, 'column': 23, 'index': 7305}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 201, 'column': 45, 'index': 7327}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 222, 'column': 16, 'index': 8196}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 223, 'column': 20, 'index': 8231}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 234, 'column': 23, 'index': 8906}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 234, 'column': 45, 'index': 8928}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 253, 'column': 16, 'index': 9750}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 254, 'column': 20, 'index': 9785}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 264, 'column': 23, 'index': 10374}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 264, 'column': 45, 'index': 10396}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 281, 'column': 16, 'index': 11071}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 282, 'column': 20, 'index': 11106}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 293, 'column': 23, 'index': 11793}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 293, 'column': 45, 'index': 11815}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 312, 'column': 16, 'index': 12641}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 313, 'column': 20, 'index': 12676}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 323, 'column': 23, 'index': 13286}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 323, 'column': 45, 'index': 13308}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 340, 'column': 16, 'index': 13985}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 341, 'column': 20, 'index': 14020}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 352, 'column': 23, 'index': 14709}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Eager Test,"{'line': 352, 'column': 45, 'index': 14731}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 13, 'column': 8, 'index': 493}","it(""throws with a `null` key in a branch position"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        expect(() =>
            setPathValues(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
            ])).toThrow(NullInPathError);
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 14, 'column': 8, 'index': 515}","it(""throws with a `null` key in a branch position"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        expect(() =>
            setPathValues(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
            ])).toThrow(NullInPathError);
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 15, 'column': 8, 'index': 539}","it(""throws with a `null` key in a branch position"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        expect(() =>
            setPathValues(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
            ])).toThrow(NullInPathError);
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 26, 'column': 8, 'index': 859}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 27, 'column': 8, 'index': 883}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 43, 'column': 8, 'index': 1326}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 44, 'column': 8, 'index': 1348}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 45, 'column': 8, 'index': 1372}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 75, 'column': 8, 'index': 2403}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 76, 'column': 8, 'index': 2427}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 102, 'column': 8, 'index': 3317}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 103, 'column': 8, 'index': 3341}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 127, 'column': 8, 'index': 4181}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 128, 'column': 8, 'index': 4205}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 148, 'column': 8, 'index': 4994}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], ""foo-value-1""),
                $pathValue([""foo"", ""value"", null], ""foo-value-2"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 149, 'column': 8, 'index': 5018}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], ""foo-value-1""),
                $pathValue([""foo"", ""value"", null], ""foo-value-2"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 169, 'column': 16, 'index': 5712}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 170, 'column': 16, 'index': 5744}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 187, 'column': 16, 'index': 6527}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 188, 'column': 16, 'index': 6559}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 220, 'column': 16, 'index': 8131}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 221, 'column': 16, 'index': 8163}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 251, 'column': 16, 'index': 9685}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 252, 'column': 16, 'index': 9717}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 279, 'column': 16, 'index': 11006}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 280, 'column': 16, 'index': 11038}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 310, 'column': 16, 'index': 12576}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 311, 'column': 16, 'index': 12608}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 338, 'column': 16, 'index': 13920}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Global Variable,"{'line': 339, 'column': 16, 'index': 13952}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 18, 'column': 12, 'index': 590}","it(""throws with a `null` key in a branch position"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        expect(() =>
            setPathValues(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
            ])).toThrow(NullInPathError);
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 19, 'column': 16, 'index': 621}","it(""throws with a `null` key in a branch position"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        expect(() =>
            setPathValues(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
            ])).toThrow(NullInPathError);
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 28, 'column': 8, 'index': 908}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 29, 'column': 12, 'index': 935}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 33, 'column': 15, 'index': 1084}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 46, 'column': 8, 'index': 1397}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 47, 'column': 12, 'index': 1424}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 61, 'column': 15, 'index': 1980}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 77, 'column': 8, 'index': 2452}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 78, 'column': 12, 'index': 2479}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 87, 'column': 15, 'index': 2906}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 104, 'column': 8, 'index': 3366}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 105, 'column': 12, 'index': 3393}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 113, 'column': 15, 'index': 3753}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 129, 'column': 8, 'index': 4230}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 130, 'column': 12, 'index': 4257}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 138, 'column': 15, 'index': 4619}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 150, 'column': 8, 'index': 5043}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], ""foo-value-1""),
                $pathValue([""foo"", ""value"", null], ""foo-value-2"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 151, 'column': 12, 'index': 5070}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], ""foo-value-1""),
                $pathValue([""foo"", ""value"", null], ""foo-value-2"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 159, 'column': 15, 'index': 5415}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], ""foo-value-1""),
                $pathValue([""foo"", ""value"", null], ""foo-value-2"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 171, 'column': 16, 'index': 5777}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 172, 'column': 20, 'index': 5812}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 177, 'column': 23, 'index': 6051}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 189, 'column': 16, 'index': 6592}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 190, 'column': 20, 'index': 6627}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 201, 'column': 23, 'index': 7305}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 222, 'column': 16, 'index': 8196}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 223, 'column': 20, 'index': 8231}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 234, 'column': 23, 'index': 8906}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 253, 'column': 16, 'index': 9750}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 254, 'column': 20, 'index': 9785}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 264, 'column': 23, 'index': 10374}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 281, 'column': 16, 'index': 11071}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 282, 'column': 20, 'index': 11106}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 293, 'column': 23, 'index': 11793}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 312, 'column': 16, 'index': 12641}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 313, 'column': 20, 'index': 12676}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 323, 'column': 23, 'index': 13286}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 340, 'column': 16, 'index': 13985}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 341, 'column': 20, 'index': 14020}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/primitive.spec.js,Lazy Test,"{'line': 352, 'column': 23, 'index': 14709}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathValues/expired.spec.js,Eager Test,"{'line': 16, 'column': 8, 'index': 482}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Eager Test,"{'line': 17, 'column': 12, 'index': 509}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Eager Test,"{'line': 28, 'column': 15, 'index': 906}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Eager Test,"{'line': 28, 'column': 37, 'index': 928}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Eager Test,"{'line': 41, 'column': 8, 'index': 1241}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Eager Test,"{'line': 42, 'column': 12, 'index': 1268}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Eager Test,"{'line': 52, 'column': 15, 'index': 1657}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Eager Test,"{'line': 52, 'column': 37, 'index': 1679}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Eager Test,"{'line': 65, 'column': 8, 'index': 2008}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Eager Test,"{'line': 66, 'column': 12, 'index': 2035}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Eager Test,"{'line': 76, 'column': 15, 'index': 2437}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Eager Test,"{'line': 76, 'column': 37, 'index': 2459}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Global Variable,"{'line': 13, 'column': 8, 'index': 432}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Global Variable,"{'line': 14, 'column': 8, 'index': 456}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Global Variable,"{'line': 24, 'column': 8, 'index': 772}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Global Variable,"{'line': 25, 'column': 8, 'index': 811}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Global Variable,"{'line': 36, 'column': 8, 'index': 1129}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Global Variable,"{'line': 37, 'column': 8, 'index': 1165}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Global Variable,"{'line': 38, 'column': 8, 'index': 1189}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Global Variable,"{'line': 39, 'column': 8, 'index': 1214}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Global Variable,"{'line': 60, 'column': 8, 'index': 1896}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Global Variable,"{'line': 61, 'column': 8, 'index': 1932}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Global Variable,"{'line': 62, 'column': 8, 'index': 1956}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Global Variable,"{'line': 63, 'column': 8, 'index': 1981}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Lazy Test,"{'line': 16, 'column': 8, 'index': 482}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Lazy Test,"{'line': 17, 'column': 12, 'index': 509}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Lazy Test,"{'line': 28, 'column': 15, 'index': 906}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Lazy Test,"{'line': 41, 'column': 8, 'index': 1241}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Lazy Test,"{'line': 42, 'column': 12, 'index': 1268}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Lazy Test,"{'line': 52, 'column': 15, 'index': 1657}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Lazy Test,"{'line': 65, 'column': 8, 'index': 2008}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Lazy Test,"{'line': 66, 'column': 12, 'index': 2035}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Lazy Test,"{'line': 76, 'column': 15, 'index': 2437}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Magic Number,"{'line': 51, 'column': 36, 'index': 1638}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/expired.spec.js,Magic Number,"{'line': 75, 'column': 36, 'index': 2418}","it(""sets through an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathValues(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathValue(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 22, 'column': 8, 'index': 732}","it('should allow null at end of path.', function() {
        var cache = {
            a: $ref(['b']),
            b: 'title'
        };
        var model = new Model({
            cache: cache
        });

        setPathValues(
                model,
                [{
                    path: ['a', null],
                    value: 'summary'
                }]
        );

        expect(strip(model._root.cache)).toEqual(strip({
            a: $ref(['b']),
            b: $atom('summary')
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 30, 'column': 15, 'index': 911}","it('should allow null at end of path.', function() {
        var cache = {
            a: $ref(['b']),
            b: 'title'
        };
        var model = new Model({
            cache: cache
        });

        setPathValues(
                model,
                [{
                    path: ['a', null],
                    value: 'summary'
                }]
        );

        expect(strip(model._root.cache)).toEqual(strip({
            a: $ref(['b']),
            b: $atom('summary')
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 30, 'column': 49, 'index': 945}","it('should allow null at end of path.', function() {
        var cache = {
            a: $ref(['b']),
            b: 'title'
        };
        var model = new Model({
            cache: cache
        });

        setPathValues(
                model,
                [{
                    path: ['a', null],
                    value: 'summary'
                }]
        );

        expect(strip(model._root.cache)).toEqual(strip({
            a: $ref(['b']),
            b: $atom('summary')
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 53, 'column': 8, 'index': 1493}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 54, 'column': 12, 'index': 1520}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 60, 'column': 15, 'index': 1756}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 60, 'column': 37, 'index': 1778}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 69, 'column': 8, 'index': 1992}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 70, 'column': 12, 'index': 2019}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 78, 'column': 8, 'index': 2380}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 79, 'column': 12, 'index': 2407}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 84, 'column': 15, 'index': 2563}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 84, 'column': 37, 'index': 2585}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 99, 'column': 8, 'index': 2984}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 100, 'column': 12, 'index': 3011}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 106, 'column': 15, 'index': 3247}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 106, 'column': 37, 'index': 3269}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 115, 'column': 8, 'index': 3476}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 116, 'column': 12, 'index': 3503}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 124, 'column': 8, 'index': 3864}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 125, 'column': 12, 'index': 3891}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 130, 'column': 15, 'index': 4047}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Eager Test,"{'line': 130, 'column': 37, 'index': 4069}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Global Variable,"{'line': 14, 'column': 8, 'index': 578}","it('should allow null at end of path.', function() {
        var cache = {
            a: $ref(['b']),
            b: 'title'
        };
        var model = new Model({
            cache: cache
        });

        setPathValues(
                model,
                [{
                    path: ['a', null],
                    value: 'summary'
                }]
        );

        expect(strip(model._root.cache)).toEqual(strip({
            a: $ref(['b']),
            b: $atom('summary')
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Global Variable,"{'line': 18, 'column': 8, 'index': 662}","it('should allow null at end of path.', function() {
        var cache = {
            a: $ref(['b']),
            b: 'title'
        };
        var model = new Model({
            cache: cache
        });

        setPathValues(
                model,
                [{
                    path: ['a', null],
                    value: 'summary'
                }]
        );

        expect(strip(model._root.cache)).toEqual(strip({
            a: $ref(['b']),
            b: $atom('summary')
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Global Variable,"{'line': 37, 'column': 8, 'index': 1118}","it('should throw an error if null is in middle of path.', function() {
        var model = new Model();
        var error;
        expect(() => 
            setPathValues(
                model,
                [{
                    path: ['a', null, 'c'],
                    value: 'summary'
                }]
            )).toThrow(NullInPathError);
    })",steel
/test/set/pathValues/branch.spec.js,Global Variable,"{'line': 38, 'column': 8, 'index': 1151}","it('should throw an error if null is in middle of path.', function() {
        var model = new Model();
        var error;
        expect(() => 
            setPathValues(
                model,
                [{
                    path: ['a', null, 'c'],
                    value: 'summary'
                }]
            )).toThrow(NullInPathError);
    })",steel
/test/set/pathValues/branch.spec.js,Global Variable,"{'line': 51, 'column': 8, 'index': 1444}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Global Variable,"{'line': 52, 'column': 8, 'index': 1468}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Global Variable,"{'line': 67, 'column': 8, 'index': 1943}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Global Variable,"{'line': 68, 'column': 8, 'index': 1967}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Global Variable,"{'line': 97, 'column': 8, 'index': 2935}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Global Variable,"{'line': 98, 'column': 8, 'index': 2959}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Global Variable,"{'line': 113, 'column': 8, 'index': 3427}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Global Variable,"{'line': 114, 'column': 8, 'index': 3451}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 22, 'column': 8, 'index': 732}","it('should allow null at end of path.', function() {
        var cache = {
            a: $ref(['b']),
            b: 'title'
        };
        var model = new Model({
            cache: cache
        });

        setPathValues(
                model,
                [{
                    path: ['a', null],
                    value: 'summary'
                }]
        );

        expect(strip(model._root.cache)).toEqual(strip({
            a: $ref(['b']),
            b: $atom('summary')
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 30, 'column': 15, 'index': 911}","it('should allow null at end of path.', function() {
        var cache = {
            a: $ref(['b']),
            b: 'title'
        };
        var model = new Model({
            cache: cache
        });

        setPathValues(
                model,
                [{
                    path: ['a', null],
                    value: 'summary'
                }]
        );

        expect(strip(model._root.cache)).toEqual(strip({
            a: $ref(['b']),
            b: $atom('summary')
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 40, 'column': 12, 'index': 1196}","it('should throw an error if null is in middle of path.', function() {
        var model = new Model();
        var error;
        expect(() => 
            setPathValues(
                model,
                [{
                    path: ['a', null, 'c'],
                    value: 'summary'
                }]
            )).toThrow(NullInPathError);
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 53, 'column': 8, 'index': 1493}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 54, 'column': 12, 'index': 1520}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 60, 'column': 15, 'index': 1756}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 69, 'column': 8, 'index': 1992}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 70, 'column': 12, 'index': 2019}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 84, 'column': 15, 'index': 2563}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 99, 'column': 8, 'index': 2984}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 100, 'column': 12, 'index': 3011}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 106, 'column': 15, 'index': 3247}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 115, 'column': 8, 'index': 3476}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 116, 'column': 12, 'index': 3503}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/branch.spec.js,Lazy Test,"{'line': 130, 'column': 15, 'index': 4047}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 16, 'column': 8, 'index': 427}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 17, 'column': 12, 'index': 454}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 25, 'column': 15, 'index': 728}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 25, 'column': 37, 'index': 750}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 43, 'column': 8, 'index': 1166}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 44, 'column': 12, 'index': 1193}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 52, 'column': 8, 'index': 1558}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 53, 'column': 12, 'index': 1585}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 61, 'column': 15, 'index': 1857}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 61, 'column': 37, 'index': 1879}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 81, 'column': 8, 'index': 2443}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 82, 'column': 12, 'index': 2470}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 94, 'column': 15, 'index': 3007}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 94, 'column': 37, 'index': 3029}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 114, 'column': 8, 'index': 3580}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 115, 'column': 12, 'index': 3607}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 126, 'column': 15, 'index': 4077}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 126, 'column': 37, 'index': 4099}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 146, 'column': 8, 'index': 4670}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 147, 'column': 12, 'index': 4697}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 158, 'column': 15, 'index': 5167}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 158, 'column': 37, 'index': 5189}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 173, 'column': 8, 'index': 5680}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-1"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-2""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 174, 'column': 12, 'index': 5707}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-1"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-2""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 182, 'column': 15, 'index': 6066}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-1"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-2""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 182, 'column': 37, 'index': 6088}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-1"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-2""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 195, 'column': 8, 'index': 6388}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 196, 'column': 12, 'index': 6415}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 204, 'column': 8, 'index': 6719}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 205, 'column': 12, 'index': 6746}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 213, 'column': 15, 'index': 7058}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 213, 'column': 37, 'index': 7080}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 231, 'column': 16, 'index': 7576}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 232, 'column': 20, 'index': 7611}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 237, 'column': 23, 'index': 7859}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 237, 'column': 45, 'index': 7881}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 249, 'column': 16, 'index': 8427}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 250, 'column': 20, 'index': 8462}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 261, 'column': 23, 'index': 9154}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 261, 'column': 45, 'index': 9176}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 282, 'column': 16, 'index': 10072}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 283, 'column': 20, 'index': 10107}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 294, 'column': 23, 'index': 10796}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 294, 'column': 45, 'index': 10818}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 313, 'column': 16, 'index': 11667}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 314, 'column': 20, 'index': 11702}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 324, 'column': 23, 'index': 12305}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 324, 'column': 45, 'index': 12327}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 341, 'column': 16, 'index': 13020}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 342, 'column': 20, 'index': 13055}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 353, 'column': 23, 'index': 13756}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 353, 'column': 45, 'index': 13778}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 372, 'column': 16, 'index': 14631}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 373, 'column': 20, 'index': 14666}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 383, 'column': 23, 'index': 15290}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 383, 'column': 45, 'index': 15312}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 400, 'column': 16, 'index': 16007}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 401, 'column': 20, 'index': 16042}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 412, 'column': 23, 'index': 16745}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Eager Test,"{'line': 412, 'column': 45, 'index': 16767}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 13, 'column': 8, 'index': 377}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 14, 'column': 8, 'index': 401}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 39, 'column': 8, 'index': 1084}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 40, 'column': 8, 'index': 1116}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 41, 'column': 8, 'index': 1140}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 78, 'column': 8, 'index': 2393}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 79, 'column': 8, 'index': 2417}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 111, 'column': 8, 'index': 3530}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 112, 'column': 8, 'index': 3554}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 143, 'column': 8, 'index': 4620}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 144, 'column': 8, 'index': 4644}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 171, 'column': 8, 'index': 5631}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-1"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-2""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 172, 'column': 8, 'index': 5655}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-1"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-2""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 190, 'column': 8, 'index': 6270}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 191, 'column': 8, 'index': 6306}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 192, 'column': 8, 'index': 6338}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 193, 'column': 8, 'index': 6362}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 229, 'column': 16, 'index': 7511}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 230, 'column': 16, 'index': 7543}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 247, 'column': 16, 'index': 8362}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 248, 'column': 16, 'index': 8394}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 280, 'column': 16, 'index': 10007}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 281, 'column': 16, 'index': 10039}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 311, 'column': 16, 'index': 11602}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 312, 'column': 16, 'index': 11634}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 339, 'column': 16, 'index': 12955}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 340, 'column': 16, 'index': 12987}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 370, 'column': 16, 'index': 14566}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 371, 'column': 16, 'index': 14598}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 398, 'column': 16, 'index': 15942}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Global Variable,"{'line': 399, 'column': 16, 'index': 15974}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 16, 'column': 8, 'index': 427}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 17, 'column': 12, 'index': 454}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 25, 'column': 15, 'index': 728}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 43, 'column': 8, 'index': 1166}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 44, 'column': 12, 'index': 1193}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 61, 'column': 15, 'index': 1857}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 81, 'column': 8, 'index': 2443}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 82, 'column': 12, 'index': 2470}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 94, 'column': 15, 'index': 3007}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 114, 'column': 8, 'index': 3580}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 115, 'column': 12, 'index': 3607}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 126, 'column': 15, 'index': 4077}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 146, 'column': 8, 'index': 4670}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 147, 'column': 12, 'index': 4697}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 158, 'column': 15, 'index': 5167}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 173, 'column': 8, 'index': 5680}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-1"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-2""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 174, 'column': 12, 'index': 5707}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-1"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-2""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 182, 'column': 15, 'index': 6066}","it(""through a reference that lands on an atom with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathValues(
            getModel({ cache: cache, version: version++ }), [
                $pathValue(""foo.value"", $ref(""bar.value"")),
                $pathValue(""bar.value"", $atom(""bar-value"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-1"")),
                $pathValue([""foo"", ""value"", null], $atom(""foo-value-2""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            foo: { value: $ref(""bar.value"") },
            bar: { value: $atom(""foo-value-2"") }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 195, 'column': 8, 'index': 6388}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 196, 'column': 12, 'index': 6415}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 213, 'column': 15, 'index': 7058}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 231, 'column': 16, 'index': 7576}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 232, 'column': 20, 'index': 7611}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 237, 'column': 23, 'index': 7859}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 249, 'column': 16, 'index': 8427}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 250, 'column': 20, 'index': 8462}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 261, 'column': 23, 'index': 9154}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 282, 'column': 16, 'index': 10072}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 283, 'column': 20, 'index': 10107}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 294, 'column': 23, 'index': 10796}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 313, 'column': 16, 'index': 11667}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 314, 'column': 20, 'index': 11702}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 324, 'column': 23, 'index': 12305}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 341, 'column': 16, 'index': 13020}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 342, 'column': 20, 'index': 13055}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 353, 'column': 23, 'index': 13756}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 372, 'column': 16, 'index': 14631}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 373, 'column': 20, 'index': 14666}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 383, 'column': 23, 'index': 15290}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 400, 'column': 16, 'index': 16007}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 401, 'column': 20, 'index': 16042}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathValues/atom.spec.js,Lazy Test,"{'line': 412, 'column': 23, 'index': 16745}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathValues(
                    getModel({ cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 29, 'column': 8, 'index': 943}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 30, 'column': 12, 'index': 968}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 34, 'column': 15, 'index': 1123}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 34, 'column': 37, 'index': 1145}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 47, 'column': 8, 'index': 1436}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 48, 'column': 12, 'index': 1461}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 56, 'column': 8, 'index': 1850}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 57, 'column': 12, 'index': 1875}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 62, 'column': 15, 'index': 2045}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 62, 'column': 37, 'index': 2067}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 78, 'column': 8, 'index': 2517}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].title"", $atom()),
                $pathMapEnvelope(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 79, 'column': 12, 'index': 2542}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].title"", $atom()),
                $pathMapEnvelope(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 88, 'column': 15, 'index': 2999}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].title"", $atom()),
                $pathMapEnvelope(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 88, 'column': 37, 'index': 3021}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].title"", $atom()),
                $pathMapEnvelope(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 105, 'column': 8, 'index': 3459}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 106, 'column': 12, 'index': 3484}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 114, 'column': 15, 'index': 3868}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 114, 'column': 37, 'index': 3890}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 153, 'column': 16, 'index': 5251}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 154, 'column': 20, 'index': 5284}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 159, 'column': 23, 'index': 5529}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 159, 'column': 45, 'index': 5551}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 171, 'column': 16, 'index': 6070}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 172, 'column': 20, 'index': 6103}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 183, 'column': 23, 'index': 6823}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 183, 'column': 45, 'index': 6845}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 204, 'column': 16, 'index': 7714}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 205, 'column': 20, 'index': 7747}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 216, 'column': 23, 'index': 8464}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 216, 'column': 45, 'index': 8486}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 235, 'column': 16, 'index': 9308}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 236, 'column': 20, 'index': 9341}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 246, 'column': 23, 'index': 9966}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 246, 'column': 45, 'index': 9988}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 263, 'column': 16, 'index': 10663}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 264, 'column': 20, 'index': 10696}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 275, 'column': 23, 'index': 11425}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 275, 'column': 45, 'index': 11447}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 294, 'column': 16, 'index': 12273}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 295, 'column': 20, 'index': 12306}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 305, 'column': 23, 'index': 12952}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 305, 'column': 45, 'index': 12974}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 322, 'column': 16, 'index': 13651}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 323, 'column': 20, 'index': 13684}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 334, 'column': 23, 'index': 14415}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Eager Test,"{'line': 334, 'column': 45, 'index': 14437}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 13, 'column': 8, 'index': 495}","xit(""throws with a `null` key in a branch position"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        var errored = false;

        expect(() =>
            setPathMaps(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
            ])).toThrow(NullInPathError);
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 14, 'column': 8, 'index': 517}","xit(""throws with a `null` key in a branch position"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        var errored = false;

        expect(() =>
            setPathMaps(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
            ])).toThrow(NullInPathError);
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 15, 'column': 8, 'index': 541}","xit(""throws with a `null` key in a branch position"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        var errored = false;

        expect(() =>
            setPathMaps(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
            ])).toThrow(NullInPathError);
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 16, 'column': 8, 'index': 566}","xit(""throws with a `null` key in a branch position"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        var errored = false;

        expect(() =>
            setPathMaps(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
            ])).toThrow(NullInPathError);
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 27, 'column': 8, 'index': 894}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 28, 'column': 8, 'index': 918}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 44, 'column': 8, 'index': 1365}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 45, 'column': 8, 'index': 1387}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 46, 'column': 8, 'index': 1411}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 76, 'column': 8, 'index': 2468}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].title"", $atom()),
                $pathMapEnvelope(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 77, 'column': 8, 'index': 2492}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].title"", $atom()),
                $pathMapEnvelope(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 103, 'column': 8, 'index': 3410}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 104, 'column': 8, 'index': 3434}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 128, 'column': 8, 'index': 4297}","xit(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope([""grid"", 0, 2, null], ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 129, 'column': 8, 'index': 4321}","xit(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope([""grid"", 0, 2, null], ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 151, 'column': 16, 'index': 5186}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 152, 'column': 16, 'index': 5218}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 169, 'column': 16, 'index': 6005}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 170, 'column': 16, 'index': 6037}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 202, 'column': 16, 'index': 7649}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 203, 'column': 16, 'index': 7681}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 233, 'column': 16, 'index': 9243}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 234, 'column': 16, 'index': 9275}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 261, 'column': 16, 'index': 10598}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 262, 'column': 16, 'index': 10630}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 292, 'column': 16, 'index': 12208}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 293, 'column': 16, 'index': 12240}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 320, 'column': 16, 'index': 13586}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Global Variable,"{'line': 321, 'column': 16, 'index': 13618}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 29, 'column': 8, 'index': 943}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 30, 'column': 12, 'index': 968}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 34, 'column': 15, 'index': 1123}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
        ]);

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 47, 'column': 8, 'index': 1436}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 48, 'column': 12, 'index': 1461}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 62, 'column': 15, 'index': 2045}","it(""through a reference"", function() {
        var lru = {};
        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 78, 'column': 8, 'index': 2517}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].title"", $atom()),
                $pathMapEnvelope(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 79, 'column': 12, 'index': 2542}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].title"", $atom()),
                $pathMapEnvelope(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 88, 'column': 15, 'index': 2999}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].title"", $atom()),
                $pathMapEnvelope(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 105, 'column': 8, 'index': 3459}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 106, 'column': 12, 'index': 3484}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 114, 'column': 15, 'index': 3868}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].title"", ""Reservior Dogs"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 153, 'column': 16, 'index': 5251}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 154, 'column': 20, 'index': 5284}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 159, 'column': 23, 'index': 5529}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 171, 'column': 16, 'index': 6070}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 172, 'column': 20, 'index': 6103}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 183, 'column': 23, 'index': 6823}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 204, 'column': 16, 'index': 7714}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 205, 'column': 20, 'index': 7747}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 216, 'column': 23, 'index': 8464}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 235, 'column': 16, 'index': 9308}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 236, 'column': 20, 'index': 9341}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 246, 'column': 23, 'index': 9966}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 263, 'column': 16, 'index': 10663}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 264, 'column': 20, 'index': 10696}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 275, 'column': 23, 'index': 11425}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 294, 'column': 16, 'index': 12273}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 295, 'column': 20, 'index': 12306}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 305, 'column': 23, 'index': 12952}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 322, 'column': 16, 'index': 13651}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 323, 'column': 20, 'index': 13684}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/primitive.spec.js,Lazy Test,"{'line': 334, 'column': 23, 'index': 14415}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].director"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/pathMaps/expired.spec.js,Eager Test,"{'line': 16, 'column': 8, 'index': 483}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Eager Test,"{'line': 17, 'column': 12, 'index': 508}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Eager Test,"{'line': 28, 'column': 15, 'index': 917}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Eager Test,"{'line': 28, 'column': 37, 'index': 939}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Eager Test,"{'line': 41, 'column': 8, 'index': 1252}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Eager Test,"{'line': 42, 'column': 12, 'index': 1277}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Eager Test,"{'line': 52, 'column': 15, 'index': 1684}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Eager Test,"{'line': 52, 'column': 37, 'index': 1706}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Eager Test,"{'line': 65, 'column': 8, 'index': 2039}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Eager Test,"{'line': 66, 'column': 12, 'index': 2064}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Eager Test,"{'line': 76, 'column': 15, 'index': 2484}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Eager Test,"{'line': 76, 'column': 37, 'index': 2506}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Global Variable,"{'line': 13, 'column': 8, 'index': 433}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Global Variable,"{'line': 14, 'column': 8, 'index': 457}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Global Variable,"{'line': 24, 'column': 8, 'index': 783}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Global Variable,"{'line': 25, 'column': 8, 'index': 822}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Global Variable,"{'line': 36, 'column': 8, 'index': 1140}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Global Variable,"{'line': 37, 'column': 8, 'index': 1176}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Global Variable,"{'line': 38, 'column': 8, 'index': 1200}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Global Variable,"{'line': 39, 'column': 8, 'index': 1225}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Global Variable,"{'line': 60, 'column': 8, 'index': 1927}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Global Variable,"{'line': 61, 'column': 8, 'index': 1963}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Global Variable,"{'line': 62, 'column': 8, 'index': 1987}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Global Variable,"{'line': 63, 'column': 8, 'index': 2012}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Lazy Test,"{'line': 16, 'column': 8, 'index': 483}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Lazy Test,"{'line': 17, 'column': 12, 'index': 508}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Lazy Test,"{'line': 28, 'column': 15, 'index': 917}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ]
        );
        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Lazy Test,"{'line': 41, 'column': 8, 'index': 1252}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Lazy Test,"{'line': 42, 'column': 12, 'index': 1277}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Lazy Test,"{'line': 52, 'column': 15, 'index': 1684}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Lazy Test,"{'line': 65, 'column': 8, 'index': 2039}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Lazy Test,"{'line': 66, 'column': 12, 'index': 2064}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Lazy Test,"{'line': 76, 'column': 15, 'index': 2484}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Magic Number,"{'line': 51, 'column': 36, 'index': 1665}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: 0
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/expired.spec.js,Magic Number,"{'line': 75, 'column': 36, 'index': 2465}","it(""sets through an immediately expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setPathMaps(
            getModel({ cache: cache, expired: expired, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: startTime - 10
                })),
                $pathMapEnvelope(""grid[0][0].title"", ""Pulp Fiction"")
            ]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: { 0: { title: $atom(""Pulp Fiction"") } } } }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Eager Test,"{'line': 16, 'column': 8, 'index': 494}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Eager Test,"{'line': 17, 'column': 12, 'index': 519}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Eager Test,"{'line': 23, 'column': 15, 'index': 767}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Eager Test,"{'line': 23, 'column': 37, 'index': 789}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Eager Test,"{'line': 62, 'column': 8, 'index': 2022}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Eager Test,"{'line': 63, 'column': 12, 'index': 2047}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Eager Test,"{'line': 69, 'column': 15, 'index': 2295}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Eager Test,"{'line': 69, 'column': 37, 'index': 2317}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Global Variable,"{'line': 14, 'column': 8, 'index': 445}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Global Variable,"{'line': 15, 'column': 8, 'index': 469}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Global Variable,"{'line': 30, 'column': 8, 'index': 955}","xit(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Global Variable,"{'line': 31, 'column': 8, 'index': 979}","xit(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope([""grid"", 0, 0, null], ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Global Variable,"{'line': 60, 'column': 8, 'index': 1973}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Global Variable,"{'line': 61, 'column': 8, 'index': 1997}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Global Variable,"{'line': 76, 'column': 8, 'index': 2476}","xit(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Global Variable,"{'line': 77, 'column': 8, 'index': 2500}","xit(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope([""grid"", 0, 0, null], $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Lazy Test,"{'line': 16, 'column': 8, 'index': 494}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Lazy Test,"{'line': 17, 'column': 12, 'index': 519}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Lazy Test,"{'line': 23, 'column': 15, 'index': 767}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Lazy Test,"{'line': 62, 'column': 8, 'index': 2022}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Lazy Test,"{'line': 63, 'column': 12, 'index': 2047}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathMaps/branch.spec.js,Lazy Test,"{'line': 69, 'column': 15, 'index': 2295}","it(""directly"", function() {

        var cache = {};
        var version = 0;
        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
                $pathMapEnvelope(""movies['pulp-fiction']"", $error(""oops""))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 16, 'column': 8, 'index': 428}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 17, 'column': 12, 'index': 453}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 25, 'column': 15, 'index': 733}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 25, 'column': 37, 'index': 755}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 43, 'column': 8, 'index': 1171}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 44, 'column': 12, 'index': 1196}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 52, 'column': 8, 'index': 1585}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 53, 'column': 12, 'index': 1610}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 61, 'column': 15, 'index': 1888}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 61, 'column': 37, 'index': 1910}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 81, 'column': 8, 'index': 2474}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].summary"", $atom()),
                $pathMapEnvelope(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 82, 'column': 12, 'index': 2499}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].summary"", $atom()),
                $pathMapEnvelope(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 94, 'column': 15, 'index': 3066}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].summary"", $atom()),
                $pathMapEnvelope(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 94, 'column': 37, 'index': 3088}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].summary"", $atom()),
                $pathMapEnvelope(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 114, 'column': 8, 'index': 3639}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 115, 'column': 12, 'index': 3664}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 126, 'column': 15, 'index': 4158}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 126, 'column': 37, 'index': 4180}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 176, 'column': 8, 'index': 5814}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 177, 'column': 12, 'index': 5839}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 185, 'column': 8, 'index': 6149}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 186, 'column': 12, 'index': 6174}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 194, 'column': 15, 'index': 6492}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 194, 'column': 37, 'index': 6514}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 212, 'column': 16, 'index': 7010}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 213, 'column': 20, 'index': 7043}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 218, 'column': 23, 'index': 7304}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 218, 'column': 45, 'index': 7326}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 230, 'column': 16, 'index': 7872}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 231, 'column': 20, 'index': 7905}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 242, 'column': 23, 'index': 8639}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 242, 'column': 45, 'index': 8661}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 263, 'column': 16, 'index': 9557}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 264, 'column': 20, 'index': 9590}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 275, 'column': 23, 'index': 10321}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 275, 'column': 45, 'index': 10343}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 294, 'column': 16, 'index': 11192}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 295, 'column': 20, 'index': 11225}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 305, 'column': 23, 'index': 11864}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 305, 'column': 45, 'index': 11886}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 322, 'column': 16, 'index': 12579}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 323, 'column': 20, 'index': 12612}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 334, 'column': 23, 'index': 13355}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 334, 'column': 45, 'index': 13377}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 353, 'column': 16, 'index': 14230}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 354, 'column': 20, 'index': 14263}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 364, 'column': 23, 'index': 14923}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 364, 'column': 45, 'index': 14945}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 381, 'column': 16, 'index': 15640}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 382, 'column': 20, 'index': 15673}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 393, 'column': 23, 'index': 16418}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Eager Test,"{'line': 393, 'column': 45, 'index': 16440}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 13, 'column': 8, 'index': 378}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 14, 'column': 8, 'index': 402}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 39, 'column': 8, 'index': 1089}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 40, 'column': 8, 'index': 1121}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 41, 'column': 8, 'index': 1145}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 78, 'column': 8, 'index': 2424}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].summary"", $atom()),
                $pathMapEnvelope(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 79, 'column': 8, 'index': 2448}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].summary"", $atom()),
                $pathMapEnvelope(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 111, 'column': 8, 'index': 3589}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 112, 'column': 8, 'index': 3613}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 143, 'column': 8, 'index': 4702}","xit(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 144, 'column': 8, 'index': 4726}","xit(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 171, 'column': 8, 'index': 5696}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 172, 'column': 8, 'index': 5732}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 173, 'column': 8, 'index': 5764}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 174, 'column': 8, 'index': 5788}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 210, 'column': 16, 'index': 6945}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 211, 'column': 16, 'index': 6977}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 228, 'column': 16, 'index': 7807}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 229, 'column': 16, 'index': 7839}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 261, 'column': 16, 'index': 9492}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 262, 'column': 16, 'index': 9524}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 292, 'column': 16, 'index': 11127}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 293, 'column': 16, 'index': 11159}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 320, 'column': 16, 'index': 12514}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 321, 'column': 16, 'index': 12546}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 351, 'column': 16, 'index': 14165}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 352, 'column': 16, 'index': 14197}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 379, 'column': 16, 'index': 15575}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Global Variable,"{'line': 380, 'column': 16, 'index': 15607}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 16, 'column': 8, 'index': 428}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 17, 'column': 12, 'index': 453}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 25, 'column': 15, 'index': 733}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 43, 'column': 8, 'index': 1171}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 44, 'column': 12, 'index': 1196}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 61, 'column': 15, 'index': 1888}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathMapEnvelope(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 81, 'column': 8, 'index': 2474}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].summary"", $atom()),
                $pathMapEnvelope(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 82, 'column': 12, 'index': 2499}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].summary"", $atom()),
                $pathMapEnvelope(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 94, 'column': 15, 'index': 3066}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathMapEnvelope(""movies['kill-bill-1'].summary"", $atom()),
                $pathMapEnvelope(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 114, 'column': 8, 'index': 3639}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 115, 'column': 12, 'index': 3664}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 126, 'column': 15, 'index': 4158}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathMapEnvelope(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 176, 'column': 8, 'index': 5814}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 177, 'column': 12, 'index': 5839}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 194, 'column': 15, 'index': 6492}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ]
        );

        setPathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 212, 'column': 16, 'index': 7010}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 213, 'column': 20, 'index': 7043}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 218, 'column': 23, 'index': 7304}","it(""directly"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 230, 'column': 16, 'index': 7872}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 231, 'column': 20, 'index': 7905}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 242, 'column': 23, 'index': 8639}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 263, 'column': 16, 'index': 9557}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 264, 'column': 20, 'index': 9590}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 275, 'column': 23, 'index': 10321}","it(""to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 294, 'column': 16, 'index': 11192}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 295, 'column': 20, 'index': 11225}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 305, 'column': 23, 'index': 11864}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 322, 'column': 16, 'index': 12579}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 323, 'column': 20, 'index': 12612}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 334, 'column': 23, 'index': 13355}","it(""length:3"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 353, 'column': 16, 'index': 14230}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 354, 'column': 20, 'index': 14263}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 364, 'column': 23, 'index': 14923}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 381, 'column': 16, 'index': 15640}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 382, 'column': 20, 'index': 15673}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/pathMaps/atom.spec.js,Lazy Test,"{'line': 393, 'column': 23, 'index': 16418}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;
                setPathMaps(
                    getModel({ cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid"", $ref(""grids['id']"")),
                        $pathMapEnvelope(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathMapEnvelope(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathMapEnvelope(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathMapEnvelope(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathMapEnvelope(""movies['kill-bill-1'].genres"", $atom()),
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/reference.spec.js,Eager Test,"{'line': 21, 'column': 8, 'index': 737}","it(""leaves the newer reference in place and short-circuit"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"", {
                    $timestamp: startTime
                })),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""lists['id'][0]"", $ref(""movies['kill-bill-1']"", {
                        $timestamp: startTime - 10
                    })),
                    $pathValue(""movies['kill-bill-1'].title"", ""Kill Bill"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/reference.spec.js,Eager Test,"{'line': 22, 'column': 12, 'index': 764}","it(""leaves the newer reference in place and short-circuit"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"", {
                    $timestamp: startTime
                })),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""lists['id'][0]"", $ref(""movies['kill-bill-1']"", {
                        $timestamp: startTime - 10
                    })),
                    $pathValue(""movies['kill-bill-1'].title"", ""Kill Bill"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/reference.spec.js,Eager Test,"{'line': 33, 'column': 8, 'index': 1233}","it(""leaves the newer reference in place and short-circuit"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"", {
                    $timestamp: startTime
                })),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""lists['id'][0]"", $ref(""movies['kill-bill-1']"", {
                        $timestamp: startTime - 10
                    })),
                    $pathValue(""movies['kill-bill-1'].title"", ""Kill Bill"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/reference.spec.js,Eager Test,"{'line': 34, 'column': 12, 'index': 1260}","it(""leaves the newer reference in place and short-circuit"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"", {
                    $timestamp: startTime
                })),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""lists['id'][0]"", $ref(""movies['kill-bill-1']"", {
                        $timestamp: startTime - 10
                    })),
                    $pathValue(""movies['kill-bill-1'].title"", ""Kill Bill"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/reference.spec.js,Eager Test,"{'line': 45, 'column': 15, 'index': 1704}","it(""leaves the newer reference in place and short-circuit"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"", {
                    $timestamp: startTime
                })),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""lists['id'][0]"", $ref(""movies['kill-bill-1']"", {
                        $timestamp: startTime - 10
                    })),
                    $pathValue(""movies['kill-bill-1'].title"", ""Kill Bill"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/reference.spec.js,Eager Test,"{'line': 45, 'column': 37, 'index': 1726}","it(""leaves the newer reference in place and short-circuit"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"", {
                    $timestamp: startTime
                })),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""lists['id'][0]"", $ref(""movies['kill-bill-1']"", {
                        $timestamp: startTime - 10
                    })),
                    $pathValue(""movies['kill-bill-1'].title"", ""Kill Bill"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/reference.spec.js,Global Variable,"{'line': 16, 'column': 8, 'index': 619}","it(""leaves the newer reference in place and short-circuit"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"", {
                    $timestamp: startTime
                })),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""lists['id'][0]"", $ref(""movies['kill-bill-1']"", {
                        $timestamp: startTime - 10
                    })),
                    $pathValue(""movies['kill-bill-1'].title"", ""Kill Bill"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/reference.spec.js,Global Variable,"{'line': 17, 'column': 8, 'index': 655}","it(""leaves the newer reference in place and short-circuit"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"", {
                    $timestamp: startTime
                })),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""lists['id'][0]"", $ref(""movies['kill-bill-1']"", {
                        $timestamp: startTime - 10
                    })),
                    $pathValue(""movies['kill-bill-1'].title"", ""Kill Bill"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/reference.spec.js,Global Variable,"{'line': 18, 'column': 8, 'index': 687}","it(""leaves the newer reference in place and short-circuit"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"", {
                    $timestamp: startTime
                })),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""lists['id'][0]"", $ref(""movies['kill-bill-1']"", {
                        $timestamp: startTime - 10
                    })),
                    $pathValue(""movies['kill-bill-1'].title"", ""Kill Bill"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/reference.spec.js,Global Variable,"{'line': 19, 'column': 8, 'index': 711}","it(""leaves the newer reference in place and short-circuit"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"", {
                    $timestamp: startTime
                })),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""lists['id'][0]"", $ref(""movies['kill-bill-1']"", {
                        $timestamp: startTime - 10
                    })),
                    $pathValue(""movies['kill-bill-1'].title"", ""Kill Bill"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 26, 'column': 8, 'index': 866}","it('should set a null object into an empty cache wrapping it in an atom.', function() {
        var cache = {};
        var version = 0;
        var jsonGraphEnvelope = {
            jsonGraph: {
                a: {
                    b: null
                }
            },
            paths: [['a', 'b']]
        };

        setJSONGraphs(
            getModel({cache: cache, version: version++}),
            [jsonGraphEnvelope]);

        expect(strip(cache)).toEqual(strip({
            a: {
                b: $atom(null)
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 27, 'column': 12, 'index': 893}","it('should set a null object into an empty cache wrapping it in an atom.', function() {
        var cache = {};
        var version = 0;
        var jsonGraphEnvelope = {
            jsonGraph: {
                a: {
                    b: null
                }
            },
            paths: [['a', 'b']]
        };

        setJSONGraphs(
            getModel({cache: cache, version: version++}),
            [jsonGraphEnvelope]);

        expect(strip(cache)).toEqual(strip({
            a: {
                b: $atom(null)
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 30, 'column': 15, 'index': 989}","it('should set a null object into an empty cache wrapping it in an atom.', function() {
        var cache = {};
        var version = 0;
        var jsonGraphEnvelope = {
            jsonGraph: {
                a: {
                    b: null
                }
            },
            paths: [['a', 'b']]
        };

        setJSONGraphs(
            getModel({cache: cache, version: version++}),
            [jsonGraphEnvelope]);

        expect(strip(cache)).toEqual(strip({
            a: {
                b: $atom(null)
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 30, 'column': 37, 'index': 1011}","it('should set a null object into an empty cache wrapping it in an atom.', function() {
        var cache = {};
        var version = 0;
        var jsonGraphEnvelope = {
            jsonGraph: {
                a: {
                    b: null
                }
            },
            paths: [['a', 'b']]
        };

        setJSONGraphs(
            getModel({cache: cache, version: version++}),
            [jsonGraphEnvelope]);

        expect(strip(cache)).toEqual(strip({
            a: {
                b: $atom(null)
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 43, 'column': 12, 'index': 1288}","it(""throws with a `null` key in a branch position"", function() {
        var lru = new Object();
        var cache = {};
        var version = 0;

        expect(() => 
            setJSONGraphs(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $jsonGraphEnvelope([
                    $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
                ])]
            )).toThrow(NullInPathError);
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 44, 'column': 16, 'index': 1319}","it(""throws with a `null` key in a branch position"", function() {
        var lru = new Object();
        var cache = {};
        var version = 0;

        expect(() => 
            setJSONGraphs(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $jsonGraphEnvelope([
                    $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
                ])]
            )).toThrow(NullInPathError);
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 56, 'column': 8, 'index': 1667}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 57, 'column': 12, 'index': 1694}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 63, 'column': 15, 'index': 1895}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 63, 'column': 37, 'index': 1917}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 78, 'column': 8, 'index': 2220}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 79, 'column': 12, 'index': 2247}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 88, 'column': 8, 'index': 2647}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 89, 'column': 12, 'index': 2674}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 97, 'column': 15, 'index': 2965}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 97, 'column': 37, 'index': 2987}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 114, 'column': 8, 'index': 3438}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 115, 'column': 12, 'index': 3465}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 125, 'column': 15, 'index': 3927}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 125, 'column': 37, 'index': 3949}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 143, 'column': 8, 'index': 4388}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 144, 'column': 12, 'index': 4415}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 152, 'column': 8, 'index': 4737}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 153, 'column': 12, 'index': 4764}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 161, 'column': 15, 'index': 5049}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 161, 'column': 37, 'index': 5071}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 178, 'column': 8, 'index': 5527}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs']"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 179, 'column': 12, 'index': 5554}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs']"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 187, 'column': 8, 'index': 5876}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs']"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 188, 'column': 12, 'index': 5903}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs']"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 196, 'column': 15, 'index': 6179}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs']"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 196, 'column': 37, 'index': 6201}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs']"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 211, 'column': 16, 'index': 6674}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 212, 'column': 20, 'index': 6709}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 218, 'column': 23, 'index': 6991}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 218, 'column': 45, 'index': 7013}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 231, 'column': 16, 'index': 7533}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 232, 'column': 20, 'index': 7568}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 244, 'column': 23, 'index': 8289}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 244, 'column': 45, 'index': 8311}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 266, 'column': 16, 'index': 9181}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 267, 'column': 20, 'index': 9216}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 279, 'column': 23, 'index': 9934}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 279, 'column': 45, 'index': 9956}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 299, 'column': 16, 'index': 10779}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 300, 'column': 20, 'index': 10814}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 311, 'column': 23, 'index': 11446}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 311, 'column': 45, 'index': 11468}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 329, 'column': 16, 'index': 12144}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 330, 'column': 20, 'index': 12179}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 342, 'column': 23, 'index': 12909}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 342, 'column': 45, 'index': 12931}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 362, 'column': 16, 'index': 13758}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 363, 'column': 20, 'index': 13793}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 374, 'column': 23, 'index': 14446}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 374, 'column': 45, 'index': 14468}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 392, 'column': 16, 'index': 15146}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 393, 'column': 20, 'index': 15181}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 405, 'column': 23, 'index': 15913}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Eager Test,"{'line': 405, 'column': 45, 'index': 15935}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 15, 'column': 8, 'index': 632}","it('should set a null object into an empty cache wrapping it in an atom.', function() {
        var cache = {};
        var version = 0;
        var jsonGraphEnvelope = {
            jsonGraph: {
                a: {
                    b: null
                }
            },
            paths: [['a', 'b']]
        };

        setJSONGraphs(
            getModel({cache: cache, version: version++}),
            [jsonGraphEnvelope]);

        expect(strip(cache)).toEqual(strip({
            a: {
                b: $atom(null)
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 16, 'column': 8, 'index': 656}","it('should set a null object into an empty cache wrapping it in an atom.', function() {
        var cache = {};
        var version = 0;
        var jsonGraphEnvelope = {
            jsonGraph: {
                a: {
                    b: null
                }
            },
            paths: [['a', 'b']]
        };

        setJSONGraphs(
            getModel({cache: cache, version: version++}),
            [jsonGraphEnvelope]);

        expect(strip(cache)).toEqual(strip({
            a: {
                b: $atom(null)
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 17, 'column': 8, 'index': 681}","it('should set a null object into an empty cache wrapping it in an atom.', function() {
        var cache = {};
        var version = 0;
        var jsonGraphEnvelope = {
            jsonGraph: {
                a: {
                    b: null
                }
            },
            paths: [['a', 'b']]
        };

        setJSONGraphs(
            getModel({cache: cache, version: version++}),
            [jsonGraphEnvelope]);

        expect(strip(cache)).toEqual(strip({
            a: {
                b: $atom(null)
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 38, 'column': 8, 'index': 1180}","it(""throws with a `null` key in a branch position"", function() {
        var lru = new Object();
        var cache = {};
        var version = 0;

        expect(() => 
            setJSONGraphs(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $jsonGraphEnvelope([
                    $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
                ])]
            )).toThrow(NullInPathError);
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 39, 'column': 8, 'index': 1212}","it(""throws with a `null` key in a branch position"", function() {
        var lru = new Object();
        var cache = {};
        var version = 0;

        expect(() => 
            setJSONGraphs(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $jsonGraphEnvelope([
                    $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
                ])]
            )).toThrow(NullInPathError);
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 40, 'column': 8, 'index': 1236}","it(""throws with a `null` key in a branch position"", function() {
        var lru = new Object();
        var cache = {};
        var version = 0;

        expect(() => 
            setJSONGraphs(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $jsonGraphEnvelope([
                    $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
                ])]
            )).toThrow(NullInPathError);
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 53, 'column': 8, 'index': 1617}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 54, 'column': 8, 'index': 1641}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 74, 'column': 8, 'index': 2138}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 75, 'column': 8, 'index': 2170}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 76, 'column': 8, 'index': 2194}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 111, 'column': 8, 'index': 3388}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 112, 'column': 8, 'index': 3412}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 140, 'column': 8, 'index': 4338}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 141, 'column': 8, 'index': 4362}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 175, 'column': 8, 'index': 5477}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs']"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 176, 'column': 8, 'index': 5501}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs']"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 208, 'column': 16, 'index': 6608}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 209, 'column': 16, 'index': 6640}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 228, 'column': 16, 'index': 7467}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 229, 'column': 16, 'index': 7499}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 263, 'column': 16, 'index': 9115}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 264, 'column': 16, 'index': 9147}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 296, 'column': 16, 'index': 10713}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 297, 'column': 16, 'index': 10745}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 326, 'column': 16, 'index': 12078}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 327, 'column': 16, 'index': 12110}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 359, 'column': 16, 'index': 13692}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 360, 'column': 16, 'index': 13724}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 389, 'column': 16, 'index': 15080}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Global Variable,"{'line': 390, 'column': 16, 'index': 15112}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 26, 'column': 8, 'index': 866}","it('should set a null object into an empty cache wrapping it in an atom.', function() {
        var cache = {};
        var version = 0;
        var jsonGraphEnvelope = {
            jsonGraph: {
                a: {
                    b: null
                }
            },
            paths: [['a', 'b']]
        };

        setJSONGraphs(
            getModel({cache: cache, version: version++}),
            [jsonGraphEnvelope]);

        expect(strip(cache)).toEqual(strip({
            a: {
                b: $atom(null)
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 27, 'column': 12, 'index': 893}","it('should set a null object into an empty cache wrapping it in an atom.', function() {
        var cache = {};
        var version = 0;
        var jsonGraphEnvelope = {
            jsonGraph: {
                a: {
                    b: null
                }
            },
            paths: [['a', 'b']]
        };

        setJSONGraphs(
            getModel({cache: cache, version: version++}),
            [jsonGraphEnvelope]);

        expect(strip(cache)).toEqual(strip({
            a: {
                b: $atom(null)
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 30, 'column': 15, 'index': 989}","it('should set a null object into an empty cache wrapping it in an atom.', function() {
        var cache = {};
        var version = 0;
        var jsonGraphEnvelope = {
            jsonGraph: {
                a: {
                    b: null
                }
            },
            paths: [['a', 'b']]
        };

        setJSONGraphs(
            getModel({cache: cache, version: version++}),
            [jsonGraphEnvelope]);

        expect(strip(cache)).toEqual(strip({
            a: {
                b: $atom(null)
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 43, 'column': 12, 'index': 1288}","it(""throws with a `null` key in a branch position"", function() {
        var lru = new Object();
        var cache = {};
        var version = 0;

        expect(() => 
            setJSONGraphs(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $jsonGraphEnvelope([
                    $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
                ])]
            )).toThrow(NullInPathError);
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 44, 'column': 16, 'index': 1319}","it(""throws with a `null` key in a branch position"", function() {
        var lru = new Object();
        var cache = {};
        var version = 0;

        expect(() => 
            setJSONGraphs(
                getModel({ lru: lru, cache: cache, version: version++ }), [
                $jsonGraphEnvelope([
                    $pathValue([""movies"", null, ""pulp-fiction"", ""title""], ""Pulp Fiction"")
                ])]
            )).toThrow(NullInPathError);
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 56, 'column': 8, 'index': 1667}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 57, 'column': 12, 'index': 1694}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 63, 'column': 15, 'index': 1895}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 78, 'column': 8, 'index': 2220}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 79, 'column': 12, 'index': 2247}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 97, 'column': 15, 'index': 2965}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    title: $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 114, 'column': 8, 'index': 3438}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 115, 'column': 12, 'index': 3465}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 125, 'column': 15, 'index': 3927}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom()),
                $pathValue(""grid[0][1].title"", ""Kill Bill Vol. 1"")
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    title: $atom(""Kill Bill Vol. 1"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 143, 'column': 8, 'index': 4388}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 144, 'column': 12, 'index': 4415}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 161, 'column': 15, 'index': 5049}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    title: $atom(""Reservior Dogs"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 178, 'column': 8, 'index': 5527}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs']"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 179, 'column': 12, 'index': 5554}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs']"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 196, 'column': 15, 'index': 6179}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ])]
        );

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 2, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['reservior-dogs']"", ""Reservior Dogs"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom(""Reservior Dogs"") }
        }));
    })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 211, 'column': 16, 'index': 6674}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 212, 'column': 20, 'index': 6709}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 218, 'column': 23, 'index': 6991}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 231, 'column': 16, 'index': 7533}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 232, 'column': 20, 'index': 7568}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 244, 'column': 23, 'index': 8289}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 266, 'column': 16, 'index': 9181}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 267, 'column': 20, 'index': 9216}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 279, 'column': 23, 'index': 9934}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][0..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 299, 'column': 16, 'index': 10779}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 300, 'column': 20, 'index': 10814}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 311, 'column': 23, 'index': 11446}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue(""grid[0][1..2].director"", ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 329, 'column': 16, 'index': 12144}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 330, 'column': 20, 'index': 12179}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 342, 'column': 23, 'index': 12909}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 362, 'column': 16, 'index': 13758}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 363, 'column': 20, 'index': 13793}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 374, 'column': 23, 'index': 14446}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 392, 'column': 16, 'index': 15146}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 393, 'column': 20, 'index': 15181}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/primitive.spec.js,Lazy Test,"{'line': 405, 'column': 23, 'index': 15913}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""director""], ""Quentin Tarantino"")
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""kill-bill-1"": { ""director"": $atom(""Quentin Tarantino"") },
                        ""reservior-dogs"": { ""director"": $atom(""Quentin Tarantino"") }
                    }
                }));
            })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 18, 'column': 8, 'index': 598}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ])]
        );

        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 19, 'column': 12, 'index': 625}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ])]
        );

        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 32, 'column': 15, 'index': 1058}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ])]
        );

        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 32, 'column': 37, 'index': 1080}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ])]
        );

        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 44, 'column': 8, 'index': 1357}","it(""sets through an immediately expired reference"", function() {

        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: 0
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 45, 'column': 12, 'index': 1384}","it(""sets through an immediately expired reference"", function() {

        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: 0
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 59, 'column': 15, 'index': 1998}","it(""sets through an immediately expired reference"", function() {

        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: 0
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 59, 'column': 37, 'index': 2020}","it(""sets through an immediately expired reference"", function() {

        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: 0
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 78, 'column': 8, 'index': 2545}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 79, 'column': 12, 'index': 2572}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 93, 'column': 15, 'index': 3199}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 93, 'column': 37, 'index': 3221}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 107, 'column': 8, 'index': 3569}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 108, 'column': 12, 'index': 3596}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 123, 'column': 30, 'index': 4248}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 124, 'column': 12, 'index': 4275}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 133, 'column': 15, 'index': 4646}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Eager Test,"{'line': 133, 'column': 37, 'index': 4668}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 15, 'column': 8, 'index': 548}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ])]
        );

        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 16, 'column': 8, 'index': 572}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ])]
        );

        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 28, 'column': 8, 'index': 924}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ])]
        );

        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 29, 'column': 8, 'index': 963}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ])]
        );

        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 40, 'column': 8, 'index': 1281}","it(""sets through an immediately expired reference"", function() {

        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: 0
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 41, 'column': 8, 'index': 1305}","it(""sets through an immediately expired reference"", function() {

        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: 0
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 42, 'column': 8, 'index': 1330}","it(""sets through an immediately expired reference"", function() {

        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: 0
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 73, 'column': 8, 'index': 2433}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 74, 'column': 8, 'index': 2469}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 75, 'column': 8, 'index': 2493}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 76, 'column': 8, 'index': 2518}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 101, 'column': 8, 'index': 3425}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 102, 'column': 8, 'index': 3457}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 103, 'column': 8, 'index': 3481}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 104, 'column': 8, 'index': 3506}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 105, 'column': 8, 'index': 3532}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Global Variable,"{'line': 123, 'column': 8, 'index': 4226}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Lazy Test,"{'line': 18, 'column': 8, 'index': 598}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ])]
        );

        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Lazy Test,"{'line': 19, 'column': 12, 'index': 625}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ])]
        );

        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Lazy Test,"{'line': 32, 'column': 15, 'index': 1058}","it(""converts a negative $expires value to an absolute time"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                    $expires: -1000
                }))
            ])]
        );

        var value = cache.grids.id[0];
        var expires = value.$expires;

        expect(expires > Date.now()).toBe(true);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Lazy Test,"{'line': 44, 'column': 8, 'index': 1357}","it(""sets through an immediately expired reference"", function() {

        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: 0
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Lazy Test,"{'line': 45, 'column': 12, 'index': 1384}","it(""sets through an immediately expired reference"", function() {

        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: 0
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Lazy Test,"{'line': 59, 'column': 15, 'index': 1998}","it(""sets through an immediately expired reference"", function() {

        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: 0
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Lazy Test,"{'line': 78, 'column': 8, 'index': 2545}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Lazy Test,"{'line': 79, 'column': 12, 'index': 2572}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Lazy Test,"{'line': 93, 'column': 15, 'index': 3199}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Lazy Test,"{'line': 107, 'column': 8, 'index': 3569}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Lazy Test,"{'line': 108, 'column': 12, 'index': 3596}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Lazy Test,"{'line': 133, 'column': 15, 'index': 4646}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Magic Number,"{'line': 58, 'column': 36, 'index': 1979}","it(""sets through an immediately expired reference"", function() {

        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: 0
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Magic Number,"{'line': 92, 'column': 36, 'index': 3180}","it(""short-circuits writing an already expired reference"", function() {

        var startTime = Date.now();
        var cache = {};
        var version = 0;
        var expired = [];

        setJSONGraphs(
            getModel({ cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: startTime - 10
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(expired.length).toBe(1);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } }
        }));
    })",steel
/test/set/jsonGraphs/expired.spec.js,Magic Number,"{'line': 132, 'column': 47, 'index': 4627}","it(""short-circuits writing past an expired reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;
        var expired = [];
        var startTime = Date.now();

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""title""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""grid"", $ref(""grids['id']"")),
                    $pathValue(""grids['id'][0]"", $ref(""lists['id']"", {
                        $expires: -5
                    })),
                    $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                    $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
                ])
            }]
        );

        do {} while (Date.now() - startTime < 10);

        var successfulPaths = setJSONGraphs(
            getModel({ lru: lru, cache: cache, expired: expired, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""director""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].director"", ""Quentin Tarantino"")
                ])
            }]
        );

        expect(successfulPaths[1].length).toBe(0);
        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    ""title"": $atom(""Pulp Fiction"")
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 56, 'column': 8, 'index': 1708}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 57, 'column': 12, 'index': 1735}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 63, 'column': 8, 'index': 1939}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 64, 'column': 12, 'index': 1966}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 70, 'column': 15, 'index': 2170}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 70, 'column': 37, 'index': 2192}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 80, 'column': 8, 'index': 2428}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 81, 'column': 12, 'index': 2455}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 90, 'column': 8, 'index': 2861}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 91, 'column': 12, 'index': 2888}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 99, 'column': 15, 'index': 3170}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 99, 'column': 37, 'index': 3192}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 115, 'column': 8, 'index': 3613}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 116, 'column': 12, 'index': 3640}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 122, 'column': 8, 'index': 3835}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 123, 'column': 12, 'index': 3862}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 129, 'column': 15, 'index': 4066}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 129, 'column': 37, 'index': 4088}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 139, 'column': 8, 'index': 4317}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 140, 'column': 12, 'index': 4344}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 149, 'column': 8, 'index': 4750}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 150, 'column': 12, 'index': 4777}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 158, 'column': 15, 'index': 5059}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Eager Test,"{'line': 158, 'column': 37, 'index': 5081}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 17, 'column': 8, 'index': 739}","it('should allow null at end of path.', function() {
        var model = new Model();
        setJSONGraphs(
            model,
            [{
                jsonGraph: {
                    a: $ref(['b']),
                    b: 'title'
                },
                paths: [
                    ['a', null]
                ]
            }]
        );
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 33, 'column': 8, 'index': 1129}","it('should throw an error if null is in middle of path.', function() {
        var model = new Model();
        expect(() => 
            setJSONGraphs(
                model,
                [{
                    jsonGraph: {
                        a: $ref(['b']),
                        b: {
                            c: 'title'
                        }
                    },
                    paths: [
                        ['a', null, 'c']
                    ]
                }]
            )).toThrow(NullInPathError);
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 52, 'column': 8, 'index': 1636}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 53, 'column': 8, 'index': 1658}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 54, 'column': 8, 'index': 1682}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 76, 'column': 8, 'index': 2356}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 77, 'column': 8, 'index': 2378}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 78, 'column': 8, 'index': 2402}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 111, 'column': 8, 'index': 3541}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 112, 'column': 8, 'index': 3563}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 113, 'column': 8, 'index': 3587}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 135, 'column': 8, 'index': 4245}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 136, 'column': 8, 'index': 4267}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Global Variable,"{'line': 137, 'column': 8, 'index': 4291}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 18, 'column': 8, 'index': 772}","it('should allow null at end of path.', function() {
        var model = new Model();
        setJSONGraphs(
            model,
            [{
                jsonGraph: {
                    a: $ref(['b']),
                    b: 'title'
                },
                paths: [
                    ['a', null]
                ]
            }]
        );
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 35, 'column': 12, 'index': 1188}","it('should throw an error if null is in middle of path.', function() {
        var model = new Model();
        expect(() => 
            setJSONGraphs(
                model,
                [{
                    jsonGraph: {
                        a: $ref(['b']),
                        b: {
                            c: 'title'
                        }
                    },
                    paths: [
                        ['a', null, 'c']
                    ]
                }]
            )).toThrow(NullInPathError);
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 56, 'column': 8, 'index': 1708}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 57, 'column': 12, 'index': 1735}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 70, 'column': 15, 'index': 2170}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 80, 'column': 8, 'index': 2428}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 81, 'column': 12, 'index': 2455}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 99, 'column': 15, 'index': 3170}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $atom(""Pulp Fiction"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 115, 'column': 8, 'index': 3613}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 116, 'column': 12, 'index': 3640}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 129, 'column': 15, 'index': 4066}","it(""directly"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction""),
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction']"", $error(""oops""))
            ])]
        )

        expect(strip(cache)).toEqual(strip({
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 139, 'column': 8, 'index': 4317}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 140, 'column': 12, 'index': 4344}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Lazy Test,"{'line': 158, 'column': 15, 'index': 5059}","it(""through a reference with a null last key"", function() {
        var lru = {};
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction'].title"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, null]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction']"", $error(""oops""))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: { ""pulp-fiction"": $error(""oops"") }
        }));
    })",steel
/test/set/jsonGraphs/branch.spec.js,Unknown Test,"{'column': 4, 'line': 16}","it('should allow null at end of path.', function() {
        var model = new Model();
        setJSONGraphs(
            model,
            [{
                jsonGraph: {
                    a: $ref(['b']),
                    b: 'title'
                },
                paths: [
                    ['a', null]
                ]
            }]
        );
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 18, 'column': 8, 'index': 543}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 19, 'column': 12, 'index': 570}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 28, 'column': 15, 'index': 879}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 28, 'column': 37, 'index': 901}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 46, 'column': 8, 'index': 1317}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""summary""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].summary"", $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    }))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 47, 'column': 12, 'index': 1344}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""summary""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].summary"", $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    }))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 56, 'column': 8, 'index': 1744}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""summary""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].summary"", $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    }))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 57, 'column': 12, 'index': 1771}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""summary""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].summary"", $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    }))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 68, 'column': 15, 'index': 2184}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""summary""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].summary"", $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    }))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 68, 'column': 37, 'index': 2206}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""summary""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].summary"", $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    }))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 88, 'column': 8, 'index': 2770}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 89, 'column': 12, 'index': 2797}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 102, 'column': 15, 'index': 3369}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 102, 'column': 37, 'index': 3391}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 122, 'column': 8, 'index': 3942}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 123, 'column': 12, 'index': 3969}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 135, 'column': 15, 'index': 4474}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 135, 'column': 37, 'index': 4496}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 155, 'column': 8, 'index': 5067}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 156, 'column': 12, 'index': 5094}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 168, 'column': 15, 'index': 5599}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 168, 'column': 37, 'index': 5621}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 186, 'column': 8, 'index': 6142}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 187, 'column': 12, 'index': 6169}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 196, 'column': 8, 'index': 6508}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 197, 'column': 12, 'index': 6535}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 206, 'column': 15, 'index': 6882}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 206, 'column': 37, 'index': 6904}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 225, 'column': 16, 'index': 7401}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 226, 'column': 20, 'index': 7436}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 232, 'column': 23, 'index': 7727}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 232, 'column': 45, 'index': 7749}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 245, 'column': 16, 'index': 8296}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 246, 'column': 20, 'index': 8331}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 258, 'column': 23, 'index': 9066}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 258, 'column': 45, 'index': 9088}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 280, 'column': 16, 'index': 9985}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 281, 'column': 20, 'index': 10020}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 293, 'column': 23, 'index': 10752}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 293, 'column': 45, 'index': 10774}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 313, 'column': 16, 'index': 11624}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 314, 'column': 20, 'index': 11659}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 325, 'column': 23, 'index': 12305}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 325, 'column': 45, 'index': 12327}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 343, 'column': 16, 'index': 13021}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 344, 'column': 20, 'index': 13056}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 356, 'column': 23, 'index': 13800}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 356, 'column': 45, 'index': 13822}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 376, 'column': 16, 'index': 14676}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 377, 'column': 20, 'index': 14711}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 388, 'column': 23, 'index': 15378}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 388, 'column': 45, 'index': 15400}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 406, 'column': 16, 'index': 16096}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 407, 'column': 20, 'index': 16131}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 419, 'column': 23, 'index': 16877}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Eager Test,"{'line': 419, 'column': 45, 'index': 16899}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 15, 'column': 8, 'index': 493}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 16, 'column': 8, 'index': 517}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 42, 'column': 8, 'index': 1235}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""summary""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].summary"", $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    }))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 43, 'column': 8, 'index': 1267}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""summary""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].summary"", $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    }))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 44, 'column': 8, 'index': 1291}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""summary""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].summary"", $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    }))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 85, 'column': 8, 'index': 2720}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 86, 'column': 8, 'index': 2744}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 119, 'column': 8, 'index': 3892}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 120, 'column': 8, 'index': 3916}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 152, 'column': 8, 'index': 5017}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 153, 'column': 8, 'index': 5041}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 181, 'column': 8, 'index': 6024}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 182, 'column': 8, 'index': 6060}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 183, 'column': 8, 'index': 6092}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 184, 'column': 8, 'index': 6116}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 222, 'column': 16, 'index': 7335}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 223, 'column': 16, 'index': 7367}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 242, 'column': 16, 'index': 8230}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 243, 'column': 16, 'index': 8262}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 277, 'column': 16, 'index': 9919}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 278, 'column': 16, 'index': 9951}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 310, 'column': 16, 'index': 11558}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 311, 'column': 16, 'index': 11590}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 340, 'column': 16, 'index': 12955}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 341, 'column': 16, 'index': 12987}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 373, 'column': 16, 'index': 14610}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 374, 'column': 16, 'index': 14642}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 403, 'column': 16, 'index': 16030}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Global Variable,"{'line': 404, 'column': 16, 'index': 16062}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 18, 'column': 8, 'index': 543}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 19, 'column': 12, 'index': 570}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 28, 'column': 15, 'index': 879}","it(""directly"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 46, 'column': 8, 'index': 1317}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""summary""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].summary"", $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    }))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 47, 'column': 12, 'index': 1344}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""summary""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].summary"", $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    }))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 68, 'column': 15, 'index': 2184}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [{
                paths: [[""grid"", 0, 0, ""summary""]],
                jsonGraph: $jsonGraph([
                    $pathValue(""movies['pulp-fiction'].summary"", $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    }))
                ])
            }]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } },
            movies: {
                ""pulp-fiction"": {
                    summary: $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 88, 'column': 8, 'index': 2770}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 89, 'column': 12, 'index': 2797}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 102, 'column': 15, 'index': 3369}","it(""through a reference that lands on an atom"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].summary"", $atom()),
                $pathValue(""grid[0][1].summary"", $atom({
                    title: ""Kill Bill: Vol. 1"",
                    url: ""/movies/id/kill-bill-1""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } },
            movies: {
                ""kill-bill-1"": {
                    summary: $atom({
                        title: ""Kill Bill: Vol. 1"",
                        url: ""/movies/id/kill-bill-1""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 122, 'column': 8, 'index': 3942}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 123, 'column': 12, 'index': 3969}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 135, 'column': 15, 'index': 4474}","it(""through a broken reference"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""grid[0][2].summary"", $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: {
                ""reservior-dogs"": {
                    summary: $atom({
                        title: ""Reservior Dogs"",
                        url: ""/movies/id/reservior-dogs""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 155, 'column': 8, 'index': 5067}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 156, 'column': 12, 'index': 5094}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 168, 'column': 15, 'index': 5599}","it(""through a reference with a null last key"", function() {

        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue([""grid"", 0, 2, null], $atom({
                    title: ""Reservior Dogs"",
                    url: ""/movies/id/reservior-dogs""
                }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } },
            movies: { ""reservior-dogs"": $atom({
                title: ""Reservior Dogs"",
                url: ""/movies/id/reservior-dogs""
            }) }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 186, 'column': 8, 'index': 6142}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 187, 'column': 12, 'index': 6169}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 206, 'column': 15, 'index': 6882}","it(""with an older timestamp"", function() {

        var startTime = Date.now();
        var lru = new Object();
        var cache = {};
        var version = 0;

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Pulp Fiction"",
                    url: ""/movies/id/pulp-fiction""
                }, { $timestamp: startTime }))
            ])]
        );

        setJSONGraphs(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $jsonGraphEnvelope([
                $pathValue(""movies['pulp-fiction'].summary"", $atom({
                    title: ""Kill Bill"",
                    url: ""/movies/id/kill-bill-1""
                }, { $timestamp: startTime - 10 }))
            ])]
        );

        expect(strip(cache)).toEqual(strip({
            movies: {
                ""pulp-fiction"": {
                    ""summary"": $atom({
                        title: ""Pulp Fiction"",
                        url: ""/movies/id/pulp-fiction""
                    })
                }
            }
        }));
    })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 225, 'column': 16, 'index': 7401}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 226, 'column': 20, 'index': 7436}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 232, 'column': 23, 'index': 7727}","it(""directly"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].genres"", [""Crime"", ""Drama"", ""Thriller""])
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 245, 'column': 16, 'index': 8296}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 246, 'column': 20, 'index': 8331}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 258, 'column': 23, 'index': 9066}","it(""through successful, short-circuit, and broken references"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0, 1, 2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 280, 'column': 16, 'index': 9985}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 281, 'column': 20, 'index': 10020}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 293, 'column': 23, 'index': 10752}","it(""to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][0..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 313, 'column': 16, 'index': 11624}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 314, 'column': 20, 'index': 11659}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 325, 'column': 23, 'index': 12305}","it(""from:1, to:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue(""grid[0][1..2].genres"", $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 343, 'column': 16, 'index': 13021}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 344, 'column': 20, 'index': 13056}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 356, 'column': 23, 'index': 13800}","it(""length:3"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {length: 3}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 376, 'column': 16, 'index': 14676}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 377, 'column': 20, 'index': 14711}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 388, 'column': 23, 'index': 15378}","it(""from:1, length:2"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, {from: 1, length: 2}, ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 406, 'column': 16, 'index': 16096}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 407, 'column': 20, 'index': 16131}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/set/jsonGraphs/atom.spec.js,Lazy Test,"{'line': 419, 'column': 23, 'index': 16877}","it(""[length:3]"", function() {

                var cache = {};
                var version = 0;

                setJSONGraphs(
                    getModel({ cache: cache, version: version++ }), [
                    $jsonGraphEnvelope([
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].genres"", $atom()),
                        $pathValue([""grid"", 0, [{length: 3}], ""genres""], $atom([""Crime"", ""Drama"", ""Thriller""]))
                    ])]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    },
                    movies: {
                        ""pulp-fiction"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""kill-bill-1"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) },
                        ""reservior-dogs"": { ""genres"": $atom([""Crime"", ""Drama"", ""Thriller""]) }
                    }
                }));
            })",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 5, 'column': 8, 'index': 241}","it(""should create onNext and onError even if no parameters are passed to constructor"", function() {
        var modelResponseObserver = new ModelResponseObserver();
        modelResponseObserver.onNext(5);
        modelResponseObserver.onError(5);
    })",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 11, 'column': 8, 'index': 506}","it(""should create onNext and onCompleted even if no parameters are passed to constructor"", function() {
        var modelResponseObserver = new ModelResponseObserver();
        modelResponseObserver.onNext(5);
        modelResponseObserver.onCompleted();
    })",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 19, 'column': 12, 'index': 785}","it(
        ""should call onNext callback when onNext is called on ModelResponseObserver"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver(function(
                value
            ) {
                onNextValue = value;
            });
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(5);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 20, 'column': 12, 'index': 814}","it(
        ""should call onNext callback when onNext is called on ModelResponseObserver"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver(function(
                value
            ) {
                onNextValue = value;
            });
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(5);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 34, 'column': 12, 'index': 1201}","it(
        ""should suppress onNext callback after ModelResponseObserver is onCompleted"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver(function(
                value
            ) {
                onNextValue = value;
            });
            modelResponseObserver.onCompleted();
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 35, 'column': 12, 'index': 1230}","it(
        ""should suppress onNext callback after ModelResponseObserver is onCompleted"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver(function(
                value
            ) {
                onNextValue = value;
            });
            modelResponseObserver.onCompleted();
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 50, 'column': 12, 'index': 1673}","it(
        ""should suppress onNext callback after ModelResponseObserver is onError'ed"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver(function(
                value
            ) {
                onNextValue = value;
            });
            modelResponseObserver.onError();
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 51, 'column': 12, 'index': 1702}","it(
        ""should suppress onNext callback after ModelResponseObserver is onError'ed"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver(function(
                value
            ) {
                onNextValue = value;
            });
            modelResponseObserver.onError();
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 66, 'column': 12, 'index': 2180}","it(
        ""should call onError callback max 1 time when no matter how many times onError is called on ModelResponseObserver"",
        function() {
            var onErrorValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function(e) {
                    onErrorValues.push(e);
                }
            );
            modelResponseObserver.onError(1);
            modelResponseObserver.onError(2);

            expect(onErrorValues.length).toBe(1);
            expect(onErrorValues[0]).toBe(1);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 67, 'column': 12, 'index': 2216}","it(
        ""should call onError callback max 1 time when no matter how many times onError is called on ModelResponseObserver"",
        function() {
            var onErrorValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function(e) {
                    onErrorValues.push(e);
                }
            );
            modelResponseObserver.onError(1);
            modelResponseObserver.onError(2);

            expect(onErrorValues.length).toBe(1);
            expect(onErrorValues[0]).toBe(1);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 84, 'column': 12, 'index': 2788}","it(
        ""should call onCompleted callback max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function() {},
                function(value) {
                    onCompletedValues.push(value);
                }
            );
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 85, 'column': 12, 'index': 2828}","it(
        ""should call onCompleted callback max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function() {},
                function(value) {
                    onCompletedValues.push(value);
                }
            );
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 103, 'column': 12, 'index': 3419}","it(
        ""should call onNext method when onNext is called on ModelResponseObserver"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function(value) {
                    onNextValue = value;
                }
            });
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(5);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 104, 'column': 12, 'index': 3448}","it(
        ""should call onNext method when onNext is called on ModelResponseObserver"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function(value) {
                    onNextValue = value;
                }
            });
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(5);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 118, 'column': 12, 'index': 3851}","it(
        ""should suppress onNext method after ModelResponseObserver is onCompleted"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function(value) {
                    onNextValue = value;
                }
            });
            modelResponseObserver.onCompleted();
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 119, 'column': 12, 'index': 3880}","it(
        ""should suppress onNext method after ModelResponseObserver is onCompleted"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function(value) {
                    onNextValue = value;
                }
            });
            modelResponseObserver.onCompleted();
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 134, 'column': 12, 'index': 4339}","it(
        ""should suppress onNext method after ModelResponseObserver is onError'ed"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function(value) {
                    onNextValue = value;
                }
            });
            modelResponseObserver.onError();
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 135, 'column': 12, 'index': 4368}","it(
        ""should suppress onNext method after ModelResponseObserver is onError'ed"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function(value) {
                    onNextValue = value;
                }
            });
            modelResponseObserver.onError();
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 150, 'column': 12, 'index': 4862}","it(
        ""should call onError method max 1 time when no matter how many times onError is called on ModelResponseObserver"",
        function() {
            var onErrorValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function(e) {
                    onErrorValues.push(e);
                }
            });
            modelResponseObserver.onError(1);
            modelResponseObserver.onError(2);

            expect(onErrorValues.length).toBe(1);
            expect(onErrorValues[0]).toBe(1);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 151, 'column': 12, 'index': 4898}","it(
        ""should call onError method max 1 time when no matter how many times onError is called on ModelResponseObserver"",
        function() {
            var onErrorValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function(e) {
                    onErrorValues.push(e);
                }
            });
            modelResponseObserver.onError(1);
            modelResponseObserver.onError(2);

            expect(onErrorValues.length).toBe(1);
            expect(onErrorValues[0]).toBe(1);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 168, 'column': 12, 'index': 5487}","it(
        ""should call onCompleted method max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function() {},
                onCompleted: function(value) {
                    onCompletedValues.push(value);
                }
            });
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Global Variable,"{'line': 169, 'column': 12, 'index': 5527}","it(
        ""should call onCompleted method max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function() {},
                onCompleted: function(value) {
                    onCompletedValues.push(value);
                }
            });
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Magic Number,"{'line': 27, 'column': 37, 'index': 1052}","it(
        ""should call onNext callback when onNext is called on ModelResponseObserver"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver(function(
                value
            ) {
                onNextValue = value;
            });
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(5);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Magic Number,"{'line': 76, 'column': 46, 'index': 2547}","it(
        ""should call onError callback max 1 time when no matter how many times onError is called on ModelResponseObserver"",
        function() {
            var onErrorValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function(e) {
                    onErrorValues.push(e);
                }
            );
            modelResponseObserver.onError(1);
            modelResponseObserver.onError(2);

            expect(onErrorValues.length).toBe(1);
            expect(onErrorValues[0]).toBe(1);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Magic Number,"{'line': 77, 'column': 42, 'index': 2593}","it(
        ""should call onError callback max 1 time when no matter how many times onError is called on ModelResponseObserver"",
        function() {
            var onErrorValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function(e) {
                    onErrorValues.push(e);
                }
            );
            modelResponseObserver.onError(1);
            modelResponseObserver.onError(2);

            expect(onErrorValues.length).toBe(1);
            expect(onErrorValues[0]).toBe(1);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Magic Number,"{'line': 95, 'column': 50, 'index': 3214}","it(
        ""should call onCompleted callback max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver(
                function() {},
                function() {},
                function(value) {
                    onCompletedValues.push(value);
                }
            );
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Magic Number,"{'line': 111, 'column': 37, 'index': 3704}","it(
        ""should call onNext method when onNext is called on ModelResponseObserver"",
        function() {
            var onNextValue;
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function(value) {
                    onNextValue = value;
                }
            });
            modelResponseObserver.onNext(5);

            expect(onNextValue).toBe(5);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Magic Number,"{'line': 160, 'column': 46, 'index': 5248}","it(
        ""should call onError method max 1 time when no matter how many times onError is called on ModelResponseObserver"",
        function() {
            var onErrorValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function(e) {
                    onErrorValues.push(e);
                }
            });
            modelResponseObserver.onError(1);
            modelResponseObserver.onError(2);

            expect(onErrorValues.length).toBe(1);
            expect(onErrorValues[0]).toBe(1);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Magic Number,"{'line': 161, 'column': 42, 'index': 5294}","it(
        ""should call onError method max 1 time when no matter how many times onError is called on ModelResponseObserver"",
        function() {
            var onErrorValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function(e) {
                    onErrorValues.push(e);
                }
            });
            modelResponseObserver.onError(1);
            modelResponseObserver.onError(2);

            expect(onErrorValues.length).toBe(1);
            expect(onErrorValues[0]).toBe(1);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Magic Number,"{'line': 179, 'column': 50, 'index': 5945}","it(
        ""should call onCompleted method max 1 time when no matter how many times onCompleted is called on ModelResponseObserver"",
        function() {
            var onCompletedValues = [];
            var modelResponseObserver = new ModelResponseObserver({
                onNext: function() {},
                onError: function() {},
                onCompleted: function(value) {
                    onCompletedValues.push(value);
                }
            });
            modelResponseObserver.onCompleted(1);
            modelResponseObserver.onCompleted(2);

            expect(onCompletedValues.length).toBe(1);
            expect(onCompletedValues[0]).toBe(undefined);
        }
    )",steel
/test/response/ModelResponseObserver.spec.js,Unknown Test,"{'column': 4, 'line': 4}","it(""should create onNext and onError even if no parameters are passed to constructor"", function() {
        var modelResponseObserver = new ModelResponseObserver();
        modelResponseObserver.onNext(5);
        modelResponseObserver.onError(5);
    })",steel
/test/response/ModelResponseObserver.spec.js,Unknown Test,"{'column': 4, 'line': 10}","it(""should create onNext and onCompleted even if no parameters are passed to constructor"", function() {
        var modelResponseObserver = new ModelResponseObserver();
        modelResponseObserver.onNext(5);
        modelResponseObserver.onCompleted();
    })",steel
/test/lru/lru.splice.overwrite.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 38}",Unknown,steel
/test/lru/lru.splice.overwrite.spec.js,Global Variable,"{'line': 3, 'column': 0, 'index': 64}",Unknown,steel
/test/lru/lru.splice.overwrite.spec.js,Global Variable,"{'line': 12, 'column': 8, 'index': 421}","it('should overwrite the cache and update the lru as PathValue', function() {
        var model = getModel();
        model.set({path: [1], value: 'overwrite'}).subscribe();
        testLRU(model);
    })",steel
/test/lru/lru.splice.overwrite.spec.js,Global Variable,"{'line': 17, 'column': 8, 'index': 626}","it('should overwrite the cache and update the lru as JSON', function() {
        var model = getModel();
        model.set({json: {1: 'overwrite'}}).subscribe();
        testLRU(model);
    })",steel
/test/lru/lru.splice.overwrite.spec.js,Global Variable,"{'line': 22, 'column': 8, 'index': 829}","it('should overwrite the cache and update the lru as JSONGraph', function() {
        var model = getModel();
        model.set({
            jsonGraph: {
                1: 'overwrite'
            },
            paths: [[1]]
        }).subscribe();
        testLRU(model);
    })",steel
/test/lru/lru.splice.overwrite.spec.js,Global Variable,"{'line': 34, 'column': 4, 'index': 1056}",Unknown,steel
/test/lru/lru.splice.overwrite.spec.js,Unknown Test,"{'column': 4, 'line': 11}","it('should overwrite the cache and update the lru as PathValue', function() {
        var model = getModel();
        model.set({path: [1], value: 'overwrite'}).subscribe();
        testLRU(model);
    })",steel
/test/lru/lru.splice.overwrite.spec.js,Unknown Test,"{'column': 4, 'line': 16}","it('should overwrite the cache and update the lru as JSON', function() {
        var model = getModel();
        model.set({json: {1: 'overwrite'}}).subscribe();
        testLRU(model);
    })",steel
/test/lru/lru.splice.overwrite.spec.js,Unknown Test,"{'column': 4, 'line': 21}","it('should overwrite the cache and update the lru as JSONGraph', function() {
        var model = getModel();
        model.set({
            jsonGraph: {
                1: 'overwrite'
            },
            paths: [[1]]
        }).subscribe();
        testLRU(model);
    })",steel
/test/lru/lru.splice.expired.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 38}",Unknown,steel
/test/lru/lru.splice.expired.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 88}",Unknown,steel
/test/lru/lru.splice.expired.spec.js,Global Variable,"{'line': 13, 'column': 8, 'index': 432}","it('should ensure that get avoids expired items', function(done) {
        var model = new Model({cache: {
            ""expireSoon"": {
                ""$size"": 51,
                ""summary"": {
                    ""$size"": 51,
                    ""$expires"": Date.now() + 50,
                    ""$type"": ""atom"",
                    ""value"": 'sad panda'
                }
            }
        }});

        expect(model._root[__head].value).toBe('sad panda');

        var onNext = jest.fn();
        Rx.Observable.
            timer(100).
            flatMap(function() {
                return model.get(['expireSoon', 'summary']);
            }).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(model._root[__head]).toBeUndefined();
                expect(model._root[__tail]).toBeUndefined();
            }).
            subscribe(noOp, done, done);
    })",steel
/test/lru/lru.splice.expired.spec.js,Global Variable,"{'line': 27, 'column': 8, 'index': 826}","it('should ensure that get avoids expired items', function(done) {
        var model = new Model({cache: {
            ""expireSoon"": {
                ""$size"": 51,
                ""summary"": {
                    ""$size"": 51,
                    ""$expires"": Date.now() + 50,
                    ""$type"": ""atom"",
                    ""value"": 'sad panda'
                }
            }
        }});

        expect(model._root[__head].value).toBe('sad panda');

        var onNext = jest.fn();
        Rx.Observable.
            timer(100).
            flatMap(function() {
                return model.get(['expireSoon', 'summary']);
            }).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(model._root[__head]).toBeUndefined();
                expect(model._root[__tail]).toBeUndefined();
            }).
            subscribe(noOp, done, done);
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 189, 'column': 8, 'index': 3957}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 189, 'column': 8, 'index': 3957}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 190, 'column': 8, 'index': 4000}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 190, 'column': 8, 'index': 4000}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 193, 'column': 8, 'index': 4077}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 193, 'column': 8, 'index': 4077}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 194, 'column': 8, 'index': 4119}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 194, 'column': 8, 'index': 4119}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 197, 'column': 8, 'index': 4202}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 197, 'column': 8, 'index': 4202}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 198, 'column': 8, 'index': 4241}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 201, 'column': 8, 'index': 4323}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 201, 'column': 8, 'index': 4323}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 202, 'column': 8, 'index': 4367}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 202, 'column': 8, 'index': 4367}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 203, 'column': 8, 'index': 4424}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 203, 'column': 8, 'index': 4424}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 214, 'column': 8, 'index': 4676}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 214, 'column': 8, 'index': 4676}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 215, 'column': 8, 'index': 4715}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 218, 'column': 8, 'index': 4788}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 218, 'column': 8, 'index': 4788}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 219, 'column': 8, 'index': 4832}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 219, 'column': 8, 'index': 4832}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 222, 'column': 8, 'index': 4919}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 222, 'column': 8, 'index': 4919}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 223, 'column': 8, 'index': 4962}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 223, 'column': 8, 'index': 4962}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 226, 'column': 8, 'index': 5039}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 226, 'column': 8, 'index': 5039}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 227, 'column': 8, 'index': 5081}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 227, 'column': 8, 'index': 5081}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 228, 'column': 8, 'index': 5134}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Duplicate Assert,"{'line': 228, 'column': 8, 'index': 5134}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 38}",Unknown,steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 3, 'column': 0, 'index': 64}",Unknown,steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 14, 'column': 8, 'index': 486}","it('should set with pathValues.', function() {
        var model = getModel();

        model.set({
             path: ['1'],
             value: 'i am 1'
        }).subscribe();

        singleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 24, 'column': 8, 'index': 698}","it('should set with json', function() {
        var model = getModel();

        model.set({
            json: {
                1: 'i am 1'
            }
        }).subscribe();

        singleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 35, 'column': 8, 'index': 923}","it('should set with json-graph', function() {
        var model = getModel();

        model.set({
            jsonGraph: {
                1: 'i am 1'
            },
            paths: [
                [1]
            ]
        }).subscribe();

        singleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 49, 'column': 8, 'index': 1212}","it('should set with 2 pathValues.', function() {
        var model = getModel();

        model.set({
             path: ['1'],
             value: 'i am 1'
        }).subscribe();

        model.set({
             path: ['2'],
             value: 'i am 2'
        }).subscribe();

        doubleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 64, 'column': 8, 'index': 1526}","it('should set with 2 json', function() {
        var model = getModel();

        model.set({
            json: {
                1: 'i am 1'
            }
        }).subscribe();

        model.set({
            json: {
                2: 'i am 2'
            }
        }).subscribe();

        doubleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 81, 'column': 8, 'index': 1860}","it('should set with 2 json-graph', function() {
        var model = getModel();

        model.set({
            jsonGraph: {
                1: 'i am 1'
            },
            paths: [
                [1]
            ]
        }).subscribe();


        model.set({
            jsonGraph: {
                2: 'i am 2'
            },
            paths: [
                [2]
            ]
        }).subscribe();

        doubleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 105, 'column': 8, 'index': 2318}","it('should set with 3 pathValues.', function() {
        var model = getModel();

        model.set({
             path: ['1'],
             value: 'i am 1'
        }).subscribe();

        model.set({
             path: ['2'],
             value: 'i am 2'
        }).subscribe();

        model.set({
             path: ['3'],
             value: 'i am 3'
        }).subscribe();

        tripleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 125, 'column': 8, 'index': 2732}","it('should set with 3 json', function() {
        var model = getModel();

        model.set({
            json: {
                1: 'i am 1'
            }
        }).subscribe();

        model.set({
            json: {
                2: 'i am 2'
            }
        }).subscribe();


        model.set({
            json: {
                3: 'i am 3'
            }
        }).subscribe();

        tripleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 149, 'column': 8, 'index': 3174}","it('should set with 3 json-graph', function() {
        var model = getModel();

        model.set({
            jsonGraph: {
                1: 'i am 1'
            },
            paths: [
                [1]
            ]
        }).subscribe();


        model.set({
            jsonGraph: {
                2: 'i am 2'
            },
            paths: [
                [2]
            ]
        }).subscribe();

        model.set({
            jsonGraph: {
                3: 'i am 3'
            },
            paths: [
                [3]
            ]
        }).subscribe();

        tripleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 183, 'column': 8, 'index': 3807}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 187, 'column': 8, 'index': 3892}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 188, 'column': 8, 'index': 3924}","it('should promote references on a set.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.
            set({
                path: ['lolomo', '0'],
                value: 'foo'
            }).
            subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual('foo');

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.set.spec.js,Global Variable,"{'line': 232, 'column': 4, 'index': 5210}",Unknown,steel
/test/lru/lru.promote.set.spec.js,Unknown Test,"{'column': 4, 'line': 13}","it('should set with pathValues.', function() {
        var model = getModel();

        model.set({
             path: ['1'],
             value: 'i am 1'
        }).subscribe();

        singleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Unknown Test,"{'column': 4, 'line': 23}","it('should set with json', function() {
        var model = getModel();

        model.set({
            json: {
                1: 'i am 1'
            }
        }).subscribe();

        singleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Unknown Test,"{'column': 4, 'line': 34}","it('should set with json-graph', function() {
        var model = getModel();

        model.set({
            jsonGraph: {
                1: 'i am 1'
            },
            paths: [
                [1]
            ]
        }).subscribe();

        singleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Unknown Test,"{'column': 4, 'line': 48}","it('should set with 2 pathValues.', function() {
        var model = getModel();

        model.set({
             path: ['1'],
             value: 'i am 1'
        }).subscribe();

        model.set({
             path: ['2'],
             value: 'i am 2'
        }).subscribe();

        doubleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Unknown Test,"{'column': 4, 'line': 63}","it('should set with 2 json', function() {
        var model = getModel();

        model.set({
            json: {
                1: 'i am 1'
            }
        }).subscribe();

        model.set({
            json: {
                2: 'i am 2'
            }
        }).subscribe();

        doubleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Unknown Test,"{'column': 4, 'line': 80}","it('should set with 2 json-graph', function() {
        var model = getModel();

        model.set({
            jsonGraph: {
                1: 'i am 1'
            },
            paths: [
                [1]
            ]
        }).subscribe();


        model.set({
            jsonGraph: {
                2: 'i am 2'
            },
            paths: [
                [2]
            ]
        }).subscribe();

        doubleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Unknown Test,"{'column': 4, 'line': 104}","it('should set with 3 pathValues.', function() {
        var model = getModel();

        model.set({
             path: ['1'],
             value: 'i am 1'
        }).subscribe();

        model.set({
             path: ['2'],
             value: 'i am 2'
        }).subscribe();

        model.set({
             path: ['3'],
             value: 'i am 3'
        }).subscribe();

        tripleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Unknown Test,"{'column': 4, 'line': 124}","it('should set with 3 json', function() {
        var model = getModel();

        model.set({
            json: {
                1: 'i am 1'
            }
        }).subscribe();

        model.set({
            json: {
                2: 'i am 2'
            }
        }).subscribe();


        model.set({
            json: {
                3: 'i am 3'
            }
        }).subscribe();

        tripleItem(model);
    })",steel
/test/lru/lru.promote.set.spec.js,Unknown Test,"{'column': 4, 'line': 148}","it('should set with 3 json-graph', function() {
        var model = getModel();

        model.set({
            jsonGraph: {
                1: 'i am 1'
            },
            paths: [
                [1]
            ]
        }).subscribe();


        model.set({
            jsonGraph: {
                2: 'i am 2'
            },
            paths: [
                [2]
            ]
        }).subscribe();

        model.set({
            jsonGraph: {
                3: 'i am 3'
            },
            paths: [
                [3]
            ]
        }).subscribe();

        tripleItem(model);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 43, 'column': 8, 'index': 1685}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 43, 'column': 8, 'index': 1685}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 44, 'column': 8, 'index': 1728}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 44, 'column': 8, 'index': 1728}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 47, 'column': 8, 'index': 1805}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 47, 'column': 8, 'index': 1805}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 48, 'column': 8, 'index': 1847}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 48, 'column': 8, 'index': 1847}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 51, 'column': 8, 'index': 1930}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 51, 'column': 8, 'index': 1930}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 52, 'column': 8, 'index': 1969}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 52, 'column': 8, 'index': 1969}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 55, 'column': 8, 'index': 2051}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 55, 'column': 8, 'index': 2051}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 56, 'column': 8, 'index': 2095}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 56, 'column': 8, 'index': 2095}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 57, 'column': 8, 'index': 2152}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 57, 'column': 8, 'index': 2152}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 63, 'column': 8, 'index': 2308}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 63, 'column': 8, 'index': 2308}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 64, 'column': 8, 'index': 2347}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 64, 'column': 8, 'index': 2347}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 67, 'column': 8, 'index': 2429}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 67, 'column': 8, 'index': 2429}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 68, 'column': 8, 'index': 2473}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 68, 'column': 8, 'index': 2473}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 71, 'column': 8, 'index': 2560}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 71, 'column': 8, 'index': 2560}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 72, 'column': 8, 'index': 2603}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 72, 'column': 8, 'index': 2603}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 75, 'column': 8, 'index': 2680}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 75, 'column': 8, 'index': 2680}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 76, 'column': 8, 'index': 2722}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 76, 'column': 8, 'index': 2722}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 77, 'column': 8, 'index': 2775}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 77, 'column': 8, 'index': 2775}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 93, 'column': 8, 'index': 3487}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 93, 'column': 8, 'index': 3487}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 95, 'column': 8, 'index': 3568}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 95, 'column': 8, 'index': 3568}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 97, 'column': 8, 'index': 3649}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 100, 'column': 8, 'index': 3779}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 100, 'column': 8, 'index': 3779}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 102, 'column': 8, 'index': 3860}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 102, 'column': 8, 'index': 3860}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 117, 'column': 8, 'index': 4583}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 117, 'column': 8, 'index': 4583}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 119, 'column': 8, 'index': 4664}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 119, 'column': 8, 'index': 4664}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 121, 'column': 8, 'index': 4745}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 124, 'column': 8, 'index': 4875}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 124, 'column': 8, 'index': 4875}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 126, 'column': 8, 'index': 4956}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 126, 'column': 8, 'index': 4956}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 137, 'column': 8, 'index': 5269}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 137, 'column': 8, 'index': 5269}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 138, 'column': 8, 'index': 5312}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 138, 'column': 8, 'index': 5312}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 141, 'column': 8, 'index': 5389}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 141, 'column': 8, 'index': 5389}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 142, 'column': 8, 'index': 5431}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 142, 'column': 8, 'index': 5431}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 145, 'column': 8, 'index': 5514}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 145, 'column': 8, 'index': 5514}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 146, 'column': 8, 'index': 5553}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 146, 'column': 8, 'index': 5553}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 149, 'column': 8, 'index': 5635}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 149, 'column': 8, 'index': 5635}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 150, 'column': 8, 'index': 5679}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 150, 'column': 8, 'index': 5679}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 151, 'column': 8, 'index': 5736}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 151, 'column': 8, 'index': 5736}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 157, 'column': 8, 'index': 5892}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 157, 'column': 8, 'index': 5892}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 158, 'column': 8, 'index': 5931}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 158, 'column': 8, 'index': 5931}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 161, 'column': 8, 'index': 6013}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 161, 'column': 8, 'index': 6013}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 162, 'column': 8, 'index': 6057}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 162, 'column': 8, 'index': 6057}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 165, 'column': 8, 'index': 6144}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 165, 'column': 8, 'index': 6144}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 166, 'column': 8, 'index': 6187}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 166, 'column': 8, 'index': 6187}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 169, 'column': 8, 'index': 6264}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 169, 'column': 8, 'index': 6264}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 170, 'column': 8, 'index': 6306}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 170, 'column': 8, 'index': 6306}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 171, 'column': 8, 'index': 6359}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Duplicate Assert,"{'line': 171, 'column': 8, 'index': 6359}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 38}",Unknown,steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 129}",Unknown,steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 6, 'column': 0, 'index': 188}",Unknown,steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 18, 'column': 12, 'index': 709}","it('should promote the get item to the head _toJSONG.', function() {
            var model = new Model();
            model.set({json: {1: 'I am 1'}}).subscribe();
            model.set({json: {2: 'I am 2'}}).subscribe();
            model.set({json: {3: 'I am 3'}}).subscribe();

            getWithPathsAsJSONGraph(model, [['1']], [{}]);
            expect(model._root[__head].value).toBe('I am 1');
        })",steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 27, 'column': 12, 'index': 1129}","it('should promote the get item to the head toJSON.', function() {
            var model = new Model();
            model.set({json: {1: 'I am 1'}}).subscribe();
            model.set({json: {2: 'I am 2'}}).subscribe();
            model.set({json: {3: 'I am 3'}}).subscribe();

            getWithPathsAsPathMap(model, [['1']], [{}]);
            expect(model._root[__head].value).toBe('I am 1');
        })",steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 37, 'column': 8, 'index': 1535}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 41, 'column': 8, 'index': 1620}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 42, 'column': 8, 'index': 1652}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 82, 'column': 8, 'index': 2944}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 92, 'column': 8, 'index': 3444}","it('should promote the get item to the head toJSON.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsPathMap(model, [['2']], [{}]);
        getWithPathsAsPathMap(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 106, 'column': 8, 'index': 4036}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 116, 'column': 8, 'index': 4540}","it('should promote the get item to the head _toJSONG.', function() {
        var model = new Model();
        model.set({json: {1: 'I am 1'}}).subscribe();
        model.set({json: {2: 'I am 2'}}).subscribe();
        model.set({json: {3: 'I am 3'}}).subscribe();

        expect(model._root[__head].value).toBe('I am 3');
        expect(model._root[__head][__next].value).toBe('I am 2');
        expect(model._root[__head][__next][__next].value).toBe('I am 1');
        getWithPathsAsJSONGraph(model, [['2']], [{}]);
        getWithPathsAsJSONGraph(model, [['1']], [{}]);
        var current = model._root[__head];
        expect(current.value).toBe('I am 1');
        current = current[__next];
        expect(current.value).toBe('I am 2');
        current = current[__next];
        expect(current.value).toBe('I am 3');
        expect(current[__next]).toBe(undefined);
        current = current[__prev];
        expect(current.value).toBe('I am 2');
        current = current[__prev];
        expect(current.value).toBe('I am 1');
        expect(current[__prev]).toBe(undefined);
    })",steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 131, 'column': 8, 'index': 5119}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 135, 'column': 8, 'index': 5204}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Global Variable,"{'line': 136, 'column': 8, 'index': 5236}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Lazy Test,"{'line': 38, 'column': 19, 'index': 1578}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/lru/lru.promote.get.spec.js,Lazy Test,"{'line': 132, 'column': 19, 'index': 5162}","it('should promote references on a get.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var root = model._root;
        var curr = root[__head];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);

        curr = curr[__next];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);
        expect(curr[__next]).toBeUndefined();

        model.get(['lolomo', 0]).subscribe();

        // new order to the list
        curr = root[__head];
        expect(curr[__key]).toBe('0');
        expect(curr.value).toEqual(['lists', 'A']);

        curr = curr[__next];
        expect(curr[__key]).toBe('lolomo');
        expect(curr.value).toEqual(['lolomos', '1234']);

        curr = curr[__next];
        expect(curr[__key]).toBe('title');
        expect(curr.value).toEqual('Video 0');

        curr = curr[__next];
        expect(curr[__key]).toBe('item');
        expect(curr.value).toEqual(['videos', '0']);
        expect(curr[__next]).toBeUndefined();
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 19, 'column': 8, 'index': 604}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 20, 'column': 12, 'index': 631}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 24, 'column': 8, 'index': 767}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 25, 'column': 12, 'index': 799}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 29, 'column': 15, 'index': 937}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 29, 'column': 37, 'index': 959}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 38, 'column': 8, 'index': 1114}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 39, 'column': 12, 'index': 1141}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 47, 'column': 8, 'index': 1506}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 48, 'column': 12, 'index': 1538}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 53, 'column': 15, 'index': 1681}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 53, 'column': 37, 'index': 1703}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 66, 'column': 8, 'index': 2048}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 67, 'column': 12, 'index': 2075}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 75, 'column': 8, 'index': 2437}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 76, 'column': 12, 'index': 2469}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 81, 'column': 15, 'index': 2612}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 81, 'column': 37, 'index': 2634}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 95, 'column': 8, 'index': 2974}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 96, 'column': 12, 'index': 3001}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 103, 'column': 8, 'index': 3298}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 104, 'column': 12, 'index': 3330}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 109, 'column': 15, 'index': 3473}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 109, 'column': 37, 'index': 3495}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 122, 'column': 8, 'index': 3841}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 123, 'column': 12, 'index': 3868}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 131, 'column': 8, 'index': 4245}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 132, 'column': 12, 'index': 4277}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 137, 'column': 15, 'index': 4422}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 137, 'column': 37, 'index': 4444}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 152, 'column': 16, 'index': 4890}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 153, 'column': 20, 'index': 4925}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 158, 'column': 16, 'index': 5167}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 159, 'column': 20, 'index': 5207}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 164, 'column': 23, 'index': 5430}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 164, 'column': 45, 'index': 5452}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 172, 'column': 16, 'index': 5691}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 173, 'column': 20, 'index': 5726}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 183, 'column': 16, 'index': 6321}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 184, 'column': 20, 'index': 6361}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 189, 'column': 23, 'index': 6545}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 189, 'column': 45, 'index': 6567}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 207, 'column': 16, 'index': 7172}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 208, 'column': 20, 'index': 7207}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 218, 'column': 16, 'index': 7802}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 219, 'column': 20, 'index': 7842}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 224, 'column': 23, 'index': 8023}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 224, 'column': 45, 'index': 8045}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 240, 'column': 16, 'index': 8603}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 241, 'column': 20, 'index': 8638}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 250, 'column': 16, 'index': 9147}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 251, 'column': 20, 'index': 9187}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 256, 'column': 23, 'index': 9368}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 256, 'column': 45, 'index': 9390}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 271, 'column': 16, 'index': 9885}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 272, 'column': 20, 'index': 9920}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 282, 'column': 16, 'index': 10515}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 283, 'column': 20, 'index': 10555}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 288, 'column': 23, 'index': 10748}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 288, 'column': 45, 'index': 10770}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 304, 'column': 16, 'index': 11332}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 305, 'column': 20, 'index': 11367}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 314, 'column': 16, 'index': 11876}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 315, 'column': 20, 'index': 11916}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 320, 'column': 23, 'index': 12118}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 320, 'column': 45, 'index': 12140}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 335, 'column': 16, 'index': 12637}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 336, 'column': 20, 'index': 12672}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 346, 'column': 16, 'index': 13267}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 347, 'column': 20, 'index': 13307}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 352, 'column': 23, 'index': 13502}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Eager Test,"{'line': 352, 'column': 45, 'index': 13524}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 15, 'column': 8, 'index': 522}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 16, 'column': 8, 'index': 554}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 17, 'column': 8, 'index': 578}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 34, 'column': 8, 'index': 1032}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 35, 'column': 8, 'index': 1064}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 36, 'column': 8, 'index': 1088}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 62, 'column': 8, 'index': 1966}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 63, 'column': 8, 'index': 1998}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 64, 'column': 8, 'index': 2022}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 91, 'column': 8, 'index': 2892}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 92, 'column': 8, 'index': 2924}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 93, 'column': 8, 'index': 2948}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 118, 'column': 8, 'index': 3759}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 119, 'column': 8, 'index': 3791}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 120, 'column': 8, 'index': 3815}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 148, 'column': 16, 'index': 4784}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 149, 'column': 16, 'index': 4824}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 150, 'column': 16, 'index': 4856}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 168, 'column': 16, 'index': 5585}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 169, 'column': 16, 'index': 5625}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 170, 'column': 16, 'index': 5657}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 203, 'column': 16, 'index': 7066}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 204, 'column': 16, 'index': 7106}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 205, 'column': 16, 'index': 7138}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 236, 'column': 16, 'index': 8497}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 237, 'column': 16, 'index': 8537}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 238, 'column': 16, 'index': 8569}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 267, 'column': 16, 'index': 9779}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 268, 'column': 16, 'index': 9819}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 269, 'column': 16, 'index': 9851}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 300, 'column': 16, 'index': 11226}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 301, 'column': 16, 'index': 11266}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 302, 'column': 16, 'index': 11298}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 331, 'column': 16, 'index': 12531}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 332, 'column': 16, 'index': 12571}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Global Variable,"{'line': 333, 'column': 16, 'index': 12603}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 19, 'column': 8, 'index': 604}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 20, 'column': 12, 'index': 631}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 24, 'column': 8, 'index': 767}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 29, 'column': 15, 'index': 937}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $path(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 38, 'column': 8, 'index': 1114}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 39, 'column': 12, 'index': 1141}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 47, 'column': 8, 'index': 1506}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 53, 'column': 15, 'index': 1681}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 66, 'column': 8, 'index': 2048}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 67, 'column': 12, 'index': 2075}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 75, 'column': 8, 'index': 2437}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 81, 'column': 15, 'index': 2612}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 95, 'column': 8, 'index': 2974}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 96, 'column': 12, 'index': 3001}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 103, 'column': 8, 'index': 3298}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 109, 'column': 15, 'index': 3473}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 122, 'column': 8, 'index': 3841}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 123, 'column': 12, 'index': 3868}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 131, 'column': 8, 'index': 4245}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 137, 'column': 15, 'index': 4422}","it(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathSets(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $path([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 152, 'column': 16, 'index': 4890}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 153, 'column': 20, 'index': 4925}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 158, 'column': 16, 'index': 5167}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 164, 'column': 23, 'index': 5430}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 172, 'column': 16, 'index': 5691}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 173, 'column': 20, 'index': 5726}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 183, 'column': 16, 'index': 6321}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 189, 'column': 23, 'index': 6545}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 207, 'column': 16, 'index': 7172}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 208, 'column': 20, 'index': 7207}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 218, 'column': 16, 'index': 7802}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 224, 'column': 23, 'index': 8023}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 240, 'column': 16, 'index': 8603}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 241, 'column': 20, 'index': 8638}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 250, 'column': 16, 'index': 9147}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 256, 'column': 23, 'index': 9368}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 271, 'column': 16, 'index': 9885}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 272, 'column': 20, 'index': 9920}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 282, 'column': 16, 'index': 10515}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 288, 'column': 23, 'index': 10748}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 304, 'column': 16, 'index': 11332}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 305, 'column': 20, 'index': 11367}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 314, 'column': 16, 'index': 11876}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 320, 'column': 23, 'index': 12118}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 335, 'column': 16, 'index': 12637}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 336, 'column': 20, 'index': 12672}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 346, 'column': 16, 'index': 13267}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathSets.spec.js,Lazy Test,"{'line': 352, 'column': 23, 'index': 13502}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathSets(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $path([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 19, 'column': 8, 'index': 618}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 20, 'column': 12, 'index': 645}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 24, 'column': 8, 'index': 781}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 25, 'column': 12, 'index': 813}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 29, 'column': 15, 'index': 962}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 29, 'column': 37, 'index': 984}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 38, 'column': 8, 'index': 1139}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 39, 'column': 12, 'index': 1166}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 47, 'column': 8, 'index': 1531}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 48, 'column': 12, 'index': 1563}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 53, 'column': 15, 'index': 1717}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 53, 'column': 37, 'index': 1739}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 66, 'column': 8, 'index': 2084}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 67, 'column': 12, 'index': 2111}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 75, 'column': 8, 'index': 2473}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 76, 'column': 12, 'index': 2505}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 81, 'column': 15, 'index': 2659}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 81, 'column': 37, 'index': 2681}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 95, 'column': 8, 'index': 3021}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 96, 'column': 12, 'index': 3048}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 103, 'column': 8, 'index': 3345}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 104, 'column': 12, 'index': 3377}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 109, 'column': 15, 'index': 3531}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 109, 'column': 37, 'index': 3553}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 152, 'column': 16, 'index': 4960}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 153, 'column': 20, 'index': 4995}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 158, 'column': 16, 'index': 5237}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 159, 'column': 20, 'index': 5277}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 164, 'column': 23, 'index': 5511}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 164, 'column': 45, 'index': 5533}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 172, 'column': 16, 'index': 5772}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 173, 'column': 20, 'index': 5807}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 183, 'column': 16, 'index': 6402}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 184, 'column': 20, 'index': 6442}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 189, 'column': 23, 'index': 6637}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 189, 'column': 45, 'index': 6659}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 207, 'column': 16, 'index': 7264}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 208, 'column': 20, 'index': 7299}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 218, 'column': 16, 'index': 7894}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 219, 'column': 20, 'index': 7934}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 224, 'column': 23, 'index': 8126}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 224, 'column': 45, 'index': 8148}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 240, 'column': 16, 'index': 8706}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 241, 'column': 20, 'index': 8741}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 250, 'column': 16, 'index': 9250}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 251, 'column': 20, 'index': 9290}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 256, 'column': 23, 'index': 9482}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 256, 'column': 45, 'index': 9504}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 271, 'column': 16, 'index': 9999}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 272, 'column': 20, 'index': 10034}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 282, 'column': 16, 'index': 10629}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 283, 'column': 20, 'index': 10669}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 288, 'column': 23, 'index': 10873}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 288, 'column': 45, 'index': 10895}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 304, 'column': 16, 'index': 11457}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 305, 'column': 20, 'index': 11492}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 314, 'column': 16, 'index': 12001}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 315, 'column': 20, 'index': 12041}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 320, 'column': 23, 'index': 12254}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 320, 'column': 45, 'index': 12276}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 335, 'column': 16, 'index': 12773}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 336, 'column': 20, 'index': 12808}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 346, 'column': 16, 'index': 13403}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 347, 'column': 20, 'index': 13443}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 352, 'column': 23, 'index': 13649}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Eager Test,"{'line': 352, 'column': 45, 'index': 13671}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 15, 'column': 8, 'index': 536}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 16, 'column': 8, 'index': 568}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 17, 'column': 8, 'index': 592}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 34, 'column': 8, 'index': 1057}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 35, 'column': 8, 'index': 1089}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 36, 'column': 8, 'index': 1113}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 62, 'column': 8, 'index': 2002}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 63, 'column': 8, 'index': 2034}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 64, 'column': 8, 'index': 2058}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 91, 'column': 8, 'index': 2939}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 92, 'column': 8, 'index': 2971}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 93, 'column': 8, 'index': 2995}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 118, 'column': 8, 'index': 3818}","xit(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 119, 'column': 8, 'index': 3850}","xit(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 120, 'column': 8, 'index': 3874}","xit(""through a reference with a null last key"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                $pathValue(""movies['reservior-dogs'].title"", ""Reservior Dogs"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope([""grid"", 0, 2, null])
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 148, 'column': 16, 'index': 4854}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 149, 'column': 16, 'index': 4894}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 150, 'column': 16, 'index': 4926}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 168, 'column': 16, 'index': 5666}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 169, 'column': 16, 'index': 5706}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 170, 'column': 16, 'index': 5738}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 203, 'column': 16, 'index': 7158}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 204, 'column': 16, 'index': 7198}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 205, 'column': 16, 'index': 7230}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 236, 'column': 16, 'index': 8600}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 237, 'column': 16, 'index': 8640}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 238, 'column': 16, 'index': 8672}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 267, 'column': 16, 'index': 9893}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 268, 'column': 16, 'index': 9933}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 269, 'column': 16, 'index': 9965}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 300, 'column': 16, 'index': 11351}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 301, 'column': 16, 'index': 11391}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 302, 'column': 16, 'index': 11423}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 331, 'column': 16, 'index': 12667}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 332, 'column': 16, 'index': 12707}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Global Variable,"{'line': 333, 'column': 16, 'index': 12739}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 19, 'column': 8, 'index': 618}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 20, 'column': 12, 'index': 645}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 24, 'column': 8, 'index': 781}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 29, 'column': 15, 'index': 962}","it(""directly"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathValue(""movies['pulp-fiction'].title"")
        ]);

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
            $pathMapEnvelope(""movies['pulp-fiction'].title"")
        ]);

        expect(strip(cache)).toEqual(strip({}));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 38, 'column': 8, 'index': 1139}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 39, 'column': 12, 'index': 1166}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 47, 'column': 8, 'index': 1531}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 53, 'column': 15, 'index': 1717}","it(""through a reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                $pathValue(""movies['pulp-fiction']"", ""Pulp Fiction"")
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][0].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 0: $ref(""movies['pulp-fiction']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 66, 'column': 8, 'index': 2084}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 67, 'column': 12, 'index': 2111}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 75, 'column': 8, 'index': 2473}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 81, 'column': 15, 'index': 2659}","it(""through a reference that lands on an atom"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                $pathValue(""movies['kill-bill-1'].title"", $atom())
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][1].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 1: $ref(""movies['kill-bill-1']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 95, 'column': 8, 'index': 3021}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 96, 'column': 12, 'index': 3048}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 103, 'column': 8, 'index': 3345}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 109, 'column': 15, 'index': 3531}","it(""short-circuits on a broken reference"", function() {

        var lru = new Object();
        var cache = {};
        var version = 0;

        setPathValues(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathValue(""grid"", $ref(""grids['id']"")),
                $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']""))
            ]
        );

        invalidatePathMaps(
            getModel({ lru: lru, cache: cache, version: version++ }), [
                $pathMapEnvelope(""grid[0][2].title"")
            ]
        );

        expect(strip(cache)).toEqual(strip({
            grid: $ref(""grids['id']""),
            grids: { id: { 0: $ref(""lists['id']"") } },
            lists: { id: { 2: $ref(""movies['reservior-dogs']"") } }
        }));
    })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 152, 'column': 16, 'index': 4960}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 153, 'column': 20, 'index': 4995}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 158, 'column': 16, 'index': 5237}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 164, 'column': 23, 'index': 5511}","it(""directly"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"", ""Quentin Tarantino"")
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""movies['pulp-fiction', 'kill-bill-1', 'reservior-dogs'].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({}));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 172, 'column': 16, 'index': 5772}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 173, 'column': 20, 'index': 5807}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 183, 'column': 16, 'index': 6402}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 189, 'column': 23, 'index': 6637}","it(""through successful, short-circuit, and broken references"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0, 1, 2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 207, 'column': 16, 'index': 7264}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 208, 'column': 20, 'index': 7299}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 218, 'column': 16, 'index': 7894}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 224, 'column': 23, 'index': 8126}","it(""to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][0..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 240, 'column': 16, 'index': 8706}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 241, 'column': 20, 'index': 8741}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 250, 'column': 16, 'index': 9250}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 256, 'column': 23, 'index': 9482}","it(""from:1, to:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope(""grid[0][1..2].director"")
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 271, 'column': 16, 'index': 9999}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 272, 'column': 20, 'index': 10034}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 282, 'column': 16, 'index': 10629}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 288, 'column': 23, 'index': 10873}","it(""length:3"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {length: 3}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 304, 'column': 16, 'index': 11457}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 305, 'column': 20, 'index': 11492}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 314, 'column': 16, 'index': 12001}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 320, 'column': 23, 'index': 12254}","it(""from:1, length:2"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, {from: 1, length: 2}, ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 335, 'column': 16, 'index': 12773}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 336, 'column': 20, 'index': 12808}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 346, 'column': 16, 'index': 13403}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/pathMaps.spec.js,Lazy Test,"{'line': 352, 'column': 23, 'index': 13649}","it(""[length:3]"", function() {

                var lru = new Object();
                var cache = {};
                var version = 0;

                setPathValues(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathValue(""grid"", $ref(""grids['id']"")),
                        $pathValue(""grids['id'][0]"", $ref(""lists['id']"")),
                        $pathValue(""lists['id'][0]"", $ref(""movies['pulp-fiction']"")),
                        $pathValue(""lists['id'][1]"", $ref(""movies['kill-bill-1']"")),
                        $pathValue(""lists['id'][2]"", $ref(""movies['reservior-dogs']"")),
                        $pathValue(""movies['kill-bill-1'].director"", $atom())
                    ]
                );

                invalidatePathMaps(
                    getModel({ lru: lru, cache: cache, version: version++ }), [
                        $pathMapEnvelope([""grid"", 0, [{length: 3}], ""director""])
                    ]
                );

                expect(strip(cache)).toEqual(strip({
                    grid: $ref(""grids['id']""),
                    grids: { id: { 0: $ref(""lists['id']"") } },
                    lists: { id: {
                        0: $ref(""movies['pulp-fiction']""),
                        1: $ref(""movies['kill-bill-1']""),
                        2: $ref(""movies['reservior-dogs']"") }
                    }
                }));
            })",steel
/test/invalidate/invalidate.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 37}",Unknown,steel
/test/invalidate/invalidate.spec.js,Global Variable,"{'line': 6, 'column': 0, 'index': 168}",Unknown,steel
/test/invalidate/invalidate.spec.js,Global Variable,"{'line': 9, 'column': 4, 'index': 256}","it('should invalidate with pathSyntax', function(done) {
    var model = new Model({
        cache: {
            foo: {
                bar: 5,
                bazz: 7
            }
        }
    });

    model.invalidate('foo.bar');

    var onNext = jest.fn();
    toObservable(model.
        get('foo.bar', 'foo.bazz')).
        doAction(onNext, noOp, function() {
            expect(onNext).toHaveBeenCalledTimes(1);
            expect(strip(onNext.mock.calls[0][0])).toEqual({
                json: {
                    foo: {
                        bazz: 7
                    }
                }
            });
        }).
        subscribe(noOp, done, done);
})",steel
/test/invalidate/invalidate.spec.js,Global Variable,"{'line': 20, 'column': 4, 'index': 435}","it('should invalidate with pathSyntax', function(done) {
    var model = new Model({
        cache: {
            foo: {
                bar: 5,
                bazz: 7
            }
        }
    });

    model.invalidate('foo.bar');

    var onNext = jest.fn();
    toObservable(model.
        get('foo.bar', 'foo.bazz')).
        doAction(onNext, noOp, function() {
            expect(onNext).toHaveBeenCalledTimes(1);
            expect(strip(onNext.mock.calls[0][0])).toEqual({
                json: {
                    foo: {
                        bazz: 7
                    }
                }
            });
        }).
        subscribe(noOp, done, done);
})",steel
/test/invalidate/invalidate.spec.js,Global Variable,"{'line': 37, 'column': 4, 'index': 927}","it('should throw for undefined paths', function() {
    var model = new Model({ cache: { value: 1 } });
    expect(() => model.invalidate(undefined)).toThrow();
    expect(model.getCache()).toEqual({ value: 1 });
})",steel
/test/invalidate/invalidate.spec.js,Global Variable,"{'line': 43, 'column': 4, 'index': 1141}","it('should throw for empty paths', function() {
    var model = new Model({ cache: { value: 1 } });
    expect(() => model.invalidate([])).toThrow();
    expect(model.getCache()).toEqual({ value: 1 });
})",steel
/test/invalidate/invalidate.spec.js,Global Variable,"{'line': 49, 'column': 4, 'index': 1360}","it('should do nothing for non-existing paths', function() {
    var model = new Model({ cache: { value: 1 } });
    model.invalidate('no.such.path');
    expect(model.getCache()).toEqual({ value: 1 });
})",steel
/test/internal/ModelRoot.comparator.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 50}",Unknown,steel
/test/internal/ModelRoot.comparator.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 147}",Unknown,steel
/test/internal/ModelRoot.comparator.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 178}",Unknown,steel
/test/internal/ModelRoot.comparator.spec.js,Global Variable,"{'line': 12, 'column': 8, 'index': 465}","it('should validate that two equivalent objects are true', function() {
        var obj = {};
        expect(comparator(obj, obj)).toBe(true);
    })",steel
/test/internal/ModelRoot.comparator.spec.js,Global Variable,"{'line': 16, 'column': 8, 'index': 624}","it('should validate that two equal type values are the same.', function() {
        var type1 = atom(5);
        var type2 = atom(5);
        expect(comparator(type1, type2)).toBe(true);
    })",steel
/test/internal/ModelRoot.comparator.spec.js,Global Variable,"{'line': 17, 'column': 8, 'index': 653}","it('should validate that two equal type values are the same.', function() {
        var type1 = atom(5);
        var type2 = atom(5);
        expect(comparator(type1, type2)).toBe(true);
    })",steel
/test/internal/ModelRoot.comparator.spec.js,Global Variable,"{'line': 21, 'column': 8, 'index': 822}","it('should validate that two unequal type values are false.', function() {
        var type1 = atom(5);
        var type2 = atom(6);
        expect(comparator(type1, type2)).toBe(false);
    })",steel
/test/internal/ModelRoot.comparator.spec.js,Global Variable,"{'line': 22, 'column': 8, 'index': 851}","it('should validate that two unequal type values are false.', function() {
        var type1 = atom(5);
        var type2 = atom(6);
        expect(comparator(type1, type2)).toBe(false);
    })",steel
/test/internal/ModelRoot.comparator.spec.js,Global Variable,"{'line': 26, 'column': 8, 'index': 1010}","it('should be false because the types dont match', function() {
        var type1 = atom(5);
        var type2 = error(5);
        expect(comparator(type1, type2)).toBe(false);
    })",steel
/test/internal/ModelRoot.comparator.spec.js,Global Variable,"{'line': 27, 'column': 8, 'index': 1039}","it('should be false because the types dont match', function() {
        var type1 = atom(5);
        var type2 = error(5);
        expect(comparator(type1, type2)).toBe(false);
    })",steel
/test/internal/ModelRoot.comparator.spec.js,Global Variable,"{'line': 31, 'column': 8, 'index': 1202}","it('should be false because the expiry times differ', function() {
        var type1 = atom(5);
        var type2 = atom(5);
        type1.$expires = Date.now();
        expect(comparator(type1, type2)).toBe(false);
    })",steel
/test/internal/ModelRoot.comparator.spec.js,Global Variable,"{'line': 32, 'column': 8, 'index': 1231}","it('should be false because the expiry times differ', function() {
        var type1 = atom(5);
        var type2 = atom(5);
        type1.$expires = Date.now();
        expect(comparator(type1, type2)).toBe(false);
    })",steel
/test/internal/sync/_setValueSync.spec.js,Global Variable,"{'line': 5, 'column': 2, 'index': 108}","describe('_setValueSync', function() {
  var model;
  beforeEach(function() {
    model = falcor({ _path: ['some'], cache: { some: { thing: '1'}}});
  });

  it('sets value in cache synchronously', function() {
    model._setValueSync(['thing'], '2');
    assert.equal(model.getCache().some.thing, '2');
  });

  it('returns the value from cache', function() {
    assert.equal(model._setValueSync(['thing'], '2'), '2')
  });

  it('is symmetrical with _getValueSync', function() {
    model._setValueSync(['thing'], '2');
    assert.equal(model._getValueSync(['thing']), '2');
  });
})",steel
/test/internal/request/complement.spec.js,Lazy Test,"{'line': 6, 'column': 15, 'index': 261}","it(""handles empty path sets"", () => {
        expect(complement([], [], {})).toEqual({
            intersection: [],
            optimizedComplement: [],
            requestedComplement: []
        });
    })",steel
/test/internal/request/complement.spec.js,Lazy Test,"{'line': 15, 'column': 15, 'index': 542}","it(""returns all paths if no deduping possible"", () => {
        const paths = [[""videos"", 0, ""title""]];
        expect(complement(paths, paths, {})).toEqual({
            intersection: [],
            optimizedComplement: paths,
            requestedComplement: paths
        });
    })",steel
/test/internal/request/complement.spec.js,Lazy Test,"{'line': 27, 'column': 15, 'index': 1014}","it(""returns the complement and intersection consisting of paths that can be partially deduped"", () => {
        const partialMatchingPath = [""videos"", [0, 1], ""title""];
        const paths = [partialMatchingPath];
        const pathTree = { 3: { videos: { 0: { title: null } } } };

        expect(complement(paths, paths, pathTree)).toEqual({
            intersection: [[""videos"", 0, ""title""]],
            optimizedComplement: [[""videos"", 1, ""title""]],
            requestedComplement: [[""videos"", 1, ""title""]]
        });
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 57, 'column': 12, 'index': 2264}","it(""makes a couple requests and have them batched together"", done => {
        const scheduler = new TimeoutScheduler(1); // To allow batching
        const source = new LocalDataSource(Cache());
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        queue.get([videos1], [videos1], zip);

        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(false);
        expect(queue._requests[0].scheduled).toBe(true);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 81, 'column': 8, 'index': 3112}","it(""makes a couple requests and have them batched together"", done => {
        const scheduler = new TimeoutScheduler(1); // To allow batching
        const source = new LocalDataSource(Cache());
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        queue.get([videos1], [videos1], zip);

        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(false);
        expect(queue._requests[0].scheduled).toBe(true);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 94, 'column': 12, 'index': 3672}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 113, 'column': 8, 'index': 4348}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 113, 'column': 8, 'index': 4348}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 114, 'column': 8, 'index': 4396}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 114, 'column': 8, 'index': 4396}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 115, 'column': 8, 'index': 4448}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 115, 'column': 8, 'index': 4448}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 118, 'column': 8, 'index': 4553}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 118, 'column': 8, 'index': 4553}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 119, 'column': 8, 'index': 4601}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 119, 'column': 8, 'index': 4601}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 120, 'column': 8, 'index': 4653}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 120, 'column': 8, 'index': 4653}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 156, 'column': 8, 'index': 6051}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 157, 'column': 8, 'index': 6099}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 157, 'column': 8, 'index': 6099}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 158, 'column': 8, 'index': 6151}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 158, 'column': 8, 'index': 6151}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 161, 'column': 8, 'index': 6274}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 162, 'column': 8, 'index': 6322}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 162, 'column': 8, 'index': 6322}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 164, 'column': 8, 'index': 6426}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 164, 'column': 8, 'index': 6426}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 200, 'column': 8, 'index': 7750}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 200, 'column': 8, 'index': 7750}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 201, 'column': 8, 'index': 7798}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 201, 'column': 8, 'index': 7798}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 202, 'column': 8, 'index': 7850}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 202, 'column': 8, 'index': 7850}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 205, 'column': 8, 'index': 7955}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 205, 'column': 8, 'index': 7955}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 206, 'column': 8, 'index': 8003}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 206, 'column': 8, 'index': 8003}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 207, 'column': 8, 'index': 8055}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 207, 'column': 8, 'index': 8055}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 234, 'column': 8, 'index': 9016}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 234, 'column': 8, 'index': 9016}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 235, 'column': 8, 'index': 9064}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 235, 'column': 8, 'index': 9064}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 236, 'column': 8, 'index': 9116}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 236, 'column': 8, 'index': 9116}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 239, 'column': 8, 'index': 9241}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 239, 'column': 8, 'index': 9241}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 240, 'column': 8, 'index': 9289}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 240, 'column': 8, 'index': 9289}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 241, 'column': 8, 'index': 9341}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 241, 'column': 8, 'index': 9341}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 277, 'column': 8, 'index': 10612}","it(""makes a couple requests where only part of the second request is deduped then disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 282, 'column': 8, 'index': 10855}","it(""makes a couple requests where only part of the second request is deduped then disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 311, 'column': 8, 'index': 11918}","it(""makes a couple requests where only part of the second request is deduped then both are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 316, 'column': 8, 'index': 12161}","it(""makes a couple requests where only part of the second request is deduped then both are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 335, 'column': 12, 'index': 12911}","it(""does not dedupe requests when request deduplication is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disableRequestDeduplication: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            expect(dsGetSpy).toHaveBeenCalledTimes(2);

            // Paths should still be collapsed
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [[""videos"", { from: 0, to: 1 }, ""title""]], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [[""videos"", { from: 1, to: 2 }, ""title""]], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 338, 'column': 12, 'index': 13014}","it(""does not dedupe requests when request deduplication is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disableRequestDeduplication: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            expect(dsGetSpy).toHaveBeenCalledTimes(2);

            // Paths should still be collapsed
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [[""videos"", { from: 0, to: 1 }, ""title""]], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [[""videos"", { from: 1, to: 2 }, ""title""]], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 339, 'column': 12, 'index': 13144}","it(""does not dedupe requests when request deduplication is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disableRequestDeduplication: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            expect(dsGetSpy).toHaveBeenCalledTimes(2);

            // Paths should still be collapsed
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [[""videos"", { from: 0, to: 1 }, ""title""]], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [[""videos"", { from: 1, to: 2 }, ""title""]], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 360, 'column': 12, 'index': 14014}","it(""does not collapse paths when path collapse is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disablePathCollapse: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            // Requests should still be deduplicated
            expect(dsGetSpy).toHaveBeenCalledTimes(2);
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos2], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 361, 'column': 12, 'index': 14069}","it(""does not collapse paths when path collapse is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disablePathCollapse: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            // Requests should still be deduplicated
            expect(dsGetSpy).toHaveBeenCalledTimes(2);
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos2], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 362, 'column': 12, 'index': 14176}","it(""does not collapse paths when path collapse is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disablePathCollapse: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            // Requests should still be deduplicated
            expect(dsGetSpy).toHaveBeenCalledTimes(2);
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos2], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 384, 'column': 16, 'index': 15161}","it(""does not collapse paths or dedupe requests"", done => {
            const scheduler = new ImmediateScheduler();
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                // No path collapse, no request dedupe
                expect(dsGetSpy).toHaveBeenCalledTimes(2);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
                expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 385, 'column': 16, 'index': 15220}","it(""does not collapse paths or dedupe requests"", done => {
            const scheduler = new ImmediateScheduler();
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                // No path collapse, no request dedupe
                expect(dsGetSpy).toHaveBeenCalledTimes(2);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
                expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 386, 'column': 16, 'index': 15331}","it(""does not collapse paths or dedupe requests"", done => {
            const scheduler = new ImmediateScheduler();
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                // No path collapse, no request dedupe
                expect(dsGetSpy).toHaveBeenCalledTimes(2);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
                expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 406, 'column': 16, 'index': 16225}","it(""combines batched paths without collapse"", done => {
            const scheduler = new TimeoutScheduler(1); // To allow batching
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                expect(dsGetSpy).toHaveBeenCalledTimes(1);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1, videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",steel
/test/internal/request/RequestQueue.get.spec.js,Duplicate Assert,"{'line': 407, 'column': 16, 'index': 16284}","it(""combines batched paths without collapse"", done => {
            const scheduler = new TimeoutScheduler(1); // To allow batching
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                expect(dsGetSpy).toHaveBeenCalledTimes(1);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1, videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 55, 'column': 20, 'index': 2188}","it(""makes a couple requests and have them batched together"", done => {
        const scheduler = new TimeoutScheduler(1); // To allow batching
        const source = new LocalDataSource(Cache());
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        queue.get([videos1], [videos1], zip);

        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(false);
        expect(queue._requests[0].scheduled).toBe(true);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 60, 'column': 12, 'index': 2355}","it(""makes a couple requests and have them batched together"", done => {
        const scheduler = new TimeoutScheduler(1); // To allow batching
        const source = new LocalDataSource(Cache());
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        queue.get([videos1], [videos1], zip);

        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(false);
        expect(queue._requests[0].scheduled).toBe(true);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 92, 'column': 20, 'index': 3596}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 97, 'column': 12, 'index': 3763}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 129, 'column': 20, 'index': 5080}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 135, 'column': 16, 'index': 5232}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 176, 'column': 20, 'index': 6916}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 182, 'column': 16, 'index': 7068}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 218, 'column': 20, 'index': 8496}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 224, 'column': 16, 'index': 8648}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 253, 'column': 20, 'index': 9797}","it(""makes a couple requests where only part of the second request is deduped then disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 259, 'column': 16, 'index': 9949}","it(""makes a couple requests where only part of the second request is deduped then disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 295, 'column': 20, 'index': 11398}","it(""makes a couple requests where only part of the second request is deduped then both are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Eager Test,"{'line': 301, 'column': 16, 'index': 11550}","it(""makes a couple requests where only part of the second request is deduped then both are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 33, 'column': 8, 'index': 1309}","it(""makes a simple get request"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(Cache(), { onGet });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);
        const callback = jest.fn();
        queue.get([videos0], [videos0], 1, callback);

        expect(callback).toHaveBeenCalledTimes(1);
        const onNext = jest.fn();
        toObservable(model.withoutDataSource().get(videos0))
            .doAction(onNext, noOp, () => {
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });
                expect(onGet).toHaveBeenCalledWith(expect.anything(), [videos0], 1);
            })
            .subscribe(noOp, done, done);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 55, 'column': 20, 'index': 2188}","it(""makes a couple requests and have them batched together"", done => {
        const scheduler = new TimeoutScheduler(1); // To allow batching
        const source = new LocalDataSource(Cache());
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        queue.get([videos1], [videos1], zip);

        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(false);
        expect(queue._requests[0].scheduled).toBe(true);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 60, 'column': 12, 'index': 2355}","it(""makes a couple requests and have them batched together"", done => {
        const scheduler = new TimeoutScheduler(1); // To allow batching
        const source = new LocalDataSource(Cache());
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        queue.get([videos1], [videos1], zip);

        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(false);
        expect(queue._requests[0].scheduled).toBe(true);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 92, 'column': 20, 'index': 3596}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 97, 'column': 12, 'index': 3763}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 129, 'column': 20, 'index': 5080}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 135, 'column': 16, 'index': 5232}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 176, 'column': 20, 'index': 6916}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 182, 'column': 16, 'index': 7068}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 218, 'column': 20, 'index': 8496}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 224, 'column': 16, 'index': 8648}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 253, 'column': 20, 'index': 9797}","it(""makes a couple requests where only part of the second request is deduped then disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 259, 'column': 16, 'index': 9949}","it(""makes a couple requests where only part of the second request is deduped then disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 295, 'column': 20, 'index': 11398}","it(""makes a couple requests where only part of the second request is deduped then both are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 301, 'column': 16, 'index': 11550}","it(""makes a couple requests where only part of the second request is deduped then both are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 331, 'column': 20, 'index': 12782}","it(""does not dedupe requests when request deduplication is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disableRequestDeduplication: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            expect(dsGetSpy).toHaveBeenCalledTimes(2);

            // Paths should still be collapsed
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [[""videos"", { from: 0, to: 1 }, ""title""]], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [[""videos"", { from: 1, to: 2 }, ""title""]], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 355, 'column': 20, 'index': 13832}","it(""does not collapse paths when path collapse is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disablePathCollapse: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            // Requests should still be deduplicated
            expect(dsGetSpy).toHaveBeenCalledTimes(2);
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos2], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 379, 'column': 24, 'index': 14965}","it(""does not collapse paths or dedupe requests"", done => {
            const scheduler = new ImmediateScheduler();
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                // No path collapse, no request dedupe
                expect(dsGetSpy).toHaveBeenCalledTimes(2);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
                expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",steel
/test/internal/request/RequestQueue.get.spec.js,Lazy Test,"{'line': 402, 'column': 24, 'index': 16084}","it(""combines batched paths without collapse"", done => {
            const scheduler = new TimeoutScheduler(1); // To allow batching
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                expect(dsGetSpy).toHaveBeenCalledTimes(1);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1, videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 44, 'column': 81, 'index': 1794}","it(""makes a simple get request"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(Cache(), { onGet });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);
        const callback = jest.fn();
        queue.get([videos0], [videos0], 1, callback);

        expect(callback).toHaveBeenCalledTimes(1);
        const onNext = jest.fn();
        toObservable(model.withoutDataSource().get(videos0))
            .doAction(onNext, noOp, () => {
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });
                expect(onGet).toHaveBeenCalledWith(expect.anything(), [videos0], 1);
            })
            .subscribe(noOp, done, done);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 56, 'column': 35, 'index': 2248}","it(""makes a couple requests and have them batched together"", done => {
        const scheduler = new TimeoutScheduler(1); // To allow batching
        const source = new LocalDataSource(Cache());
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        queue.get([videos1], [videos1], zip);

        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(false);
        expect(queue._requests[0].scheduled).toBe(true);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 57, 'column': 48, 'index': 2300}","it(""makes a couple requests and have them batched together"", done => {
        const scheduler = new TimeoutScheduler(1); // To allow batching
        const source = new LocalDataSource(Cache());
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        queue.get([videos1], [videos1], zip);

        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(false);
        expect(queue._requests[0].scheduled).toBe(true);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 81, 'column': 44, 'index': 3148}","it(""makes a couple requests and have them batched together"", done => {
        const scheduler = new TimeoutScheduler(1); // To allow batching
        const source = new LocalDataSource(Cache());
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        queue.get([videos1], [videos1], zip);

        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(false);
        expect(queue._requests[0].scheduled).toBe(true);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 93, 'column': 35, 'index': 3656}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 94, 'column': 48, 'index': 3708}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 113, 'column': 44, 'index': 4384}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 118, 'column': 44, 'index': 4589}","it(""makes a couple requests where the second argument is deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 132, 'column': 39, 'index': 5169}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 156, 'column': 44, 'index': 6087}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 161, 'column': 44, 'index': 6310}","it(""makes a couple requests where only part of the second request is deduped then first request is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    },
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 179, 'column': 39, 'index': 7005}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 200, 'column': 44, 'index': 7786}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 205, 'column': 44, 'index': 7991}","it(""makes a couple requests where the second request is deduped and the first is disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 221, 'column': 39, 'index': 8585}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 234, 'column': 44, 'index': 9052}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 239, 'column': 44, 'index': 9277}","it(""makes a couple requests where the second argument is deduped and all the requests are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 256, 'column': 39, 'index': 9886}","it(""makes a couple requests where only part of the second request is deduped then disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 277, 'column': 44, 'index': 10648}","it(""makes a couple requests where only part of the second request is deduped then disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 282, 'column': 44, 'index': 10891}","it(""makes a couple requests where only part of the second request is deduped then disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(1);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 298, 'column': 39, 'index': 11487}","it(""makes a couple requests where only part of the second request is deduped then both are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 311, 'column': 44, 'index': 11954}","it(""makes a couple requests where only part of the second request is deduped then both are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 316, 'column': 44, 'index': 12197}","it(""makes a couple requests where only part of the second request is deduped then both are disposed"", done => {
        const scheduler = new ImmediateScheduler();
        const source = new LocalDataSource(Cache(), { wait: 100 });
        const model = new Model({ source });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(
            2,
            callCount => {
                expect(callCount).toBe(0);

                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(onNext).toHaveBeenCalledTimes(1);
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        const disposable = queue.get([videos0], [videos0], zip);
        expect(queue._requests.length).toBe(1);
        expect(queue._requests[0].sent).toBe(true);
        expect(queue._requests[0].scheduled).toBe(false);

        const disposable2 = queue.get([videos0, videos1], [videos0, videos1], zip);
        expect(queue._requests.length).toBe(2);
        expect(queue._requests[1].sent).toBe(true);
        expect(queue._requests[1].scheduled).toBe(false);

        disposable();
        disposable2();
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 332, 'column': 35, 'index': 12842}","it(""does not dedupe requests when request deduplication is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disableRequestDeduplication: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            expect(dsGetSpy).toHaveBeenCalledTimes(2);

            // Paths should still be collapsed
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [[""videos"", { from: 0, to: 1 }, ""title""]], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [[""videos"", { from: 1, to: 2 }, ""title""]], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 333, 'column': 48, 'index': 12894}","it(""does not dedupe requests when request deduplication is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disableRequestDeduplication: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            expect(dsGetSpy).toHaveBeenCalledTimes(2);

            // Paths should still be collapsed
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [[""videos"", { from: 0, to: 1 }, ""title""]], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [[""videos"", { from: 1, to: 2 }, ""title""]], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 356, 'column': 35, 'index': 13892}","it(""does not collapse paths when path collapse is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disablePathCollapse: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            // Requests should still be deduplicated
            expect(dsGetSpy).toHaveBeenCalledTimes(2);
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos2], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 357, 'column': 48, 'index': 13944}","it(""does not collapse paths when path collapse is disabled"", done => {
        const scheduler = new ImmediateScheduler();
        const dsGetSpy = jest.fn();
        const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
        const model = new Model({ source, disablePathCollapse: true });
        const queue = new RequestQueue(model, scheduler);

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            expect(queue._requests.length).toBe(0);

            // Requests should still be deduplicated
            expect(dsGetSpy).toHaveBeenCalledTimes(2);
            expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
            expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos2], undefined);

            done();
        });

        queue.get([videos0, videos1], [videos0, videos1], zip);
        queue.get([videos1, videos2], [videos1, videos2], zip);
    })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 380, 'column': 39, 'index': 15029}","it(""does not collapse paths or dedupe requests"", done => {
            const scheduler = new ImmediateScheduler();
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                // No path collapse, no request dedupe
                expect(dsGetSpy).toHaveBeenCalledTimes(2);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
                expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 381, 'column': 52, 'index': 15085}","it(""does not collapse paths or dedupe requests"", done => {
            const scheduler = new ImmediateScheduler();
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                // No path collapse, no request dedupe
                expect(dsGetSpy).toHaveBeenCalledTimes(2);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1], undefined);
                expect(dsGetSpy).toHaveBeenNthCalledWith(2, expect.anything(), [videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 403, 'column': 39, 'index': 16148}","it(""combines batched paths without collapse"", done => {
            const scheduler = new TimeoutScheduler(1); // To allow batching
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                expect(dsGetSpy).toHaveBeenCalledTimes(1);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1, videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",steel
/test/internal/request/RequestQueue.get.spec.js,Magic Number,"{'line': 404, 'column': 52, 'index': 16204}","it(""combines batched paths without collapse"", done => {
            const scheduler = new TimeoutScheduler(1); // To allow batching
            const dsGetSpy = jest.fn();
            const source = new LocalDataSource(Cache(), { wait: 100, onGet: dsGetSpy });
            const model = new Model({ source, disablePathCollapse: true, disableRequestDeduplication: true });
            const queue = new RequestQueue(model, scheduler);

            const zip = zipSpy(2, callCount => {
                expect(callCount).toBe(2);
                expect(queue._requests.length).toBe(0);

                expect(dsGetSpy).toHaveBeenCalledTimes(1);
                expect(dsGetSpy).toHaveBeenNthCalledWith(1, expect.anything(), [videos0, videos1, videos1, videos2], undefined);

                done();
            });

            queue.get([videos0, videos1], [videos0, videos1], zip);
            queue.get([videos1, videos2], [videos1, videos2], zip);
        })",steel
/test/internal/request/GetRequest.spec.js,Conditional Test Logic,"{'line': 21, 'column': 16, 'index': 766}","it(""unsubscribing should cancel DataSource request (sync scheduler)."", () => {
        let unsubscribeSpy;
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            const handle = setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            });

            unsubscribeSpy = jest.fn(() => {
                clearTimeout(handle);
            });

            return {
                dispose: unsubscribeSpy
            };
        });

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        subscription.dispose();

        expect(subscribeSpy).toHaveBeenCalledTimes(1);
        expect(unsubscribeSpy).toHaveBeenCalledTimes(1);
        expect(onNext).not.toHaveBeenCalled();
        expect(onError).not.toHaveBeenCalled();
        expect(onCompleted).not.toHaveBeenCalled();
    })",steel
/test/internal/request/GetRequest.spec.js,Conditional Test Logic,"{'line': 81, 'column': 16, 'index': 2613}","it(""unsubscribing should cancel DataSource request (async scheduler, unsubscribed immediate)."", () => {
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            });

            // No need to have a spy, if subscribe is called, we fail.
            return {
                dispose() {}
            };
        });

        const model = new Model({
            scheduler: new TimeoutScheduler(1),
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        subscription.dispose();

        expect(subscribeSpy).not.toHaveBeenCalled();
        expect(onNext).not.toHaveBeenCalled();
        expect(onError).not.toHaveBeenCalled();
        expect(onCompleted).not.toHaveBeenCalled();
    })",steel
/test/internal/request/GetRequest.spec.js,Conditional Test Logic,"{'line': 139, 'column': 16, 'index': 4460}","it(""unsubscribing should cancel DataSource request (async scheduler, unsubscribed after subscribe)."", done => {
        let unsubscribeSpy;
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            const handle = setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            }, 100000);

            unsubscribeSpy = jest.fn(() => {
                clearTimeout(handle);
            });

            return {
                dispose: unsubscribeSpy
            };
        });

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        function waitOrExpect() {
            if (!unsubscribeSpy) {
                setTimeout(waitOrExpect, 0);
                return;
            }
            subscription.dispose();

            expect(subscribeSpy).toHaveBeenCalledTimes(1);
            expect(unsubscribeSpy).toHaveBeenCalledTimes(1);
            expect(onNext).not.toHaveBeenCalled();
            expect(onError).not.toHaveBeenCalled();
            expect(onCompleted).not.toHaveBeenCalled();

            done();
        }

        waitOrExpect();
    })",steel
/test/internal/request/GetRequest.spec.js,Conditional Test Logic,"{'line': 179, 'column': 12, 'index': 5550}","it(""unsubscribing should cancel DataSource request (async scheduler, unsubscribed after subscribe)."", done => {
        let unsubscribeSpy;
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            const handle = setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            }, 100000);

            unsubscribeSpy = jest.fn(() => {
                clearTimeout(handle);
            });

            return {
                dispose: unsubscribeSpy
            };
        });

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        function waitOrExpect() {
            if (!unsubscribeSpy) {
                setTimeout(waitOrExpect, 0);
                return;
            }
            subscription.dispose();

            expect(subscribeSpy).toHaveBeenCalledTimes(1);
            expect(unsubscribeSpy).toHaveBeenCalledTimes(1);
            expect(onNext).not.toHaveBeenCalled();
            expect(onError).not.toHaveBeenCalled();
            expect(onCompleted).not.toHaveBeenCalled();

            done();
        }

        waitOrExpect();
    })",steel
/test/internal/request/GetRequest.spec.js,Sleepy Test,"{'line': 11, 'column': 27, 'index': 459}","it(""unsubscribing should cancel DataSource request (sync scheduler)."", () => {
        let unsubscribeSpy;
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            const handle = setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            });

            unsubscribeSpy = jest.fn(() => {
                clearTimeout(handle);
            });

            return {
                dispose: unsubscribeSpy
            };
        });

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        subscription.dispose();

        expect(subscribeSpy).toHaveBeenCalledTimes(1);
        expect(unsubscribeSpy).toHaveBeenCalledTimes(1);
        expect(onNext).not.toHaveBeenCalled();
        expect(onError).not.toHaveBeenCalled();
        expect(onCompleted).not.toHaveBeenCalled();
    })",steel
/test/internal/request/GetRequest.spec.js,Sleepy Test,"{'line': 71, 'column': 12, 'index': 2306}","it(""unsubscribing should cancel DataSource request (async scheduler, unsubscribed immediate)."", () => {
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            });

            // No need to have a spy, if subscribe is called, we fail.
            return {
                dispose() {}
            };
        });

        const model = new Model({
            scheduler: new TimeoutScheduler(1),
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        subscription.dispose();

        expect(subscribeSpy).not.toHaveBeenCalled();
        expect(onNext).not.toHaveBeenCalled();
        expect(onError).not.toHaveBeenCalled();
        expect(onCompleted).not.toHaveBeenCalled();
    })",steel
/test/internal/request/GetRequest.spec.js,Sleepy Test,"{'line': 129, 'column': 27, 'index': 4153}","it(""unsubscribing should cancel DataSource request (async scheduler, unsubscribed after subscribe)."", done => {
        let unsubscribeSpy;
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            const handle = setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            }, 100000);

            unsubscribeSpy = jest.fn(() => {
                clearTimeout(handle);
            });

            return {
                dispose: unsubscribeSpy
            };
        });

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        function waitOrExpect() {
            if (!unsubscribeSpy) {
                setTimeout(waitOrExpect, 0);
                return;
            }
            subscription.dispose();

            expect(subscribeSpy).toHaveBeenCalledTimes(1);
            expect(unsubscribeSpy).toHaveBeenCalledTimes(1);
            expect(onNext).not.toHaveBeenCalled();
            expect(onError).not.toHaveBeenCalled();
            expect(onCompleted).not.toHaveBeenCalled();

            done();
        }

        waitOrExpect();
    })",steel
/test/internal/request/GetRequest.spec.js,Sleepy Test,"{'line': 180, 'column': 16, 'index': 5589}","it(""unsubscribing should cancel DataSource request (async scheduler, unsubscribed after subscribe)."", done => {
        let unsubscribeSpy;
        const subscribeSpy = jest.fn((observerOrOnNext, onError, onCompleted) => {
            const handle = setTimeout(() => {
                const response = {
                    jsonGraph: {
                        list: {
                            1: { name: ""another test"" }
                        }
                    },
                    paths: [""list"", 1, ""name""]
                };

                if (typeof observerOrOnNext === ""function"") {
                    observerOrOnNext(response);
                    onCompleted();
                } else {
                    observerOrOnNext.onNext(response);
                    observerOrOnNext.onCompleted();
                }
            }, 100000);

            unsubscribeSpy = jest.fn(() => {
                clearTimeout(handle);
            });

            return {
                dispose: unsubscribeSpy
            };
        });

        const model = new Model({
            cache: {
                list: {
                    0: { name: ""test"" }
                }
            },
            source: {
                get() {
                    return {
                        subscribe: subscribeSpy
                    };
                }
            }
        });

        const onNext = jest.fn();
        const onError = jest.fn();
        const onCompleted = jest.fn();

        const subscription = model.get(""list[0,1].name"").subscribe(onNext, onError, onCompleted);

        function waitOrExpect() {
            if (!unsubscribeSpy) {
                setTimeout(waitOrExpect, 0);
                return;
            }
            subscription.dispose();

            expect(subscribeSpy).toHaveBeenCalledTimes(1);
            expect(unsubscribeSpy).toHaveBeenCalledTimes(1);
            expect(onNext).not.toHaveBeenCalled();
            expect(onError).not.toHaveBeenCalled();
            expect(onCompleted).not.toHaveBeenCalled();

            done();
        }

        waitOrExpect();
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Conditional Test Logic,"{'line': 34, 'column': 12, 'index': 1299}","it(""should make a request to the dataSource with an immediate scheduler"", done => {
        let inlineBoolean = true;
        const scheduler = new ImmediateScheduler();
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        request.batch([videos0], [videos0], (err, data) => {
            if (err) {
                done(err);
            }

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0))
                .doAction(onNext, noOp, () => {
                    expect(inlineBoolean).toBe(true);
                    expect(getSpy).toHaveBeenCalledTimes(1);
                    expect(getSpy.mock.calls[0][1]).toEqual([videos0]);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });
        inlineBoolean = false;
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Conditional Test Logic,"{'line': 73, 'column': 12, 'index': 2728}","it(""should make a request to the dataSource with an async scheduler."", done => {
        let inlineBoolean = true;
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });
        const callback = jest.fn((err, data) => {
            if (err) {
                done(err);
            }

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0))
                .doAction(onNext, noOp, () => {
                    expect(inlineBoolean).toBe(false);
                    expect(getSpy).toHaveBeenCalledTimes(1);
                    expect(getSpy.mock.calls[0][1]).toEqual([videos0]);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        request.batch([videos0], [videos0], callback);
        inlineBoolean = false;
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Eager Test,"{'line': 113, 'column': 20, 'index': 4111}","it(""should batch some requests together."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        request.batch([videos0], [videos0], zip);
        request.batch([videos1], [videos1], zip);
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Eager Test,"{'line': 116, 'column': 12, 'index': 4225}","it(""should batch some requests together."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        request.batch([videos0], [videos0], zip);
        request.batch([videos1], [videos1], zip);
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Eager Test,"{'line': 150, 'column': 20, 'index': 5430}","it(""should batch some requests together and dispose the first one."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(
            2,
            callCount => {
                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(callCount).toBe(1);
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );
        const disposable = request.batch([videos0], [videos0], zip);
        request.batch([videos1], [videos1], zip);

        disposable();
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Eager Test,"{'line': 154, 'column': 16, 'index': 5538}","it(""should batch some requests together and dispose the first one."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(
            2,
            callCount => {
                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(callCount).toBe(1);
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );
        const disposable = request.batch([videos0], [videos0], zip);
        request.batch([videos1], [videos1], zip);

        disposable();
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Eager Test,"{'line': 189, 'column': 20, 'index': 6789}","it(""should batch some requests together and dispose the second one."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(
            2,
            callCount => {
                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(callCount).toBe(1);
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        request.batch([videos0], [videos0], zip);
        const disposable = request.batch([videos1], [videos1], zip);

        disposable();
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Eager Test,"{'line': 193, 'column': 16, 'index': 6897}","it(""should batch some requests together and dispose the second one."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(
            2,
            callCount => {
                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(callCount).toBe(1);
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        request.batch([videos0], [videos0], zip);
        const disposable = request.batch([videos1], [videos1], zip);

        disposable();
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Lazy Test,"{'line': 39, 'column': 12, 'index': 1402}","it(""should make a request to the dataSource with an immediate scheduler"", done => {
        let inlineBoolean = true;
        const scheduler = new ImmediateScheduler();
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        request.batch([videos0], [videos0], (err, data) => {
            if (err) {
                done(err);
            }

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0))
                .doAction(onNext, noOp, () => {
                    expect(inlineBoolean).toBe(true);
                    expect(getSpy).toHaveBeenCalledTimes(1);
                    expect(getSpy.mock.calls[0][1]).toEqual([videos0]);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });
        inlineBoolean = false;
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Lazy Test,"{'line': 78, 'column': 12, 'index': 2831}","it(""should make a request to the dataSource with an async scheduler."", done => {
        let inlineBoolean = true;
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });
        const callback = jest.fn((err, data) => {
            if (err) {
                done(err);
            }

            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0))
                .doAction(onNext, noOp, () => {
                    expect(inlineBoolean).toBe(false);
                    expect(getSpy).toHaveBeenCalledTimes(1);
                    expect(getSpy.mock.calls[0][1]).toEqual([videos0]);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        request.batch([videos0], [videos0], callback);
        inlineBoolean = false;
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Lazy Test,"{'line': 113, 'column': 20, 'index': 4111}","it(""should batch some requests together."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        request.batch([videos0], [videos0], zip);
        request.batch([videos1], [videos1], zip);
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Lazy Test,"{'line': 116, 'column': 12, 'index': 4225}","it(""should batch some requests together."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        request.batch([videos0], [videos0], zip);
        request.batch([videos1], [videos1], zip);
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Lazy Test,"{'line': 150, 'column': 20, 'index': 5430}","it(""should batch some requests together and dispose the first one."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(
            2,
            callCount => {
                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(callCount).toBe(1);
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );
        const disposable = request.batch([videos0], [videos0], zip);
        request.batch([videos1], [videos1], zip);

        disposable();
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Lazy Test,"{'line': 154, 'column': 16, 'index': 5538}","it(""should batch some requests together and dispose the first one."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(
            2,
            callCount => {
                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(callCount).toBe(1);
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );
        const disposable = request.batch([videos0], [videos0], zip);
        request.batch([videos1], [videos1], zip);

        disposable();
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Lazy Test,"{'line': 189, 'column': 20, 'index': 6789}","it(""should batch some requests together and dispose the second one."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(
            2,
            callCount => {
                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(callCount).toBe(1);
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        request.batch([videos0], [videos0], zip);
        const disposable = request.batch([videos1], [videos1], zip);

        disposable();
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Lazy Test,"{'line': 193, 'column': 16, 'index': 6897}","it(""should batch some requests together and dispose the second one."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(
            2,
            callCount => {
                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(callCount).toBe(1);
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        request.batch([videos0], [videos0], zip);
        const disposable = request.batch([videos1], [videos1], zip);

        disposable();
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Magic Number,"{'line': 114, 'column': 35, 'index': 4171}","it(""should batch some requests together."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(2, callCount => {
            expect(callCount).toBe(2);
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1))
                .doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0""
                                },
                                1: {
                                    title: ""Video 1""
                                }
                            }
                        }
                    });
                })
                .subscribe(noOp, done, done);
        });

        request.batch([videos0], [videos0], zip);
        request.batch([videos1], [videos1], zip);
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Magic Number,"{'line': 156, 'column': 47, 'index': 5699}","it(""should batch some requests together and dispose the first one."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(
            2,
            callCount => {
                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(callCount).toBe(1);
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    1: {
                                        title: ""Video 1""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );
        const disposable = request.batch([videos0], [videos0], zip);
        request.batch([videos1], [videos1], zip);

        disposable();
    })",steel
/test/internal/request/GetRequest.batch.spec.js,Magic Number,"{'line': 195, 'column': 47, 'index': 7058}","it(""should batch some requests together and dispose the second one."", done => {
        const scheduler = new TimeoutScheduler(1);
        const getSpy = jest.fn();
        const source = new LocalDataSource(Cache(), {
            onGet: getSpy
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest() {},
            model
        });

        const zip = zipSpy(
            2,
            callCount => {
                const onNext = jest.fn();
                toObservable(model.withoutDataSource().get(videos0, videos1))
                    .doAction(onNext, noOp, () => {
                        expect(callCount).toBe(1);
                        expect(strip(onNext.mock.calls[0][0])).toEqual({
                            json: {
                                videos: {
                                    0: {
                                        title: ""Video 0""
                                    }
                                }
                            }
                        });
                    })
                    .subscribe(noOp, done, done);
            },
            300
        );

        request.batch([videos0], [videos0], zip);
        const disposable = request.batch([videos1], [videos1], zip);

        disposable();
    })",steel
/test/internal/request/GetRequest.add.spec.js,Eager Test,"{'line': 19, 'column': 43, 'index': 804}","it(""should send a request and dedupe another"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        request.batch([videos0], [videos0], partDone);
        expect(request.sent).toBe(true);

        results = request.add([videos0, videos1], [videos0, videos1], partDone);
    })",steel
/test/internal/request/GetRequest.add.spec.js,Eager Test,"{'line': 32, 'column': 12, 'index': 1153}","it(""should send a request and dedupe another"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        request.batch([videos0], [videos0], partDone);
        expect(request.sent).toBe(true);

        results = request.add([videos0, videos1], [videos0, videos1], partDone);
    })",steel
/test/internal/request/GetRequest.add.spec.js,Eager Test,"{'line': 63, 'column': 43, 'index': 2356}","it(""should send a request and dedupe another when dedupe is in second position"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        request.batch([videos0], [videos0], partDone);
        expect(request.sent).toBe(true);

        results = request.add([videos1, videos0], [videos1, videos0], partDone);
    })",steel
/test/internal/request/GetRequest.add.spec.js,Eager Test,"{'line': 76, 'column': 12, 'index': 2705}","it(""should send a request and dedupe another when dedupe is in second position"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        request.batch([videos0], [videos0], partDone);
        expect(request.sent).toBe(true);

        results = request.add([videos1, videos0], [videos1, videos0], partDone);
    })",steel
/test/internal/request/GetRequest.add.spec.js,Eager Test,"{'line': 107, 'column': 43, 'index': 3898}","it(""should send a request and dedupe another and dispose of original"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        const disposable = request.batch([videos0], [videos0], () =>
            done(new Error(""Request should have been cancelled""))
        );
        expect(request.sent).toBe(true);

        results = request.add([videos0, videos1], [videos0, videos1], partDone);

        // Cancel initial request
        disposable();

        partDone();
    })",steel
/test/internal/request/GetRequest.add.spec.js,Eager Test,"{'line': 120, 'column': 12, 'index': 4247}","it(""should send a request and dedupe another and dispose of original"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        const disposable = request.batch([videos0], [videos0], () =>
            done(new Error(""Request should have been cancelled""))
        );
        expect(request.sent).toBe(true);

        results = request.add([videos0, videos1], [videos0, videos1], partDone);

        // Cancel initial request
        disposable();

        partDone();
    })",steel
/test/internal/request/GetRequest.add.spec.js,Eager Test,"{'line': 158, 'column': 43, 'index': 5608}","it(""should send a request and dedupe another and dispose of deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        request.batch([videos0], [videos0], partDone);
        expect(request.sent).toBe(true);
        results = request.add([videos0, videos1], [videos0, videos1], () =>
            done(new Error(""Request should have been cancelled""))
        );

        // Cancel added request
        results[3]();

        partDone();
    })",steel
/test/internal/request/GetRequest.add.spec.js,Eager Test,"{'line': 171, 'column': 12, 'index': 5957}","it(""should send a request and dedupe another and dispose of deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        request.batch([videos0], [videos0], partDone);
        expect(request.sent).toBe(true);
        results = request.add([videos0, videos1], [videos0, videos1], () =>
            done(new Error(""Request should have been cancelled""))
        );

        // Cancel added request
        results[3]();

        partDone();
    })",steel
/test/internal/request/GetRequest.add.spec.js,Lazy Test,"{'line': 19, 'column': 43, 'index': 804}","it(""should send a request and dedupe another"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        request.batch([videos0], [videos0], partDone);
        expect(request.sent).toBe(true);

        results = request.add([videos0, videos1], [videos0, videos1], partDone);
    })",steel
/test/internal/request/GetRequest.add.spec.js,Lazy Test,"{'line': 32, 'column': 12, 'index': 1153}","it(""should send a request and dedupe another"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        request.batch([videos0], [videos0], partDone);
        expect(request.sent).toBe(true);

        results = request.add([videos0, videos1], [videos0, videos1], partDone);
    })",steel
/test/internal/request/GetRequest.add.spec.js,Lazy Test,"{'line': 63, 'column': 43, 'index': 2356}","it(""should send a request and dedupe another when dedupe is in second position"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        request.batch([videos0], [videos0], partDone);
        expect(request.sent).toBe(true);

        results = request.add([videos1, videos0], [videos1, videos0], partDone);
    })",steel
/test/internal/request/GetRequest.add.spec.js,Lazy Test,"{'line': 76, 'column': 12, 'index': 2705}","it(""should send a request and dedupe another when dedupe is in second position"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        request.batch([videos0], [videos0], partDone);
        expect(request.sent).toBe(true);

        results = request.add([videos1, videos0], [videos1, videos0], partDone);
    })",steel
/test/internal/request/GetRequest.add.spec.js,Lazy Test,"{'line': 107, 'column': 43, 'index': 3898}","it(""should send a request and dedupe another and dispose of original"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        const disposable = request.batch([videos0], [videos0], () =>
            done(new Error(""Request should have been cancelled""))
        );
        expect(request.sent).toBe(true);

        results = request.add([videos0, videos1], [videos0, videos1], partDone);

        // Cancel initial request
        disposable();

        partDone();
    })",steel
/test/internal/request/GetRequest.add.spec.js,Lazy Test,"{'line': 120, 'column': 12, 'index': 4247}","it(""should send a request and dedupe another and dispose of original"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        const disposable = request.batch([videos0], [videos0], () =>
            done(new Error(""Request should have been cancelled""))
        );
        expect(request.sent).toBe(true);

        results = request.add([videos0, videos1], [videos0, videos1], partDone);

        // Cancel initial request
        disposable();

        partDone();
    })",steel
/test/internal/request/GetRequest.add.spec.js,Lazy Test,"{'line': 158, 'column': 43, 'index': 5608}","it(""should send a request and dedupe another and dispose of deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        request.batch([videos0], [videos0], partDone);
        expect(request.sent).toBe(true);
        results = request.add([videos0, videos1], [videos0, videos1], () =>
            done(new Error(""Request should have been cancelled""))
        );

        // Cancel added request
        results[3]();

        partDone();
    })",steel
/test/internal/request/GetRequest.add.spec.js,Lazy Test,"{'line': 171, 'column': 12, 'index': 5957}","it(""should send a request and dedupe another and dispose of deduped"", done => {
        const scheduler = new ImmediateScheduler();
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            wait: 0,
            onGet
        });
        const model = new Model({ source });
        const request = new GetRequest(scheduler, {
            removeRequest: noOp,
            model
        });

        let results;
        const partDone = after(2, () => {
            const onNext = jest.fn();
            toObservable(model.withoutDataSource().get(videos0, videos1)).subscribe(onNext, done, () => {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([videos0]);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });

                expect(results[0]).toBe(true);
                expect(results[1]).toEqual([videos1]);
                expect(results[2]).toEqual([videos1]);

                done();
            });
        });

        request.batch([videos0], [videos0], partDone);
        expect(request.sent).toBe(true);
        results = request.add([videos0, videos1], [videos0, videos1], () =>
            done(new Error(""Request should have been cancelled""))
        );

        // Cancel added request
        results[3]();

        partDone();
    })",steel
/test/integration/get.spec.js,Global Variable,"{'line': 8, 'column': 0, 'index': 372}",Unknown,steel
/test/integration/get.spec.js,Global Variable,"{'line': 12, 'column': 4, 'index': 490}","describe('Get Integration Tests', function() {
    var app, server, serverUrl, model, onNext;

    beforeEach(function(done) {
        app = express();
        server = app.listen(60002, done);
        serverUrl = 'http://localhost:60002';
        model = new falcor.Model({
            source: new falcor.HttpDataSource(serverUrl + '/model.json')
        });
        onNext = jest.fn();
    });

    it('should be able to return null from a router. #535', function(done) {
        setRoutes([
            {
                route: ['thing', 'prop'],
                get: function (path) {
                    return {
                        path: ['thing', 'prop'],
                        value: null
                    };
                }
            }
        ]);

        toObservable(model.
            get(['thing', 'prop'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        thing: {
                            prop: null
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    });

    describe('expiry', function() {
        it('$expires = 0 should expire immediately after current tick of event loop', function(done) {
            setRoutes([{
                route: ['path'],
                get: function() {
                    return {
                        path: ['path'],
                        value: { $type: 'atom', $expires: 0, value: 'value' }
                    };
                }
            }]);

            model.get('path').subscribe(onNext, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: { path: 'value' }
                });
                model.
                    withoutDataSource().
                    get('path').
                    subscribe(function(sameTickValue) {
                        expect(sameTickValue).toEqual({
                            json: { path: 'value' }
                        });
                    }, done, function() {
                        setTimeout(function() {
                            model.
                                withoutDataSource().
                                get('path').
                                subscribe(function(nextTickValue) {
                                    expect(nextTickValue).toEqual({ json: {} });
                                }, done, done);
                        }, 0);
                    });
            });
        });

        it('$expires = 1 should never expire (unless kicked out by LRU cache)', function(done) {
            setRoutes([{
                route: ['path'],
                get: function() {
                    return {
                        path: ['path'],
                        value: { $type: 'atom', $expires: 1, value: 'value' }
                    };
                }
            }]);

            model.get('path').subscribe(onNext, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: { path: 'value' }
                });
                setTimeout(function() {
                    model.
                        withoutDataSource().
                        get('path').
                        subscribe(function(nearFutureValue) {
                            expect(nearFutureValue).toEqual({
                                json: { path: 'value' }
                            });
                        }, done, function() {
                            setTimeout(function() {
                                model.
                                    withoutDataSource().
                                    get('path').
                                    subscribe(function(farFutureValue) {
                                        expect(farFutureValue).toEqual({
                                            json: { path: 'value' }
                                        });
                                    }, done, done);
                            }, 500);
                        });
                }, 20);
            });
        });

        it('$expires = -<timestamp> should expire in relative future', function(done) {
            setRoutes([{
                route: ['path'],
                get: function() {
                    return {
                        path: ['path'],
                        value: { $type: 'atom', $expires: -100, value: 'value' }
                    };
                }
            }]);

            model.get('path').subscribe(onNext, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: { path: 'value' }
                });
                setTimeout(function() {
                    model.
                        withoutDataSource().
                        get('path').
                        subscribe(function(nearFutureValue) {
                            expect(nearFutureValue).toEqual({
                                json: { path: 'value' }
                            });
                        }, done, function() {
                            setTimeout(function() {
                                model.
                                    withoutDataSource().
                                    get('path').
                                    subscribe(function(farFutureValue) {
                                        expect(farFutureValue).toEqual({});
                                    }, done, done);
                            }, 50);
                        });
                }, 50);
            });
        });

        it('$expires = <timestamp> should expire at absolute time', function(done) {
            setRoutes([{
                route: ['path'],
                get: function() {
                    return {
                        path: ['path'],
                        value: { $type: 'atom', $expires: Date.now() + 100, value: 'value' }
                    };
                }
            }]);

            model.get('path').subscribe(onNext, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: { path: 'value' }
                });
                setTimeout(function() {
                    model.
                        withoutDataSource().
                        get('path').
                        subscribe(function(nearFutureValue) {
                            expect(nearFutureValue).toEqual({
                                json: { path: 'value' }
                            });
                        }, done, function() {
                            setTimeout(function() {
                                model.
                                    withoutDataSource().
                                    get('path').
                                    subscribe(function(farFutureValue) {
                                        expect(farFutureValue).toEqual({});
                                    }, done, done);
                            }, 50);
                        });
                }, 50);
            });
        });

        it('$expires = <past timestamp> has already expired, causing retries', function(done) {
            setRoutes([{
                route: ['path'],
                get: function() {
                    return {
                        path: ['path'],
                        value: { $type: 'atom', $expires: Date.now() - 100, value: 'value' }
                    };
                }
            }]);

            model.get('path').subscribe(noOp, function(e) {
                expect(MaxRetryExceededError.is(e)).toBe(true);
                done();
            }, done.bind(null, new Error('should not complete')));
        });
    });

    afterEach(function(done) {
        server.close(done);
    });

    function setRoutes(routes) {
      app.use('/model.json', FalcorServer.dataSourceRoute(function() {
          return new Router(routes);
      }));
    }
})",steel
/test/integration/get.spec.js,Sleepy Test,"{'line': 77, 'column': 24, 'index': 2724}","it('$expires = 0 should expire immediately after current tick of event loop', function(done) {
            setRoutes([{
                route: ['path'],
                get: function() {
                    return {
                        path: ['path'],
                        value: { $type: 'atom', $expires: 0, value: 'value' }
                    };
                }
            }]);

            model.get('path').subscribe(onNext, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: { path: 'value' }
                });
                model.
                    withoutDataSource().
                    get('path').
                    subscribe(function(sameTickValue) {
                        expect(sameTickValue).toEqual({
                            json: { path: 'value' }
                        });
                    }, done, function() {
                        setTimeout(function() {
                            model.
                                withoutDataSource().
                                get('path').
                                subscribe(function(nextTickValue) {
                                    expect(nextTickValue).toEqual({ json: {} });
                                }, done, done);
                        }, 0);
                    });
            });
        })",steel
/test/integration/get.spec.js,Sleepy Test,"{'line': 105, 'column': 16, 'index': 3826}","it('$expires = 1 should never expire (unless kicked out by LRU cache)', function(done) {
            setRoutes([{
                route: ['path'],
                get: function() {
                    return {
                        path: ['path'],
                        value: { $type: 'atom', $expires: 1, value: 'value' }
                    };
                }
            }]);

            model.get('path').subscribe(onNext, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: { path: 'value' }
                });
                setTimeout(function() {
                    model.
                        withoutDataSource().
                        get('path').
                        subscribe(function(nearFutureValue) {
                            expect(nearFutureValue).toEqual({
                                json: { path: 'value' }
                            });
                        }, done, function() {
                            setTimeout(function() {
                                model.
                                    withoutDataSource().
                                    get('path').
                                    subscribe(function(farFutureValue) {
                                        expect(farFutureValue).toEqual({
                                            json: { path: 'value' }
                                        });
                                    }, done, done);
                            }, 500);
                        });
                }, 20);
            });
        })",steel
/test/integration/get.spec.js,Sleepy Test,"{'line': 114, 'column': 28, 'index': 4245}","it('$expires = 1 should never expire (unless kicked out by LRU cache)', function(done) {
            setRoutes([{
                route: ['path'],
                get: function() {
                    return {
                        path: ['path'],
                        value: { $type: 'atom', $expires: 1, value: 'value' }
                    };
                }
            }]);

            model.get('path').subscribe(onNext, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: { path: 'value' }
                });
                setTimeout(function() {
                    model.
                        withoutDataSource().
                        get('path').
                        subscribe(function(nearFutureValue) {
                            expect(nearFutureValue).toEqual({
                                json: { path: 'value' }
                            });
                        }, done, function() {
                            setTimeout(function() {
                                model.
                                    withoutDataSource().
                                    get('path').
                                    subscribe(function(farFutureValue) {
                                        expect(farFutureValue).toEqual({
                                            json: { path: 'value' }
                                        });
                                    }, done, done);
                            }, 500);
                        });
                }, 20);
            });
        })",steel
/test/integration/get.spec.js,Sleepy Test,"{'line': 145, 'column': 16, 'index': 5500}","it('$expires = -<timestamp> should expire in relative future', function(done) {
            setRoutes([{
                route: ['path'],
                get: function() {
                    return {
                        path: ['path'],
                        value: { $type: 'atom', $expires: -100, value: 'value' }
                    };
                }
            }]);

            model.get('path').subscribe(onNext, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: { path: 'value' }
                });
                setTimeout(function() {
                    model.
                        withoutDataSource().
                        get('path').
                        subscribe(function(nearFutureValue) {
                            expect(nearFutureValue).toEqual({
                                json: { path: 'value' }
                            });
                        }, done, function() {
                            setTimeout(function() {
                                model.
                                    withoutDataSource().
                                    get('path').
                                    subscribe(function(farFutureValue) {
                                        expect(farFutureValue).toEqual({});
                                    }, done, done);
                            }, 50);
                        });
                }, 50);
            });
        })",steel
/test/integration/get.spec.js,Sleepy Test,"{'line': 154, 'column': 28, 'index': 5919}","it('$expires = -<timestamp> should expire in relative future', function(done) {
            setRoutes([{
                route: ['path'],
                get: function() {
                    return {
                        path: ['path'],
                        value: { $type: 'atom', $expires: -100, value: 'value' }
                    };
                }
            }]);

            model.get('path').subscribe(onNext, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: { path: 'value' }
                });
                setTimeout(function() {
                    model.
                        withoutDataSource().
                        get('path').
                        subscribe(function(nearFutureValue) {
                            expect(nearFutureValue).toEqual({
                                json: { path: 'value' }
                            });
                        }, done, function() {
                            setTimeout(function() {
                                model.
                                    withoutDataSource().
                                    get('path').
                                    subscribe(function(farFutureValue) {
                                        expect(farFutureValue).toEqual({});
                                    }, done, done);
                            }, 50);
                        });
                }, 50);
            });
        })",steel
/test/integration/get.spec.js,Sleepy Test,"{'line': 183, 'column': 16, 'index': 7073}","it('$expires = <timestamp> should expire at absolute time', function(done) {
            setRoutes([{
                route: ['path'],
                get: function() {
                    return {
                        path: ['path'],
                        value: { $type: 'atom', $expires: Date.now() + 100, value: 'value' }
                    };
                }
            }]);

            model.get('path').subscribe(onNext, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: { path: 'value' }
                });
                setTimeout(function() {
                    model.
                        withoutDataSource().
                        get('path').
                        subscribe(function(nearFutureValue) {
                            expect(nearFutureValue).toEqual({
                                json: { path: 'value' }
                            });
                        }, done, function() {
                            setTimeout(function() {
                                model.
                                    withoutDataSource().
                                    get('path').
                                    subscribe(function(farFutureValue) {
                                        expect(farFutureValue).toEqual({});
                                    }, done, done);
                            }, 50);
                        });
                }, 50);
            });
        })",steel
/test/integration/get.spec.js,Sleepy Test,"{'line': 192, 'column': 28, 'index': 7492}","it('$expires = <timestamp> should expire at absolute time', function(done) {
            setRoutes([{
                route: ['path'],
                get: function() {
                    return {
                        path: ['path'],
                        value: { $type: 'atom', $expires: Date.now() + 100, value: 'value' }
                    };
                }
            }]);

            model.get('path').subscribe(onNext, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: { path: 'value' }
                });
                setTimeout(function() {
                    model.
                        withoutDataSource().
                        get('path').
                        subscribe(function(nearFutureValue) {
                            expect(nearFutureValue).toEqual({
                                json: { path: 'value' }
                            });
                        }, done, function() {
                            setTimeout(function() {
                                model.
                                    withoutDataSource().
                                    get('path').
                                    subscribe(function(farFutureValue) {
                                        expect(farFutureValue).toEqual({});
                                    }, done, done);
                            }, 50);
                        });
                }, 50);
            });
        })",steel
/test/integration/express.spec.js,Global Variable,"{'line': 7, 'column': 0, 'index': 276}",Unknown,steel
/test/integration/express.spec.js,Global Variable,"{'line': 8, 'column': 0, 'index': 302}",Unknown,steel
/test/integration/express.spec.js,Global Variable,"{'line': 9, 'column': 0, 'index': 346}",Unknown,steel
/test/integration/express.spec.js,Global Variable,"{'line': 14, 'column': 4, 'index': 526}","describe('Express Integration', function() {
    var server;
    beforeEach(function(done) {
        var app = express();
        app.use(bodyParser.urlencoded({ extended: false }));

        // Simple middleware to handle get/post
        app.use('/model.json', FalcorServer.dataSourceRoute(function(req, res) {
            return new FalcorRouter([
                {
                    // match a request for the key ""greeting""
                    route: ""greeting"",
                    // respond with a PathValue with the value of ""Hello World.""
                    get: function() {
                        return {path:[""greeting""], value: ""Hello World""};
                    }
                }
            ]);
        }));

        server = app.listen(60001, done);
    });

    it('should be able to perform the express demo.', function(done) {
        var model = new falcor.Model({
            source: new falcor.HttpDataSource('http://localhost:60001/model.json')
        });
        var onNext = jest.fn();

        toObservable(model.
            get('greeting')).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        greeting: 'Hello World'
                    }
                });
            }).
            subscribe(noOp, done, done);
    });

    afterEach(function() {
        server.close();
    });
})",steel
/test/integration/express.spec.js,Global Variable,"{'line': 16, 'column': 8, 'index': 578}","beforeEach(function(done) {
        var app = express();
        app.use(bodyParser.urlencoded({ extended: false }));

        // Simple middleware to handle get/post
        app.use('/model.json', FalcorServer.dataSourceRoute(function(req, res) {
            return new FalcorRouter([
                {
                    // match a request for the key ""greeting""
                    route: ""greeting"",
                    // respond with a PathValue with the value of ""Hello World.""
                    get: function() {
                        return {path:[""greeting""], value: ""Hello World""};
                    }
                }
            ]);
        }));

        server = app.listen(60001, done);
    })",steel
/test/integration/express.spec.js,Global Variable,"{'line': 37, 'column': 8, 'index': 1340}","it('should be able to perform the express demo.', function(done) {
        var model = new falcor.Model({
            source: new falcor.HttpDataSource('http://localhost:60001/model.json')
        });
        var onNext = jest.fn();

        toObservable(model.
            get('greeting')).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        greeting: 'Hello World'
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/express.spec.js,Global Variable,"{'line': 40, 'column': 8, 'index': 1474}","it('should be able to perform the express demo.', function(done) {
        var model = new falcor.Model({
            source: new falcor.HttpDataSource('http://localhost:60001/model.json')
        });
        var onNext = jest.fn();

        toObservable(model.
            get('greeting')).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        greeting: 'Hello World'
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/dedupe.spec.js,Duplicate Assert,"{'line': 34, 'column': 28, 'index': 1044}","it(""dedupes new requested paths with previous in-flight requests"", done => {
        const onGet = jest.fn();
        const model = new falcor.Model({
            source: new LocalDataSource(
                {
                    things: {
                        0: ""thing: 0"",
                        1: ""thing: 1"",
                        2: ""thing: 2""
                    }
                },
                { wait: 0, onGet }
            )
        });

        const partDone = after(2, () => {
            expect(onGet.mock.calls[1][1]).toEqual([[""things"", ""2""]]);

            done();
        });

        model
            .get([""things"", { from: 0, to: 1 }])
            .subscribe(
                response => expect(strip(response.json)).toEqual({ things: { 0: ""thing: 0"", 1: ""thing: 1"" } }),
                done,
                partDone
            );

        model
            .get([""things"", { from: 1, to: 2 }])
            .subscribe(
                response => expect(strip(response.json)).toEqual({ things: { 1: ""thing: 1"", 2: ""thing: 2"" } }),
                done,
                partDone
            );
    })",steel
/test/integration/dedupe.spec.js,Duplicate Assert,"{'line': 42, 'column': 28, 'index': 1306}","it(""dedupes new requested paths with previous in-flight requests"", done => {
        const onGet = jest.fn();
        const model = new falcor.Model({
            source: new LocalDataSource(
                {
                    things: {
                        0: ""thing: 0"",
                        1: ""thing: 1"",
                        2: ""thing: 2""
                    }
                },
                { wait: 0, onGet }
            )
        });

        const partDone = after(2, () => {
            expect(onGet.mock.calls[1][1]).toEqual([[""things"", ""2""]]);

            done();
        });

        model
            .get([""things"", { from: 0, to: 1 }])
            .subscribe(
                response => expect(strip(response.json)).toEqual({ things: { 0: ""thing: 0"", 1: ""thing: 1"" } }),
                done,
                partDone
            );

        model
            .get([""things"", { from: 1, to: 2 }])
            .subscribe(
                response => expect(strip(response.json)).toEqual({ things: { 1: ""thing: 1"", 2: ""thing: 2"" } }),
                done,
                partDone
            );
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 93}",Unknown,steel
/test/integration/call.spec.js,Global Variable,"{'line': 7, 'column': 0, 'index': 223}",Unknown,steel
/test/integration/call.spec.js,Global Variable,"{'line': 11, 'column': 8, 'index': 393}","it('#339 should use the router as a data source and make a call to the router.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {
                return {
                    path: ['genreList', 0, 'titles', 2],
                    value: {
                        $type: 'ref',
                        value: ['titlesById', 1]
                    }
                };
            }
        }, {
            route: 'titlesById[{integers:ids}].name',
            get: function(aliasMap) {
                var id = aliasMap.ids[0];
                return {
                    path: ['titlesById', id, 'name'],
                    value: 'House of Cards'
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });
        var args = [falcor.Model.ref('titlesById[1]')];
        var onNext = jest.fn();
        toObservable(model.
            call(""genreList[0].titles.push"", args, ['name'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        genreList: {
                            0: {
                                titles: {
                                    2: {
                                        name: 'House of Cards'
                                    }
                                },
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 25, 'column': 16, 'index': 897}","it('#339 should use the router as a data source and make a call to the router.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {
                return {
                    path: ['genreList', 0, 'titles', 2],
                    value: {
                        $type: 'ref',
                        value: ['titlesById', 1]
                    }
                };
            }
        }, {
            route: 'titlesById[{integers:ids}].name',
            get: function(aliasMap) {
                var id = aliasMap.ids[0];
                return {
                    path: ['titlesById', id, 'name'],
                    value: 'House of Cards'
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });
        var args = [falcor.Model.ref('titlesById[1]')];
        var onNext = jest.fn();
        toObservable(model.
            call(""genreList[0].titles.push"", args, ['name'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        genreList: {
                            0: {
                                titles: {
                                    2: {
                                        name: 'House of Cards'
                                    }
                                },
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 33, 'column': 8, 'index': 1101}","it('#339 should use the router as a data source and make a call to the router.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {
                return {
                    path: ['genreList', 0, 'titles', 2],
                    value: {
                        $type: 'ref',
                        value: ['titlesById', 1]
                    }
                };
            }
        }, {
            route: 'titlesById[{integers:ids}].name',
            get: function(aliasMap) {
                var id = aliasMap.ids[0];
                return {
                    path: ['titlesById', id, 'name'],
                    value: 'House of Cards'
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });
        var args = [falcor.Model.ref('titlesById[1]')];
        var onNext = jest.fn();
        toObservable(model.
            call(""genreList[0].titles.push"", args, ['name'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        genreList: {
                            0: {
                                titles: {
                                    2: {
                                        name: 'House of Cards'
                                    }
                                },
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 36, 'column': 8, 'index': 1179}","it('#339 should use the router as a data source and make a call to the router.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {
                return {
                    path: ['genreList', 0, 'titles', 2],
                    value: {
                        $type: 'ref',
                        value: ['titlesById', 1]
                    }
                };
            }
        }, {
            route: 'titlesById[{integers:ids}].name',
            get: function(aliasMap) {
                var id = aliasMap.ids[0];
                return {
                    path: ['titlesById', id, 'name'],
                    value: 'House of Cards'
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });
        var args = [falcor.Model.ref('titlesById[1]')];
        var onNext = jest.fn();
        toObservable(model.
            call(""genreList[0].titles.push"", args, ['name'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        genreList: {
                            0: {
                                titles: {
                                    2: {
                                        name: 'House of Cards'
                                    }
                                },
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 37, 'column': 8, 'index': 1235}","it('#339 should use the router as a data source and make a call to the router.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {
                return {
                    path: ['genreList', 0, 'titles', 2],
                    value: {
                        $type: 'ref',
                        value: ['titlesById', 1]
                    }
                };
            }
        }, {
            route: 'titlesById[{integers:ids}].name',
            get: function(aliasMap) {
                var id = aliasMap.ids[0];
                return {
                    path: ['titlesById', id, 'name'],
                    value: 'House of Cards'
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });
        var args = [falcor.Model.ref('titlesById[1]')];
        var onNext = jest.fn();
        toObservable(model.
            call(""genreList[0].titles.push"", args, ['name'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        genreList: {
                            0: {
                                titles: {
                                    2: {
                                        name: 'House of Cards'
                                    }
                                },
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 60, 'column': 8, 'index': 2092}","it('#339 should ensure that an empty call does not explode.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {
                return {
                    path: ['genreList', 0, 'titles', 2],
                    value: {
                        $type: 'ref',
                        value: ['titlesById', 1]
                    }
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });
        var args = [falcor.Model.ref('titlesById[1]')];
        var onNext = jest.fn();
        toObservable(model.
            call(""genreList[0].titles.push"", args, ['name'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 73, 'column': 8, 'index': 2497}","it('#339 should ensure that an empty call does not explode.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {
                return {
                    path: ['genreList', 0, 'titles', 2],
                    value: {
                        $type: 'ref',
                        value: ['titlesById', 1]
                    }
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });
        var args = [falcor.Model.ref('titlesById[1]')];
        var onNext = jest.fn();
        toObservable(model.
            call(""genreList[0].titles.push"", args, ['name'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 76, 'column': 8, 'index': 2575}","it('#339 should ensure that an empty call does not explode.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {
                return {
                    path: ['genreList', 0, 'titles', 2],
                    value: {
                        $type: 'ref',
                        value: ['titlesById', 1]
                    }
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });
        var args = [falcor.Model.ref('titlesById[1]')];
        var onNext = jest.fn();
        toObservable(model.
            call(""genreList[0].titles.push"", args, ['name'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 77, 'column': 8, 'index': 2631}","it('#339 should ensure that an empty call does not explode.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {
                return {
                    path: ['genreList', 0, 'titles', 2],
                    value: {
                        $type: 'ref',
                        value: ['titlesById', 1]
                    }
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });
        var args = [falcor.Model.ref('titlesById[1]')];
        var onNext = jest.fn();
        toObservable(model.
            call(""genreList[0].titles.push"", args, ['name'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 87, 'column': 8, 'index': 3013}","it('Response with invalidations and no paths should not explode.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {

                var invalidatedPath = callPath.slice(0, callPath.length-1);
                // [genreList, [0], titles, length]
                invalidatedPath.push('length');

                return {
                    path: invalidatedPath,
                    invalidated: true
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });

        var args = [falcor.Model.ref('titlesById[1]')];

        var onNext = jest.fn();

        toObservable(model.
            call(""genreList[0].titles.push"", args)).
            doAction(onNext, noOp, noOp).
            subscribe(noOp, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                });
                done();
            });
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 91, 'column': 16, 'index': 3160}","it('Response with invalidations and no paths should not explode.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {

                var invalidatedPath = callPath.slice(0, callPath.length-1);
                // [genreList, [0], titles, length]
                invalidatedPath.push('length');

                return {
                    path: invalidatedPath,
                    invalidated: true
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });

        var args = [falcor.Model.ref('titlesById[1]')];

        var onNext = jest.fn();

        toObservable(model.
            call(""genreList[0].titles.push"", args)).
            doAction(onNext, noOp, noOp).
            subscribe(noOp, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                });
                done();
            });
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 102, 'column': 8, 'index': 3482}","it('Response with invalidations and no paths should not explode.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {

                var invalidatedPath = callPath.slice(0, callPath.length-1);
                // [genreList, [0], titles, length]
                invalidatedPath.push('length');

                return {
                    path: invalidatedPath,
                    invalidated: true
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });

        var args = [falcor.Model.ref('titlesById[1]')];

        var onNext = jest.fn();

        toObservable(model.
            call(""genreList[0].titles.push"", args)).
            doAction(onNext, noOp, noOp).
            subscribe(noOp, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                });
                done();
            });
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 106, 'column': 8, 'index': 3561}","it('Response with invalidations and no paths should not explode.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {

                var invalidatedPath = callPath.slice(0, callPath.length-1);
                // [genreList, [0], titles, length]
                invalidatedPath.push('length');

                return {
                    path: invalidatedPath,
                    invalidated: true
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });

        var args = [falcor.Model.ref('titlesById[1]')];

        var onNext = jest.fn();

        toObservable(model.
            call(""genreList[0].titles.push"", args)).
            doAction(onNext, noOp, noOp).
            subscribe(noOp, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                });
                done();
            });
    })",steel
/test/integration/call.spec.js,Global Variable,"{'line': 108, 'column': 8, 'index': 3618}","it('Response with invalidations and no paths should not explode.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {

                var invalidatedPath = callPath.slice(0, callPath.length-1);
                // [genreList, [0], titles, length]
                invalidatedPath.push('length');

                return {
                    path: invalidatedPath,
                    invalidated: true
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });

        var args = [falcor.Model.ref('titlesById[1]')];

        var onNext = jest.fn();

        toObservable(model.
            call(""genreList[0].titles.push"", args)).
            doAction(onNext, noOp, noOp).
            subscribe(noOp, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                });
                done();
            });
    })",steel
/test/integration/call.spec.js,Lazy Test,"{'line': 38, 'column': 8, 'index': 1267}","it('#339 should use the router as a data source and make a call to the router.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {
                return {
                    path: ['genreList', 0, 'titles', 2],
                    value: {
                        $type: 'ref',
                        value: ['titlesById', 1]
                    }
                };
            }
        }, {
            route: 'titlesById[{integers:ids}].name',
            get: function(aliasMap) {
                var id = aliasMap.ids[0];
                return {
                    path: ['titlesById', id, 'name'],
                    value: 'House of Cards'
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });
        var args = [falcor.Model.ref('titlesById[1]')];
        var onNext = jest.fn();
        toObservable(model.
            call(""genreList[0].titles.push"", args, ['name'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        genreList: {
                            0: {
                                titles: {
                                    2: {
                                        name: 'House of Cards'
                                    }
                                },
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/call.spec.js,Lazy Test,"{'line': 78, 'column': 8, 'index': 2663}","it('#339 should ensure that an empty call does not explode.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {
                return {
                    path: ['genreList', 0, 'titles', 2],
                    value: {
                        $type: 'ref',
                        value: ['titlesById', 1]
                    }
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });
        var args = [falcor.Model.ref('titlesById[1]')];
        var onNext = jest.fn();
        toObservable(model.
            call(""genreList[0].titles.push"", args, ['name'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/integration/call.spec.js,Lazy Test,"{'line': 110, 'column': 8, 'index': 3651}","it('Response with invalidations and no paths should not explode.', function(done) {
        var router = new R([{
            route: 'genreList[{integers:titles}].titles.push',
            call: function(callPath, args) {

                var invalidatedPath = callPath.slice(0, callPath.length-1);
                // [genreList, [0], titles, length]
                invalidatedPath.push('length');

                return {
                    path: invalidatedPath,
                    invalidated: true
                };
            }
        }]);

        var model = new falcor.Model({
            source: router
        });

        var args = [falcor.Model.ref('titlesById[1]')];

        var onNext = jest.fn();

        toObservable(model.
            call(""genreList[0].titles.push"", args)).
            doAction(onNext, noOp, noOp).
            subscribe(noOp, done, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                });
                done();
            });
    })",steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 38}",Unknown,steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 9, 'column': 0, 'index': 323}",Unknown,steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 10, 'column': 0, 'index': 361}",Unknown,steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 11, 'column': 0, 'index': 393}",Unknown,steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 12, 'column': 0, 'index': 423}",Unknown,steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 13, 'column': 0, 'index': 451}",Unknown,steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 23, 'column': 4, 'index': 818}","describe('Removing', function() {
    var getPath = ['genreList', 0, 0, 'summary'];
    var setPath = {path: ['genreList', 0], value: 4};
    var setJSON = {json: {genreList: {0: 4}}};
    describe('setPaths', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                flatMap(function() {
                    return setTest(setPath, '_toJSONG');
                }).
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                flatMap(function() {
                    return setTest(setPath, 'toJSON');
                }).
                subscribe(noOp, done, done);
        });
    });
    describe('setJSON', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                flatMap(function() {
                    return setTest(setJSON, '_toJSONG');
                }).
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                flatMap(function() {
                    return setTest(setJSON, 'toJSON');
                }).
                subscribe(noOp, done, done);
        });
    });
})",steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 24, 'column': 4, 'index': 868}","describe('Removing', function() {
    var getPath = ['genreList', 0, 0, 'summary'];
    var setPath = {path: ['genreList', 0], value: 4};
    var setJSON = {json: {genreList: {0: 4}}};
    describe('setPaths', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                flatMap(function() {
                    return setTest(setPath, '_toJSONG');
                }).
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                flatMap(function() {
                    return setTest(setPath, 'toJSON');
                }).
                subscribe(noOp, done, done);
        });
    });
    describe('setJSON', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                flatMap(function() {
                    return setTest(setJSON, '_toJSONG');
                }).
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                flatMap(function() {
                    return setTest(setJSON, 'toJSON');
                }).
                subscribe(noOp, done, done);
        });
    });
})",steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 25, 'column': 4, 'index': 922}","describe('Removing', function() {
    var getPath = ['genreList', 0, 0, 'summary'];
    var setPath = {path: ['genreList', 0], value: 4};
    var setJSON = {json: {genreList: {0: 4}}};
    describe('setPaths', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                flatMap(function() {
                    return setTest(setPath, '_toJSONG');
                }).
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                flatMap(function() {
                    return setTest(setPath, 'toJSON');
                }).
                subscribe(noOp, done, done);
        });
    });
    describe('setJSON', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                flatMap(function() {
                    return setTest(setJSON, '_toJSONG');
                }).
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                flatMap(function() {
                    return setTest(setJSON, 'toJSON');
                }).
                subscribe(noOp, done, done);
        });
    });
})",steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 61, 'column': 4, 'index': 2295}",Unknown,steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 62, 'column': 4, 'index': 2340}",Unknown,steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 63, 'column': 4, 'index': 2386}",Unknown,steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 79, 'column': 4, 'index': 2932}",Unknown,steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 80, 'column': 4, 'index': 2977}",Unknown,steel
/test/hardlink/hardlink.remove.spec.js,Global Variable,"{'line': 81, 'column': 4, 'index': 3023}",Unknown,steel
/test/hardlink/hardlink.remove.spec.js,Unknown Test,"{'column': 8, 'line': 27}","it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                flatMap(function() {
                    return setTest(setPath, '_toJSONG');
                }).
                subscribe(noOp, done, done);
        })",steel
/test/hardlink/hardlink.remove.spec.js,Unknown Test,"{'column': 8, 'line': 34}","it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                flatMap(function() {
                    return setTest(setPath, 'toJSON');
                }).
                subscribe(noOp, done, done);
        })",steel
/test/hardlink/hardlink.remove.spec.js,Unknown Test,"{'column': 8, 'line': 43}","it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                flatMap(function() {
                    return setTest(setJSON, '_toJSONG');
                }).
                subscribe(noOp, done, done);
        })",steel
/test/hardlink/hardlink.remove.spec.js,Unknown Test,"{'column': 8, 'line': 50}","it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                flatMap(function() {
                    return setTest(setJSON, 'toJSON');
                }).
                subscribe(noOp, done, done);
        })",steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 38}",Unknown,steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 9, 'column': 0, 'index': 323}",Unknown,steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 10, 'column': 0, 'index': 361}",Unknown,steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 11, 'column': 0, 'index': 393}",Unknown,steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 12, 'column': 0, 'index': 423}",Unknown,steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 13, 'column': 0, 'index': 451}",Unknown,steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 23, 'column': 4, 'index': 814}","describe('Adding', function() {
    var getPath = ['genreList', 0, 0, 'summary'];
    var setPath = {path: ['genreList', 0, 'length'], value: 4};
    var setJSON = {json: {genreList: {0: {length: 4}}}};
    describe('getPaths', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                subscribe(noOp, done, done);
        });
    });
    describe('setPaths', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            setTest(setPath, '_toJSONG').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            setTest(setPath, 'toJSON').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toPathValues.', function(done) {
            setTest(setPath, 'toPathValues').
                subscribe(noOp, done, done);
        });
    });
    describe('setJSON', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            setTest(setJSON, '_toJSONG').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            setTest(setJSON, 'toJSON').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toPathValues.', function(done) {
            setTest(setJSON, 'toPathValues').
                subscribe(noOp, done, done);
        });
    });
})",steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 24, 'column': 4, 'index': 864}","describe('Adding', function() {
    var getPath = ['genreList', 0, 0, 'summary'];
    var setPath = {path: ['genreList', 0, 'length'], value: 4};
    var setJSON = {json: {genreList: {0: {length: 4}}}};
    describe('getPaths', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                subscribe(noOp, done, done);
        });
    });
    describe('setPaths', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            setTest(setPath, '_toJSONG').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            setTest(setPath, 'toJSON').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toPathValues.', function(done) {
            setTest(setPath, 'toPathValues').
                subscribe(noOp, done, done);
        });
    });
    describe('setJSON', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            setTest(setJSON, '_toJSONG').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            setTest(setJSON, 'toJSON').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toPathValues.', function(done) {
            setTest(setJSON, 'toPathValues').
                subscribe(noOp, done, done);
        });
    });
})",steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 25, 'column': 4, 'index': 928}","describe('Adding', function() {
    var getPath = ['genreList', 0, 0, 'summary'];
    var setPath = {path: ['genreList', 0, 'length'], value: 4};
    var setJSON = {json: {genreList: {0: {length: 4}}}};
    describe('getPaths', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                subscribe(noOp, done, done);
        });
    });
    describe('setPaths', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            setTest(setPath, '_toJSONG').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            setTest(setPath, 'toJSON').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toPathValues.', function(done) {
            setTest(setPath, 'toPathValues').
                subscribe(noOp, done, done);
        });
    });
    describe('setJSON', function() {
        it('should perform a hard-link with back references _toJSONG.', function(done) {
            setTest(setJSON, '_toJSONG').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toJSON.', function(done) {
            setTest(setJSON, 'toJSON').
                subscribe(noOp, done, done);
        });
        it('should perform a hard-link with back references toPathValues.', function(done) {
            setTest(setJSON, 'toPathValues').
                subscribe(noOp, done, done);
        });
    });
})",steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 67, 'column': 4, 'index': 2669}",Unknown,steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 68, 'column': 4, 'index': 2714}",Unknown,steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 69, 'column': 4, 'index': 2760}",Unknown,steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 85, 'column': 4, 'index': 3306}",Unknown,steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 86, 'column': 4, 'index': 3351}",Unknown,steel
/test/hardlink/hardlink.add.spec.js,Global Variable,"{'line': 87, 'column': 4, 'index': 3397}",Unknown,steel
/test/hardlink/hardlink.add.spec.js,Unknown Test,"{'column': 8, 'line': 27}","it('should perform a hard-link with back references _toJSONG.', function(done) {
            getTest(getPath, '_toJSONG').
                subscribe(noOp, done, done);
        })",steel
/test/hardlink/hardlink.add.spec.js,Unknown Test,"{'column': 8, 'line': 31}","it('should perform a hard-link with back references toJSON.', function(done) {
            getTest(getPath, 'toJSON').
                subscribe(noOp, done, done);
        })",steel
/test/hardlink/hardlink.add.spec.js,Unknown Test,"{'column': 8, 'line': 37}","it('should perform a hard-link with back references _toJSONG.', function(done) {
            setTest(setPath, '_toJSONG').
                subscribe(noOp, done, done);
        })",steel
/test/hardlink/hardlink.add.spec.js,Unknown Test,"{'column': 8, 'line': 41}","it('should perform a hard-link with back references toJSON.', function(done) {
            setTest(setPath, 'toJSON').
                subscribe(noOp, done, done);
        })",steel
/test/hardlink/hardlink.add.spec.js,Unknown Test,"{'column': 8, 'line': 45}","it('should perform a hard-link with back references toPathValues.', function(done) {
            setTest(setPath, 'toPathValues').
                subscribe(noOp, done, done);
        })",steel
/test/hardlink/hardlink.add.spec.js,Unknown Test,"{'column': 8, 'line': 51}","it('should perform a hard-link with back references _toJSONG.', function(done) {
            setTest(setJSON, '_toJSONG').
                subscribe(noOp, done, done);
        })",steel
/test/hardlink/hardlink.add.spec.js,Unknown Test,"{'column': 8, 'line': 55}","it('should perform a hard-link with back references toJSON.', function(done) {
            setTest(setJSON, 'toJSON').
                subscribe(noOp, done, done);
        })",steel
/test/hardlink/hardlink.add.spec.js,Unknown Test,"{'column': 8, 'line': 59}","it('should perform a hard-link with back references toPathValues.', function(done) {
            setTest(setJSON, 'toPathValues').
                subscribe(noOp, done, done);
        })",steel
/test/get-core/values.spec.js,Eager Test,"{'line': 316, 'column': 27, 'index': 9650}","it('should get JSONGraph through references.', function() {
        getCoreRunner({
            input: [['lolomo', 0, 0, 'item', 'title']],
            isJSONG: true,
            output: {
                jsonGraph: cacheGenerator(0, 1),
                paths: [['lolomo', 0, 0, 'item', 'title']]
            },
            cache: cacheGenerator(0, 10)
        });
    })",steel
/test/get-core/values.spec.js,Eager Test,"{'line': 319, 'column': 19, 'index': 9765}","it('should get JSONGraph through references.', function() {
        getCoreRunner({
            input: [['lolomo', 0, 0, 'item', 'title']],
            isJSONG: true,
            output: {
                jsonGraph: cacheGenerator(0, 1),
                paths: [['lolomo', 0, 0, 'item', 'title']]
            },
            cache: cacheGenerator(0, 10)
        });
    })",steel
/test/get-core/values.spec.js,Eager Test,"{'line': 327, 'column': 35, 'index': 10068}","it('should get JSONGraph through references with complex pathSet.', function() {
        getCoreRunner({
            input: [['lolomo', {to: 1}, {to: 1}, 'item', 'title']],
            isJSONG: true,
            output: {
                jsonGraph: _.merge(cacheGenerator(0, 2), cacheGenerator(10, 2, undefined, false)),
                paths: [
                    ['lolomo', 0, 0, 'item', 'title'],
                    ['lolomo', 0, 1, 'item', 'title'],
                    ['lolomo', 1, 0, 'item', 'title'],
                    ['lolomo', 1, 1, 'item', 'title']
                ]
            },
            cache: cacheGenerator(0, 30)
        });
    })",steel
/test/get-core/values.spec.js,Eager Test,"{'line': 327, 'column': 57, 'index': 10090}","it('should get JSONGraph through references with complex pathSet.', function() {
        getCoreRunner({
            input: [['lolomo', {to: 1}, {to: 1}, 'item', 'title']],
            isJSONG: true,
            output: {
                jsonGraph: _.merge(cacheGenerator(0, 2), cacheGenerator(10, 2, undefined, false)),
                paths: [
                    ['lolomo', 0, 0, 'item', 'title'],
                    ['lolomo', 0, 1, 'item', 'title'],
                    ['lolomo', 1, 0, 'item', 'title'],
                    ['lolomo', 1, 1, 'item', 'title']
                ]
            },
            cache: cacheGenerator(0, 30)
        });
    })",steel
/test/get-core/values.spec.js,Eager Test,"{'line': 335, 'column': 19, 'index': 10428}","it('should get JSONGraph through references with complex pathSet.', function() {
        getCoreRunner({
            input: [['lolomo', {to: 1}, {to: 1}, 'item', 'title']],
            isJSONG: true,
            output: {
                jsonGraph: _.merge(cacheGenerator(0, 2), cacheGenerator(10, 2, undefined, false)),
                paths: [
                    ['lolomo', 0, 0, 'item', 'title'],
                    ['lolomo', 0, 1, 'item', 'title'],
                    ['lolomo', 1, 0, 'item', 'title'],
                    ['lolomo', 1, 1, 'item', 'title']
                ]
            },
            cache: cacheGenerator(0, 30)
        });
    })",steel
/test/get-core/values.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 205}",Unknown,steel
/test/get-core/values.spec.js,Global Variable,"{'line': 6, 'column': 0, 'index': 232}",Unknown,steel
/test/get-core/values.spec.js,Global Variable,"{'line': 69, 'column': 8, 'index': 2531}","it('should allow for multiple arguments with different length paths.', function() {
        var lolomo0 = {
            length: 1337
        };
        lolomo0.$__path = ['lolomo', '0']; // eslint-disable-line camelcase
        var lolomo = {
            length: 1,
            0: lolomo0
        };
        lolomo.$__path = ['lolomo']; // eslint-disable-line camelcase
        var output = {
            json: {
                lolomo: lolomo
            }
        };

        getCoreRunner({
            input: [
                ['lolomo', 0, 'length'],
                ['lolomo', 'length']
            ],
            output: output,
            cache: {
                lolomo: {
                    length: 1,
                    0: {
                        length: 1337
                    }
                }
            }
        });
    })",steel
/test/get-core/values.spec.js,Global Variable,"{'line': 73, 'column': 8, 'index': 2667}","it('should allow for multiple arguments with different length paths.', function() {
        var lolomo0 = {
            length: 1337
        };
        lolomo0.$__path = ['lolomo', '0']; // eslint-disable-line camelcase
        var lolomo = {
            length: 1,
            0: lolomo0
        };
        lolomo.$__path = ['lolomo']; // eslint-disable-line camelcase
        var output = {
            json: {
                lolomo: lolomo
            }
        };

        getCoreRunner({
            input: [
                ['lolomo', 0, 'length'],
                ['lolomo', 'length']
            ],
            output: output,
            cache: {
                lolomo: {
                    length: 1,
                    0: {
                        length: 1337
                    }
                }
            }
        });
    })",steel
/test/get-core/values.spec.js,Global Variable,"{'line': 78, 'column': 8, 'index': 2817}","it('should allow for multiple arguments with different length paths.', function() {
        var lolomo0 = {
            length: 1337
        };
        lolomo0.$__path = ['lolomo', '0']; // eslint-disable-line camelcase
        var lolomo = {
            length: 1,
            0: lolomo0
        };
        lolomo.$__path = ['lolomo']; // eslint-disable-line camelcase
        var output = {
            json: {
                lolomo: lolomo
            }
        };

        getCoreRunner({
            input: [
                ['lolomo', 0, 'length'],
                ['lolomo', 'length']
            ],
            output: output,
            cache: {
                lolomo: {
                    length: 1,
                    0: {
                        length: 1337
                    }
                }
            }
        });
    })",steel
/test/get-core/values.spec.js,Lazy Test,"{'line': 15, 'column': 19, 'index': 584}","it('should get a simple value out of the cache', function() {
        getCoreRunner({
            input: [['videos', 0, 'title']],
            output: outputGenerator.videoGenerator([0]),
            cache: cacheGenerator(0, 1)
        });
    })",steel
/test/get-core/values.spec.js,Lazy Test,"{'line': 22, 'column': 19, 'index': 850}","it('should get a value through a reference.', function() {
        getCoreRunner({
            input: [['lolomo', 0, 0, 'item', 'title']],
            output: outputGenerator.lolomoGenerator([0], [0]),
            cache: cacheGenerator(0, 1)
        });
    })",steel
/test/get-core/values.spec.js,Lazy Test,"{'line': 65, 'column': 19, 'index': 2393}","it('should get a value through references with complex pathSet.', function() {
        getCoreRunner({
            input: [['lolomo', {to: 1}, {to: 1}, 'item', 'title']],
            output: outputGenerator.lolomoGenerator([0, 1], [0, 1]),
            cache: cacheGenerator(0, 30)
        });
    })",steel
/test/get-core/values.spec.js,Lazy Test,"{'line': 231, 'column': 19, 'index': 7130}","it('should emit branch structure for empty paths.', function() {
        getCoreRunner({
            input: [['lolomo', 0, [], 'item', 'title']],
            output: {
                json: {
                    lolomo: {
                        0: {

                        }
                    }
                }
            },
            cache: cacheGenerator(0, 1)
        });
    })",steel
/test/get-core/values.spec.js,Lazy Test,"{'line': 241, 'column': 19, 'index': 7367}","it('should emit branch structure for empty get.', function() {
        getCoreRunner({
            input: [],
            output: {
                json: {}
            },
            cache: cacheGenerator(0, 1)
        });
    })",steel
/test/get-core/values.spec.js,Lazy Test,"{'line': 260, 'column': 19, 'index': 7948}","it('should get JSONGraph for a single value out, modelCreated', function() {
        getCoreRunner({
            input: [['videos', 0, 'title']],
            isJSONG: true,
            output: {
                jsonGraph: {
                    videos: {
                        0: {
                            title: 'Video 0'
                        }
                    }
                },
                paths: [['videos', 0, 'title']]
            },
            cache: cacheGenerator(0, 1, undefined, true)
        });
    })",steel
/test/get-core/values.spec.js,Lazy Test,"{'line': 277, 'column': 19, 'index': 8494}","it('should get JSONGraph for a single value out, !modelCreated', function() {
        getCoreRunner({
            input: [['videos', 0, 'title']],
            isJSONG: true,
            output: {
                jsonGraph: {
                    videos: {
                        0: {
                            title: atom('Video 0')
                        }
                    }
                },
                paths: [['videos', 0, 'title']]
            },
            cache: cacheGenerator(0, 1, undefined, false)
        });
    })",steel
/test/get-core/values.spec.js,Lazy Test,"{'line': 316, 'column': 27, 'index': 9650}","it('should get JSONGraph through references.', function() {
        getCoreRunner({
            input: [['lolomo', 0, 0, 'item', 'title']],
            isJSONG: true,
            output: {
                jsonGraph: cacheGenerator(0, 1),
                paths: [['lolomo', 0, 0, 'item', 'title']]
            },
            cache: cacheGenerator(0, 10)
        });
    })",steel
/test/get-core/values.spec.js,Lazy Test,"{'line': 327, 'column': 35, 'index': 10068}","it('should get JSONGraph through references with complex pathSet.', function() {
        getCoreRunner({
            input: [['lolomo', {to: 1}, {to: 1}, 'item', 'title']],
            isJSONG: true,
            output: {
                jsonGraph: _.merge(cacheGenerator(0, 2), cacheGenerator(10, 2, undefined, false)),
                paths: [
                    ['lolomo', 0, 0, 'item', 'title'],
                    ['lolomo', 0, 1, 'item', 'title'],
                    ['lolomo', 1, 0, 'item', 'title'],
                    ['lolomo', 1, 1, 'item', 'title']
                ]
            },
            cache: cacheGenerator(0, 30)
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 11}","it('should get a simple value out of the cache', function() {
        getCoreRunner({
            input: [['videos', 0, 'title']],
            output: outputGenerator.videoGenerator([0]),
            cache: cacheGenerator(0, 1)
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 18}","it('should get a value through a reference.', function() {
        getCoreRunner({
            input: [['lolomo', 0, 0, 'item', 'title']],
            output: outputGenerator.lolomoGenerator([0], [0]),
            cache: cacheGenerator(0, 1)
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 25}","it('should get a value of type atom when in materialized mode.', function() {
        getCoreRunner({
            input: [['videos', {to:1}, 'title']],
            materialize: true,
            output: {
                json: {
                    videos: {
                        $__path: ['videos'], // eslint-disable-line camelcase
                        0: {
                            $__path: ['videos', 0], // eslint-disable-line camelcase
                            title: {$type: 'atom'}
                        },
                        1: {
                            $__path: ['videos', 1], // eslint-disable-line camelcase
                            title: {$type: 'atom'}
                        }
                    }
                }
            },
            cache: {
                jsonGraph: {
                    videos: {
                        0: {
                            title: {$type: 'atom'}
                        },
                        1: {
                            title: {$type: 'atom'}
                        }
                    }
                },
                paths: [
                    ['videos', {to: 1}, 'title']
                ]
            }
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 61}","it('should get a value through references with complex pathSet.', function() {
        getCoreRunner({
            input: [['lolomo', {to: 1}, {to: 1}, 'item', 'title']],
            output: outputGenerator.lolomoGenerator([0, 1], [0, 1]),
            cache: cacheGenerator(0, 30)
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 68}","it('should allow for multiple arguments with different length paths.', function() {
        var lolomo0 = {
            length: 1337
        };
        lolomo0.$__path = ['lolomo', '0']; // eslint-disable-line camelcase
        var lolomo = {
            length: 1,
            0: lolomo0
        };
        lolomo.$__path = ['lolomo']; // eslint-disable-line camelcase
        var output = {
            json: {
                lolomo: lolomo
            }
        };

        getCoreRunner({
            input: [
                ['lolomo', 0, 'length'],
                ['lolomo', 'length']
            ],
            output: output,
            cache: {
                lolomo: {
                    length: 1,
                    0: {
                        length: 1337
                    }
                }
            }
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 100}","it('should allow for a null at the end to get a value behind a reference.', function() {
        getCoreRunner({
            input: [['lolomo', null]],
            output: {
                json: {
                    lolomo: 'value'
                }
            },
            cache: {
                lolomo: ref(['test', 'value']),
                test: {
                    value: atom('value')
                }
            }
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 116}","it('should not get the value after the reference.', function() {
        getCoreRunner({
            input: [['lolomo']],
            output: {
                json: {}
            },
            cache: {
                lolomo: ref(['test', 'value']),
                test: {
                    value: atom('value')
                }
            }
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 130}","it('should not get references.', function() {
        getCoreRunner({
            input: [[""lists"", 2343, ""0""]],
            output: {
                json: {
                    lists: {
                        2343: {
                        }
                    }
                }
            },
            cache: {
                lists: {
                    2343: {
                        0: ref([""videos"", 123])
                    }
                },
                videos: {
                    123: {
                        name: atom(""House of cards"")
                    }
                }
            }
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 190}","it('should have identical behavior when fetching a missing value or atom of undefined.', function() {
        getCoreRunner({
            input: [[""lists"", 2343, ""0"", ""name""], [""lists"", 2343, ""1"", ""rating""]],
            output: {
                json: {
                    lists: {
                        2343: {
                            0: {},
                            1: {}
                        }
                    }
                }
            },
            cache: {
                lists: {
                    2343: {
                        0: ref([""videos"", 123]),
                        1: ref([""videos"", 123])
                    }
                },
                videos: {
                    123: {
                        name: atom()
                    }
                }
            }
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 219}","it('should emit branch structure for empty paths.', function() {
        getCoreRunner({
            input: [['lolomo', 0, [], 'item', 'title']],
            output: {
                json: {
                    lolomo: {
                        0: {

                        }
                    }
                }
            },
            cache: cacheGenerator(0, 1)
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 235}","it('should emit branch structure for empty get.', function() {
        getCoreRunner({
            input: [],
            output: {
                json: {}
            },
            cache: cacheGenerator(0, 1)
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 246}","it('should get JSONGraph for a single value out, modelCreated', function() {
        getCoreRunner({
            input: [['videos', 0, 'title']],
            isJSONG: true,
            output: {
                jsonGraph: {
                    videos: {
                        0: {
                            title: 'Video 0'
                        }
                    }
                },
                paths: [['videos', 0, 'title']]
            },
            cache: cacheGenerator(0, 1, undefined, true)
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 263}","it('should get JSONGraph for a single value out, !modelCreated', function() {
        getCoreRunner({
            input: [['videos', 0, 'title']],
            isJSONG: true,
            output: {
                jsonGraph: {
                    videos: {
                        0: {
                            title: atom('Video 0')
                        }
                    }
                },
                paths: [['videos', 0, 'title']]
            },
            cache: cacheGenerator(0, 1, undefined, false)
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 280}","it('should allow for multiple arguments with different length paths as JSONGraph.', function() {
        getCoreRunner({
            input: [
                ['lolomo', 0, 'length'],
                ['lolomo', 'length']
            ],
            output: {
                jsonGraph: {
                    lolomo: {
                        length: 1,
                        0: {
                            length: 1337
                        }
                    }
                },
                paths: [
                    ['lolomo', 0, 'length'],
                    ['lolomo', 'length']
                ]
            },
            isJSONG: true,
            cache: {
                lolomo: {
                    length: 1,
                    0: {
                        length: 1337
                    }
                }
            }
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 311}","it('should get JSONGraph through references.', function() {
        getCoreRunner({
            input: [['lolomo', 0, 0, 'item', 'title']],
            isJSONG: true,
            output: {
                jsonGraph: cacheGenerator(0, 1),
                paths: [['lolomo', 0, 0, 'item', 'title']]
            },
            cache: cacheGenerator(0, 10)
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 322}","it('should get JSONGraph through references with complex pathSet.', function() {
        getCoreRunner({
            input: [['lolomo', {to: 1}, {to: 1}, 'item', 'title']],
            isJSONG: true,
            output: {
                jsonGraph: _.merge(cacheGenerator(0, 2), cacheGenerator(10, 2, undefined, false)),
                paths: [
                    ['lolomo', 0, 0, 'item', 'title'],
                    ['lolomo', 0, 1, 'item', 'title'],
                    ['lolomo', 1, 0, 'item', 'title'],
                    ['lolomo', 1, 1, 'item', 'title']
                ]
            },
            cache: cacheGenerator(0, 30)
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 338}","it('should get JSONGraph allow for a null at the end to get a value behind a reference.', function() {
        getCoreRunner({
            input: [['reference', null]],
            isJSONG: true,
            output: {
                jsonGraph: {
                    ""reference"": {
                        ""$type"": ""ref"",
                        ""value"": [""foo"", ""bar""]
                    },
                    ""foo"": {
                        ""bar"": {
                            ""$type"": ""atom"",
                            ""value"": ""value""
                        }
                    }
                },
                paths: [
                    [""reference"", null]
                ]
            },
            cache: {
                reference: ref(['foo', 'bar']),
                foo: {
                    bar: atom('value')
                }
            }
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 367}","it('should get JSONGraph to get a reference.', function() {
        getCoreRunner({
            input: [['reference']],
            isJSONG: true,
            output: {
                jsonGraph: {
                    ""reference"": {
                        ""$type"": ""ref"",
                        ""value"": [""foo"", ""bar""]
                    }
                },
                paths: [
                    [""reference""]
                ]
            },
            cache: {
                reference: ref(['foo', 'bar']),
                foo: {
                    bar: atom('value')
                }
            }
        });
    })",steel
/test/get-core/values.spec.js,Unknown Test,"{'column': 4, 'line': 391}","it(""follows nested reference in JSONGraph mode"", function () {
        getCoreRunner({
            input: [[""first"", ""title""]],
            isJSONG: true,
            cache: {
                first: ref([""second""]),
                second: ref([""third""]),
                third: { title: ""title"" }
            },
            output: {
                ""jsonGraph"": {
                    ""first"": { ""$type"": ""ref"", ""value"": [""second""] },
                    ""second"": { ""$type"": ""ref"", ""value"": [""third""] },
                    ""third"": { ""title"": ""title"" }
                },
                ""paths"": [[""first"", ""title""]]
            }
        });
    })",steel
/test/get-core/references.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 150}",Unknown,steel
/test/get-core/references.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 177}",Unknown,steel
/test/get-core/references.spec.js,Global Variable,"{'line': 9, 'column': 4, 'index': 270}","describe('References', function() {
    var referenceCache = function() {
        return {
            toReference: ref(['to', 'reference']),
            short: ref(['toShort', 'next']),
            circular: ref(['circular', 'next']),
            to: {
                reference: ref(['too']),
                toValue: ref(['too', 'title']),
                title: 'Title'
            },
            too: {
                title: 'Title'
            },
            toShort: 'Short'
        };
    };

    it('should follow a reference to reference', function() {
        var toReference = {
            title: 'Title'
        };
        toReference.$__path = ['too'];

        // Should be the second references reference not
        // toReferences reference.
        getCoreRunner({
            input: [['toReference', 'title']],
            output: {
                json: {
                    toReference: toReference
                }
            },
            cache: referenceCache
        });
    });

    it('should follow a reference to value', function() {
        getCoreRunner({
            input: [['short', 'title']],
            output: {
                json: {
                    short: 'Short'
                }
            },
            cache: referenceCache
        });
    });

    it('should never follow inner references.', function() {
        getCoreRunner({
            input: [['circular', 'title']],
            output: {
                json: {
                    circular: {}
                }
            },
            cache: referenceCache
        });
    });

    it('should ensure that values are followed correctly when through references and previous paths have longer lengths to litter the requested path.', function() {
        var to = {
            reference: {
                title: 'Title'
            },
            toValue: 'Title'
        };
        to.$__path = ['to'];
        to.reference.$__path = ['too'];

        getCoreRunner({
            input: [
                ['to', ['reference', 'toValue'], 'title'],
            ],
            output: {
                json: {
                    to: to
                }
            },
            cache: referenceCache
        });
    });

    it('should validate that _fromWhenceYouCame does correctly pluck the paths for references.', function() {
        getCoreRunner({
            input: [
                ['lolomo', 0, 0, 'item', 'title'],
            ],
            fromWhenceYouCame: true,
            output: {
                json: {
                    lolomo: {
                        $__path: ['lolomos', 1234],
                        $__refPath: ['lolomos', 1234],
                        $__toReference: ['lolomo'],
                        0: {
                            $__path: ['lists', 'A'],
                            $__refPath: ['lists', 'A'],
                            $__toReference: ['lolomos', 1234, 0],
                            0: {
                                $__path: ['lists', 'A', 0],
                                $__refPath: ['lists', 'A'],
                                $__toReference: ['lolomos', 1234, 0],
                                item: {
                                    $__path: ['videos', 0],
                                    $__refPath: ['videos', 0],
                                    $__toReference: ['lists', 'A', 0, 'item'],
                                    title: 'Video 0'
                                }
                            }
                        }
                    }
                }
            },
            cache: cacheGenerator(0, 1)
        });
    });
})",steel
/test/get-core/references.spec.js,Global Variable,"{'line': 27, 'column': 8, 'index': 802}","it('should follow a reference to reference', function() {
        var toReference = {
            title: 'Title'
        };
        toReference.$__path = ['too'];

        // Should be the second references reference not
        // toReferences reference.
        getCoreRunner({
            input: [['toReference', 'title']],
            output: {
                json: {
                    toReference: toReference
                }
            },
            cache: referenceCache
        });
    })",steel
/test/get-core/references.spec.js,Global Variable,"{'line': 70, 'column': 8, 'index': 2003}","it('should ensure that values are followed correctly when through references and previous paths have longer lengths to litter the requested path.', function() {
        var to = {
            reference: {
                title: 'Title'
            },
            toValue: 'Title'
        };
        to.$__path = ['to'];
        to.reference.$__path = ['too'];

        getCoreRunner({
            input: [
                ['to', ['reference', 'toValue'], 'title'],
            ],
            output: {
                json: {
                    to: to
                }
            },
            cache: referenceCache
        });
    })",steel
/test/get-core/references.spec.js,Unknown Test,"{'column': 4, 'line': 26}","it('should follow a reference to reference', function() {
        var toReference = {
            title: 'Title'
        };
        toReference.$__path = ['too'];

        // Should be the second references reference not
        // toReferences reference.
        getCoreRunner({
            input: [['toReference', 'title']],
            output: {
                json: {
                    toReference: toReference
                }
            },
            cache: referenceCache
        });
    })",steel
/test/get-core/references.spec.js,Unknown Test,"{'column': 4, 'line': 45}","it('should follow a reference to value', function() {
        getCoreRunner({
            input: [['short', 'title']],
            output: {
                json: {
                    short: 'Short'
                }
            },
            cache: referenceCache
        });
    })",steel
/test/get-core/references.spec.js,Unknown Test,"{'column': 4, 'line': 57}","it('should never follow inner references.', function() {
        getCoreRunner({
            input: [['circular', 'title']],
            output: {
                json: {
                    circular: {}
                }
            },
            cache: referenceCache
        });
    })",steel
/test/get-core/references.spec.js,Unknown Test,"{'column': 4, 'line': 69}","it('should ensure that values are followed correctly when through references and previous paths have longer lengths to litter the requested path.', function() {
        var to = {
            reference: {
                title: 'Title'
            },
            toValue: 'Title'
        };
        to.$__path = ['to'];
        to.reference.$__path = ['too'];

        getCoreRunner({
            input: [
                ['to', ['reference', 'toValue'], 'title'],
            ],
            output: {
                json: {
                    to: to
                }
            },
            cache: referenceCache
        });
    })",steel
/test/get-core/references.spec.js,Unknown Test,"{'column': 4, 'line': 92}","it('should validate that _fromWhenceYouCame does correctly pluck the paths for references.', function() {
        getCoreRunner({
            input: [
                ['lolomo', 0, 0, 'item', 'title'],
            ],
            fromWhenceYouCame: true,
            output: {
                json: {
                    lolomo: {
                        $__path: ['lolomos', 1234],
                        $__refPath: ['lolomos', 1234],
                        $__toReference: ['lolomo'],
                        0: {
                            $__path: ['lists', 'A'],
                            $__refPath: ['lists', 'A'],
                            $__toReference: ['lolomos', 1234, 0],
                            0: {
                                $__path: ['lists', 'A', 0],
                                $__refPath: ['lists', 'A'],
                                $__toReference: ['lolomos', 1234, 0],
                                item: {
                                    $__path: ['videos', 0],
                                    $__refPath: ['videos', 0],
                                    $__toReference: ['lists', 'A', 0, 'item'],
                                    title: 'Video 0'
                                }
                            }
                        }
                    }
                }
            },
            cache: cacheGenerator(0, 1)
        });
    })",steel
/test/get-core/null.spec.js,Unknown Test,"{'column': 4, 'line': 4}","it(""should allow null past end of path."", function() {
        getCoreRunner({
            input: [[""a"", ""b"", ""c"", null]],
            output: {
                json: {
                    a: { b: { c: ""title"" } },
                },
            },
            cache: {
                a: { b: { c: ""title"" } },
            },
        });
    })",steel
/test/get-core/null.spec.js,Unknown Test,"{'column': 4, 'line': 18}","it(""should allow null at end of path."", function() {
        getCoreRunner({
            input: [[""a"", ""b"", null]],
            output: {
                json: {
                    a: { b: {} },
                },
            },
            cache: {
                a: { b: { c: ""title"" } },
            },
        });
    })",steel
/test/get-core/null.spec.js,Unknown Test,"{'column': 4, 'line': 32}","it(""should allow null in middle of path."", function() {
        getCoreRunner({
            input: [[""a"", null, ""c""]],
            output: {
                json: {
                    a: {},
                },
            },
            cache: {
                a: { b: { c: ""title"" } },
            },
        });
    })",steel
/test/get-core/null.spec.js,Unknown Test,"{'column': 4, 'line': 46}","it(""should allow null in key sets."", function() {
        getCoreRunner({
            input: [[""a"", [null, ""b""], ""c""]],
            output: {
                json: {
                    a: { b: { c: ""title"" } },
                },
            },
            cache: {
                a: { b: { c: ""title"" } },
            },
        });

        getCoreRunner({
            input: [[""a"", [""b"", null], ""c""]],
            output: {
                json: {
                    a: { b: { c: ""title"" } },
                },
            },
            cache: {
                a: { b: { c: ""title"" } },
            },
        });
    })",steel
/test/get-core/missing.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 150}",Unknown,steel
/test/get-core/missing.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 177}",Unknown,steel
/test/get-core/missing.spec.js,Global Variable,"{'line': 10, 'column': 4, 'index': 268}","describe('Missing', function() {

    var missingCache = function() {
        return {
            missing: ref(['toMissing']),
            multi: {
                0: ref(['toMissing0']),
                1: {
                    0: ref(['toMissing1'])
                }
            }
        };
    };
    it('should report a missing path.', function() {
        getCoreRunner({
            input: [['missing', 'title']],
            output: {
                json: {}
            },
            requestedMissingPaths: [['missing', 'title']],
            optimizedMissingPaths: [['toMissing', 'title']],
            cache: missingCache
        });
    });
    it('should report missing paths.', function() {
        getCoreRunner({
            input: [['multi', {to: 1}, 0, 'title']],
            output: {
                json: {
                    multi: {
                        1: {}
                    }
                }
            },
            requestedMissingPaths: [
                ['multi', 0, 0, 'title'],
                ['multi', 1, 0, 'title']
            ],
            optimizedMissingPaths: [
                ['toMissing0', 0, 'title'],
                ['toMissing1', 'title']
            ],
            cache: missingCache
        });
    });
    it('should report a value when materialized.', function() {
        getCoreRunner({
            input: [['missing', 'title']],
            materialize: true,
            output: {
                json: {
                    missing: { $type: 'atom' }
                }
            },
            cache: missingCache
        });
    });
    it('should report missing paths through many complex keys.', function() {
        getCoreRunner({
            input: [[{to:1}, {to:1}, {to:1}, 'summary']],
            output: {
                json: {
                    0: {
                        0: {
                            0: {},
                            1: {}
                        },
                        1: {}
                    },
                    1: {}
                }
            },
            optimizedMissingPaths: [
                [0, 0, 0, 'summary'],
                [0, 0, 1, 'summary'],
                [0, 1, 0, 'summary'],
                [0, 1, 1, 'summary'],
                [1, 0, {to: 1}, 'summary'],
                [1, 1, {to: 1}, 'summary'],
            ],
            cache: {
                0: {
                    0: {
                        // Missing Leaf
                        0: {
                            title: '0',
                        },
                        1: {
                            title: '1',
                        }
                    },
                    1: {
                        // Missing Branch
                        3: {
                            title: '2',
                        },
                        4: {
                            title: '3',
                        }
                    }
                },
                // Missing complex key.
                1: {
                    length: 1
                }
            }
        });
    });
    it('should report a missing path ending with null', function() {
        getCoreRunner({
            input: [['refMissing', null]],
            output: {
                json: {}
            },
            requestedMissingPaths: [['refMissing', null]],
            optimizedMissingPaths: [['refMissing', null]],
            cache: { }
        });
    });

})",steel
/test/get-core/missing.spec.js,Unknown Test,"{'column': 4, 'line': 21}","it('should report a missing path.', function() {
        getCoreRunner({
            input: [['missing', 'title']],
            output: {
                json: {}
            },
            requestedMissingPaths: [['missing', 'title']],
            optimizedMissingPaths: [['toMissing', 'title']],
            cache: missingCache
        });
    })",steel
/test/get-core/missing.spec.js,Unknown Test,"{'column': 4, 'line': 32}","it('should report missing paths.', function() {
        getCoreRunner({
            input: [['multi', {to: 1}, 0, 'title']],
            output: {
                json: {
                    multi: {
                        1: {}
                    }
                }
            },
            requestedMissingPaths: [
                ['multi', 0, 0, 'title'],
                ['multi', 1, 0, 'title']
            ],
            optimizedMissingPaths: [
                ['toMissing0', 0, 'title'],
                ['toMissing1', 'title']
            ],
            cache: missingCache
        });
    })",steel
/test/get-core/missing.spec.js,Unknown Test,"{'column': 4, 'line': 53}","it('should report a value when materialized.', function() {
        getCoreRunner({
            input: [['missing', 'title']],
            materialize: true,
            output: {
                json: {
                    missing: { $type: 'atom' }
                }
            },
            cache: missingCache
        });
    })",steel
/test/get-core/missing.spec.js,Unknown Test,"{'column': 4, 'line': 65}","it('should report missing paths through many complex keys.', function() {
        getCoreRunner({
            input: [[{to:1}, {to:1}, {to:1}, 'summary']],
            output: {
                json: {
                    0: {
                        0: {
                            0: {},
                            1: {}
                        },
                        1: {}
                    },
                    1: {}
                }
            },
            optimizedMissingPaths: [
                [0, 0, 0, 'summary'],
                [0, 0, 1, 'summary'],
                [0, 1, 0, 'summary'],
                [0, 1, 1, 'summary'],
                [1, 0, {to: 1}, 'summary'],
                [1, 1, {to: 1}, 'summary'],
            ],
            cache: {
                0: {
                    0: {
                        // Missing Leaf
                        0: {
                            title: '0',
                        },
                        1: {
                            title: '1',
                        }
                    },
                    1: {
                        // Missing Branch
                        3: {
                            title: '2',
                        },
                        4: {
                            title: '3',
                        }
                    }
                },
                // Missing complex key.
                1: {
                    length: 1
                }
            }
        });
    })",steel
/test/get-core/missing.spec.js,Unknown Test,"{'column': 4, 'line': 116}","it('should report a missing path ending with null', function() {
        getCoreRunner({
            input: [['refMissing', null]],
            output: {
                json: {}
            },
            requestedMissingPaths: [['refMissing', null]],
            optimizedMissingPaths: [['refMissing', null]],
            cache: { }
        });
    })",steel
/test/get-core/get.cache.spec.js,Conditional Test Logic,"{'line': 9, 'column': 4, 'index': 305}",Unknown,steel
/test/get-core/get.cache.spec.js,Conditional Test Logic,"{'line': 12, 'column': 8, 'index': 362}",Unknown,steel
/test/get-core/get.cache.spec.js,Eager Test,"{'line': 21, 'column': 39, 'index': 591}","it(""should serialize the cache"", function() {
        var model = new Model({ cache: cacheGenerator(0, 1) });
        var cache = model.getCache();
        clean(cache);
        expect(cache).toEqual(cacheGenerator(0, 1));
    })",steel
/test/get-core/get.cache.spec.js,Eager Test,"{'line': 24, 'column': 30, 'index': 706}","it(""should serialize the cache"", function() {
        var model = new Model({ cache: cacheGenerator(0, 1) });
        var cache = model.getCache();
        clean(cache);
        expect(cache).toEqual(cacheGenerator(0, 1));
    })",steel
/test/get-core/get.cache.spec.js,Eager Test,"{'line': 28, 'column': 39, 'index': 835}","it(""should serialize part of the cache"", function() {
        var model = new Model({ cache: cacheGenerator(0, 10) });
        var cache = model.getCache(['lolomo', 0, 3, 'item', 'title']);
        clean(cache);
        expect(cache).toEqual(cacheGenerator(3, 1));
    })",steel
/test/get-core/get.cache.spec.js,Eager Test,"{'line': 31, 'column': 30, 'index': 984}","it(""should serialize part of the cache"", function() {
        var model = new Model({ cache: cacheGenerator(0, 10) });
        var cache = model.getCache(['lolomo', 0, 3, 'item', 'title']);
        clean(cache);
        expect(cache).toEqual(cacheGenerator(3, 1));
    })",steel
/test/get-core/get.cache.spec.js,Eager Test,"{'line': 35, 'column': 39, 'index': 1166}","it(""serialized cache should not contain internal keys (including $size, on boxedValues)"", function(done) {
        var model = new Model({ cache: cacheGenerator(0, 1) });

        model.get(['lolomo', 0, 0, 'item', 'title']).subscribe(function() {}, done, function() {
            var cache = model.getCache();

            deepExpectations(cache, function(key) {
                expect(isInternalKey(key)).toBe(false);
            });

            done();
        });
    })",steel
/test/get-core/get.cache.spec.js,Eager Test,"{'line': 41, 'column': 23, 'index': 1407}","it(""serialized cache should not contain internal keys (including $size, on boxedValues)"", function(done) {
        var model = new Model({ cache: cacheGenerator(0, 1) });

        model.get(['lolomo', 0, 0, 'item', 'title']).subscribe(function() {}, done, function() {
            var cache = model.getCache();

            deepExpectations(cache, function(key) {
                expect(isInternalKey(key)).toBe(false);
            });

            done();
        });
    })",steel
/test/get-core/get.cache.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 202}",Unknown,steel
/test/get-core/get.cache.spec.js,Global Variable,"{'line': 6, 'column': 0, 'index': 228}",Unknown,steel
/test/get-core/get.cache.spec.js,Global Variable,"{'line': 9, 'column': 9, 'index': 310}",Unknown,steel
/test/get-core/get.cache.spec.js,Global Variable,"{'line': 21, 'column': 8, 'index': 560}","it(""should serialize the cache"", function() {
        var model = new Model({ cache: cacheGenerator(0, 1) });
        var cache = model.getCache();
        clean(cache);
        expect(cache).toEqual(cacheGenerator(0, 1));
    })",steel
/test/get-core/get.cache.spec.js,Global Variable,"{'line': 22, 'column': 8, 'index': 624}","it(""should serialize the cache"", function() {
        var model = new Model({ cache: cacheGenerator(0, 1) });
        var cache = model.getCache();
        clean(cache);
        expect(cache).toEqual(cacheGenerator(0, 1));
    })",steel
/test/get-core/get.cache.spec.js,Global Variable,"{'line': 28, 'column': 8, 'index': 804}","it(""should serialize part of the cache"", function() {
        var model = new Model({ cache: cacheGenerator(0, 10) });
        var cache = model.getCache(['lolomo', 0, 3, 'item', 'title']);
        clean(cache);
        expect(cache).toEqual(cacheGenerator(3, 1));
    })",steel
/test/get-core/get.cache.spec.js,Global Variable,"{'line': 29, 'column': 8, 'index': 869}","it(""should serialize part of the cache"", function() {
        var model = new Model({ cache: cacheGenerator(0, 10) });
        var cache = model.getCache(['lolomo', 0, 3, 'item', 'title']);
        clean(cache);
        expect(cache).toEqual(cacheGenerator(3, 1));
    })",steel
/test/get-core/get.cache.spec.js,Global Variable,"{'line': 35, 'column': 8, 'index': 1135}","it(""serialized cache should not contain internal keys (including $size, on boxedValues)"", function(done) {
        var model = new Model({ cache: cacheGenerator(0, 1) });

        model.get(['lolomo', 0, 0, 'item', 'title']).subscribe(function() {}, done, function() {
            var cache = model.getCache();

            deepExpectations(cache, function(key) {
                expect(isInternalKey(key)).toBe(false);
            });

            done();
        });
    })",steel
/test/get-core/get.cache.spec.js,Global Variable,"{'line': 38, 'column': 12, 'index': 1301}","it(""serialized cache should not contain internal keys (including $size, on boxedValues)"", function(done) {
        var model = new Model({ cache: cacheGenerator(0, 1) });

        model.get(['lolomo', 0, 0, 'item', 'title']).subscribe(function() {}, done, function() {
            var cache = model.getCache();

            deepExpectations(cache, function(key) {
                expect(isInternalKey(key)).toBe(false);
            });

            done();
        });
    })",steel
/test/get-core/get.cache.spec.js,Global Variable,"{'line': 49, 'column': 8, 'index': 1577}","it('should serialize a cache with undefined values.', function() {
        var model = new Model({
            cache: {
                test: 'foo'
            }
        });

        // mimicking cache clean-up
        model._root.cache.testing = undefined;
        var cache = model.getCache();
        clean(cache);
        expect(cache).toEqual({
            test: 'foo'
        });
    })",steel
/test/get-core/get.cache.spec.js,Global Variable,"{'line': 57, 'column': 8, 'index': 1768}","it('should serialize a cache with undefined values.', function() {
        var model = new Model({
            cache: {
                test: 'foo'
            }
        });

        // mimicking cache clean-up
        model._root.cache.testing = undefined;
        var cache = model.getCache();
        clean(cache);
        expect(cache).toEqual({
            test: 'foo'
        });
    })",steel
/test/get-core/get.cache.spec.js,Lazy Test,"{'line': 21, 'column': 39, 'index': 591}","it(""should serialize the cache"", function() {
        var model = new Model({ cache: cacheGenerator(0, 1) });
        var cache = model.getCache();
        clean(cache);
        expect(cache).toEqual(cacheGenerator(0, 1));
    })",steel
/test/get-core/get.cache.spec.js,Lazy Test,"{'line': 28, 'column': 39, 'index': 835}","it(""should serialize part of the cache"", function() {
        var model = new Model({ cache: cacheGenerator(0, 10) });
        var cache = model.getCache(['lolomo', 0, 3, 'item', 'title']);
        clean(cache);
        expect(cache).toEqual(cacheGenerator(3, 1));
    })",steel
/test/get-core/get.cache.spec.js,Lazy Test,"{'line': 35, 'column': 39, 'index': 1166}","it(""serialized cache should not contain internal keys (including $size, on boxedValues)"", function(done) {
        var model = new Model({ cache: cacheGenerator(0, 1) });

        model.get(['lolomo', 0, 0, 'item', 'title']).subscribe(function() {}, done, function() {
            var cache = model.getCache();

            deepExpectations(cache, function(key) {
                expect(isInternalKey(key)).toBe(false);
            });

            done();
        });
    })",steel
/test/get-core/errors.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 200}",Unknown,steel
/test/get-core/errors.spec.js,Global Variable,"{'line': 6, 'column': 0, 'index': 225}",Unknown,steel
/test/get-core/errors.spec.js,Global Variable,"{'line': 10, 'column': 4, 'index': 318}","describe('Errors', function() {
    var expired = error('expired');
    expired.$expires = Date.now() - 1000;

    var fooBranch = function() {
        return {
            $__path: ['foo'],
            bar: {
                $__path: ['foo', 'bar'],
                baz: {
                    $__path: ['foo', 'bar', 'baz'],
                    qux: 'qux'
                }
            }
        };
    };

    var errorCache = function() {
        return {
            reference: ref(['to', 'error']),
            to: {
                error: error('Oops!'),
                expired: expired,
                title: 'Hello World'
            },
            list: {
                0: ref(['to']),
                1: ref(['to', 'error'])
            },
            foo: {
                bar: {
                    baz: {
                        qux: 'qux'
                    }
                }
            }
        };
    };

    it('should report error with path.', function() {
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: {}
                }
            },
            errors: [{
                path: ['to', 'error'],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
    it('should report error with path when reusing walk arrays.', function() {
        getCoreRunner({
            input: [
                ['foo', 'bar', 'baz', 'qux'],
                ['to', 'error']
            ],
            output: {
                json: {
                    foo: fooBranch(),
                    to: {}
                }
            },
            errors: [{
                path: ['to', 'error'],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
    it('should report error path with null from reference.', function() {
        getCoreRunner({
            input: [['reference', 'title']],
            output: {
                json: {
                    reference: {}
                }
            },
            errors: [{
                path: ['reference', null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
    it('should report error path with null from reference with path ending in null.', function() {
        getCoreRunner({
            input: [['reference', null]],
            output: {
                json: {
                    reference: {}
                }
            },
            errors: [{
                path: ['reference', null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
    it('should report error with path in treateErrorsAsValues.', function() {
        var to = {
            error: 'Oops!'
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: to
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    });
    it('should report error path with null from reference in treatErrorsAsValues.', function() {
        getCoreRunner({
            input: [['reference', 'title']],
            output: {
                json: {
                    reference: 'Oops!'
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    });
    it('should report error with path in treatErrorsAsValues when reusing walk arrays.', function() {
        var to = {
            error: 'Oops!'
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [
                ['foo', 'bar', 'baz', 'qux'],
                ['to', 'error']
            ],
            output: {
                json: {
                    foo: fooBranch(),
                    to: to
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    });
    it('should report error with path in treateErrorsAsValues and boxValues.', function() {
        var to = {
            error: error('Oops!')
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: to
                }
            },
            treatErrorsAsValues: true,
            boxValues: true,
            cache: errorCache
        });
    });
    it('should report error path with null from reference in treatErrorsAsValues and boxValues.', function() {
        getCoreRunner({
            input: [['reference', 'title']],
            output: {
                json: {
                    reference: error('Oops!')
                }
            },
            treatErrorsAsValues: true,
            boxValues: true,
            cache: errorCache
        });
    });
    it('should not report an expired error.', function() {
        getCoreRunner({
            input: [['to', 'expired']],
            output: { },
            optimizedMissingPaths: [
                ['to', 'expired']
            ],
            cache: errorCache
        });
    });

    it('should report both values and errors when error is less length than value path.', function() {
        var list = {
            0: {
                title: 'Hello World'
            },
            1: {}
        };
        list.$__path = ['list'];
        list[0].$__path = ['to'];
        getCoreRunner({
            input: [
                ['list', {to: 1}, 'title']
            ],
            output: {
                json: {
                    list: list
                }
            },
            errors: [{
                path: ['list', 1, null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
})",steel
/test/get-core/errors.spec.js,Global Variable,"{'line': 13, 'column': 4, 'index': 397}","describe('Errors', function() {
    var expired = error('expired');
    expired.$expires = Date.now() - 1000;

    var fooBranch = function() {
        return {
            $__path: ['foo'],
            bar: {
                $__path: ['foo', 'bar'],
                baz: {
                    $__path: ['foo', 'bar', 'baz'],
                    qux: 'qux'
                }
            }
        };
    };

    var errorCache = function() {
        return {
            reference: ref(['to', 'error']),
            to: {
                error: error('Oops!'),
                expired: expired,
                title: 'Hello World'
            },
            list: {
                0: ref(['to']),
                1: ref(['to', 'error'])
            },
            foo: {
                bar: {
                    baz: {
                        qux: 'qux'
                    }
                }
            }
        };
    };

    it('should report error with path.', function() {
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: {}
                }
            },
            errors: [{
                path: ['to', 'error'],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
    it('should report error with path when reusing walk arrays.', function() {
        getCoreRunner({
            input: [
                ['foo', 'bar', 'baz', 'qux'],
                ['to', 'error']
            ],
            output: {
                json: {
                    foo: fooBranch(),
                    to: {}
                }
            },
            errors: [{
                path: ['to', 'error'],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
    it('should report error path with null from reference.', function() {
        getCoreRunner({
            input: [['reference', 'title']],
            output: {
                json: {
                    reference: {}
                }
            },
            errors: [{
                path: ['reference', null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
    it('should report error path with null from reference with path ending in null.', function() {
        getCoreRunner({
            input: [['reference', null]],
            output: {
                json: {
                    reference: {}
                }
            },
            errors: [{
                path: ['reference', null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
    it('should report error with path in treateErrorsAsValues.', function() {
        var to = {
            error: 'Oops!'
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: to
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    });
    it('should report error path with null from reference in treatErrorsAsValues.', function() {
        getCoreRunner({
            input: [['reference', 'title']],
            output: {
                json: {
                    reference: 'Oops!'
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    });
    it('should report error with path in treatErrorsAsValues when reusing walk arrays.', function() {
        var to = {
            error: 'Oops!'
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [
                ['foo', 'bar', 'baz', 'qux'],
                ['to', 'error']
            ],
            output: {
                json: {
                    foo: fooBranch(),
                    to: to
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    });
    it('should report error with path in treateErrorsAsValues and boxValues.', function() {
        var to = {
            error: error('Oops!')
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: to
                }
            },
            treatErrorsAsValues: true,
            boxValues: true,
            cache: errorCache
        });
    });
    it('should report error path with null from reference in treatErrorsAsValues and boxValues.', function() {
        getCoreRunner({
            input: [['reference', 'title']],
            output: {
                json: {
                    reference: error('Oops!')
                }
            },
            treatErrorsAsValues: true,
            boxValues: true,
            cache: errorCache
        });
    });
    it('should not report an expired error.', function() {
        getCoreRunner({
            input: [['to', 'expired']],
            output: { },
            optimizedMissingPaths: [
                ['to', 'expired']
            ],
            cache: errorCache
        });
    });

    it('should report both values and errors when error is less length than value path.', function() {
        var list = {
            0: {
                title: 'Hello World'
            },
            1: {}
        };
        list.$__path = ['list'];
        list[0].$__path = ['to'];
        getCoreRunner({
            input: [
                ['list', {to: 1}, 'title']
            ],
            output: {
                json: {
                    list: list
                }
            },
            errors: [{
                path: ['list', 1, null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
})",steel
/test/get-core/errors.spec.js,Global Variable,"{'line': 26, 'column': 4, 'index': 694}","describe('Errors', function() {
    var expired = error('expired');
    expired.$expires = Date.now() - 1000;

    var fooBranch = function() {
        return {
            $__path: ['foo'],
            bar: {
                $__path: ['foo', 'bar'],
                baz: {
                    $__path: ['foo', 'bar', 'baz'],
                    qux: 'qux'
                }
            }
        };
    };

    var errorCache = function() {
        return {
            reference: ref(['to', 'error']),
            to: {
                error: error('Oops!'),
                expired: expired,
                title: 'Hello World'
            },
            list: {
                0: ref(['to']),
                1: ref(['to', 'error'])
            },
            foo: {
                bar: {
                    baz: {
                        qux: 'qux'
                    }
                }
            }
        };
    };

    it('should report error with path.', function() {
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: {}
                }
            },
            errors: [{
                path: ['to', 'error'],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
    it('should report error with path when reusing walk arrays.', function() {
        getCoreRunner({
            input: [
                ['foo', 'bar', 'baz', 'qux'],
                ['to', 'error']
            ],
            output: {
                json: {
                    foo: fooBranch(),
                    to: {}
                }
            },
            errors: [{
                path: ['to', 'error'],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
    it('should report error path with null from reference.', function() {
        getCoreRunner({
            input: [['reference', 'title']],
            output: {
                json: {
                    reference: {}
                }
            },
            errors: [{
                path: ['reference', null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
    it('should report error path with null from reference with path ending in null.', function() {
        getCoreRunner({
            input: [['reference', null]],
            output: {
                json: {
                    reference: {}
                }
            },
            errors: [{
                path: ['reference', null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
    it('should report error with path in treateErrorsAsValues.', function() {
        var to = {
            error: 'Oops!'
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: to
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    });
    it('should report error path with null from reference in treatErrorsAsValues.', function() {
        getCoreRunner({
            input: [['reference', 'title']],
            output: {
                json: {
                    reference: 'Oops!'
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    });
    it('should report error with path in treatErrorsAsValues when reusing walk arrays.', function() {
        var to = {
            error: 'Oops!'
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [
                ['foo', 'bar', 'baz', 'qux'],
                ['to', 'error']
            ],
            output: {
                json: {
                    foo: fooBranch(),
                    to: to
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    });
    it('should report error with path in treateErrorsAsValues and boxValues.', function() {
        var to = {
            error: error('Oops!')
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: to
                }
            },
            treatErrorsAsValues: true,
            boxValues: true,
            cache: errorCache
        });
    });
    it('should report error path with null from reference in treatErrorsAsValues and boxValues.', function() {
        getCoreRunner({
            input: [['reference', 'title']],
            output: {
                json: {
                    reference: error('Oops!')
                }
            },
            treatErrorsAsValues: true,
            boxValues: true,
            cache: errorCache
        });
    });
    it('should not report an expired error.', function() {
        getCoreRunner({
            input: [['to', 'expired']],
            output: { },
            optimizedMissingPaths: [
                ['to', 'expired']
            ],
            cache: errorCache
        });
    });

    it('should report both values and errors when error is less length than value path.', function() {
        var list = {
            0: {
                title: 'Hello World'
            },
            1: {}
        };
        list.$__path = ['list'];
        list[0].$__path = ['to'];
        getCoreRunner({
            input: [
                ['list', {to: 1}, 'title']
            ],
            output: {
                json: {
                    list: list
                }
            },
            errors: [{
                path: ['list', 1, null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    });
})",steel
/test/get-core/errors.spec.js,Global Variable,"{'line': 113, 'column': 8, 'index': 3060}","it('should report error with path in treateErrorsAsValues.', function() {
        var to = {
            error: 'Oops!'
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: to
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Global Variable,"{'line': 141, 'column': 8, 'index': 3878}","it('should report error with path in treatErrorsAsValues when reusing walk arrays.', function() {
        var to = {
            error: 'Oops!'
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [
                ['foo', 'bar', 'baz', 'qux'],
                ['to', 'error']
            ],
            output: {
                json: {
                    foo: fooBranch(),
                    to: to
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Global Variable,"{'line': 161, 'column': 8, 'index': 4427}","it('should report error with path in treateErrorsAsValues and boxValues.', function() {
        var to = {
            error: error('Oops!')
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: to
                }
            },
            treatErrorsAsValues: true,
            boxValues: true,
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Global Variable,"{'line': 202, 'column': 8, 'index': 5617}","it('should report both values and errors when error is less length than value path.', function() {
        var list = {
            0: {
                title: 'Hello World'
            },
            1: {}
        };
        list.$__path = ['list'];
        list[0].$__path = ['to'];
        getCoreRunner({
            input: [
                ['list', {to: 1}, 'title']
            ],
            output: {
                json: {
                    list: list
                }
            },
            errors: [{
                path: ['list', 1, null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Unknown Test,"{'column': 4, 'line': 48}","it('should report error with path.', function() {
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: {}
                }
            },
            errors: [{
                path: ['to', 'error'],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Unknown Test,"{'column': 4, 'line': 63}","it('should report error with path when reusing walk arrays.', function() {
        getCoreRunner({
            input: [
                ['foo', 'bar', 'baz', 'qux'],
                ['to', 'error']
            ],
            output: {
                json: {
                    foo: fooBranch(),
                    to: {}
                }
            },
            errors: [{
                path: ['to', 'error'],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Unknown Test,"{'column': 4, 'line': 82}","it('should report error path with null from reference.', function() {
        getCoreRunner({
            input: [['reference', 'title']],
            output: {
                json: {
                    reference: {}
                }
            },
            errors: [{
                path: ['reference', null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Unknown Test,"{'column': 4, 'line': 97}","it('should report error path with null from reference with path ending in null.', function() {
        getCoreRunner({
            input: [['reference', null]],
            output: {
                json: {
                    reference: {}
                }
            },
            errors: [{
                path: ['reference', null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Unknown Test,"{'column': 4, 'line': 112}","it('should report error with path in treateErrorsAsValues.', function() {
        var to = {
            error: 'Oops!'
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: to
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Unknown Test,"{'column': 4, 'line': 128}","it('should report error path with null from reference in treatErrorsAsValues.', function() {
        getCoreRunner({
            input: [['reference', 'title']],
            output: {
                json: {
                    reference: 'Oops!'
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Unknown Test,"{'column': 4, 'line': 140}","it('should report error with path in treatErrorsAsValues when reusing walk arrays.', function() {
        var to = {
            error: 'Oops!'
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [
                ['foo', 'bar', 'baz', 'qux'],
                ['to', 'error']
            ],
            output: {
                json: {
                    foo: fooBranch(),
                    to: to
                }
            },
            treatErrorsAsValues: true,
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Unknown Test,"{'column': 4, 'line': 160}","it('should report error with path in treateErrorsAsValues and boxValues.', function() {
        var to = {
            error: error('Oops!')
        };
        to.$__path = ['to'];
        getCoreRunner({
            input: [['to', 'error']],
            output: {
                json: {
                    to: to
                }
            },
            treatErrorsAsValues: true,
            boxValues: true,
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Unknown Test,"{'column': 4, 'line': 177}","it('should report error path with null from reference in treatErrorsAsValues and boxValues.', function() {
        getCoreRunner({
            input: [['reference', 'title']],
            output: {
                json: {
                    reference: error('Oops!')
                }
            },
            treatErrorsAsValues: true,
            boxValues: true,
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Unknown Test,"{'column': 4, 'line': 190}","it('should not report an expired error.', function() {
        getCoreRunner({
            input: [['to', 'expired']],
            output: { },
            optimizedMissingPaths: [
                ['to', 'expired']
            ],
            cache: errorCache
        });
    })",steel
/test/get-core/errors.spec.js,Unknown Test,"{'column': 4, 'line': 201}","it('should report both values and errors when error is less length than value path.', function() {
        var list = {
            0: {
                title: 'Hello World'
            },
            1: {}
        };
        list.$__path = ['list'];
        list[0].$__path = ['to'];
        getCoreRunner({
            input: [
                ['list', {to: 1}, 'title']
            ],
            output: {
                json: {
                    list: list
                }
            },
            errors: [{
                path: ['list', 1, null],
                value: 'Oops!'
            }],
            cache: errorCache
        });
    })",steel
/test/get-core/edges.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 200}",Unknown,steel
/test/get-core/edges.spec.js,Global Variable,"{'line': 6, 'column': 0, 'index': 227}",Unknown,steel
/test/get-core/edges.spec.js,Global Variable,"{'line': 62, 'column': 8, 'index': 1887}","it('should get out a relative expired item.', function() {
        var output = {
            videos: {
                1234: {
                    title: 'Running Man'
                }
            }
        };
        output.videos.$__path = ['videos']
        output.videos[1234].$__path = ['videos', 1234];

        getCoreRunner({
            input: [['videos', 1234, 'title']],
            output: {
                json: output
            },
            cache: {
                videos: {
                    1234: {
                        title: {
                            $type: $atom,
                            $expires: -60000,
                            value: 'Running Man'
                        }
                    }
                }
            }
        });
    })",steel
/test/get-core/edges.spec.js,Unknown Test,"{'column': 4, 'line': 14}","it('should report nothing on empty path.', function() {
        getCoreRunner({
            input: [['videos', [], 'title']],
            output: {
                json: {
                    videos: {}
                }
            },
            cache: cacheGenerator(0, 1),
        });
    })",steel
/test/get-core/edges.spec.js,Unknown Test,"{'column': 4, 'line': 25}","it('should report an atom of undefined in non-progressive mode.', function() {
        getCoreRunner({
            input: [['videos']],
            output: {
                json: {}
            },
            cache: {
                videos: atom(undefined)
            }
        });
    })",steel
/test/get-core/edges.spec.js,Unknown Test,"{'column': 4, 'line': 36}","it('should not report an atom of undefined in non-materialize mode.', function() {
        getCoreRunner({
            input: [['user'], ['gen']],
            output: {
                jsonGraph: {
                    user: {
                        $type: $atom,
                        $hello: 'world',
                        value: 5
                    },
                    gen: 5
                },
                paths: [['user'], ['gen']]
            },
            isJSONG: true,
            cache: {
                user: {
                    $type: $atom,
                    $hello: 'world',
                    value: 5
                },
                gen: 5
            }
        });
    })",steel
/test/get-core/edges.spec.js,Unknown Test,"{'column': 4, 'line': 61}","it('should get out a relative expired item.', function() {
        var output = {
            videos: {
                1234: {
                    title: 'Running Man'
                }
            }
        };
        output.videos.$__path = ['videos']
        output.videos[1234].$__path = ['videos', 1234];

        getCoreRunner({
            input: [['videos', 1234, 'title']],
            output: {
                json: output
            },
            cache: {
                videos: {
                    1234: {
                        title: {
                            $type: $atom,
                            $expires: -60000,
                            value: 'Running Man'
                        }
                    }
                }
            }
        });
    })",steel
/test/get-core/edges.spec.js,Unknown Test,"{'column': 4, 'line': 90}","it('should not get out an expired item.', function() {
        getCoreRunner({
            input: [['videos', 1234, 'title']],
            output: { },
            requestedMissingPaths: [['videos', 1234, 'title']],
            cache: {
                videos: {
                    1234: {
                        title: {
                            $type: $atom,
                            $expires: Date.now() - 1000,
                            value: 'Running Man'
                        }
                    }
                }
            }
        });
    })",steel
/test/get-core/edges.spec.js,Unknown Test,"{'column': 4, 'line': 108}","it('should not get out an expired item through references.', function() {
        getCoreRunner({
            input: [['videos', 1234, 'title']],
            output: {
                json: {
                    videos: {}
                }
            },
            requestedMissingPaths: [['videos', 1234, 'title']],
            cache: {
                to: {
                    $type: $ref,
                    $expires: Date.now() - 1000,
                    value: ['videos']
                },
                videos: {
                    title: 'Running Man'
                }
            }
        });
    })",steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 205}",Unknown,steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 7, 'column': 0, 'index': 259}",Unknown,steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 11, 'column': 0, 'index': 457}",Unknown,steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 29, 'column': 8, 'index': 1041}","it('should get multiple arguments out of the cache.', function() {
        var output = outputGenerator.lolomoGenerator([0], [0, 1]).json.lolomo[0];

        // Cheating in how we are creating the output.  'path' key should not exist
        // at the top level of output.
        delete output.$__path;
        delete output.$__refPath;
        delete output.$__toReference;

        getCoreRunner({
            input: [
                [0, 'item', 'title'],
                [1, 'item', 'title']
            ],
            output: {
                json: output
            },
            deref: ['lists', 'A'],
            referenceContainer: ['lolomos', 1234, 0],
            cache: cacheGenerator(0, 2)
        });
    })",steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 77, 'column': 8, 'index': 2402}","it('should throw an error when bound and calling jsonGraph.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        })._derefSync(['videos', 0]);

        var res = model._getPathValuesAsJSONG(model, [['summary']], [{}]);
        expect(res.criticalError.name).toBe(""BoundJSONGraphModelError"");
        expect(res.criticalError.message).toBe(
            ""It is not legal to use the JSON Graph "" +
            ""format from a bound Model. JSON Graph format"" +
            "" can only be used from a root model.""
        );
    })",steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 81, 'column': 8, 'index': 2513}","it('should throw an error when bound and calling jsonGraph.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        })._derefSync(['videos', 0]);

        var res = model._getPathValuesAsJSONG(model, [['summary']], [{}]);
        expect(res.criticalError.name).toBe(""BoundJSONGraphModelError"");
        expect(res.criticalError.message).toBe(
            ""It is not legal to use the JSON Graph "" +
            ""format from a bound Model. JSON Graph format"" +
            "" can only be used from a root model.""
        );
    })",steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 91, 'column': 8, 'index': 2986}","it('should ensure that correct parents are produced for non-paths.', function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: {
                        e: '&'
                    }
                }
            }
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['a', 'b', 'e'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                var json = onNext.mock.calls[0][0].json;

                // Top level
                expect(json.$__path).toBeUndefined();

                // a
                var a = json.a;
                expect(a.$__path).toEqual(['a']);

                // b
                var b = a.b;
                expect(b.$__path).toEqual(['a', 'b']);

                // e
                var e = b.e;
                expect(e).toBe('&');
            }).
            subscribe(noOp, done, done);
    })",steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 101, 'column': 8, 'index': 3183}","it('should ensure that correct parents are produced for non-paths.', function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: {
                        e: '&'
                    }
                }
            }
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['a', 'b', 'e'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                var json = onNext.mock.calls[0][0].json;

                // Top level
                expect(json.$__path).toBeUndefined();

                // a
                var a = json.a;
                expect(a.$__path).toEqual(['a']);

                // b
                var b = a.b;
                expect(b.$__path).toEqual(['a', 'b']);

                // e
                var e = b.e;
                expect(e).toBe('&');
            }).
            subscribe(noOp, done, done);
    })",steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 106, 'column': 16, 'index': 3391}","it('should ensure that correct parents are produced for non-paths.', function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: {
                        e: '&'
                    }
                }
            }
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['a', 'b', 'e'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                var json = onNext.mock.calls[0][0].json;

                // Top level
                expect(json.$__path).toBeUndefined();

                // a
                var a = json.a;
                expect(a.$__path).toEqual(['a']);

                // b
                var b = a.b;
                expect(b.$__path).toEqual(['a', 'b']);

                // e
                var e = b.e;
                expect(e).toBe('&');
            }).
            subscribe(noOp, done, done);
    })",steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 112, 'column': 16, 'index': 3554}","it('should ensure that correct parents are produced for non-paths.', function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: {
                        e: '&'
                    }
                }
            }
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['a', 'b', 'e'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                var json = onNext.mock.calls[0][0].json;

                // Top level
                expect(json.$__path).toBeUndefined();

                // a
                var a = json.a;
                expect(a.$__path).toEqual(['a']);

                // b
                var b = a.b;
                expect(b.$__path).toEqual(['a', 'b']);

                // e
                var e = b.e;
                expect(e).toBe('&');
            }).
            subscribe(noOp, done, done);
    })",steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 116, 'column': 16, 'index': 3658}","it('should ensure that correct parents are produced for non-paths.', function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: {
                        e: '&'
                    }
                }
            }
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['a', 'b', 'e'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                var json = onNext.mock.calls[0][0].json;

                // Top level
                expect(json.$__path).toBeUndefined();

                // a
                var a = json.a;
                expect(a.$__path).toEqual(['a']);

                // b
                var b = a.b;
                expect(b.$__path).toEqual(['a', 'b']);

                // e
                var e = b.e;
                expect(e).toBe('&');
            }).
            subscribe(noOp, done, done);
    })",steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 120, 'column': 16, 'index': 3764}","it('should ensure that correct parents are produced for non-paths.', function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: {
                        e: '&'
                    }
                }
            }
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['a', 'b', 'e'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                var json = onNext.mock.calls[0][0].json;

                // Top level
                expect(json.$__path).toBeUndefined();

                // a
                var a = json.a;
                expect(a.$__path).toEqual(['a']);

                // b
                var b = a.b;
                expect(b.$__path).toEqual(['a', 'b']);

                // e
                var e = b.e;
                expect(e).toBe('&');
            }).
            subscribe(noOp, done, done);
    })",steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 127, 'column': 8, 'index': 3972}","it('ensures that the sequencial get / deref works correctly.', function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: {
                        e: '&'
                    }
                }
            }
        });

        model.get(['a', 'b', 'e']).subscribe(function(json) {
            model = model.deref(json.json.a);
        });

        model.get(['b', 'e']).subscribe(function(json) {
            model = model.deref(json.json.b);
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['e'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(onNext.mock.calls[0][0]).toEqual({
                    json: {
                        e: '&'
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/get-core/deref.spec.js,Global Variable,"{'line': 145, 'column': 8, 'index': 4406}","it('ensures that the sequencial get / deref works correctly.', function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: {
                        e: '&'
                    }
                }
            }
        });

        model.get(['a', 'b', 'e']).subscribe(function(json) {
            model = model.deref(json.json.a);
        });

        model.get(['b', 'e']).subscribe(function(json) {
            model = model.deref(json.json.b);
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['e'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(onNext.mock.calls[0][0]).toEqual({
                    json: {
                        e: '&'
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/get-core/deref.spec.js,Lazy Test,"{'line': 25, 'column': 19, 'index': 921}","it('should get a simple value out of the cache', function() {
        getCoreRunner({
            input: [['title']],
            output: {
                json: {
                    title: 'Video 0'
                }
            },
            deref: ['videos', 0],
            referenceContainer: ['lists', 'A', 0, 'item'],
            cache: cacheGenerator(0, 1)
        });
    })",steel
/test/get-core/deref.spec.js,Lazy Test,"{'line': 47, 'column': 19, 'index': 1652}","it('should get multiple arguments out of the cache.', function() {
        var output = outputGenerator.lolomoGenerator([0], [0, 1]).json.lolomo[0];

        // Cheating in how we are creating the output.  'path' key should not exist
        // at the top level of output.
        delete output.$__path;
        delete output.$__refPath;
        delete output.$__toReference;

        getCoreRunner({
            input: [
                [0, 'item', 'title'],
                [1, 'item', 'title']
            ],
            output: {
                json: output
            },
            deref: ['lists', 'A'],
            referenceContainer: ['lolomos', 1234, 0],
            cache: cacheGenerator(0, 2)
        });
    })",steel
/test/get-core/deref.spec.js,Lazy Test,"{'line': 78, 'column': 19, 'index': 2445}","it('should throw an error when bound and calling jsonGraph.', function() {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        })._derefSync(['videos', 0]);

        var res = model._getPathValuesAsJSONG(model, [['summary']], [{}]);
        expect(res.criticalError.name).toBe(""BoundJSONGraphModelError"");
        expect(res.criticalError.message).toBe(
            ""It is not legal to use the JSON Graph "" +
            ""format from a bound Model. JSON Graph format"" +
            "" can only be used from a root model.""
        );
    })",steel
/test/get-core/deref.spec.js,Lazy Test,"{'line': 102, 'column': 8, 'index': 3215}","it('should ensure that correct parents are produced for non-paths.', function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: {
                        e: '&'
                    }
                }
            }
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['a', 'b', 'e'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                var json = onNext.mock.calls[0][0].json;

                // Top level
                expect(json.$__path).toBeUndefined();

                // a
                var a = json.a;
                expect(a.$__path).toEqual(['a']);

                // b
                var b = a.b;
                expect(b.$__path).toEqual(['a', 'b']);

                // e
                var e = b.e;
                expect(e).toBe('&');
            }).
            subscribe(noOp, done, done);
    })",steel
/test/get-core/deref.spec.js,Lazy Test,"{'line': 146, 'column': 8, 'index': 4438}","it('ensures that the sequencial get / deref works correctly.', function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: {
                        e: '&'
                    }
                }
            }
        });

        model.get(['a', 'b', 'e']).subscribe(function(json) {
            model = model.deref(json.json.a);
        });

        model.get(['b', 'e']).subscribe(function(json) {
            model = model.deref(json.json.b);
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['e'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(onNext.mock.calls[0][0]).toEqual({
                    json: {
                        e: '&'
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/get-core/deref.spec.js,Unknown Test,"{'column': 4, 'line': 15}","it('should get a simple value out of the cache', function() {
        getCoreRunner({
            input: [['title']],
            output: {
                json: {
                    title: 'Video 0'
                }
            },
            deref: ['videos', 0],
            referenceContainer: ['lists', 'A', 0, 'item'],
            cache: cacheGenerator(0, 1)
        });
    })",steel
/test/get-core/deref.spec.js,Unknown Test,"{'column': 4, 'line': 28}","it('should get multiple arguments out of the cache.', function() {
        var output = outputGenerator.lolomoGenerator([0], [0, 1]).json.lolomo[0];

        // Cheating in how we are creating the output.  'path' key should not exist
        // at the top level of output.
        delete output.$__path;
        delete output.$__refPath;
        delete output.$__toReference;

        getCoreRunner({
            input: [
                [0, 'item', 'title'],
                [1, 'item', 'title']
            ],
            output: {
                json: output
            },
            deref: ['lists', 'A'],
            referenceContainer: ['lolomos', 1234, 0],
            cache: cacheGenerator(0, 2)
        });
    })",steel
/test/get-core/deref.spec.js,Unknown Test,"{'column': 4, 'line': 50}","it('should get multiple arguments as missing paths from the cache.', function() {
        getCoreRunner({
            input: [
                ['b', 'c'],
                ['b', 'd']
            ],
            output: {
                json: {
                    b: {}
                }
            },
            deref: ['a'],
            optimizedMissingPaths: [
                ['a', 'b', 'c'],
                ['a', 'b', 'd']
            ],
            cache: {
                a: {
                    b: {
                        e: '&'
                    }
                }
            }
        });
    })",steel
/test/falcor/operations.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 35}",Unknown,steel
/test/falcor/operations.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 102}",Unknown,steel
/test/falcor/operations.spec.js,Global Variable,"{'line': 9, 'column': 8, 'index': 252}","it('should filter the meta data from a falcor response.', function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: {
                        c: 42
                    }
                }
            }
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['a', 'b', 'c'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(falcor.keys(onNext.mock.calls[0][0].json.a)).toEqual([
                    'b'
                ]);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/operations.spec.js,Global Variable,"{'line': 19, 'column': 8, 'index': 448}","it('should filter the meta data from a falcor response.', function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: {
                        c: 42
                    }
                }
            }
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['a', 'b', 'c'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(falcor.keys(onNext.mock.calls[0][0].json.a)).toEqual([
                    'b'
                ]);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.setCache.spec.js,Duplicate Assert,"{'line': 106, 'column': 12, 'index': 3478}","it(""should be fine when you hydrate from an existing cache"", function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: $ref(""a""),
                    c: ""foo""
                }
            },
            source: new LocalDataSource({
                a: {
                    b: $ref(""d"")
                },
                d: {
                    c: ""foo""
                }
            })});

        var cache = model.getCache();
        model.setCache({});

        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        });

        model.setCache(cache);
        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);
    })",steel
/test/falcor/set/set.setCache.spec.js,Duplicate Assert,"{'line': 106, 'column': 12, 'index': 3478}","it(""should be fine when you hydrate from an existing cache"", function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: $ref(""a""),
                    c: ""foo""
                }
            },
            source: new LocalDataSource({
                a: {
                    b: $ref(""d"")
                },
                d: {
                    c: ""foo""
                }
            })});

        var cache = model.getCache();
        model.setCache({});

        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        });

        model.setCache(cache);
        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);
    })",steel
/test/falcor/set/set.setCache.spec.js,Duplicate Assert,"{'line': 113, 'column': 12, 'index': 3676}","it(""should be fine when you hydrate from an existing cache"", function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: $ref(""a""),
                    c: ""foo""
                }
            },
            source: new LocalDataSource({
                a: {
                    b: $ref(""d"")
                },
                d: {
                    c: ""foo""
                }
            })});

        var cache = model.getCache();
        model.setCache({});

        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        });

        model.setCache(cache);
        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);
    })",steel
/test/falcor/set/set.setCache.spec.js,Duplicate Assert,"{'line': 113, 'column': 12, 'index': 3676}","it(""should be fine when you hydrate from an existing cache"", function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: $ref(""a""),
                    c: ""foo""
                }
            },
            source: new LocalDataSource({
                a: {
                    b: $ref(""d"")
                },
                d: {
                    c: ""foo""
                }
            })});

        var cache = model.getCache();
        model.setCache({});

        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        });

        model.setCache(cache);
        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);
    })",steel
/test/falcor/set/set.setCache.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/set/set.setCache.spec.js,Global Variable,"{'line': 7, 'column': 0, 'index': 258}",Unknown,steel
/test/falcor/set/set.setCache.spec.js,Global Variable,"{'line': 11, 'column': 8, 'index': 394}","it(""should be fine when you set an empty cache"", function(done) {
        var model = new Model({source: new LocalDataSource({
            a: { b: $ref(""a""),
                 c: ""foo"" }
        })});
        model.setCache({});
        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);
    })",steel
/test/falcor/set/set.setCache.spec.js,Global Variable,"{'line': 23, 'column': 8, 'index': 816}","it(""should be fine when you set an undefined cache"", function(done) {
        var model = new Model({source: new LocalDataSource({
            a: { b: $ref(""a""),
                 c: ""foo"" }
        })});
        model.setCache(undefined);
        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);
    })",steel
/test/falcor/set/set.setCache.spec.js,Global Variable,"{'line': 35, 'column': 8, 'index': 1267}","it(""should be fine when you set an empty cache with a pre-existing cache"", function(done) {
        var model = new Model({
            cache: { a: {
                b: $ref(""a""),
                c: ""foo"" } },
            source: new LocalDataSource({
                a: { b: $ref(""a""),
                     c: ""foo"" }
            })});
        model.setCache({});
        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);
    })",steel
/test/falcor/set/set.setCache.spec.js,Global Variable,"{'line': 51, 'column': 8, 'index': 1826}","it(""should be fine when you set an undefined cache with a pre-existing cache"", function(done) {
        var model = new Model({
            cache: { a: {
                b: $ref(""a""),
                c: ""foo"" } },
            source: new LocalDataSource({
                a: { b: $ref(""a""),
                     c: ""foo"" }
            })});
        model.setCache(undefined);
        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);
    })",steel
/test/falcor/set/set.setCache.spec.js,Global Variable,"{'line': 67, 'column': 8, 'index': 2359}","it(""should be fine when you set a new cache"", function(done) {
        var model = new Model({
            cache: { a: {
                b: $ref(""a""),
                c: ""foo"" } },
            source: new LocalDataSource({
                a: { b: $ref(""d"") },
                d: { c: ""foo"" }
            })});
        model.setCache({
                a: { b: $ref(""d"") },
                d: { c: ""foo"" }
            });
        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);
    })",steel
/test/falcor/set/set.setCache.spec.js,Global Variable,"{'line': 86, 'column': 8, 'index': 2984}","it(""should be fine when you hydrate from an existing cache"", function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: $ref(""a""),
                    c: ""foo""
                }
            },
            source: new LocalDataSource({
                a: {
                    b: $ref(""d"")
                },
                d: {
                    c: ""foo""
                }
            })});

        var cache = model.getCache();
        model.setCache({});

        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        });

        model.setCache(cache);
        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);
    })",steel
/test/falcor/set/set.setCache.spec.js,Global Variable,"{'line': 102, 'column': 8, 'index': 3356}","it(""should be fine when you hydrate from an existing cache"", function(done) {
        var model = new Model({
            cache: {
                a: {
                    b: $ref(""a""),
                    c: ""foo""
                }
            },
            source: new LocalDataSource({
                a: {
                    b: $ref(""d"")
                },
                d: {
                    c: ""foo""
                }
            })});

        var cache = model.getCache();
        model.setCache({});

        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        });

        model.setCache(cache);
        model.get(""a.b.c"").subscribe(function(x) {
            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);
    })",steel
/test/falcor/set/set.setCache.spec.js,Global Variable,"{'line': 120, 'column': 8, 'index': 3953}","it(""should re-establish atoms and references when you hydrate from an existing cache into a completely new model instance"", function(done) {
        var modelOrig = new Model({
            cache: {
                a: {
                    b: $ref(""d"")
                },
                d: {
                    c: ""foo""
                }
            }
        });

        var cache = modelOrig.getCache();
        var modelNew = new Model();

        modelNew.setCache(cache);
        modelNew.get(""a.b.c"").subscribe(function(x) {

            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);

    })",steel
/test/falcor/set/set.setCache.spec.js,Global Variable,"{'line': 131, 'column': 8, 'index': 4178}","it(""should re-establish atoms and references when you hydrate from an existing cache into a completely new model instance"", function(done) {
        var modelOrig = new Model({
            cache: {
                a: {
                    b: $ref(""d"")
                },
                d: {
                    c: ""foo""
                }
            }
        });

        var cache = modelOrig.getCache();
        var modelNew = new Model();

        modelNew.setCache(cache);
        modelNew.get(""a.b.c"").subscribe(function(x) {

            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);

    })",steel
/test/falcor/set/set.setCache.spec.js,Global Variable,"{'line': 132, 'column': 8, 'index': 4220}","it(""should re-establish atoms and references when you hydrate from an existing cache into a completely new model instance"", function(done) {
        var modelOrig = new Model({
            cache: {
                a: {
                    b: $ref(""d"")
                },
                d: {
                    c: ""foo""
                }
            }
        });

        var cache = modelOrig.getCache();
        var modelNew = new Model();

        modelNew.setCache(cache);
        modelNew.get(""a.b.c"").subscribe(function(x) {

            expect(clean(x)).toEqual({
                json: { a: { b: { c: ""foo"" } }}
            });
        }, done, done);

    })",steel
/test/falcor/set/set.pathSyntax.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/set/set.pathSyntax.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 134}",Unknown,steel
/test/falcor/set/set.pathSyntax.spec.js,Global Variable,"{'line': 10, 'column': 8, 'index': 399}","it('should accept strings for set in the path argument of a pathValue.', function(done) {
        var onNext = jest.fn();
        var model = new Model();

        toObservable(model.
            set({path: 'test[0]', value: 5})).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: 5
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.pathSyntax.spec.js,Global Variable,"{'line': 11, 'column': 8, 'index': 431}","it('should accept strings for set in the path argument of a pathValue.', function(done) {
        var onNext = jest.fn();
        var model = new Model();

        toObservable(model.
            set({path: 'test[0]', value: 5})).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: 5
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.pathSyntax.spec.js,Global Variable,"{'line': 28, 'column': 8, 'index': 998}","it('should accept strings for setValue', function(done) {
        var onNext = jest.fn();
        var model = new Model();

        toObservable(model.
            setValue('test[0]', 6)).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toBe(6);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.pathSyntax.spec.js,Global Variable,"{'line': 29, 'column': 8, 'index': 1030}","it('should accept strings for setValue', function(done) {
        var onNext = jest.fn();
        var model = new Model();

        toObservable(model.
            setValue('test[0]', 6)).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toBe(6);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.pathSyntax.spec.js,Lazy Test,"{'line': 13, 'column': 8, 'index': 465}","it('should accept strings for set in the path argument of a pathValue.', function(done) {
        var onNext = jest.fn();
        var model = new Model();

        toObservable(model.
            set({path: 'test[0]', value: 5})).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: 5
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.pathSyntax.spec.js,Lazy Test,"{'line': 31, 'column': 8, 'index': 1064}","it('should accept strings for setValue', function(done) {
        var onNext = jest.fn();
        var model = new Model();

        toObservable(model.
            setValue('test[0]', 6)).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toBe(6);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.pathSyntax.spec.js,Magic Number,"{'line': 35, 'column': 60, 'index': 1286}","it('should accept strings for setValue', function(done) {
        var onNext = jest.fn();
        var model = new Model();

        toObservable(model.
            setValue('test[0]', 6)).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toBe(6);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Conditional Test Logic,"{'line': 160, 'column': 16, 'index': 5296}","it(""should report paths progressively."", done => {
        const onSet = function(source, tmpGraph, jsonGraphFromSet) {
            jsonGraphFromSet.jsonGraph.videos[444].rating = 5;
            return jsonGraphFromSet;
        };
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });

        let count = 0;
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            }).
            progressively()).
            doAction(x => {
                if (count === 0) {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 3
                                }
                            }
                        }
                    });
                }

                else {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 5
                                }
                            }
                        }
                    });
                }

                count++;
            }, noOp, () => {
                expect(count === 2).toBe(true);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Duplicate Assert,"{'line': 34, 'column': 16, 'index': 1210}","it(""should validate args are sent to the dataSource collapsed."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            })).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);
                expect(onSet).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.anything(), 1);

                const cleaned = onSet.mock.calls[0][2];
                cleaned.paths[0][1] = cleaned.paths[0][1].concat();
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                rating: 5
                            },
                            444: {
                                rating: 3
                            }
                        }
                    },
                    paths: [
                        [""videos"", [444, 1234], ""rating""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Duplicate Assert,"{'line': 35, 'column': 16, 'index': 1266}","it(""should validate args are sent to the dataSource collapsed."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            })).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);
                expect(onSet).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.anything(), 1);

                const cleaned = onSet.mock.calls[0][2];
                cleaned.paths[0][1] = cleaned.paths[0][1].concat();
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                rating: 5
                            },
                            444: {
                                rating: 3
                            }
                        }
                    },
                    paths: [
                        [""videos"", [444, 1234], ""rating""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Duplicate Assert,"{'line': 161, 'column': 20, 'index': 5335}","it(""should report paths progressively."", done => {
        const onSet = function(source, tmpGraph, jsonGraphFromSet) {
            jsonGraphFromSet.jsonGraph.videos[444].rating = 5;
            return jsonGraphFromSet;
        };
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });

        let count = 0;
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            }).
            progressively()).
            doAction(x => {
                if (count === 0) {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 3
                                }
                            }
                        }
                    });
                }

                else {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 5
                                }
                            }
                        }
                    });
                }

                count++;
            }, noOp, () => {
                expect(count === 2).toBe(true);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Duplicate Assert,"{'line': 176, 'column': 20, 'index': 5814}","it(""should report paths progressively."", done => {
        const onSet = function(source, tmpGraph, jsonGraphFromSet) {
            jsonGraphFromSet.jsonGraph.videos[444].rating = 5;
            return jsonGraphFromSet;
        };
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });

        let count = 0;
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            }).
            progressively()).
            doAction(x => {
                if (count === 0) {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 3
                                }
                            }
                        }
                    });
                }

                else {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 5
                                }
                            }
                        }
                    });
                }

                count++;
            }, noOp, () => {
                expect(count === 2).toBe(true);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Duplicate Assert,"{'line': 229, 'column': 12, 'index': 7545}","it(""should return missing optimized paths with a MaxRetryExceededError."", () => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            // eslint-disable-next-line no-use-before-define
            model.invalidate(""videos[1234].title"");
            return {
                jsonGraph: {
                    videos: {
                        1234: {}
                    }
                },
                paths: []
            };
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        return model.set({
            json: {
                videos: {
                    1234: {
                        title: ""Nowhere to be found""
                    }
                }
            }
        }).then(() => {
            throw new Error(""should have rejected with MaxRetryExceededError"");
        }, e => {
            expect(e).toBeInstanceOf(MaxRetryExceededError);
            expect(e.missingOptimizedPaths).toEqual([[""videos"", ""1234"", ""title""]]);

            expect(onSet).toHaveBeenCalledTimes(3);
            expect(onSet).toHaveBeenNthCalledWith(1, expect.anything(), expect.anything(), expect.anything(), 1 );
            expect(onSet).toHaveBeenNthCalledWith(2, expect.anything(), expect.anything(), expect.anything(), 2 );
            expect(onSet).toHaveBeenNthCalledWith(3, expect.anything(), expect.anything(), expect.anything(), 3 );
        });
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Duplicate Assert,"{'line': 230, 'column': 12, 'index': 7597}","it(""should return missing optimized paths with a MaxRetryExceededError."", () => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            // eslint-disable-next-line no-use-before-define
            model.invalidate(""videos[1234].title"");
            return {
                jsonGraph: {
                    videos: {
                        1234: {}
                    }
                },
                paths: []
            };
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        return model.set({
            json: {
                videos: {
                    1234: {
                        title: ""Nowhere to be found""
                    }
                }
            }
        }).then(() => {
            throw new Error(""should have rejected with MaxRetryExceededError"");
        }, e => {
            expect(e).toBeInstanceOf(MaxRetryExceededError);
            expect(e.missingOptimizedPaths).toEqual([[""videos"", ""1234"", ""title""]]);

            expect(onSet).toHaveBeenCalledTimes(3);
            expect(onSet).toHaveBeenNthCalledWith(1, expect.anything(), expect.anything(), expect.anything(), 1 );
            expect(onSet).toHaveBeenNthCalledWith(2, expect.anything(), expect.anything(), expect.anything(), 2 );
            expect(onSet).toHaveBeenNthCalledWith(3, expect.anything(), expect.anything(), expect.anything(), 3 );
        });
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Duplicate Assert,"{'line': 231, 'column': 12, 'index': 7712}","it(""should return missing optimized paths with a MaxRetryExceededError."", () => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            // eslint-disable-next-line no-use-before-define
            model.invalidate(""videos[1234].title"");
            return {
                jsonGraph: {
                    videos: {
                        1234: {}
                    }
                },
                paths: []
            };
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        return model.set({
            json: {
                videos: {
                    1234: {
                        title: ""Nowhere to be found""
                    }
                }
            }
        }).then(() => {
            throw new Error(""should have rejected with MaxRetryExceededError"");
        }, e => {
            expect(e).toBeInstanceOf(MaxRetryExceededError);
            expect(e.missingOptimizedPaths).toEqual([[""videos"", ""1234"", ""title""]]);

            expect(onSet).toHaveBeenCalledTimes(3);
            expect(onSet).toHaveBeenNthCalledWith(1, expect.anything(), expect.anything(), expect.anything(), 1 );
            expect(onSet).toHaveBeenNthCalledWith(2, expect.anything(), expect.anything(), expect.anything(), 2 );
            expect(onSet).toHaveBeenNthCalledWith(3, expect.anything(), expect.anything(), expect.anything(), 3 );
        });
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Duplicate Assert,"{'line': 232, 'column': 12, 'index': 7827}","it(""should return missing optimized paths with a MaxRetryExceededError."", () => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            // eslint-disable-next-line no-use-before-define
            model.invalidate(""videos[1234].title"");
            return {
                jsonGraph: {
                    videos: {
                        1234: {}
                    }
                },
                paths: []
            };
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        return model.set({
            json: {
                videos: {
                    1234: {
                        title: ""Nowhere to be found""
                    }
                }
            }
        }).then(() => {
            throw new Error(""should have rejected with MaxRetryExceededError"");
        }, e => {
            expect(e).toBeInstanceOf(MaxRetryExceededError);
            expect(e.missingOptimizedPaths).toEqual([[""videos"", ""1234"", ""title""]]);

            expect(onSet).toHaveBeenCalledTimes(3);
            expect(onSet).toHaveBeenNthCalledWith(1, expect.anything(), expect.anything(), expect.anything(), 1 );
            expect(onSet).toHaveBeenNthCalledWith(2, expect.anything(), expect.anything(), expect.anything(), 2 );
            expect(onSet).toHaveBeenNthCalledWith(3, expect.anything(), expect.anything(), expect.anything(), 3 );
        });
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Eager Test,"{'line': 15, 'column': 47, 'index': 705}","it(""should validate args are sent to the dataSource collapsed."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            })).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);
                expect(onSet).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.anything(), 1);

                const cleaned = onSet.mock.calls[0][2];
                cleaned.paths[0][1] = cleaned.paths[0][1].concat();
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                rating: 5
                            },
                            444: {
                                rating: 3
                            }
                        }
                    },
                    paths: [
                        [""videos"", [444, 1234], ""rating""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Eager Test,"{'line': 20, 'column': 8, 'index': 812}","it(""should validate args are sent to the dataSource collapsed."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            })).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);
                expect(onSet).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.anything(), 1);

                const cleaned = onSet.mock.calls[0][2];
                cleaned.paths[0][1] = cleaned.paths[0][1].concat();
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                rating: 5
                            },
                            444: {
                                rating: 3
                            }
                        }
                    },
                    paths: [
                        [""videos"", [444, 1234], ""rating""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Eager Test,"{'line': 62, 'column': 47, 'index': 2300}","it(""should send off an empty string on a set to the server."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });
        toObservable(model.
            setValue(""videos[1234].another_prop"", """")).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);

                const cleaned = onSet.mock.calls[0][2];
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                another_prop: """"
                            }
                        }
                    },
                    paths: [
                        [""videos"", 1234, ""another_prop""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Eager Test,"{'line': 68, 'column': 8, 'index': 2426}","it(""should send off an empty string on a set to the server."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });
        toObservable(model.
            setValue(""videos[1234].another_prop"", """")).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);

                const cleaned = onSet.mock.calls[0][2];
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                another_prop: """"
                            }
                        }
                    },
                    paths: [
                        [""videos"", 1234, ""another_prop""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Eager Test,"{'line': 94, 'column': 47, 'index': 3361}","it(""should send off undefined on a set to the server."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            another_prop: undefined
                        }
                    }
                }
            })).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);

                const cleaned = onSet.mock.calls[0][2];
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                another_prop: {
                                    $type: ""atom""
                                }
                            }
                        }
                    },
                    paths: [
                        [""videos"", 1234, ""another_prop""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Eager Test,"{'line': 100, 'column': 8, 'index': 3487}","it(""should send off undefined on a set to the server."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            another_prop: undefined
                        }
                    }
                }
            })).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);

                const cleaned = onSet.mock.calls[0][2];
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                another_prop: {
                                    $type: ""atom""
                                }
                            }
                        }
                    },
                    paths: [
                        [""videos"", 1234, ""another_prop""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Eager Test,"{'line': 137, 'column': 47, 'index': 4732}","it(""should report paths progressively."", done => {
        const onSet = function(source, tmpGraph, jsonGraphFromSet) {
            jsonGraphFromSet.jsonGraph.videos[444].rating = 5;
            return jsonGraphFromSet;
        };
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });

        let count = 0;
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            }).
            progressively()).
            doAction(x => {
                if (count === 0) {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 3
                                }
                            }
                        }
                    });
                }

                else {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 5
                                }
                            }
                        }
                    });
                }

                count++;
            }, noOp, () => {
                expect(count === 2).toBe(true);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Eager Test,"{'line': 145, 'column': 8, 'index': 4882}","it(""should report paths progressively."", done => {
        const onSet = function(source, tmpGraph, jsonGraphFromSet) {
            jsonGraphFromSet.jsonGraph.videos[444].rating = 5;
            return jsonGraphFromSet;
        };
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });

        let count = 0;
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            }).
            progressively()).
            doAction(x => {
                if (count === 0) {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 3
                                }
                            }
                        }
                    });
                }

                else {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 5
                                }
                            }
                        }
                    });
                }

                count++;
            }, noOp, () => {
                expect(count === 2).toBe(true);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Exception Handling,"{'line': 224, 'column': 12, 'index': 7301}","it(""should return missing optimized paths with a MaxRetryExceededError."", () => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            // eslint-disable-next-line no-use-before-define
            model.invalidate(""videos[1234].title"");
            return {
                jsonGraph: {
                    videos: {
                        1234: {}
                    }
                },
                paths: []
            };
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        return model.set({
            json: {
                videos: {
                    1234: {
                        title: ""Nowhere to be found""
                    }
                }
            }
        }).then(() => {
            throw new Error(""should have rejected with MaxRetryExceededError"");
        }, e => {
            expect(e).toBeInstanceOf(MaxRetryExceededError);
            expect(e.missingOptimizedPaths).toEqual([[""videos"", ""1234"", ""title""]]);

            expect(onSet).toHaveBeenCalledTimes(3);
            expect(onSet).toHaveBeenNthCalledWith(1, expect.anything(), expect.anything(), expect.anything(), 1 );
            expect(onSet).toHaveBeenNthCalledWith(2, expect.anything(), expect.anything(), expect.anything(), 2 );
            expect(onSet).toHaveBeenNthCalledWith(3, expect.anything(), expect.anything(), expect.anything(), 3 );
        });
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Lazy Test,"{'line': 15, 'column': 47, 'index': 705}","it(""should validate args are sent to the dataSource collapsed."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            })).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);
                expect(onSet).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.anything(), 1);

                const cleaned = onSet.mock.calls[0][2];
                cleaned.paths[0][1] = cleaned.paths[0][1].concat();
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                rating: 5
                            },
                            444: {
                                rating: 3
                            }
                        }
                    },
                    paths: [
                        [""videos"", [444, 1234], ""rating""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Lazy Test,"{'line': 20, 'column': 8, 'index': 812}","it(""should validate args are sent to the dataSource collapsed."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            })).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);
                expect(onSet).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.anything(), 1);

                const cleaned = onSet.mock.calls[0][2];
                cleaned.paths[0][1] = cleaned.paths[0][1].concat();
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                rating: 5
                            },
                            444: {
                                rating: 3
                            }
                        }
                    },
                    paths: [
                        [""videos"", [444, 1234], ""rating""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Lazy Test,"{'line': 62, 'column': 47, 'index': 2300}","it(""should send off an empty string on a set to the server."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });
        toObservable(model.
            setValue(""videos[1234].another_prop"", """")).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);

                const cleaned = onSet.mock.calls[0][2];
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                another_prop: """"
                            }
                        }
                    },
                    paths: [
                        [""videos"", 1234, ""another_prop""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Lazy Test,"{'line': 68, 'column': 8, 'index': 2426}","it(""should send off an empty string on a set to the server."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });
        toObservable(model.
            setValue(""videos[1234].another_prop"", """")).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);

                const cleaned = onSet.mock.calls[0][2];
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                another_prop: """"
                            }
                        }
                    },
                    paths: [
                        [""videos"", 1234, ""another_prop""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Lazy Test,"{'line': 94, 'column': 47, 'index': 3361}","it(""should send off undefined on a set to the server."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            another_prop: undefined
                        }
                    }
                }
            })).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);

                const cleaned = onSet.mock.calls[0][2];
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                another_prop: {
                                    $type: ""atom""
                                }
                            }
                        }
                    },
                    paths: [
                        [""videos"", 1234, ""another_prop""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Lazy Test,"{'line': 100, 'column': 8, 'index': 3487}","it(""should send off undefined on a set to the server."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            another_prop: undefined
                        }
                    }
                }
            })).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);

                const cleaned = onSet.mock.calls[0][2];
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                another_prop: {
                                    $type: ""atom""
                                }
                            }
                        }
                    },
                    paths: [
                        [""videos"", 1234, ""another_prop""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Lazy Test,"{'line': 137, 'column': 47, 'index': 4732}","it(""should report paths progressively."", done => {
        const onSet = function(source, tmpGraph, jsonGraphFromSet) {
            jsonGraphFromSet.jsonGraph.videos[444].rating = 5;
            return jsonGraphFromSet;
        };
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });

        let count = 0;
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            }).
            progressively()).
            doAction(x => {
                if (count === 0) {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 3
                                }
                            }
                        }
                    });
                }

                else {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 5
                                }
                            }
                        }
                    });
                }

                count++;
            }, noOp, () => {
                expect(count === 2).toBe(true);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Lazy Test,"{'line': 145, 'column': 8, 'index': 4882}","it(""should report paths progressively."", done => {
        const onSet = function(source, tmpGraph, jsonGraphFromSet) {
            jsonGraphFromSet.jsonGraph.videos[444].rating = 5;
            return jsonGraphFromSet;
        };
        const dataSource = new LocalDataSource(Cache(), {
            onSet
        });
        const model = new Model({
            source: dataSource
        });

        let count = 0;
        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            }).
            progressively()).
            doAction(x => {
                if (count === 0) {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 3
                                }
                            }
                        }
                    });
                }

                else {
                    expect(strip(x)).toEqual({
                        json: {
                            videos: {
                                1234: {
                                    rating: 5
                                },
                                444: {
                                    rating: 5
                                }
                            }
                        }
                    });
                }

                count++;
            }, noOp, () => {
                expect(count === 2).toBe(true);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Lazy Test,"{'line': 210, 'column': 47, 'index': 6958}","it(""should return missing optimized paths with a MaxRetryExceededError."", () => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            // eslint-disable-next-line no-use-before-define
            model.invalidate(""videos[1234].title"");
            return {
                jsonGraph: {
                    videos: {
                        1234: {}
                    }
                },
                paths: []
            };
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        return model.set({
            json: {
                videos: {
                    1234: {
                        title: ""Nowhere to be found""
                    }
                }
            }
        }).then(() => {
            throw new Error(""should have rejected with MaxRetryExceededError"");
        }, e => {
            expect(e).toBeInstanceOf(MaxRetryExceededError);
            expect(e.missingOptimizedPaths).toEqual([[""videos"", ""1234"", ""title""]]);

            expect(onSet).toHaveBeenCalledTimes(3);
            expect(onSet).toHaveBeenNthCalledWith(1, expect.anything(), expect.anything(), expect.anything(), 1 );
            expect(onSet).toHaveBeenNthCalledWith(2, expect.anything(), expect.anything(), expect.anything(), 2 );
            expect(onSet).toHaveBeenNthCalledWith(3, expect.anything(), expect.anything(), expect.anything(), 3 );
        });
    })",steel
/test/falcor/set/set.dataSource-only.spec.js,Magic Number,"{'line': 35, 'column': 108, 'index': 1358}","it(""should validate args are sent to the dataSource collapsed."", done => {
        const onSet = jest.fn((source, tmpGraph, jsonGraphFromSet, dsRequestOpts) => {
            return jsonGraphFromSet;
        });
        const dataSource = new LocalDataSource(Cache(), { onSet });
        const model = new Model({
            source: dataSource
        });

        toObservable(model.
            set({
                json: {
                    videos: {
                        1234: {
                            rating: 5
                        },
                        444: {
                            rating: 3
                        }
                    }
                }
            })).
            doAction(noOp, noOp, () => {
                expect(onSet).toHaveBeenCalledTimes(1);
                expect(onSet).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.anything(), 1);

                const cleaned = onSet.mock.calls[0][2];
                cleaned.paths[0][1] = cleaned.paths[0][1].concat();
                expect(cleaned).toEqual({
                    jsonGraph: {
                        videos: {
                            1234: {
                                rating: 5
                            },
                            444: {
                                rating: 3
                            }
                        }
                    },
                    paths: [
                        [""videos"", [444, 1234], ""rating""]
                    ]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Conditional Test Logic,"{'line': 122, 'column': 16, 'index': 4827}","it('should perform multiple trips to a dataSource.', function(done) {
            var count = 0;
            var onSet = jest.fn(function(source, tmp, jsongEnv) {
                count++;
                if (count === 1) {

                    // Don't do it this way, it will cause memory leaks.
                    model._root.cache.genreList[1][1] = undefined;
                    return {
                        jsonGraph: jsongEnv.jsonGraph,
                        paths: [jsongEnv.paths[0]]
                    };
                }
                return jsongEnv;
            });
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: onSet
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set(
                    {path: ['genreList', 0, 0, 'summary'], value: 1337},
                    {path: ['genreList', 1, 1, 'summary'], value: 7331})).
                doAction(onNext, noOp, function() {
                    expect(onSet).toHaveBeenCalledTimes(2);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                },
                                1: {
                                    1: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Conditional Test Logic,"{'line': 297, 'column': 16, 'index': 11573}","it('should throw an error set and project it.', function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            errorSelector: function mapError(path, value) {
                value.$foo = 'bar';
                return value;
            }
        });
        var called = false;
        toObservable(model.
            boxValues().
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(noOp, function(e) {
                called = true;
                testRunner.compare([{
                    path: ['genreList', 0, 0, 'summary'],
                    value: {
                        $type: $error,
                        $foo: 'bar',
                        value: {
                            message: 'Timeout',
                            status: 503
                        }
                    }
                }], e, {strip: ['$size']});
            }, function() {
                done('onNext should not be called.');
            }).
            subscribe(noOp, function(e) {
                if (Array.isArray(e) && e[0].value.$foo === 'bar' && called) {
                    done();
                    return;
                }
                done(e);
            }, noOp);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 52, 'column': 75, 'index': 2132}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 60, 'column': 12, 'index': 2322}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 87, 'column': 75, 'index': 3468}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 92, 'column': 12, 'index': 3596}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 134, 'column': 44, 'index': 5292}","it('should perform multiple trips to a dataSource.', function(done) {
            var count = 0;
            var onSet = jest.fn(function(source, tmp, jsongEnv) {
                count++;
                if (count === 1) {

                    // Don't do it this way, it will cause memory leaks.
                    model._root.cache.genreList[1][1] = undefined;
                    return {
                        jsonGraph: jsongEnv.jsonGraph,
                        paths: [jsongEnv.paths[0]]
                    };
                }
                return jsongEnv;
            });
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: onSet
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set(
                    {path: ['genreList', 0, 0, 'summary'], value: 1337},
                    {path: ['genreList', 1, 1, 'summary'], value: 7331})).
                doAction(onNext, noOp, function() {
                    expect(onSet).toHaveBeenCalledTimes(2);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                },
                                1: {
                                    1: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 139, 'column': 12, 'index': 5419}","it('should perform multiple trips to a dataSource.', function(done) {
            var count = 0;
            var onSet = jest.fn(function(source, tmp, jsongEnv) {
                count++;
                if (count === 1) {

                    // Don't do it this way, it will cause memory leaks.
                    model._root.cache.genreList[1][1] = undefined;
                    return {
                        jsonGraph: jsongEnv.jsonGraph,
                        paths: [jsongEnv.paths[0]]
                    };
                }
                return jsongEnv;
            });
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: onSet
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set(
                    {path: ['genreList', 0, 0, 'summary'], value: 1337},
                    {path: ['genreList', 1, 1, 'summary'], value: 7331})).
                doAction(onNext, noOp, function() {
                    expect(onSet).toHaveBeenCalledTimes(2);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                },
                                1: {
                                    1: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 169, 'column': 44, 'index': 6704}","it('should onNext once in progressive mode if the server response is identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache())
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 172, 'column': 12, 'index': 6777}","it('should onNext once in progressive mode if the server response is identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache())
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 195, 'column': 44, 'index': 7741}","it('should onNext twice in progressive mode if the server response is not identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(self, model, jsongEnv) {
                        var copy = JSON.parse(JSON.stringify(jsongEnv));
                        copy.jsonGraph.genreList[0][0].summary = 7331;
                        return copy;
                    }
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(2);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                    expect(strip(onNext.mock.calls[1][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 204, 'column': 12, 'index': 8099}","it('should onNext twice in progressive mode if the server response is not identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(self, model, jsongEnv) {
                        var copy = JSON.parse(JSON.stringify(jsongEnv));
                        copy.jsonGraph.genreList[0][0].summary = 7331;
                        return copy;
                    }
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(2);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                    expect(strip(onNext.mock.calls[1][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 238, 'column': 19, 'index': 9414}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    sourceCalled = true;
                    testRunner.compare({
                        jsonGraph: {
                            videos: {
                                1234: {
                                    summary: 5
                                }
                            }
                        },
                        paths: [['videos', 1234, 'summary']]
                    }, jsongEnv);
                    return jsongEnv;
                }
            })
        });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 239, 'column': 40, 'index': 9463}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    sourceCalled = true;
                    testRunner.compare({
                        jsonGraph: {
                            videos: {
                                1234: {
                                    summary: 5
                                }
                            }
                        },
                        paths: [['videos', 1234, 'summary']]
                    }, jsongEnv);
                    return jsongEnv;
                }
            })
        });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Eager Test,"{'line': 258, 'column': 8, 'index': 10113}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    sourceCalled = true;
                    testRunner.compare({
                        jsonGraph: {
                            videos: {
                                1234: {
                                    summary: 5
                                }
                            }
                        },
                        paths: [['videos', 1234, 'summary']]
                    }, jsongEnv);
                    return jsongEnv;
                }
            })
        });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 114}",Unknown,steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 144}",Unknown,steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 8, 'column': 0, 'index': 272}",Unknown,steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 12, 'column': 0, 'index': 433}",Unknown,steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 21, 'column': 8, 'index': 884}","xit('should accept jsongraph without paths from the datasource', function(done) {
        var mockDataSource = {
            set: function(jsonGraphEnvelope) {
                return {
                    jsonGraph: {
                        titlesById: {
                            0: {
                                rating: 5
                            }
                        }
                    }
                }
            }
        },
        model = new falcor.Model({
            source: mockDataSource
        });
        model.
            setValue('titlesById[0].rating', 5).then(function(value) {
                return model.withoutDataSource().getValue('titlesById[0].rating').then(function(postSetValue) {
                    // value after Model.set without paths shuold be equal to same value retrieved from Model
                    testRunner.compare(postSetValue, value)
                    done();
                });
            }, function(error) {
                // Model.set operation should be able to accept jsonGraph without paths from the dataSource
                testRunner.compare(true, false);
            });
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 52, 'column': 12, 'index': 2069}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 53, 'column': 12, 'index': 2156}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 56, 'column': 12, 'index': 2224}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 59, 'column': 12, 'index': 2292}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 87, 'column': 12, 'index': 3405}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 88, 'column': 12, 'index': 3492}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 91, 'column': 12, 'index': 3566}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 119, 'column': 12, 'index': 4705}","it('should perform multiple trips to a dataSource.', function(done) {
            var count = 0;
            var onSet = jest.fn(function(source, tmp, jsongEnv) {
                count++;
                if (count === 1) {

                    // Don't do it this way, it will cause memory leaks.
                    model._root.cache.genreList[1][1] = undefined;
                    return {
                        jsonGraph: jsongEnv.jsonGraph,
                        paths: [jsongEnv.paths[0]]
                    };
                }
                return jsongEnv;
            });
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: onSet
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set(
                    {path: ['genreList', 0, 0, 'summary'], value: 1337},
                    {path: ['genreList', 1, 1, 'summary'], value: 7331})).
                doAction(onNext, noOp, function() {
                    expect(onSet).toHaveBeenCalledTimes(2);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                },
                                1: {
                                    1: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 120, 'column': 12, 'index': 4732}","it('should perform multiple trips to a dataSource.', function(done) {
            var count = 0;
            var onSet = jest.fn(function(source, tmp, jsongEnv) {
                count++;
                if (count === 1) {

                    // Don't do it this way, it will cause memory leaks.
                    model._root.cache.genreList[1][1] = undefined;
                    return {
                        jsonGraph: jsongEnv.jsonGraph,
                        paths: [jsongEnv.paths[0]]
                    };
                }
                return jsongEnv;
            });
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: onSet
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set(
                    {path: ['genreList', 0, 0, 'summary'], value: 1337},
                    {path: ['genreList', 1, 1, 'summary'], value: 7331})).
                doAction(onNext, noOp, function() {
                    expect(onSet).toHaveBeenCalledTimes(2);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                },
                                1: {
                                    1: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 133, 'column': 12, 'index': 5224}","it('should perform multiple trips to a dataSource.', function(done) {
            var count = 0;
            var onSet = jest.fn(function(source, tmp, jsongEnv) {
                count++;
                if (count === 1) {

                    // Don't do it this way, it will cause memory leaks.
                    model._root.cache.genreList[1][1] = undefined;
                    return {
                        jsonGraph: jsongEnv.jsonGraph,
                        paths: [jsongEnv.paths[0]]
                    };
                }
                return jsongEnv;
            });
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: onSet
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set(
                    {path: ['genreList', 0, 0, 'summary'], value: 1337},
                    {path: ['genreList', 1, 1, 'summary'], value: 7331})).
                doAction(onNext, noOp, function() {
                    expect(onSet).toHaveBeenCalledTimes(2);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                },
                                1: {
                                    1: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 138, 'column': 12, 'index': 5383}","it('should perform multiple trips to a dataSource.', function(done) {
            var count = 0;
            var onSet = jest.fn(function(source, tmp, jsongEnv) {
                count++;
                if (count === 1) {

                    // Don't do it this way, it will cause memory leaks.
                    model._root.cache.genreList[1][1] = undefined;
                    return {
                        jsonGraph: jsongEnv.jsonGraph,
                        paths: [jsongEnv.paths[0]]
                    };
                }
                return jsongEnv;
            });
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: onSet
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set(
                    {path: ['genreList', 0, 0, 'summary'], value: 1337},
                    {path: ['genreList', 1, 1, 'summary'], value: 7331})).
                doAction(onNext, noOp, function() {
                    expect(onSet).toHaveBeenCalledTimes(2);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                },
                                1: {
                                    1: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 167, 'column': 12, 'index': 6609}","it('should onNext once in progressive mode if the server response is identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache())
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 168, 'column': 12, 'index': 6636}","it('should onNext once in progressive mode if the server response is identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache())
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 171, 'column': 12, 'index': 6741}","it('should onNext once in progressive mode if the server response is identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache())
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 193, 'column': 12, 'index': 7646}","it('should onNext twice in progressive mode if the server response is not identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(self, model, jsongEnv) {
                        var copy = JSON.parse(JSON.stringify(jsongEnv));
                        copy.jsonGraph.genreList[0][0].summary = 7331;
                        return copy;
                    }
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(2);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                    expect(strip(onNext.mock.calls[1][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 194, 'column': 12, 'index': 7673}","it('should onNext twice in progressive mode if the server response is not identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(self, model, jsongEnv) {
                        var copy = JSON.parse(JSON.stringify(jsongEnv));
                        copy.jsonGraph.genreList[0][0].summary = 7331;
                        return copy;
                    }
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(2);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                    expect(strip(onNext.mock.calls[1][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 197, 'column': 24, 'index': 7837}","it('should onNext twice in progressive mode if the server response is not identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(self, model, jsongEnv) {
                        var copy = JSON.parse(JSON.stringify(jsongEnv));
                        copy.jsonGraph.genreList[0][0].summary = 7331;
                        return copy;
                    }
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(2);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                    expect(strip(onNext.mock.calls[1][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 203, 'column': 12, 'index': 8063}","it('should onNext twice in progressive mode if the server response is not identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(self, model, jsongEnv) {
                        var copy = JSON.parse(JSON.stringify(jsongEnv));
                        copy.jsonGraph.genreList[0][0].summary = 7331;
                        return copy;
                    }
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(2);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                    expect(strip(onNext.mock.calls[1][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 237, 'column': 8, 'index': 9371}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    sourceCalled = true;
                    testRunner.compare({
                        jsonGraph: {
                            videos: {
                                1234: {
                                    summary: 5
                                }
                            }
                        },
                        paths: [['videos', 1234, 'summary']]
                    }, jsongEnv);
                    return jsongEnv;
                }
            })
        });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 256, 'column': 8, 'index': 10051}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    sourceCalled = true;
                    testRunner.compare({
                        jsonGraph: {
                            videos: {
                                1234: {
                                    summary: 5
                                }
                            }
                        },
                        paths: [['videos', 1234, 'summary']]
                    }, jsongEnv);
                    return jsongEnv;
                }
            })
        });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 257, 'column': 8, 'index': 10079}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    sourceCalled = true;
                    testRunner.compare({
                        jsonGraph: {
                            videos: {
                                1234: {
                                    summary: 5
                                }
                            }
                        },
                        paths: [['videos', 1234, 'summary']]
                    }, jsongEnv);
                    return jsongEnv;
                }
            })
        });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 269, 'column': 8, 'index': 10549}","it('should throw an error set and project it.', function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            errorSelector: function mapError(path, value) {
                value.$foo = 'bar';
                return value;
            }
        });
        var called = false;
        toObservable(model.
            boxValues().
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(noOp, function(e) {
                called = true;
                testRunner.compare([{
                    path: ['genreList', 0, 0, 'summary'],
                    value: {
                        $type: $error,
                        $foo: 'bar',
                        value: {
                            message: 'Timeout',
                            status: 503
                        }
                    }
                }], e, {strip: ['$size']});
            }, function() {
                done('onNext should not be called.');
            }).
            subscribe(noOp, function(e) {
                if (Array.isArray(e) && e[0].value.$foo === 'bar' && called) {
                    done();
                    return;
                }
                done(e);
            }, noOp);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Global Variable,"{'line': 276, 'column': 8, 'index': 10790}","it('should throw an error set and project it.', function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            errorSelector: function mapError(path, value) {
                value.$foo = 'bar';
                return value;
            }
        });
        var called = false;
        toObservable(model.
            boxValues().
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(noOp, function(e) {
                called = true;
                testRunner.compare([{
                    path: ['genreList', 0, 0, 'summary'],
                    value: {
                        $type: $error,
                        $foo: 'bar',
                        value: {
                            message: 'Timeout',
                            status: 503
                        }
                    }
                }], e, {strip: ['$size']});
            }, function() {
                done('onNext should not be called.');
            }).
            subscribe(noOp, function(e) {
                if (Array.isArray(e) && e[0].value.$foo === 'bar' && called) {
                    done();
                    return;
                }
                done(e);
            }, noOp);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 52, 'column': 75, 'index': 2132}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 60, 'column': 12, 'index': 2322}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 87, 'column': 75, 'index': 3468}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 92, 'column': 12, 'index': 3596}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 134, 'column': 44, 'index': 5292}","it('should perform multiple trips to a dataSource.', function(done) {
            var count = 0;
            var onSet = jest.fn(function(source, tmp, jsongEnv) {
                count++;
                if (count === 1) {

                    // Don't do it this way, it will cause memory leaks.
                    model._root.cache.genreList[1][1] = undefined;
                    return {
                        jsonGraph: jsongEnv.jsonGraph,
                        paths: [jsongEnv.paths[0]]
                    };
                }
                return jsongEnv;
            });
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: onSet
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set(
                    {path: ['genreList', 0, 0, 'summary'], value: 1337},
                    {path: ['genreList', 1, 1, 'summary'], value: 7331})).
                doAction(onNext, noOp, function() {
                    expect(onSet).toHaveBeenCalledTimes(2);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                },
                                1: {
                                    1: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 139, 'column': 12, 'index': 5419}","it('should perform multiple trips to a dataSource.', function(done) {
            var count = 0;
            var onSet = jest.fn(function(source, tmp, jsongEnv) {
                count++;
                if (count === 1) {

                    // Don't do it this way, it will cause memory leaks.
                    model._root.cache.genreList[1][1] = undefined;
                    return {
                        jsonGraph: jsongEnv.jsonGraph,
                        paths: [jsongEnv.paths[0]]
                    };
                }
                return jsongEnv;
            });
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: onSet
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set(
                    {path: ['genreList', 0, 0, 'summary'], value: 1337},
                    {path: ['genreList', 1, 1, 'summary'], value: 7331})).
                doAction(onNext, noOp, function() {
                    expect(onSet).toHaveBeenCalledTimes(2);
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                },
                                1: {
                                    1: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 169, 'column': 44, 'index': 6704}","it('should onNext once in progressive mode if the server response is identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache())
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 172, 'column': 12, 'index': 6777}","it('should onNext once in progressive mode if the server response is identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache())
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 195, 'column': 44, 'index': 7741}","it('should onNext twice in progressive mode if the server response is not identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(self, model, jsongEnv) {
                        var copy = JSON.parse(JSON.stringify(jsongEnv));
                        copy.jsonGraph.genreList[0][0].summary = 7331;
                        return copy;
                    }
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(2);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                    expect(strip(onNext.mock.calls[1][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 204, 'column': 12, 'index': 8099}","it('should onNext twice in progressive mode if the server response is not identical.', function(done) {
            var count = 0;
            var model = new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(self, model, jsongEnv) {
                        var copy = JSON.parse(JSON.stringify(jsongEnv));
                        copy.jsonGraph.genreList[0][0].summary = 7331;
                        return copy;
                    }
                })
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['genreList', 0, 0, 'summary'], value: 1337}).
                progressively()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(2);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 1337
                                    }
                                }
                            }
                        }
                    });
                    expect(strip(onNext.mock.calls[1][0])).toEqual({
                        json: {
                            genreList: {
                                0: {
                                    0: {
                                        summary: 7331
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 238, 'column': 19, 'index': 9414}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    sourceCalled = true;
                    testRunner.compare({
                        jsonGraph: {
                            videos: {
                                1234: {
                                    summary: 5
                                }
                            }
                        },
                        paths: [['videos', 1234, 'summary']]
                    }, jsongEnv);
                    return jsongEnv;
                }
            })
        });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 258, 'column': 8, 'index': 10113}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    sourceCalled = true;
                    testRunner.compare({
                        jsonGraph: {
                            videos: {
                                1234: {
                                    summary: 5
                                }
                            }
                        },
                        paths: [['videos', 1234, 'summary']]
                    }, jsongEnv);
                    return jsongEnv;
                }
            })
        });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Lazy Test,"{'line': 277, 'column': 8, 'index': 10818}","it('should throw an error set and project it.', function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            errorSelector: function mapError(path, value) {
                value.$foo = 'bar';
                return value;
            }
        });
        var called = false;
        toObservable(model.
            boxValues().
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(noOp, function(e) {
                called = true;
                testRunner.compare([{
                    path: ['genreList', 0, 0, 'summary'],
                    value: {
                        $type: $error,
                        $foo: 'bar',
                        value: {
                            message: 'Timeout',
                            status: 503
                        }
                    }
                }], e, {strip: ['$size']});
            }, function() {
                done('onNext should not be called.');
            }).
            subscribe(noOp, function(e) {
                if (Array.isArray(e) && e[0].value.$foo === 'bar' && called) {
                    done();
                    return;
                }
                done(e);
            }, noOp);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Unknown Test,"{'column': 8, 'line': 51}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Unknown Test,"{'column': 8, 'line': 86}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Unknown Test,"{'column': 4, 'line': 236}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    sourceCalled = true;
                    testRunner.compare({
                        jsonGraph: {
                            videos: {
                                1234: {
                                    summary: 5
                                }
                            }
                        },
                        paths: [['videos', 1234, 'summary']]
                    }, jsongEnv);
                    return jsongEnv;
                }
            })
        });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-cache.spec.js,Unknown Test,"{'column': 4, 'line': 268}","it('should throw an error set and project it.', function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            errorSelector: function mapError(path, value) {
                value.$foo = 'bar';
                return value;
            }
        });
        var called = false;
        toObservable(model.
            boxValues().
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(noOp, function(e) {
                called = true;
                testRunner.compare([{
                    path: ['genreList', 0, 0, 'summary'],
                    value: {
                        $type: $error,
                        $foo: 'bar',
                        value: {
                            message: 'Timeout',
                            status: 503
                        }
                    }
                }], e, {strip: ['$size']});
            }, function() {
                done('onNext should not be called.');
            }).
            subscribe(noOp, function(e) {
                if (Array.isArray(e) && e[0].value.$foo === 'bar' && called) {
                    done();
                    return;
                }
                done(e);
            }, noOp);
    })",steel
/test/falcor/set/set.dataSource-and-bind.spec.js,Conditional Test Logic,"{'line': 22, 'column': 20, 'index': 896}","it('should perform multiple trips to a dataSource.', function(done) {
        var count = 0;
        var model = new Model({
            cache: M(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    count++;
                    if (count === 1) {
                        // Don't do it this way, it will cause memory leaks.
                        model._root.cache.lists.A[1] = undefined;
                        return {
                            jsonGraph: jsongEnv.jsonGraph,
                            paths: [jsongEnv.paths[0]]
                        };
                    }

                    return jsongEnv;
                }
            })
        });
        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            flatMap(function(x) {
                return model.
                    deref(x.json.lolomo[0]).
                    set(
                        {path: [0, 'item', 'title'], value: 1337},
                        {path: [1, 'item', 'title'], value: 7331});
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(count).toBe(2);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        0: {
                            item: {
                                title: 1337
                            }
                        },
                        1: {
                            item: {
                                title: 7331
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-bind.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/set/set.dataSource-and-bind.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 121}",Unknown,steel
/test/falcor/set/set.dataSource-and-bind.spec.js,Global Variable,"{'line': 16, 'column': 8, 'index': 668}","it('should perform multiple trips to a dataSource.', function(done) {
        var count = 0;
        var model = new Model({
            cache: M(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    count++;
                    if (count === 1) {
                        // Don't do it this way, it will cause memory leaks.
                        model._root.cache.lists.A[1] = undefined;
                        return {
                            jsonGraph: jsongEnv.jsonGraph,
                            paths: [jsongEnv.paths[0]]
                        };
                    }

                    return jsongEnv;
                }
            })
        });
        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            flatMap(function(x) {
                return model.
                    deref(x.json.lolomo[0]).
                    set(
                        {path: [0, 'item', 'title'], value: 1337},
                        {path: [1, 'item', 'title'], value: 7331});
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(count).toBe(2);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        0: {
                            item: {
                                title: 1337
                            }
                        },
                        1: {
                            item: {
                                title: 7331
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-bind.spec.js,Global Variable,"{'line': 17, 'column': 8, 'index': 691}","it('should perform multiple trips to a dataSource.', function(done) {
        var count = 0;
        var model = new Model({
            cache: M(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    count++;
                    if (count === 1) {
                        // Don't do it this way, it will cause memory leaks.
                        model._root.cache.lists.A[1] = undefined;
                        return {
                            jsonGraph: jsongEnv.jsonGraph,
                            paths: [jsongEnv.paths[0]]
                        };
                    }

                    return jsongEnv;
                }
            })
        });
        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            flatMap(function(x) {
                return model.
                    deref(x.json.lolomo[0]).
                    set(
                        {path: [0, 'item', 'title'], value: 1337},
                        {path: [1, 'item', 'title'], value: 7331});
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(count).toBe(2);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        0: {
                            item: {
                                title: 1337
                            }
                        },
                        1: {
                            item: {
                                title: 7331
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-bind.spec.js,Global Variable,"{'line': 35, 'column': 8, 'index': 1345}","it('should perform multiple trips to a dataSource.', function(done) {
        var count = 0;
        var model = new Model({
            cache: M(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    count++;
                    if (count === 1) {
                        // Don't do it this way, it will cause memory leaks.
                        model._root.cache.lists.A[1] = undefined;
                        return {
                            jsonGraph: jsongEnv.jsonGraph,
                            paths: [jsongEnv.paths[0]]
                        };
                    }

                    return jsongEnv;
                }
            })
        });
        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            flatMap(function(x) {
                return model.
                    deref(x.json.lolomo[0]).
                    set(
                        {path: [0, 'item', 'title'], value: 1337},
                        {path: [1, 'item', 'title'], value: 7331});
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(count).toBe(2);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        0: {
                            item: {
                                title: 1337
                            }
                        },
                        1: {
                            item: {
                                title: 7331
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.dataSource-and-bind.spec.js,Magic Number,"{'line': 47, 'column': 35, 'index': 1846}","it('should perform multiple trips to a dataSource.', function(done) {
        var count = 0;
        var model = new Model({
            cache: M(),
            source: new LocalDataSource(Cache(), {
                onSet: function(source, tmp, jsongEnv) {
                    count++;
                    if (count === 1) {
                        // Don't do it this way, it will cause memory leaks.
                        model._root.cache.lists.A[1] = undefined;
                        return {
                            jsonGraph: jsongEnv.jsonGraph,
                            paths: [jsongEnv.paths[0]]
                        };
                    }

                    return jsongEnv;
                }
            })
        });
        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            flatMap(function(x) {
                return model.
                    deref(x.json.lolomo[0]).
                    set(
                        {path: [0, 'item', 'title'], value: 1337},
                        {path: [1, 'item', 'title'], value: 7331});
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(count).toBe(2);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        0: {
                            item: {
                                title: 1337
                            }
                        },
                        1: {
                            item: {
                                title: 7331
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.change-handler.spec.js,Conditional Test Logic,"{'line': 21, 'column': 16, 'index': 641}","it(""is called when the root's version changes but before the subscription is disposed."", function () {
        var changed = false;
        var calledBeforeEnsure = false;
        var model = new Model({
            onChange: function () {
                changed = true;
            }
        });

        toObservable(model.
            set({
                path: [""a"", ""b"", ""c""],
                value: ""foo""
            })).
            ensure(function() {
                if(changed === true) {
                    calledBeforeEnsure = true;
                }
            }).
            subscribe();

        expect(changed).toBe(true);
        expect(calledBeforeEnsure).toBe(true);
    })",steel
/test/falcor/set/set.change-handler.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/set/set.change-handler.spec.js,Global Variable,"{'line': 7, 'column': 8, 'index': 274}","it(""is called when the root's version changes but before the subscription is disposed."", function () {
        var changed = false;
        var calledBeforeEnsure = false;
        var model = new Model({
            onChange: function () {
                changed = true;
            }
        });

        toObservable(model.
            set({
                path: [""a"", ""b"", ""c""],
                value: ""foo""
            })).
            ensure(function() {
                if(changed === true) {
                    calledBeforeEnsure = true;
                }
            }).
            subscribe();

        expect(changed).toBe(true);
        expect(calledBeforeEnsure).toBe(true);
    })",steel
/test/falcor/set/set.change-handler.spec.js,Global Variable,"{'line': 8, 'column': 8, 'index': 303}","it(""is called when the root's version changes but before the subscription is disposed."", function () {
        var changed = false;
        var calledBeforeEnsure = false;
        var model = new Model({
            onChange: function () {
                changed = true;
            }
        });

        toObservable(model.
            set({
                path: [""a"", ""b"", ""c""],
                value: ""foo""
            })).
            ensure(function() {
                if(changed === true) {
                    calledBeforeEnsure = true;
                }
            }).
            subscribe();

        expect(changed).toBe(true);
        expect(calledBeforeEnsure).toBe(true);
    })",steel
/test/falcor/set/set.change-handler.spec.js,Global Variable,"{'line': 9, 'column': 8, 'index': 343}","it(""is called when the root's version changes but before the subscription is disposed."", function () {
        var changed = false;
        var calledBeforeEnsure = false;
        var model = new Model({
            onChange: function () {
                changed = true;
            }
        });

        toObservable(model.
            set({
                path: [""a"", ""b"", ""c""],
                value: ""foo""
            })).
            ensure(function() {
                if(changed === true) {
                    calledBeforeEnsure = true;
                }
            }).
            subscribe();

        expect(changed).toBe(true);
        expect(calledBeforeEnsure).toBe(true);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Conditional Test Logic,"{'line': 157, 'column': 16, 'index': 6090}","it('should throw an error set and project it.', function(done) {
        var model = new Model({
            source: new Model({
                source: new ErrorDataSource(503, ""Timeout""),
                errorSelector: function mapError(path, value) {
                    value.$foo = 'bar';
                    return value;
                }
            }).asDataSource() });
        var called = false;
        toObservable(model.
            boxValues().
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(noOp, function(e) {
                called = true;
                testRunner.compare([{
                    path: ['genreList', 0, 0, 'summary'],
                    value: {
                        $type: $error,
                        $foo: 'bar',
                        value: {
                            message: 'Timeout',
                            status: 503
                        }
                    }
                }], e, {strip: ['$size']});
            }, function() {
                done('onCompleted should not be called.');
            }).
            subscribe(noOp, function(e) {
                if (Array.isArray(e) && e[0].value.$foo === 'bar' && called) {
                    done();
                    return;
                }
                done(e);
            }, noOp);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Eager Test,"{'line': 23, 'column': 44, 'index': 1008}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Eager Test,"{'line': 32, 'column': 12, 'index': 1229}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Eager Test,"{'line': 60, 'column': 44, 'index': 2411}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Eager Test,"{'line': 66, 'column': 12, 'index': 2570}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Eager Test,"{'line': 96, 'column': 19, 'index': 3734}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(source, tmp, jsongEnv) {
                        sourceCalled = true;
                        testRunner.compare({
                            jsonGraph: {
                                videos: {
                                    1234: {
                                        summary: 5
                                    }
                                }
                            },
                            paths: [['videos', 1234, 'summary']]
                        }, jsongEnv);
                        return jsongEnv;
                    }
                })
            }).asDataSource() });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Eager Test,"{'line': 98, 'column': 44, 'index': 3819}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(source, tmp, jsongEnv) {
                        sourceCalled = true;
                        testRunner.compare({
                            jsonGraph: {
                                videos: {
                                    1234: {
                                        summary: 5
                                    }
                                }
                            },
                            paths: [['videos', 1234, 'summary']]
                        }, jsongEnv);
                        return jsongEnv;
                    }
                })
            }).asDataSource() });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Eager Test,"{'line': 117, 'column': 8, 'index': 4551}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(source, tmp, jsongEnv) {
                        sourceCalled = true;
                        testRunner.compare({
                            jsonGraph: {
                                videos: {
                                    1234: {
                                        summary: 5
                                    }
                                }
                            },
                            paths: [['videos', 1234, 'summary']]
                        }, jsongEnv);
                        return jsongEnv;
                    }
                })
            }).asDataSource() });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 114}",Unknown,steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 144}",Unknown,steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 8, 'column': 0, 'index': 272}",Unknown,steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 12, 'column': 0, 'index': 433}",Unknown,steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 22, 'column': 12, 'index': 909}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 25, 'column': 12, 'index': 1063}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 28, 'column': 12, 'index': 1131}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 31, 'column': 12, 'index': 1199}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 59, 'column': 12, 'index': 2312}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 62, 'column': 12, 'index': 2466}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 65, 'column': 12, 'index': 2540}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 95, 'column': 8, 'index': 3691}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(source, tmp, jsongEnv) {
                        sourceCalled = true;
                        testRunner.compare({
                            jsonGraph: {
                                videos: {
                                    1234: {
                                        summary: 5
                                    }
                                }
                            },
                            paths: [['videos', 1234, 'summary']]
                        }, jsongEnv);
                        return jsongEnv;
                    }
                })
            }).asDataSource() });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 115, 'column': 8, 'index': 4489}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(source, tmp, jsongEnv) {
                        sourceCalled = true;
                        testRunner.compare({
                            jsonGraph: {
                                videos: {
                                    1234: {
                                        summary: 5
                                    }
                                }
                            },
                            paths: [['videos', 1234, 'summary']]
                        }, jsongEnv);
                        return jsongEnv;
                    }
                })
            }).asDataSource() });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 116, 'column': 8, 'index': 4517}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(source, tmp, jsongEnv) {
                        sourceCalled = true;
                        testRunner.compare({
                            jsonGraph: {
                                videos: {
                                    1234: {
                                        summary: 5
                                    }
                                }
                            },
                            paths: [['videos', 1234, 'summary']]
                        }, jsongEnv);
                        return jsongEnv;
                    }
                })
            }).asDataSource() });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 128, 'column': 8, 'index': 4987}","it('should throw an error set and project it.', function(done) {
        var model = new Model({
            source: new Model({
                source: new ErrorDataSource(503, ""Timeout""),
                errorSelector: function mapError(path, value) {
                    value.$foo = 'bar';
                    return value;
                }
            }).asDataSource() });
        var called = false;
        toObservable(model.
            boxValues().
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(noOp, function(e) {
                called = true;
                testRunner.compare([{
                    path: ['genreList', 0, 0, 'summary'],
                    value: {
                        $type: $error,
                        $foo: 'bar',
                        value: {
                            message: 'Timeout',
                            status: 503
                        }
                    }
                }], e, {strip: ['$size']});
            }, function() {
                done('onCompleted should not be called.');
            }).
            subscribe(noOp, function(e) {
                if (Array.isArray(e) && e[0].value.$foo === 'bar' && called) {
                    done();
                    return;
                }
                done(e);
            }, noOp);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Global Variable,"{'line': 136, 'column': 8, 'index': 5302}","it('should throw an error set and project it.', function(done) {
        var model = new Model({
            source: new Model({
                source: new ErrorDataSource(503, ""Timeout""),
                errorSelector: function mapError(path, value) {
                    value.$foo = 'bar';
                    return value;
                }
            }).asDataSource() });
        var called = false;
        toObservable(model.
            boxValues().
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(noOp, function(e) {
                called = true;
                testRunner.compare([{
                    path: ['genreList', 0, 0, 'summary'],
                    value: {
                        $type: $error,
                        $foo: 'bar',
                        value: {
                            message: 'Timeout',
                            status: 503
                        }
                    }
                }], e, {strip: ['$size']});
            }, function() {
                done('onCompleted should not be called.');
            }).
            subscribe(noOp, function(e) {
                if (Array.isArray(e) && e[0].value.$foo === 'bar' && called) {
                    done();
                    return;
                }
                done(e);
            }, noOp);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Lazy Test,"{'line': 23, 'column': 44, 'index': 1008}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Lazy Test,"{'line': 32, 'column': 12, 'index': 1229}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Lazy Test,"{'line': 60, 'column': 44, 'index': 2411}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Lazy Test,"{'line': 66, 'column': 12, 'index': 2570}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Lazy Test,"{'line': 96, 'column': 19, 'index': 3734}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(source, tmp, jsongEnv) {
                        sourceCalled = true;
                        testRunner.compare({
                            jsonGraph: {
                                videos: {
                                    1234: {
                                        summary: 5
                                    }
                                }
                            },
                            paths: [['videos', 1234, 'summary']]
                        }, jsongEnv);
                        return jsongEnv;
                    }
                })
            }).asDataSource() });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Lazy Test,"{'line': 117, 'column': 8, 'index': 4551}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(source, tmp, jsongEnv) {
                        sourceCalled = true;
                        testRunner.compare({
                            jsonGraph: {
                                videos: {
                                    1234: {
                                        summary: 5
                                    }
                                }
                            },
                            paths: [['videos', 1234, 'summary']]
                        }, jsongEnv);
                        return jsongEnv;
                    }
                })
            }).asDataSource() });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Lazy Test,"{'line': 137, 'column': 8, 'index': 5330}","it('should throw an error set and project it.', function(done) {
        var model = new Model({
            source: new Model({
                source: new ErrorDataSource(503, ""Timeout""),
                errorSelector: function mapError(path, value) {
                    value.$foo = 'bar';
                    return value;
                }
            }).asDataSource() });
        var called = false;
        toObservable(model.
            boxValues().
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(noOp, function(e) {
                called = true;
                testRunner.compare([{
                    path: ['genreList', 0, 0, 'summary'],
                    value: {
                        $type: $error,
                        $foo: 'bar',
                        value: {
                            message: 'Timeout',
                            status: 503
                        }
                    }
                }], e, {strip: ['$size']});
            }, function() {
                done('onCompleted should not be called.');
            }).
            subscribe(noOp, function(e) {
                if (Array.isArray(e) && e[0].value.$foo === 'bar' && called) {
                    done();
                    return;
                }
                done(e);
            }, noOp);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Unknown Test,"{'column': 8, 'line': 21}","it('should set a value from falcor.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var e1 = {
                newValue: '1'
            };
            var e2 = {
                newValue: '2'
            };
            var next = false;
            toObservable(model.
                set(
                    {path: ['videos', 1234, 'summary'], value: e1},
                    {path: ['videos', 766, 'summary'], value: e2})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        videos: {
                            1234: {
                                summary: {
                                    newValue: '1'
                                }
                            },
                            766: {
                                summary: {
                                    newValue: '2'
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Unknown Test,"{'column': 8, 'line': 58}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new Model({
                source: new LocalDataSource(Cache())
            }).asDataSource() });
            var expected = {
                newValue: '1'
            };
            var next = false;
            toObservable(model.
                set({path: ['genreList', 0, {to: 1}, 'summary'], value: expected})).
                doAction(function(x) {
                    next = true;
                    testRunner.compare({ json: {
                        genreList: {
                            0: {
                                0: {
                                    summary: {
                                        newValue: '1'
                                    }
                                },
                                1: {
                                    summary: {
                                        newValue: '1'
                                    }
                                }
                            }
                        }
                    }}, strip(x));
                }, noOp, function() {
                    // onNext at least once
                    testRunner.compare(true, next);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Unknown Test,"{'column': 4, 'line': 94}","it('should ensure that the jsong sent to server is optimized.', function(done) {
        var model = new Model({
            cache: Cache(),
            source: new Model({
                source: new LocalDataSource(Cache(), {
                    onSet: function(source, tmp, jsongEnv) {
                        sourceCalled = true;
                        testRunner.compare({
                            jsonGraph: {
                                videos: {
                                    1234: {
                                        summary: 5
                                    }
                                }
                            },
                            paths: [['videos', 1234, 'summary']]
                        }, jsongEnv);
                        return jsongEnv;
                    }
                })
            }).asDataSource() });
        var called = false;
        var sourceCalled = false;
        toObservable(model.
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(function(x) {
                called = true;
            }, noOp, function() {
                testRunner.compare(true, called);
                testRunner.compare(true, sourceCalled);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/set/set.cacheAsDataSource-and-cache.spec.js,Unknown Test,"{'column': 4, 'line': 127}","it('should throw an error set and project it.', function(done) {
        var model = new Model({
            source: new Model({
                source: new ErrorDataSource(503, ""Timeout""),
                errorSelector: function mapError(path, value) {
                    value.$foo = 'bar';
                    return value;
                }
            }).asDataSource() });
        var called = false;
        toObservable(model.
            boxValues().
            set({path: ['genreList', 0, 0, 'summary'], value: 5})).
            doAction(noOp, function(e) {
                called = true;
                testRunner.compare([{
                    path: ['genreList', 0, 0, 'summary'],
                    value: {
                        $type: $error,
                        $foo: 'bar',
                        value: {
                            message: 'Timeout',
                            status: 503
                        }
                    }
                }], e, {strip: ['$size']});
            }, function() {
                done('onCompleted should not be called.');
            }).
            subscribe(noOp, function(e) {
                if (Array.isArray(e) && e[0].value.$foo === 'bar' && called) {
                    done();
                    return;
                }
                done(e);
            }, noOp);
    })",steel
/test/falcor/set/set.cache-only.spec.js,Duplicate Assert,"{'line': 169, 'column': 24, 'index': 5988}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Duplicate Assert,"{'line': 178, 'column': 24, 'index': 6331}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Duplicate Assert,"{'line': 256, 'column': 24, 'index': 9129}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Duplicate Assert,"{'line': 256, 'column': 24, 'index': 9129}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Duplicate Assert,"{'line': 261, 'column': 24, 'index': 9285}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Duplicate Assert,"{'line': 261, 'column': 24, 'index': 9285}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Eager Test,"{'line': 15, 'column': 23, 'index': 593}","it('should set a value from falcor.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 1)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['videos', 0, 'title'], value: 'V0'})).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'V0'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Eager Test,"{'line': 18, 'column': 12, 'index': 678}","it('should set a value from falcor.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 1)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['videos', 0, 'title'], value: 'V0'})).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'V0'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Eager Test,"{'line': 37, 'column': 23, 'index': 1441}","it('should correctly output with many different input types.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 3)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({
                    path: ['videos', 0, 'title'],
                    value: 'V0'
                }, {
                    jsonGraph: {
                        videos: {
                            1: {
                                title: 'V1'
                            }
                        }
                    },
                    paths: [['videos', 1, 'title']]
                }, {
                    json: {
                        videos: {
                            2: {
                                title: 'V2'
                            }
                        }
                    }
                })).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'V0'
                                },
                                1: {
                                    title: 'V1'
                                },
                                2: {
                                    title: 'V2'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Eager Test,"{'line': 40, 'column': 12, 'index': 1526}","it('should correctly output with many different input types.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 3)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({
                    path: ['videos', 0, 'title'],
                    value: 'V0'
                }, {
                    jsonGraph: {
                        videos: {
                            1: {
                                title: 'V1'
                            }
                        }
                    },
                    paths: [['videos', 1, 'title']]
                }, {
                    json: {
                        videos: {
                            2: {
                                title: 'V2'
                            }
                        }
                    }
                })).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'V0'
                                },
                                1: {
                                    title: 'V1'
                                },
                                2: {
                                    title: 'V2'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Eager Test,"{'line': 86, 'column': 23, 'index': 3141}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 1)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['videos', 0, 'title'], value: 'V0'}).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: 'V0'
                                }
                            }
                        },
                        paths: [['videos', 0, 'title']]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Eager Test,"{'line': 89, 'column': 12, 'index': 3226}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 1)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['videos', 0, 'title'], value: 'V0'}).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: 'V0'
                                }
                            }
                        },
                        paths: [['videos', 0, 'title']]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Eager Test,"{'line': 148, 'column': 29, 'index': 5225}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Eager Test,"{'line': 159, 'column': 12, 'index': 5536}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Eager Test,"{'line': 186, 'column': 29, 'index': 6629}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Eager Test,"{'line': 197, 'column': 12, 'index': 6938}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Eager Test,"{'line': 228, 'column': 29, 'index': 8239}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Eager Test,"{'line': 249, 'column': 12, 'index': 8838}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 3, 'column': 0, 'index': 67}",Unknown,steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 7, 'column': 0, 'index': 259}",Unknown,steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 14, 'column': 12, 'index': 546}","it('should set a value from falcor.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 1)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['videos', 0, 'title'], value: 'V0'})).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'V0'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 17, 'column': 12, 'index': 642}","it('should set a value from falcor.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 1)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['videos', 0, 'title'], value: 'V0'})).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'V0'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 36, 'column': 12, 'index': 1394}","it('should correctly output with many different input types.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 3)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({
                    path: ['videos', 0, 'title'],
                    value: 'V0'
                }, {
                    jsonGraph: {
                        videos: {
                            1: {
                                title: 'V1'
                            }
                        }
                    },
                    paths: [['videos', 1, 'title']]
                }, {
                    json: {
                        videos: {
                            2: {
                                title: 'V2'
                            }
                        }
                    }
                })).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'V0'
                                },
                                1: {
                                    title: 'V1'
                                },
                                2: {
                                    title: 'V2'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 39, 'column': 12, 'index': 1490}","it('should correctly output with many different input types.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 3)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({
                    path: ['videos', 0, 'title'],
                    value: 'V0'
                }, {
                    jsonGraph: {
                        videos: {
                            1: {
                                title: 'V1'
                            }
                        }
                    },
                    paths: [['videos', 1, 'title']]
                }, {
                    json: {
                        videos: {
                            2: {
                                title: 'V2'
                            }
                        }
                    }
                })).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'V0'
                                },
                                1: {
                                    title: 'V1'
                                },
                                2: {
                                    title: 'V2'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 85, 'column': 12, 'index': 3094}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 1)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['videos', 0, 'title'], value: 'V0'}).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: 'V0'
                                }
                            }
                        },
                        paths: [['videos', 0, 'title']]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 88, 'column': 12, 'index': 3190}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 1)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['videos', 0, 'title'], value: 'V0'}).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: 'V0'
                                }
                            }
                        },
                        paths: [['videos', 0, 'title']]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 116, 'column': 16, 'index': 4234}","describe('Error Selector (during set)', function() {

        function generateErrorSelectorSpy(expectedPath) {
            return jest.fn(function(path, atom) {
                expect(atom.$type).toBe('error');
                expect(atom.value.message).toBe('errormsg');

                var o = {
                    $type: atom.$type,
                    $custom: 'custom',
                    value: {
                        message: atom.value.message,
                        customtype: 'customtype'
                    }
                };

                return o;
            });
        }

        function assertExpectedErrorPayload(e, expectedPath) {
            var path = e.path;
            var value = e.value;

            // To avoid hardcoding/scrubbing $size, and other internals
            expect(path).toEqual(expectedPath);

            expect(value.$type).toBe('error');
            expect(value.$custom).toBe('custom');
            expect(value.value).toEqual({
                message: 'errormsg',
                customtype: 'customtype'
            });
        }

        it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        });

        it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        });

        it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        });

    })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 130, 'column': 12, 'index': 4623}","describe('Error Selector (during set)', function() {

        function generateErrorSelectorSpy(expectedPath) {
            return jest.fn(function(path, atom) {
                expect(atom.$type).toBe('error');
                expect(atom.value.message).toBe('errormsg');

                var o = {
                    $type: atom.$type,
                    $custom: 'custom',
                    value: {
                        message: atom.value.message,
                        customtype: 'customtype'
                    }
                };

                return o;
            });
        }

        function assertExpectedErrorPayload(e, expectedPath) {
            var path = e.path;
            var value = e.value;

            // To avoid hardcoding/scrubbing $size, and other internals
            expect(path).toEqual(expectedPath);

            expect(value.$type).toBe('error');
            expect(value.$custom).toBe('custom');
            expect(value.value).toEqual({
                message: 'errormsg',
                customtype: 'customtype'
            });
        }

        it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        });

        it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        });

        it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        });

    })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 131, 'column': 12, 'index': 4654}","describe('Error Selector (during set)', function() {

        function generateErrorSelectorSpy(expectedPath) {
            return jest.fn(function(path, atom) {
                expect(atom.$type).toBe('error');
                expect(atom.value.message).toBe('errormsg');

                var o = {
                    $type: atom.$type,
                    $custom: 'custom',
                    value: {
                        message: atom.value.message,
                        customtype: 'customtype'
                    }
                };

                return o;
            });
        }

        function assertExpectedErrorPayload(e, expectedPath) {
            var path = e.path;
            var value = e.value;

            // To avoid hardcoding/scrubbing $size, and other internals
            expect(path).toEqual(expectedPath);

            expect(value.$type).toBe('error');
            expect(value.$custom).toBe('custom');
            expect(value.value).toEqual({
                message: 'errormsg',
                customtype: 'customtype'
            });
        }

        it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        });

        it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        });

        it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        });

    })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 146, 'column': 12, 'index': 5146}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 148, 'column': 12, 'index': 5208}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 150, 'column': 12, 'index': 5247}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 151, 'column': 12, 'index': 5286}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 152, 'column': 12, 'index': 5326}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 154, 'column': 12, 'index': 5398}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 184, 'column': 12, 'index': 6549}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 186, 'column': 12, 'index': 6612}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 188, 'column': 12, 'index': 6651}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 189, 'column': 12, 'index': 6690}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 190, 'column': 12, 'index': 6730}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 192, 'column': 12, 'index': 6802}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 226, 'column': 12, 'index': 8160}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 228, 'column': 12, 'index': 8222}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 230, 'column': 12, 'index': 8261}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 231, 'column': 12, 'index': 8300}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 233, 'column': 12, 'index': 8341}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Global Variable,"{'line': 236, 'column': 20, 'index': 8476}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Lazy Test,"{'line': 15, 'column': 23, 'index': 593}","it('should set a value from falcor.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 1)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['videos', 0, 'title'], value: 'V0'})).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'V0'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Lazy Test,"{'line': 18, 'column': 12, 'index': 678}","it('should set a value from falcor.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 1)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['videos', 0, 'title'], value: 'V0'})).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'V0'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Lazy Test,"{'line': 37, 'column': 23, 'index': 1441}","it('should correctly output with many different input types.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 3)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({
                    path: ['videos', 0, 'title'],
                    value: 'V0'
                }, {
                    jsonGraph: {
                        videos: {
                            1: {
                                title: 'V1'
                            }
                        }
                    },
                    paths: [['videos', 1, 'title']]
                }, {
                    json: {
                        videos: {
                            2: {
                                title: 'V2'
                            }
                        }
                    }
                })).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'V0'
                                },
                                1: {
                                    title: 'V1'
                                },
                                2: {
                                    title: 'V2'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Lazy Test,"{'line': 40, 'column': 12, 'index': 1526}","it('should correctly output with many different input types.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 3)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({
                    path: ['videos', 0, 'title'],
                    value: 'V0'
                }, {
                    jsonGraph: {
                        videos: {
                            1: {
                                title: 'V1'
                            }
                        }
                    },
                    paths: [['videos', 1, 'title']]
                }, {
                    json: {
                        videos: {
                            2: {
                                title: 'V2'
                            }
                        }
                    }
                })).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'V0'
                                },
                                1: {
                                    title: 'V1'
                                },
                                2: {
                                    title: 'V2'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Lazy Test,"{'line': 86, 'column': 23, 'index': 3141}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 1)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['videos', 0, 'title'], value: 'V0'}).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: 'V0'
                                }
                            }
                        },
                        paths: [['videos', 0, 'title']]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Lazy Test,"{'line': 89, 'column': 12, 'index': 3226}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                cache: cacheGenerator(0, 1)
            });
            var onNext = jest.fn();
            toObservable(model.
                set({path: ['videos', 0, 'title'], value: 'V0'}).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: 'V0'
                                }
                            }
                        },
                        paths: [['videos', 0, 'title']]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/set/set.cache-only.spec.js,Lazy Test,"{'line': 148, 'column': 29, 'index': 5225}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Lazy Test,"{'line': 159, 'column': 12, 'index': 5536}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Lazy Test,"{'line': 186, 'column': 29, 'index': 6629}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Lazy Test,"{'line': 197, 'column': 12, 'index': 6938}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Lazy Test,"{'line': 228, 'column': 29, 'index': 8239}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Lazy Test,"{'line': 249, 'column': 12, 'index': 8838}","it('should be allowed to change $type', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Magic Number,"{'line': 171, 'column': 46, 'index': 6080}","it('should get invoked with the right arguments for simple paths', function(done) {

            var testPath = ['genreList', 0, 0, 'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache : modelCache,
                errorSelector : errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/set/set.cache-only.spec.js,Magic Number,"{'line': 211, 'column': 46, 'index': 7607}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['genreList',[0,1],0,'errorPath'];

            var modelCache = Cache();

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                set({
                    path: testPath,
                    value: jsonGraph.error({message:'errormsg'})
                })).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['genreList',0,0,'errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['genreList',1,0,'errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['genreList',0,0,'errorPath']);
                        assertExpectedErrorPayload(e[1], ['genreList',1,0,'errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/schedulers/schedulers.spec.js,Duplicate Assert,"{'line': 30, 'column': 12, 'index': 987}","it(""should verify that longer timeouts happen after shorter timeouts."", function(done) {
        var trigger = true;
        timeout16.schedule(function() {
            expect(trigger).toBe(false);
            trigger = true;
        });
        timeout100.schedule(function() {
            expect(trigger).toBe(true);
            done();
        });
        trigger = false;
    })",steel
/test/falcor/schedulers/schedulers.spec.js,Duplicate Assert,"{'line': 34, 'column': 12, 'index': 1109}","it(""should verify that longer timeouts happen after shorter timeouts."", function(done) {
        var trigger = true;
        timeout16.schedule(function() {
            expect(trigger).toBe(false);
            trigger = true;
        });
        timeout100.schedule(function() {
            expect(trigger).toBe(true);
            done();
        });
        trigger = false;
    })",steel
/test/falcor/schedulers/schedulers.spec.js,Global Variable,"{'line': 5, 'column': 4, 'index': 201}","describe(""Schedulers"", function() {
    var nextTick = new TimeoutScheduler(0);
    var timeout16 = new TimeoutScheduler(16);
    var timeout100 = new TimeoutScheduler(100);
    var immediate = new ImmediateScheduler();

    it(""should do an immediate scheduler"", function() {
        var trigger = true;
        immediate.schedule(function() {
            expect(trigger).toBe(true);
        });
        trigger = false;
    });

    it(""should do a timeout"", function(done) {
        var trigger = true;
        timeout16.schedule(function() {
            expect(trigger).toBe(false);
            done();
        });
        trigger = false;
    });

    it(""should verify that longer timeouts happen after shorter timeouts."", function(done) {
        var trigger = true;
        timeout16.schedule(function() {
            expect(trigger).toBe(false);
            trigger = true;
        });
        timeout100.schedule(function() {
            expect(trigger).toBe(true);
            done();
        });
        trigger = false;
    });
})",steel
/test/falcor/schedulers/schedulers.spec.js,Global Variable,"{'line': 6, 'column': 4, 'index': 245}","describe(""Schedulers"", function() {
    var nextTick = new TimeoutScheduler(0);
    var timeout16 = new TimeoutScheduler(16);
    var timeout100 = new TimeoutScheduler(100);
    var immediate = new ImmediateScheduler();

    it(""should do an immediate scheduler"", function() {
        var trigger = true;
        immediate.schedule(function() {
            expect(trigger).toBe(true);
        });
        trigger = false;
    });

    it(""should do a timeout"", function(done) {
        var trigger = true;
        timeout16.schedule(function() {
            expect(trigger).toBe(false);
            done();
        });
        trigger = false;
    });

    it(""should verify that longer timeouts happen after shorter timeouts."", function(done) {
        var trigger = true;
        timeout16.schedule(function() {
            expect(trigger).toBe(false);
            trigger = true;
        });
        timeout100.schedule(function() {
            expect(trigger).toBe(true);
            done();
        });
        trigger = false;
    });
})",steel
/test/falcor/schedulers/schedulers.spec.js,Global Variable,"{'line': 7, 'column': 4, 'index': 291}","describe(""Schedulers"", function() {
    var nextTick = new TimeoutScheduler(0);
    var timeout16 = new TimeoutScheduler(16);
    var timeout100 = new TimeoutScheduler(100);
    var immediate = new ImmediateScheduler();

    it(""should do an immediate scheduler"", function() {
        var trigger = true;
        immediate.schedule(function() {
            expect(trigger).toBe(true);
        });
        trigger = false;
    });

    it(""should do a timeout"", function(done) {
        var trigger = true;
        timeout16.schedule(function() {
            expect(trigger).toBe(false);
            done();
        });
        trigger = false;
    });

    it(""should verify that longer timeouts happen after shorter timeouts."", function(done) {
        var trigger = true;
        timeout16.schedule(function() {
            expect(trigger).toBe(false);
            trigger = true;
        });
        timeout100.schedule(function() {
            expect(trigger).toBe(true);
            done();
        });
        trigger = false;
    });
})",steel
/test/falcor/schedulers/schedulers.spec.js,Global Variable,"{'line': 8, 'column': 4, 'index': 339}","describe(""Schedulers"", function() {
    var nextTick = new TimeoutScheduler(0);
    var timeout16 = new TimeoutScheduler(16);
    var timeout100 = new TimeoutScheduler(100);
    var immediate = new ImmediateScheduler();

    it(""should do an immediate scheduler"", function() {
        var trigger = true;
        immediate.schedule(function() {
            expect(trigger).toBe(true);
        });
        trigger = false;
    });

    it(""should do a timeout"", function(done) {
        var trigger = true;
        timeout16.schedule(function() {
            expect(trigger).toBe(false);
            done();
        });
        trigger = false;
    });

    it(""should verify that longer timeouts happen after shorter timeouts."", function(done) {
        var trigger = true;
        timeout16.schedule(function() {
            expect(trigger).toBe(false);
            trigger = true;
        });
        timeout100.schedule(function() {
            expect(trigger).toBe(true);
            done();
        });
        trigger = false;
    });
})",steel
/test/falcor/schedulers/schedulers.spec.js,Global Variable,"{'line': 11, 'column': 8, 'index': 446}","it(""should do an immediate scheduler"", function() {
        var trigger = true;
        immediate.schedule(function() {
            expect(trigger).toBe(true);
        });
        trigger = false;
    })",steel
/test/falcor/schedulers/schedulers.spec.js,Global Variable,"{'line': 19, 'column': 8, 'index': 647}","it(""should do a timeout"", function(done) {
        var trigger = true;
        timeout16.schedule(function() {
            expect(trigger).toBe(false);
            done();
        });
        trigger = false;
    })",steel
/test/falcor/schedulers/schedulers.spec.js,Global Variable,"{'line': 28, 'column': 8, 'index': 915}","it(""should verify that longer timeouts happen after shorter timeouts."", function(done) {
        var trigger = true;
        timeout16.schedule(function() {
            expect(trigger).toBe(false);
            trigger = true;
        });
        timeout100.schedule(function() {
            expect(trigger).toBe(true);
            done();
        });
        trigger = false;
    })",steel
/test/falcor/invalidate/invalidate.change-handler.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/invalidate/invalidate.change-handler.spec.js,Global Variable,"{'line': 7, 'column': 8, 'index': 185}","it(""is called when we invalidate a path"", function () {

        var changed = false;
        var model = new Model({
            cache: { a: { b: { c: ""foo"" } } },
            onChange: function () {
                changed = true;
            }
        });

        model.invalidate([""a"", ""b"", ""c""]);

        expect(changed).toBe(true);
    })",steel
/test/falcor/invalidate/invalidate.change-handler.spec.js,Global Variable,"{'line': 8, 'column': 8, 'index': 214}","it(""is called when we invalidate a path"", function () {

        var changed = false;
        var model = new Model({
            cache: { a: { b: { c: ""foo"" } } },
            onChange: function () {
                changed = true;
            }
        });

        model.invalidate([""a"", ""b"", ""c""]);

        expect(changed).toBe(true);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Eager Test,"{'line': 17, 'column': 19, 'index': 628}","it(""should invalidate a leaf value."", function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1, ['title', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0, ""title""]);

        toObservable(model.
            get([""videos"", 0, ""title""])).
            concat(model.get([""videos"", 0, ""art""])).
            doAction(onNext, noOp, function() {
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Eager Test,"{'line': 23, 'column': 8, 'index': 783}","it(""should invalidate a leaf value."", function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1, ['title', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0, ""title""]);

        toObservable(model.
            get([""videos"", 0, ""title""])).
            concat(model.get([""videos"", 0, ""art""])).
            doAction(onNext, noOp, function() {
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Eager Test,"{'line': 137, 'column': 45, 'index': 4535}","it(""should invalidate a branch value."", function(done) {
        var dataSourceCount = 0;
        var summary = [""videos"", 0, ""summary""];
        var art = [""videos"", 0, ""art""];
        var onGet = jest.fn();
        var dataSource = new LocalDataSource(cacheGenerator(0, 1, ['summary', 'art']), {
            onGet: onGet
        });
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art']),
            source: dataSource
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get(art.slice())).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([art]);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Eager Test,"{'line': 141, 'column': 19, 'index': 4667}","it(""should invalidate a branch value."", function(done) {
        var dataSourceCount = 0;
        var summary = [""videos"", 0, ""summary""];
        var art = [""videos"", 0, ""art""];
        var onGet = jest.fn();
        var dataSource = new LocalDataSource(cacheGenerator(0, 1, ['summary', 'art']), {
            onGet: onGet
        });
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art']),
            source: dataSource
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get(art.slice())).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([art]);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Eager Test,"{'line': 148, 'column': 8, 'index': 4847}","it(""should invalidate a branch value."", function(done) {
        var dataSourceCount = 0;
        var summary = [""videos"", 0, ""summary""];
        var art = [""videos"", 0, ""art""];
        var onGet = jest.fn();
        var dataSource = new LocalDataSource(cacheGenerator(0, 1, ['summary', 'art']), {
            onGet: onGet
        });
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art']),
            source: dataSource
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get(art.slice())).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([art]);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Eager Test,"{'line': 174, 'column': 19, 'index': 5824}","it(""should invalidate a reference but not through the reference."", function(done) {
        var summary = [""genreList"", 0, 0, ""summary""];
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""lolomo"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get([""lists"", ""A"", 0, ""item"", ""summary""])).
            doAction(onNext, noOp, function() {
                 expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        lists: {
                            A: {
                                0: {
                                    item: {
                                        summary: 'Video 0'
                                    }
                                }
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Eager Test,"{'line': 180, 'column': 8, 'index': 5972}","it(""should invalidate a reference but not through the reference."", function(done) {
        var summary = [""genreList"", 0, 0, ""summary""];
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""lolomo"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get([""lists"", ""A"", 0, ""item"", ""summary""])).
            doAction(onNext, noOp, function() {
                 expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        lists: {
                            A: {
                                0: {
                                    item: {
                                        summary: 'Video 0'
                                    }
                                }
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 6, 'column': 0, 'index': 191}",Unknown,steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 11, 'column': 0, 'index': 429}",Unknown,steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 12, 'column': 0, 'index': 454}",Unknown,steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 16, 'column': 8, 'index': 585}","it(""should invalidate a leaf value."", function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1, ['title', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0, ""title""]);

        toObservable(model.
            get([""videos"", 0, ""title""])).
            concat(model.get([""videos"", 0, ""art""])).
            doAction(onNext, noOp, function() {
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 19, 'column': 8, 'index': 687}","it(""should invalidate a leaf value."", function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1, ['title', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0, ""title""]);

        toObservable(model.
            get([""videos"", 0, ""title""])).
            concat(model.get([""videos"", 0, ""art""])).
            doAction(onNext, noOp, function() {
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 41, 'column': 8, 'index': 1404}","it(""should re-fetch an invalidated value progressively."", function(done) {
        var onGet = jest.fn();
        var onNext = jest.fn();
        var model = new Model({
            cache: {
                lolomo: {
                    0: ref(['lists', 123])
                }
            },
            source: new LocalDataSource({
                    lolomo: {
                        0: ref(['lists', 123])
                    },
                    lists: {
                        123: {
                            title: atom('List title')
                        }
                    }
                }, {wait: 100, onGet: onGet})
        });

        toObservable(model.
            get([""lolomo"", 0, ""title""]).progressively()).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(2);
                expect(onNext).toHaveBeenCalledTimes(3);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        lolomo: {}
                    }
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        lolomo: {}
                    }
                });
                expect(strip(onNext.mock.calls[2][0])).toEqual({
                    json: {
                        lolomo: {
                            0: {
                                title: 'List title'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);

        model.invalidate(['lolomo', 0]);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 42, 'column': 8, 'index': 1435}","it(""should re-fetch an invalidated value progressively."", function(done) {
        var onGet = jest.fn();
        var onNext = jest.fn();
        var model = new Model({
            cache: {
                lolomo: {
                    0: ref(['lists', 123])
                }
            },
            source: new LocalDataSource({
                    lolomo: {
                        0: ref(['lists', 123])
                    },
                    lists: {
                        123: {
                            title: atom('List title')
                        }
                    }
                }, {wait: 100, onGet: onGet})
        });

        toObservable(model.
            get([""lolomo"", 0, ""title""]).progressively()).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(2);
                expect(onNext).toHaveBeenCalledTimes(3);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        lolomo: {}
                    }
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        lolomo: {}
                    }
                });
                expect(strip(onNext.mock.calls[2][0])).toEqual({
                    json: {
                        lolomo: {
                            0: {
                                title: 'List title'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);

        model.invalidate(['lolomo', 0]);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 43, 'column': 8, 'index': 1467}","it(""should re-fetch an invalidated value progressively."", function(done) {
        var onGet = jest.fn();
        var onNext = jest.fn();
        var model = new Model({
            cache: {
                lolomo: {
                    0: ref(['lists', 123])
                }
            },
            source: new LocalDataSource({
                    lolomo: {
                        0: ref(['lists', 123])
                    },
                    lists: {
                        123: {
                            title: atom('List title')
                        }
                    }
                }, {wait: 100, onGet: onGet})
        });

        toObservable(model.
            get([""lolomo"", 0, ""title""]).progressively()).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(2);
                expect(onNext).toHaveBeenCalledTimes(3);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        lolomo: {}
                    }
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        lolomo: {}
                    }
                });
                expect(strip(onNext.mock.calls[2][0])).toEqual({
                    json: {
                        lolomo: {
                            0: {
                                title: 'List title'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);

        model.invalidate(['lolomo', 0]);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 92, 'column': 8, 'index': 3055}","it(""should re-fetch an invalidated value."", function(done) {
        var onGet = jest.fn();
        var onNext = jest.fn();
        var model = new Model({
            cache: {
                lolomo: {
                    0: ref(['lists', 123])
                }
            },
            source: new LocalDataSource({
                    lolomo: {
                        0: ref(['lists', 123])
                    },
                    lists: {
                        123: {
                            title: atom('List title')
                        }
                    }
                }, {wait: 100, onGet: onGet})
        });

        toObservable(model.
            get([""lolomo"", 0, ""title""])).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(2);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        lolomo: {
                            0: {
                                title: 'List title'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);

        model.invalidate(['lolomo', 0]);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 93, 'column': 8, 'index': 3086}","it(""should re-fetch an invalidated value."", function(done) {
        var onGet = jest.fn();
        var onNext = jest.fn();
        var model = new Model({
            cache: {
                lolomo: {
                    0: ref(['lists', 123])
                }
            },
            source: new LocalDataSource({
                    lolomo: {
                        0: ref(['lists', 123])
                    },
                    lists: {
                        123: {
                            title: atom('List title')
                        }
                    }
                }, {wait: 100, onGet: onGet})
        });

        toObservable(model.
            get([""lolomo"", 0, ""title""])).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(2);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        lolomo: {
                            0: {
                                title: 'List title'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);

        model.invalidate(['lolomo', 0]);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 94, 'column': 8, 'index': 3118}","it(""should re-fetch an invalidated value."", function(done) {
        var onGet = jest.fn();
        var onNext = jest.fn();
        var model = new Model({
            cache: {
                lolomo: {
                    0: ref(['lists', 123])
                }
            },
            source: new LocalDataSource({
                    lolomo: {
                        0: ref(['lists', 123])
                    },
                    lists: {
                        123: {
                            title: atom('List title')
                        }
                    }
                }, {wait: 100, onGet: onGet})
        });

        toObservable(model.
            get([""lolomo"", 0, ""title""])).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(2);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        lolomo: {
                            0: {
                                title: 'List title'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);

        model.invalidate(['lolomo', 0]);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 133, 'column': 8, 'index': 4346}","it(""should invalidate a branch value."", function(done) {
        var dataSourceCount = 0;
        var summary = [""videos"", 0, ""summary""];
        var art = [""videos"", 0, ""art""];
        var onGet = jest.fn();
        var dataSource = new LocalDataSource(cacheGenerator(0, 1, ['summary', 'art']), {
            onGet: onGet
        });
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art']),
            source: dataSource
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get(art.slice())).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([art]);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 134, 'column': 8, 'index': 4379}","it(""should invalidate a branch value."", function(done) {
        var dataSourceCount = 0;
        var summary = [""videos"", 0, ""summary""];
        var art = [""videos"", 0, ""art""];
        var onGet = jest.fn();
        var dataSource = new LocalDataSource(cacheGenerator(0, 1, ['summary', 'art']), {
            onGet: onGet
        });
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art']),
            source: dataSource
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get(art.slice())).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([art]);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 135, 'column': 8, 'index': 4427}","it(""should invalidate a branch value."", function(done) {
        var dataSourceCount = 0;
        var summary = [""videos"", 0, ""summary""];
        var art = [""videos"", 0, ""art""];
        var onGet = jest.fn();
        var dataSource = new LocalDataSource(cacheGenerator(0, 1, ['summary', 'art']), {
            onGet: onGet
        });
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art']),
            source: dataSource
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get(art.slice())).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([art]);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 136, 'column': 8, 'index': 4467}","it(""should invalidate a branch value."", function(done) {
        var dataSourceCount = 0;
        var summary = [""videos"", 0, ""summary""];
        var art = [""videos"", 0, ""art""];
        var onGet = jest.fn();
        var dataSource = new LocalDataSource(cacheGenerator(0, 1, ['summary', 'art']), {
            onGet: onGet
        });
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art']),
            source: dataSource
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get(art.slice())).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([art]);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 137, 'column': 8, 'index': 4498}","it(""should invalidate a branch value."", function(done) {
        var dataSourceCount = 0;
        var summary = [""videos"", 0, ""summary""];
        var art = [""videos"", 0, ""art""];
        var onGet = jest.fn();
        var dataSource = new LocalDataSource(cacheGenerator(0, 1, ['summary', 'art']), {
            onGet: onGet
        });
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art']),
            source: dataSource
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get(art.slice())).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([art]);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 140, 'column': 8, 'index': 4624}","it(""should invalidate a branch value."", function(done) {
        var dataSourceCount = 0;
        var summary = [""videos"", 0, ""summary""];
        var art = [""videos"", 0, ""art""];
        var onGet = jest.fn();
        var dataSource = new LocalDataSource(cacheGenerator(0, 1, ['summary', 'art']), {
            onGet: onGet
        });
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art']),
            source: dataSource
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get(art.slice())).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([art]);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 144, 'column': 8, 'index': 4760}","it(""should invalidate a branch value."", function(done) {
        var dataSourceCount = 0;
        var summary = [""videos"", 0, ""summary""];
        var art = [""videos"", 0, ""art""];
        var onGet = jest.fn();
        var dataSource = new LocalDataSource(cacheGenerator(0, 1, ['summary', 'art']), {
            onGet: onGet
        });
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art']),
            source: dataSource
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get(art.slice())).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([art]);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 172, 'column': 8, 'index': 5727}","it(""should invalidate a reference but not through the reference."", function(done) {
        var summary = [""genreList"", 0, 0, ""summary""];
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""lolomo"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get([""lists"", ""A"", 0, ""item"", ""summary""])).
            doAction(onNext, noOp, function() {
                 expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        lists: {
                            A: {
                                0: {
                                    item: {
                                        summary: 'Video 0'
                                    }
                                }
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 173, 'column': 8, 'index': 5781}","it(""should invalidate a reference but not through the reference."", function(done) {
        var summary = [""genreList"", 0, 0, ""summary""];
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""lolomo"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get([""lists"", ""A"", 0, ""item"", ""summary""])).
            doAction(onNext, noOp, function() {
                 expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        lists: {
                            A: {
                                0: {
                                    item: {
                                        summary: 'Video 0'
                                    }
                                }
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Global Variable,"{'line': 176, 'column': 8, 'index': 5885}","it(""should invalidate a reference but not through the reference."", function(done) {
        var summary = [""genreList"", 0, 0, ""summary""];
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""lolomo"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get([""lists"", ""A"", 0, ""item"", ""summary""])).
            doAction(onNext, noOp, function() {
                 expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        lists: {
                            A: {
                                0: {
                                    item: {
                                        summary: 'Video 0'
                                    }
                                }
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Lazy Test,"{'line': 17, 'column': 19, 'index': 628}","it(""should invalidate a leaf value."", function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1, ['title', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0, ""title""]);

        toObservable(model.
            get([""videos"", 0, ""title""])).
            concat(model.get([""videos"", 0, ""art""])).
            doAction(onNext, noOp, function() {
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Lazy Test,"{'line': 23, 'column': 8, 'index': 783}","it(""should invalidate a leaf value."", function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1, ['title', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0, ""title""]);

        toObservable(model.
            get([""videos"", 0, ""title""])).
            concat(model.get([""videos"", 0, ""art""])).
            doAction(onNext, noOp, function() {
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Lazy Test,"{'line': 61, 'column': 8, 'index': 1985}","it(""should re-fetch an invalidated value progressively."", function(done) {
        var onGet = jest.fn();
        var onNext = jest.fn();
        var model = new Model({
            cache: {
                lolomo: {
                    0: ref(['lists', 123])
                }
            },
            source: new LocalDataSource({
                    lolomo: {
                        0: ref(['lists', 123])
                    },
                    lists: {
                        123: {
                            title: atom('List title')
                        }
                    }
                }, {wait: 100, onGet: onGet})
        });

        toObservable(model.
            get([""lolomo"", 0, ""title""]).progressively()).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(2);
                expect(onNext).toHaveBeenCalledTimes(3);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        lolomo: {}
                    }
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        lolomo: {}
                    }
                });
                expect(strip(onNext.mock.calls[2][0])).toEqual({
                    json: {
                        lolomo: {
                            0: {
                                title: 'List title'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);

        model.invalidate(['lolomo', 0]);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Lazy Test,"{'line': 112, 'column': 8, 'index': 3636}","it(""should re-fetch an invalidated value."", function(done) {
        var onGet = jest.fn();
        var onNext = jest.fn();
        var model = new Model({
            cache: {
                lolomo: {
                    0: ref(['lists', 123])
                }
            },
            source: new LocalDataSource({
                    lolomo: {
                        0: ref(['lists', 123])
                    },
                    lists: {
                        123: {
                            title: atom('List title')
                        }
                    }
                }, {wait: 100, onGet: onGet})
        });

        toObservable(model.
            get([""lolomo"", 0, ""title""])).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(2);
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        lolomo: {
                            0: {
                                title: 'List title'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);

        model.invalidate(['lolomo', 0]);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Lazy Test,"{'line': 137, 'column': 45, 'index': 4535}","it(""should invalidate a branch value."", function(done) {
        var dataSourceCount = 0;
        var summary = [""videos"", 0, ""summary""];
        var art = [""videos"", 0, ""art""];
        var onGet = jest.fn();
        var dataSource = new LocalDataSource(cacheGenerator(0, 1, ['summary', 'art']), {
            onGet: onGet
        });
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art']),
            source: dataSource
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get(art.slice())).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([art]);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Lazy Test,"{'line': 148, 'column': 8, 'index': 4847}","it(""should invalidate a branch value."", function(done) {
        var dataSourceCount = 0;
        var summary = [""videos"", 0, ""summary""];
        var art = [""videos"", 0, ""art""];
        var onGet = jest.fn();
        var dataSource = new LocalDataSource(cacheGenerator(0, 1, ['summary', 'art']), {
            onGet: onGet
        });
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art']),
            source: dataSource
        });
        var onNext = jest.fn();
        model.
            invalidate([""videos"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get(art.slice())).
            doAction(onNext, noOp, function() {
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onGet.mock.calls[0][1]).toEqual([art]);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                art: 'Video 0'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Lazy Test,"{'line': 174, 'column': 19, 'index': 5824}","it(""should invalidate a reference but not through the reference."", function(done) {
        var summary = [""genreList"", 0, 0, ""summary""];
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""lolomo"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get([""lists"", ""A"", 0, ""item"", ""summary""])).
            doAction(onNext, noOp, function() {
                 expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        lists: {
                            A: {
                                0: {
                                    item: {
                                        summary: 'Video 0'
                                    }
                                }
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/invalidate/invalidate.cache-only.spec.js,Lazy Test,"{'line': 180, 'column': 8, 'index': 5972}","it(""should invalidate a reference but not through the reference."", function(done) {
        var summary = [""genreList"", 0, 0, ""summary""];
        var model = new Model({
            cache: cacheGenerator(0, 1, ['summary', 'art'])
        });
        var onNext = jest.fn();
        model.
            invalidate([""lolomo"", 0]);

        toObservable(model.
            withoutDataSource().
            get(summary.slice())).
            concat(model.get([""lists"", ""A"", 0, ""item"", ""summary""])).
            doAction(onNext, noOp, function() {
                 expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {}
                });
                expect(strip(onNext.mock.calls[1][0])).toEqual({
                    json: {
                        lists: {
                            A: {
                                0: {
                                    item: {
                                        summary: 'Video 0'
                                    }
                                }
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.pathSyntax.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/get/get.pathSyntax.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 91}",Unknown,steel
/test/falcor/get/get.pathSyntax.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 117}",Unknown,steel
/test/falcor/get/get.pathSyntax.spec.js,Global Variable,"{'line': 11, 'column': 4, 'index': 359}","describe('Path Syntax', function() {
    var model;
    beforeEach(function() {
        model = new Model({cache: CacheGenerator(0, 2)});
        model._root.unsafeMode = true;
    });

    it('should accept strings for get.', function(done) {
        var onNext = jest.fn();
        toObservable(model.get('lolomo[0][0].item.title', 'lolomo[0][1].item.title')).
            doAction(onNext, noOp, function() {
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        lolomo: {
                            0: {
                                0: {
                                    item: { title: 'Video 0' }
                                },
                                1: {
                                    item: { title: 'Video 1' }
                                }
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    });
    it('should accept strings for getValue', function(done) {
        var onNext = jest.fn();
        toObservable(model.getValue('videos[0].title')).
            doAction(onNext, noOp, function() {
                expect(onNext.mock.calls[0][0]).toEqual('Video 0');
            }).
            subscribe(noOp, done, done);
    });
})",steel
/test/falcor/get/get.pathSyntax.spec.js,Global Variable,"{'line': 18, 'column': 8, 'index': 570}","it('should accept strings for get.', function(done) {
        var onNext = jest.fn();
        toObservable(model.get('lolomo[0][0].item.title', 'lolomo[0][1].item.title')).
            doAction(onNext, noOp, function() {
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        lolomo: {
                            0: {
                                0: {
                                    item: { title: 'Video 0' }
                                },
                                1: {
                                    item: { title: 'Video 1' }
                                }
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.pathSyntax.spec.js,Global Variable,"{'line': 39, 'column': 8, 'index': 1391}","it('should accept strings for getValue', function(done) {
        var onNext = jest.fn();
        toObservable(model.getValue('videos[0].title')).
            doAction(onNext, noOp, function() {
                expect(onNext.mock.calls[0][0]).toEqual('Video 0');
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.pathSyntax.spec.js,Lazy Test,"{'line': 19, 'column': 8, 'index': 602}","it('should accept strings for get.', function(done) {
        var onNext = jest.fn();
        toObservable(model.get('lolomo[0][0].item.title', 'lolomo[0][1].item.title')).
            doAction(onNext, noOp, function() {
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        lolomo: {
                            0: {
                                0: {
                                    item: { title: 'Video 0' }
                                },
                                1: {
                                    item: { title: 'Video 1' }
                                }
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.pathSyntax.spec.js,Lazy Test,"{'line': 40, 'column': 8, 'index': 1423}","it('should accept strings for getValue', function(done) {
        var onNext = jest.fn();
        toObservable(model.getValue('videos[0].title')).
            doAction(onNext, noOp, function() {
                expect(onNext.mock.calls[0][0]).toEqual('Video 0');
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.model.adapter.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/get/get.model.adapter.spec.js,Global Variable,"{'line': 3, 'column': 0, 'index': 67}",Unknown,steel
/test/falcor/get/get.model.adapter.spec.js,Global Variable,"{'line': 8, 'column': 8, 'index': 264}","it('ensure atoms remain as strings if model created.', function(done) {
        var model = new Model({
            cache: {
                hello: 'world'
            }
        });

        var onNext = jest.fn();
        toObs(model.
            asDataSource().
            get([['hello']])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(onNext.mock.calls[0][0]).toEqual({
                    jsonGraph: {
                        hello: 'world'
                    },
                    paths: [['hello']]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.model.adapter.spec.js,Global Variable,"{'line': 14, 'column': 8, 'index': 375}","it('ensure atoms remain as strings if model created.', function(done) {
        var model = new Model({
            cache: {
                hello: 'world'
            }
        });

        var onNext = jest.fn();
        toObs(model.
            asDataSource().
            get([['hello']])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(onNext.mock.calls[0][0]).toEqual({
                    jsonGraph: {
                        hello: 'world'
                    },
                    paths: [['hello']]
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.gen.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/get/get.gen.spec.js,Global Variable,"{'line': 6, 'column': 8, 'index': 160}","it('should get a version', function() {
        var model = new Model({cache: {hello: 'world'}});
        model._root.unsafeMode = true;
        var version = model.getVersion('hello');
        expect(version >= 0).toBe(true);
    })",steel
/test/falcor/get/get.gen.spec.js,Global Variable,"{'line': 8, 'column': 8, 'index': 257}","it('should get a version', function() {
        var model = new Model({cache: {hello: 'world'}});
        model._root.unsafeMode = true;
        var version = model.getVersion('hello');
        expect(version >= 0).toBe(true);
    })",steel
/test/falcor/get/get.gen.spec.js,Global Variable,"{'line': 12, 'column': 8, 'index': 417}","it('should get a version on the root model', function() {
        var model = new Model({cache: {hello: 'world'}, unsafeMode: true});
        var version = model.getVersion();
        expect(version >= 0).toBe(true);
    })",steel
/test/falcor/get/get.gen.spec.js,Global Variable,"{'line': 13, 'column': 8, 'index': 493}","it('should get a version on the root model', function() {
        var model = new Model({cache: {hello: 'world'}, unsafeMode: true});
        var version = model.getVersion();
        expect(version >= 0).toBe(true);
    })",steel
/test/falcor/get/get.gen.spec.js,Global Variable,"{'line': 17, 'column': 8, 'index': 640}","it('should get -1 if no path exists.', function() {
        var model = new Model({cache: {hello: 'world'}});
        model._root.unsafeMode = true;
        var version = model.getVersion('world');
        expect(version === -1).toBe(true);
    })",steel
/test/falcor/get/get.gen.spec.js,Global Variable,"{'line': 19, 'column': 8, 'index': 737}","it('should get -1 if no path exists.', function() {
        var model = new Model({cache: {hello: 'world'}});
        model._root.unsafeMode = true;
        var version = model.getVersion('world');
        expect(version === -1).toBe(true);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Conditional Test Logic,"{'line': 48, 'column': 16, 'index': 2066}","it(""should perform multiple trips to a dataSource."", done => {
            const get = jest.fn((source, paths) => {
                if (paths.length === 0) {
                    paths.pop();
                }
            });
            const model = new Model({
                source: new LocalDataSource(cacheGenerator(0, 2, [""title"", ""art""]), { onGet: get })

            });
            const onNext = jest.fn();
            const secondOnNext = jest.fn();
            toObservable(model.
                preload([""videos"", 0, ""title""],
                    [""videos"", 1, ""art""])).
                doAction(onNext).
                doAction(noOp, noOp, () => {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(() => {
                    return model.get([""videos"", 0, ""title""]);
                }).
                doAction(secondOnNext).
                doAction(noOp, noOp, () => {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: { videos: { 0: { title: ""Video 0"" } } }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-only.spec.js,Conditional Test Logic,"{'line': 160, 'column': 16, 'index': 6367}","it(""should report errors from a dataSource with _treatDataSourceErrorsAsJSONGraphErrors."", done => {
        const model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new ErrorDataSource(500, ""Oops!"")
        });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, err => {
                expect(err).toEqual([{
                    path: [""videos"", 0, ""title""],
                    value: {
                        message: ""Oops!"",
                        status: 500
                    }
                }]);
            }, () => {
                throw new Error(""On Completed was called. "" +
                    ""OnError should have been called."");
            }).
            subscribe(noOp, err => {
                // ensure its the same error
                if (Array.isArray(err) && isPathValue(err[0])) {
                    return done();
                }
                return done(err);
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Conditional Test Logic,"{'line': 187, 'column': 16, 'index': 7294}","it(""should report errors from a dataSource."", done => {
        let outputError = null;
        const model = new Model({
            source: new ErrorDataSource(500, ""Oops!"")
        });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, err => {
                outputError = err;
                expect(err).toEqual({
                    $type: ""error"",
                    value: {
                        message: ""Oops!"",
                        status: 500
                    }
                });
            }, () => {
                throw new Error(""On Completed was called. "" +
                    ""OnError should have been called."");
            }).
            subscribe(noOp, err => {
                if (err === outputError) {
                    return done();
                }
                else {
                    return done(err);
                }
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Conditional Test Logic,"{'line': 409, 'column': 16, 'index': 14737}","it(""should onError a MaxRetryExceededError when data source is sync."", done => {
        const model = new Model({ source: new LocalDataSource({}) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Conditional Test Logic,"{'line': 424, 'column': 16, 'index': 15371}","it(""should onError a MaxRetryExceededError when data source is async."", done => {
        const model = new Model({ source: asyncifyDataSource(new LocalDataSource({})) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Conditional Test Logic,"{'line': 458, 'column': 16, 'index': 16575}","it(""should return missing optimized paths with MaxRetryExceededError"", done => {
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({})),
            cache: {
                lolomo: {
                    0: {
                        $type: ""ref"",
                        value: [""videos"", 1]
                    }
                },
                videos: {
                    0: {
                        title: ""Revolutionary Road""
                    }
                }
            }
        });
        toObservable(model.
            get([""lolomo"", 0, ""title""], ""videos[0].title"", ""hall[0].ween"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
                expect(e.missingOptimizedPaths).toEqual([
                    [""videos"", 1, ""title""],
                    [""hall"", 0, ""ween""]
                ]);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Conditional Test Logic,"{'line': 480, 'column': 16, 'index': 17367}","it(""should throw MaxRetryExceededError after retrying said times"", done => {
        const onGet = jest.fn();
        const model = new Model({
            maxRetries: 5,
            source: asyncifyDataSource(new LocalDataSource({}, {
                onGet
            }))
        });
        toObservable(model.
            get(""some.path"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected"").toBe(true);
                expect(onGet).toHaveBeenCalledTimes(5);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) { return done(e); }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Duplicate Assert,"{'line': 498, 'column': 16, 'index': 18031}","it(""passes the attempt count to the DataSource"", () => {
        const onGet = jest.fn();
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({}, { onGet }))
        });
        const path = [""some"", ""path""];

        return model.
            get(path).
            then(() => {
                throw new Error(""should have rejected with MaxRetryExceededError"");
            }, e => {
                expect(e).toBeInstanceOf(MaxRetryExceededError);
                expect(onGet).toHaveBeenCalledTimes(3);
                expect(onGet).toHaveBeenNthCalledWith(1, expect.anything(), [path], 1);
                expect(onGet).toHaveBeenNthCalledWith(2, expect.anything(), [path], 2);
                expect(onGet).toHaveBeenNthCalledWith(3, expect.anything(), [path], 3);
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Duplicate Assert,"{'line': 499, 'column': 16, 'index': 18087}","it(""passes the attempt count to the DataSource"", () => {
        const onGet = jest.fn();
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({}, { onGet }))
        });
        const path = [""some"", ""path""];

        return model.
            get(path).
            then(() => {
                throw new Error(""should have rejected with MaxRetryExceededError"");
            }, e => {
                expect(e).toBeInstanceOf(MaxRetryExceededError);
                expect(onGet).toHaveBeenCalledTimes(3);
                expect(onGet).toHaveBeenNthCalledWith(1, expect.anything(), [path], 1);
                expect(onGet).toHaveBeenNthCalledWith(2, expect.anything(), [path], 2);
                expect(onGet).toHaveBeenNthCalledWith(3, expect.anything(), [path], 3);
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Duplicate Assert,"{'line': 500, 'column': 16, 'index': 18175}","it(""passes the attempt count to the DataSource"", () => {
        const onGet = jest.fn();
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({}, { onGet }))
        });
        const path = [""some"", ""path""];

        return model.
            get(path).
            then(() => {
                throw new Error(""should have rejected with MaxRetryExceededError"");
            }, e => {
                expect(e).toBeInstanceOf(MaxRetryExceededError);
                expect(onGet).toHaveBeenCalledTimes(3);
                expect(onGet).toHaveBeenNthCalledWith(1, expect.anything(), [path], 1);
                expect(onGet).toHaveBeenNthCalledWith(2, expect.anything(), [path], 2);
                expect(onGet).toHaveBeenNthCalledWith(3, expect.anything(), [path], 3);
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Duplicate Assert,"{'line': 501, 'column': 16, 'index': 18263}","it(""passes the attempt count to the DataSource"", () => {
        const onGet = jest.fn();
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({}, { onGet }))
        });
        const path = [""some"", ""path""];

        return model.
            get(path).
            then(() => {
                throw new Error(""should have rejected with MaxRetryExceededError"");
            }, e => {
                expect(e).toBeInstanceOf(MaxRetryExceededError);
                expect(onGet).toHaveBeenCalledTimes(3);
                expect(onGet).toHaveBeenNthCalledWith(1, expect.anything(), [path], 1);
                expect(onGet).toHaveBeenNthCalledWith(2, expect.anything(), [path], 2);
                expect(onGet).toHaveBeenNthCalledWith(3, expect.anything(), [path], 3);
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 53, 'column': 44, 'index': 2241}","it(""should perform multiple trips to a dataSource."", done => {
            const get = jest.fn((source, paths) => {
                if (paths.length === 0) {
                    paths.pop();
                }
            });
            const model = new Model({
                source: new LocalDataSource(cacheGenerator(0, 2, [""title"", ""art""]), { onGet: get })

            });
            const onNext = jest.fn();
            const secondOnNext = jest.fn();
            toObservable(model.
                preload([""videos"", 0, ""title""],
                    [""videos"", 1, ""art""])).
                doAction(onNext).
                doAction(noOp, noOp, () => {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(() => {
                    return model.get([""videos"", 0, ""title""]);
                }).
                doAction(secondOnNext).
                doAction(noOp, noOp, () => {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: { videos: { 0: { title: ""Video 0"" } } }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 58, 'column': 12, 'index': 2408}","it(""should perform multiple trips to a dataSource."", done => {
            const get = jest.fn((source, paths) => {
                if (paths.length === 0) {
                    paths.pop();
                }
            });
            const model = new Model({
                source: new LocalDataSource(cacheGenerator(0, 2, [""title"", ""art""]), { onGet: get })

            });
            const onNext = jest.fn();
            const secondOnNext = jest.fn();
            toObservable(model.
                preload([""videos"", 0, ""title""],
                    [""videos"", 1, ""art""])).
                doAction(onNext).
                doAction(noOp, noOp, () => {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(() => {
                    return model.get([""videos"", 0, ""title""]);
                }).
                doAction(secondOnNext).
                doAction(noOp, noOp, () => {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: { videos: { 0: { title: ""Video 0"" } } }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 144, 'column': 8, 'index': 5774}","it(""should report errors from a dataSource with _treatDataSourceErrorsAsJSONGraphErrors."", done => {
        const model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new ErrorDataSource(500, ""Oops!"")
        });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, err => {
                expect(err).toEqual([{
                    path: [""videos"", 0, ""title""],
                    value: {
                        message: ""Oops!"",
                        status: 500
                    }
                }]);
            }, () => {
                throw new Error(""On Completed was called. "" +
                    ""OnError should have been called."");
            }).
            subscribe(noOp, err => {
                // ensure its the same error
                if (Array.isArray(err) && isPathValue(err[0])) {
                    return done();
                }
                return done(err);
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 160, 'column': 42, 'index': 6393}","it(""should report errors from a dataSource with _treatDataSourceErrorsAsJSONGraphErrors."", done => {
        const model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new ErrorDataSource(500, ""Oops!"")
        });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, err => {
                expect(err).toEqual([{
                    path: [""videos"", 0, ""title""],
                    value: {
                        message: ""Oops!"",
                        status: 500
                    }
                }]);
            }, () => {
                throw new Error(""On Completed was called. "" +
                    ""OnError should have been called."");
            }).
            subscribe(noOp, err => {
                // ensure its the same error
                if (Array.isArray(err) && isPathValue(err[0])) {
                    return done();
                }
                return done(err);
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 253, 'column': 43, 'index': 9452}","it(""should be able to dispose of getRequests."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);


        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).not.toHaveBeenCalled();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 258, 'column': 27, 'index': 9620}","it(""should be able to dispose of getRequests."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);


        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).not.toHaveBeenCalled();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 280, 'column': 43, 'index': 10300}","it(""should ignore response-stuffed paths."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100
        });
        const model = new Model({ source }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0]).toBeUndefined();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 286, 'column': 28, 'index': 10493}","it(""should ignore response-stuffed paths."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100
        });
        const model = new Model({ source }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0]).toBeUndefined();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 293, 'column': 8, 'index': 10737}","it(""should ignore response-stuffed paths."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100
        });
        const model = new Model({ source }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0]).toBeUndefined();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 313, 'column': 43, 'index': 11315}","it(""should honor response-stuffed paths with _useServerPaths == true."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100,
            onResults(data) {
                data.paths = [
                    [""videos"", 0, ""title""],
                    [""videos"", 1, ""title""]
                ];
            }
        });
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0].$_absolutePath).toEqual([""videos"", 0]);
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 325, 'column': 28, 'index': 11713}","it(""should honor response-stuffed paths with _useServerPaths == true."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100,
            onResults(data) {
                data.paths = [
                    [""videos"", 0, ""title""],
                    [""videos"", 1, ""title""]
                ];
            }
        });
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0].$_absolutePath).toEqual([""videos"", 0]);
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 332, 'column': 8, 'index': 11957}","it(""should honor response-stuffed paths with _useServerPaths == true."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100,
            onResults(data) {
                data.paths = [
                    [""videos"", 0, ""title""],
                    [""videos"", 1, ""title""]
                ];
            }
        });
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0].$_absolutePath).toEqual([""videos"", 0]);
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 351, 'column': 43, 'index': 12530}","it(""should throw when server paths are missing and _useServerPaths == true."", done => {
        const source = new LocalDataSource(cacheGenerator(0, 2));
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        toObservable(model.
            get([""videos"", 0, ""title""])).
            subscribe(noOp, err => {
                expect(err.message).toBe(""Server responses must include a 'paths' field when Model._useServerPaths === true"");
                done();
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 353, 'column': 8, 'index': 12638}","it(""should throw when server paths are missing and _useServerPaths == true."", done => {
        const source = new LocalDataSource(cacheGenerator(0, 2));
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        toObservable(model.
            get([""videos"", 0, ""title""])).
            subscribe(noOp, err => {
                expect(err.message).toBe(""Server responses must include a 'paths' field when Model._useServerPaths === true"");
                done();
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 363, 'column': 43, 'index': 13061}","it(""should be able to dispose one of two get requests.."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);
        const onNext2 = jest.fn();
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext2).
            subscribe(noOp, done);

        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onNext2).toHaveBeenCalledTimes(1);
                expect(strip(onNext2.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 368, 'column': 27, 'index': 13229}","it(""should be able to dispose one of two get requests.."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);
        const onNext2 = jest.fn();
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext2).
            subscribe(noOp, done);

        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onNext2).toHaveBeenCalledTimes(1);
                expect(strip(onNext2.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 375, 'column': 8, 'index': 13507}","it(""should be able to dispose one of two get requests.."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);
        const onNext2 = jest.fn();
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext2).
            subscribe(noOp, done);

        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onNext2).toHaveBeenCalledTimes(1);
                expect(strip(onNext2.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 403, 'column': 8, 'index': 14475}","it(""should onError a MaxRetryExceededError when data source is sync."", done => {
        const model = new Model({ source: new LocalDataSource({}) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 409, 'column': 20, 'index': 14741}","it(""should onError a MaxRetryExceededError when data source is sync."", done => {
        const model = new Model({ source: new LocalDataSource({}) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 417, 'column': 42, 'index': 15053}","it(""should onError a MaxRetryExceededError when data source is async."", done => {
        const model = new Model({ source: asyncifyDataSource(new LocalDataSource({})) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 418, 'column': 8, 'index': 15109}","it(""should onError a MaxRetryExceededError when data source is async."", done => {
        const model = new Model({ source: asyncifyDataSource(new LocalDataSource({})) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 424, 'column': 20, 'index': 15375}","it(""should onError a MaxRetryExceededError when data source is async."", done => {
        const model = new Model({ source: asyncifyDataSource(new LocalDataSource({})) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 433, 'column': 20, 'index': 15698}","it(""should return missing optimized paths with MaxRetryExceededError"", done => {
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({})),
            cache: {
                lolomo: {
                    0: {
                        $type: ""ref"",
                        value: [""videos"", 1]
                    }
                },
                videos: {
                    0: {
                        title: ""Revolutionary Road""
                    }
                }
            }
        });
        toObservable(model.
            get([""lolomo"", 0, ""title""], ""videos[0].title"", ""hall[0].ween"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
                expect(e.missingOptimizedPaths).toEqual([
                    [""videos"", 1, ""title""],
                    [""hall"", 0, ""ween""]
                ]);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 448, 'column': 8, 'index': 16116}","it(""should return missing optimized paths with MaxRetryExceededError"", done => {
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({})),
            cache: {
                lolomo: {
                    0: {
                        $type: ""ref"",
                        value: [""videos"", 1]
                    }
                },
                videos: {
                    0: {
                        title: ""Revolutionary Road""
                    }
                }
            }
        });
        toObservable(model.
            get([""lolomo"", 0, ""title""], ""videos[0].title"", ""hall[0].ween"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
                expect(e.missingOptimizedPaths).toEqual([
                    [""videos"", 1, ""title""],
                    [""hall"", 0, ""ween""]
                ]);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 458, 'column': 20, 'index': 16579}","it(""should return missing optimized paths with MaxRetryExceededError"", done => {
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({})),
            cache: {
                lolomo: {
                    0: {
                        $type: ""ref"",
                        value: [""videos"", 1]
                    }
                },
                videos: {
                    0: {
                        title: ""Revolutionary Road""
                    }
                }
            }
        });
        toObservable(model.
            get([""lolomo"", 0, ""title""], ""videos[0].title"", ""hall[0].ween"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
                expect(e.missingOptimizedPaths).toEqual([
                    [""videos"", 1, ""title""],
                    [""hall"", 0, ""ween""]
                ]);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 469, 'column': 20, 'index': 16958}","it(""should throw MaxRetryExceededError after retrying said times"", done => {
        const onGet = jest.fn();
        const model = new Model({
            maxRetries: 5,
            source: asyncifyDataSource(new LocalDataSource({}, {
                onGet
            }))
        });
        toObservable(model.
            get(""some.path"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected"").toBe(true);
                expect(onGet).toHaveBeenCalledTimes(5);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) { return done(e); }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 473, 'column': 8, 'index': 17061}","it(""should throw MaxRetryExceededError after retrying said times"", done => {
        const onGet = jest.fn();
        const model = new Model({
            maxRetries: 5,
            source: asyncifyDataSource(new LocalDataSource({}, {
                onGet
            }))
        });
        toObservable(model.
            get(""some.path"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected"").toBe(true);
                expect(onGet).toHaveBeenCalledTimes(5);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) { return done(e); }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Eager Test,"{'line': 480, 'column': 20, 'index': 17371}","it(""should throw MaxRetryExceededError after retrying said times"", done => {
        const onGet = jest.fn();
        const model = new Model({
            maxRetries: 5,
            source: asyncifyDataSource(new LocalDataSource({}, {
                onGet
            }))
        });
        toObservable(model.
            get(""some.path"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected"").toBe(true);
                expect(onGet).toHaveBeenCalledTimes(5);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) { return done(e); }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Exception Handling,"{'line': 155, 'column': 16, 'index': 6150}","it(""should report errors from a dataSource with _treatDataSourceErrorsAsJSONGraphErrors."", done => {
        const model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new ErrorDataSource(500, ""Oops!"")
        });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, err => {
                expect(err).toEqual([{
                    path: [""videos"", 0, ""title""],
                    value: {
                        message: ""Oops!"",
                        status: 500
                    }
                }]);
            }, () => {
                throw new Error(""On Completed was called. "" +
                    ""OnError should have been called."");
            }).
            subscribe(noOp, err => {
                // ensure its the same error
                if (Array.isArray(err) && isPathValue(err[0])) {
                    return done();
                }
                return done(err);
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Exception Handling,"{'line': 183, 'column': 16, 'index': 7122}","it(""should report errors from a dataSource."", done => {
        let outputError = null;
        const model = new Model({
            source: new ErrorDataSource(500, ""Oops!"")
        });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, err => {
                outputError = err;
                expect(err).toEqual({
                    $type: ""error"",
                    value: {
                        message: ""Oops!"",
                        status: 500
                    }
                });
            }, () => {
                throw new Error(""On Completed was called. "" +
                    ""OnError should have been called."");
            }).
            subscribe(noOp, err => {
                if (err === outputError) {
                    return done();
                }
                else {
                    return done(err);
                }
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Exception Handling,"{'line': 261, 'column': 16, 'index': 9741}","it(""should be able to dispose of getRequests."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);


        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).not.toHaveBeenCalled();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Exception Handling,"{'line': 268, 'column': 12, 'index': 9926}","it(""should be able to dispose of getRequests."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);


        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).not.toHaveBeenCalled();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Exception Handling,"{'line': 289, 'column': 16, 'index': 10614}","it(""should ignore response-stuffed paths."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100
        });
        const model = new Model({ source }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0]).toBeUndefined();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Exception Handling,"{'line': 302, 'column': 12, 'index': 10953}","it(""should ignore response-stuffed paths."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100
        });
        const model = new Model({ source }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0]).toBeUndefined();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Exception Handling,"{'line': 328, 'column': 16, 'index': 11834}","it(""should honor response-stuffed paths with _useServerPaths == true."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100,
            onResults(data) {
                data.paths = [
                    [""videos"", 0, ""title""],
                    [""videos"", 1, ""title""]
                ];
            }
        });
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0].$_absolutePath).toEqual([""videos"", 0]);
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Exception Handling,"{'line': 341, 'column': 12, 'index': 12173}","it(""should honor response-stuffed paths with _useServerPaths == true."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100,
            onResults(data) {
                data.paths = [
                    [""videos"", 0, ""title""],
                    [""videos"", 1, ""title""]
                ];
            }
        });
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0].$_absolutePath).toEqual([""videos"", 0]);
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Exception Handling,"{'line': 371, 'column': 16, 'index': 13350}","it(""should be able to dispose one of two get requests.."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);
        const onNext2 = jest.fn();
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext2).
            subscribe(noOp, done);

        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onNext2).toHaveBeenCalledTimes(1);
                expect(strip(onNext2.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Exception Handling,"{'line': 382, 'column': 12, 'index': 13705}","it(""should be able to dispose one of two get requests.."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);
        const onNext2 = jest.fn();
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext2).
            subscribe(noOp, done);

        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onNext2).toHaveBeenCalledTimes(1);
                expect(strip(onNext2.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Exception Handling,"{'line': 495, 'column': 16, 'index': 17860}","it(""passes the attempt count to the DataSource"", () => {
        const onGet = jest.fn();
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({}, { onGet }))
        });
        const path = [""some"", ""path""];

        return model.
            get(path).
            then(() => {
                throw new Error(""should have rejected with MaxRetryExceededError"");
            }, e => {
                expect(e).toBeInstanceOf(MaxRetryExceededError);
                expect(onGet).toHaveBeenCalledTimes(3);
                expect(onGet).toHaveBeenNthCalledWith(1, expect.anything(), [path], 1);
                expect(onGet).toHaveBeenNthCalledWith(2, expect.anything(), [path], 2);
                expect(onGet).toHaveBeenNthCalledWith(3, expect.anything(), [path], 3);
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 26, 'column': 12, 'index': 1161}","it(""should get a value from falcor."", done => {
            const model = new Model({ source: dataSource });
            const onNext = jest.fn();
            const secondOnNext = jest.fn();
            toObservable(model.
                preload([""videos"", 0, ""title""])).
                doAction(onNext, noOp, () => {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(() => {
                    return model.get([""videos"", 0, ""title""]);
                }).
                doAction(secondOnNext, noOp, () => {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: { 0: { title: ""Video 0"" } }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 53, 'column': 44, 'index': 2241}","it(""should perform multiple trips to a dataSource."", done => {
            const get = jest.fn((source, paths) => {
                if (paths.length === 0) {
                    paths.pop();
                }
            });
            const model = new Model({
                source: new LocalDataSource(cacheGenerator(0, 2, [""title"", ""art""]), { onGet: get })

            });
            const onNext = jest.fn();
            const secondOnNext = jest.fn();
            toObservable(model.
                preload([""videos"", 0, ""title""],
                    [""videos"", 1, ""art""])).
                doAction(onNext).
                doAction(noOp, noOp, () => {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(() => {
                    return model.get([""videos"", 0, ""title""]);
                }).
                doAction(secondOnNext).
                doAction(noOp, noOp, () => {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: { videos: { 0: { title: ""Video 0"" } } }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 58, 'column': 12, 'index': 2408}","it(""should perform multiple trips to a dataSource."", done => {
            const get = jest.fn((source, paths) => {
                if (paths.length === 0) {
                    paths.pop();
                }
            });
            const model = new Model({
                source: new LocalDataSource(cacheGenerator(0, 2, [""title"", ""art""]), { onGet: get })

            });
            const onNext = jest.fn();
            const secondOnNext = jest.fn();
            toObservable(model.
                preload([""videos"", 0, ""title""],
                    [""videos"", 1, ""art""])).
                doAction(onNext).
                doAction(noOp, noOp, () => {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(() => {
                    return model.get([""videos"", 0, ""title""]);
                }).
                doAction(secondOnNext).
                doAction(noOp, noOp, () => {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: { videos: { 0: { title: ""Video 0"" } } }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 83, 'column': 12, 'index': 3433}","it(""should get a value from falcor."", done => {
            const model = new Model({ source: dataSource });
            const onNext = jest.fn();
            toObservable(model.
                get([""videos"", 0, ""title""])).
                doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { videos: { 0: { title: ""Video 0"" } } }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 107, 'column': 12, 'index': 4324}","it(""should get a directly referenced value from falcor."", done => {
            const cache = {
                reference: {
                    $type: ""ref"",
                    value: [""foo"", ""bar""]
                },
                foo: {
                    bar: {
                        $type: ""atom"",
                        value: ""value""
                    }
                }
            };
            const model = new Model({ source: new LocalDataSource(cache) });
            const onNext = jest.fn();
            toObservable(model.
                get([""reference"", null])).
                doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { reference: ""value"" }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 121, 'column': 12, 'index': 4865}","it(""should get a value from falcor."", done => {
            const model = new Model({ source: dataSource });
            const onNext = jest.fn();
            toObservable(model.
                get([""videos"", 0, ""title""]).
                _toJSONG()).
                doAction(onNext, noOp, () => {
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: atom(""Video 0"")
                                }
                            }
                        },
                        paths: [[""videos"", 0, ""title""]]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 144, 'column': 8, 'index': 5774}","it(""should report errors from a dataSource with _treatDataSourceErrorsAsJSONGraphErrors."", done => {
        const model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new ErrorDataSource(500, ""Oops!"")
        });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, err => {
                expect(err).toEqual([{
                    path: [""videos"", 0, ""title""],
                    value: {
                        message: ""Oops!"",
                        status: 500
                    }
                }]);
            }, () => {
                throw new Error(""On Completed was called. "" +
                    ""OnError should have been called."");
            }).
            subscribe(noOp, err => {
                // ensure its the same error
                if (Array.isArray(err) && isPathValue(err[0])) {
                    return done();
                }
                return done(err);
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 171, 'column': 8, 'index': 6727}","it(""should report errors from a dataSource."", done => {
        let outputError = null;
        const model = new Model({
            source: new ErrorDataSource(500, ""Oops!"")
        });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, err => {
                outputError = err;
                expect(err).toEqual({
                    $type: ""error"",
                    value: {
                        message: ""Oops!"",
                        status: 500
                    }
                });
            }, () => {
                throw new Error(""On Completed was called. "" +
                    ""OnError should have been called."");
            }).
            subscribe(noOp, err => {
                if (err === outputError) {
                    return done();
                }
                else {
                    return done(err);
                }
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 236, 'column': 8, 'index': 8716}","it(""should get all missing paths in a single request"", done => {
        let serviceCalls = 0;
        const cacheModel = new Model({
            cache: {
                lolomo: {
                    summary: {
                        $type: ""atom"",
                        value: ""hello""
                    },
                    0: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-0""
                        }
                    },
                    1: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-1""
                        }
                    },
                    2: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-2""
                        }
                    }
                }
            }
        });
        const model = new Model({
            source: {
                get(paths) {
                    serviceCalls++;
                    return cacheModel.get.apply(cacheModel, paths)._toJSONG();
                }
            }
        });


        const onNext = jest.fn();
        toObservable(model.
            get(""lolomo.summary"", ""lolomo[0..2].summary"")).
            doAction(onNext, noOp, () => {
                const data = onNext.mock.calls[0][0];
                const json = data.json;
                const lolomo = json.lolomo;
                expect(lolomo.summary).toBeDefined();
                expect(lolomo[0].summary).toBeDefined();
                expect(lolomo[1].summary).toBeDefined();
                expect(lolomo[2].summary).toBeDefined();
                expect(serviceCalls).toBe(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 253, 'column': 43, 'index': 9452}","it(""should be able to dispose of getRequests."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);


        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).not.toHaveBeenCalled();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 258, 'column': 27, 'index': 9620}","it(""should be able to dispose of getRequests."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);


        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).not.toHaveBeenCalled();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 280, 'column': 43, 'index': 10300}","it(""should ignore response-stuffed paths."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100
        });
        const model = new Model({ source }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0]).toBeUndefined();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 286, 'column': 28, 'index': 10493}","it(""should ignore response-stuffed paths."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100
        });
        const model = new Model({ source }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0]).toBeUndefined();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 313, 'column': 43, 'index': 11315}","it(""should honor response-stuffed paths with _useServerPaths == true."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100,
            onResults(data) {
                data.paths = [
                    [""videos"", 0, ""title""],
                    [""videos"", 1, ""title""]
                ];
            }
        });
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0].$_absolutePath).toEqual([""videos"", 0]);
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 325, 'column': 28, 'index': 11713}","it(""should honor response-stuffed paths with _useServerPaths == true."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100,
            onResults(data) {
                data.paths = [
                    [""videos"", 0, ""title""],
                    [""videos"", 1, ""title""]
                ];
            }
        });
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0].$_absolutePath).toEqual([""videos"", 0]);
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 351, 'column': 43, 'index': 12530}","it(""should throw when server paths are missing and _useServerPaths == true."", done => {
        const source = new LocalDataSource(cacheGenerator(0, 2));
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        toObservable(model.
            get([""videos"", 0, ""title""])).
            subscribe(noOp, err => {
                expect(err.message).toBe(""Server responses must include a 'paths' field when Model._useServerPaths === true"");
                done();
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 353, 'column': 8, 'index': 12638}","it(""should throw when server paths are missing and _useServerPaths == true."", done => {
        const source = new LocalDataSource(cacheGenerator(0, 2));
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        toObservable(model.
            get([""videos"", 0, ""title""])).
            subscribe(noOp, err => {
                expect(err.message).toBe(""Server responses must include a 'paths' field when Model._useServerPaths === true"");
                done();
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 363, 'column': 43, 'index': 13061}","it(""should be able to dispose one of two get requests.."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);
        const onNext2 = jest.fn();
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext2).
            subscribe(noOp, done);

        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onNext2).toHaveBeenCalledTimes(1);
                expect(strip(onNext2.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 368, 'column': 27, 'index': 13229}","it(""should be able to dispose one of two get requests.."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);
        const onNext2 = jest.fn();
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext2).
            subscribe(noOp, done);

        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onNext2).toHaveBeenCalledTimes(1);
                expect(strip(onNext2.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 403, 'column': 8, 'index': 14475}","it(""should onError a MaxRetryExceededError when data source is sync."", done => {
        const model = new Model({ source: new LocalDataSource({}) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 409, 'column': 20, 'index': 14741}","it(""should onError a MaxRetryExceededError when data source is sync."", done => {
        const model = new Model({ source: new LocalDataSource({}) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 417, 'column': 42, 'index': 15053}","it(""should onError a MaxRetryExceededError when data source is async."", done => {
        const model = new Model({ source: asyncifyDataSource(new LocalDataSource({})) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 418, 'column': 8, 'index': 15109}","it(""should onError a MaxRetryExceededError when data source is async."", done => {
        const model = new Model({ source: asyncifyDataSource(new LocalDataSource({})) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 424, 'column': 20, 'index': 15375}","it(""should onError a MaxRetryExceededError when data source is async."", done => {
        const model = new Model({ source: asyncifyDataSource(new LocalDataSource({})) });
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 433, 'column': 20, 'index': 15698}","it(""should return missing optimized paths with MaxRetryExceededError"", done => {
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({})),
            cache: {
                lolomo: {
                    0: {
                        $type: ""ref"",
                        value: [""videos"", 1]
                    }
                },
                videos: {
                    0: {
                        title: ""Revolutionary Road""
                    }
                }
            }
        });
        toObservable(model.
            get([""lolomo"", 0, ""title""], ""videos[0].title"", ""hall[0].ween"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
                expect(e.missingOptimizedPaths).toEqual([
                    [""videos"", 1, ""title""],
                    [""hall"", 0, ""ween""]
                ]);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 448, 'column': 8, 'index': 16116}","it(""should return missing optimized paths with MaxRetryExceededError"", done => {
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({})),
            cache: {
                lolomo: {
                    0: {
                        $type: ""ref"",
                        value: [""videos"", 1]
                    }
                },
                videos: {
                    0: {
                        title: ""Revolutionary Road""
                    }
                }
            }
        });
        toObservable(model.
            get([""lolomo"", 0, ""title""], ""videos[0].title"", ""hall[0].ween"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
                expect(e.missingOptimizedPaths).toEqual([
                    [""videos"", 1, ""title""],
                    [""hall"", 0, ""ween""]
                ]);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 458, 'column': 20, 'index': 16579}","it(""should return missing optimized paths with MaxRetryExceededError"", done => {
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({})),
            cache: {
                lolomo: {
                    0: {
                        $type: ""ref"",
                        value: [""videos"", 1]
                    }
                },
                videos: {
                    0: {
                        title: ""Revolutionary Road""
                    }
                }
            }
        });
        toObservable(model.
            get([""lolomo"", 0, ""title""], ""videos[0].title"", ""hall[0].ween"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected."").toBe(true);
                expect(e.missingOptimizedPaths).toEqual([
                    [""videos"", 1, ""title""],
                    [""hall"", 0, ""ween""]
                ]);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 469, 'column': 20, 'index': 16958}","it(""should throw MaxRetryExceededError after retrying said times"", done => {
        const onGet = jest.fn();
        const model = new Model({
            maxRetries: 5,
            source: asyncifyDataSource(new LocalDataSource({}, {
                onGet
            }))
        });
        toObservable(model.
            get(""some.path"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected"").toBe(true);
                expect(onGet).toHaveBeenCalledTimes(5);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) { return done(e); }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 473, 'column': 8, 'index': 17061}","it(""should throw MaxRetryExceededError after retrying said times"", done => {
        const onGet = jest.fn();
        const model = new Model({
            maxRetries: 5,
            source: asyncifyDataSource(new LocalDataSource({}, {
                onGet
            }))
        });
        toObservable(model.
            get(""some.path"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected"").toBe(true);
                expect(onGet).toHaveBeenCalledTimes(5);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) { return done(e); }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 480, 'column': 20, 'index': 17371}","it(""should throw MaxRetryExceededError after retrying said times"", done => {
        const onGet = jest.fn();
        const model = new Model({
            maxRetries: 5,
            source: asyncifyDataSource(new LocalDataSource({}, {
                onGet
            }))
        });
        toObservable(model.
            get(""some.path"")).
            doAction(noOp, e => {
                expect(MaxRetryExceededError.is(e), ""MaxRetryExceededError expected"").toBe(true);
                expect(onGet).toHaveBeenCalledTimes(5);
            }).
            subscribe(noOp, e => {
                if (isAssertionError(e)) { return done(e); }
                return done();
            }, done.bind(null, new Error(""should not complete"")));
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Lazy Test,"{'line': 488, 'column': 20, 'index': 17667}","it(""passes the attempt count to the DataSource"", () => {
        const onGet = jest.fn();
        const model = new Model({
            source: asyncifyDataSource(new LocalDataSource({}, { onGet }))
        });
        const path = [""some"", ""path""];

        return model.
            get(path).
            then(() => {
                throw new Error(""should have rejected with MaxRetryExceededError"");
            }, e => {
                expect(e).toBeInstanceOf(MaxRetryExceededError);
                expect(onGet).toHaveBeenCalledTimes(3);
                expect(onGet).toHaveBeenNthCalledWith(1, expect.anything(), [path], 1);
                expect(onGet).toHaveBeenNthCalledWith(2, expect.anything(), [path], 2);
                expect(onGet).toHaveBeenNthCalledWith(3, expect.anything(), [path], 3);
            });
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Magic Number,"{'line': 246, 'column': 42, 'index': 9244}","it(""should get all missing paths in a single request"", done => {
        let serviceCalls = 0;
        const cacheModel = new Model({
            cache: {
                lolomo: {
                    summary: {
                        $type: ""atom"",
                        value: ""hello""
                    },
                    0: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-0""
                        }
                    },
                    1: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-1""
                        }
                    },
                    2: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-2""
                        }
                    }
                }
            }
        });
        const model = new Model({
            source: {
                get(paths) {
                    serviceCalls++;
                    return cacheModel.get.apply(cacheModel, paths)._toJSONG();
                }
            }
        });


        const onNext = jest.fn();
        toObservable(model.
            get(""lolomo.summary"", ""lolomo[0..2].summary"")).
            doAction(onNext, noOp, () => {
                const data = onNext.mock.calls[0][0];
                const json = data.json;
                const lolomo = json.lolomo;
                expect(lolomo.summary).toBeDefined();
                expect(lolomo[0].summary).toBeDefined();
                expect(lolomo[1].summary).toBeDefined();
                expect(lolomo[2].summary).toBeDefined();
                expect(serviceCalls).toBe(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Sleepy Test,"{'line': 267, 'column': 8, 'index': 9895}","it(""should be able to dispose of getRequests."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);


        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).not.toHaveBeenCalled();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Sleepy Test,"{'line': 297, 'column': 8, 'index': 10843}","it(""should ignore response-stuffed paths."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100
        });
        const model = new Model({ source }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0]).toBeUndefined();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Sleepy Test,"{'line': 301, 'column': 8, 'index': 10922}","it(""should ignore response-stuffed paths."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100
        });
        const model = new Model({ source }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0]).toBeUndefined();
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Sleepy Test,"{'line': 336, 'column': 8, 'index': 12063}","it(""should honor response-stuffed paths with _useServerPaths == true."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100,
            onResults(data) {
                data.paths = [
                    [""videos"", 0, ""title""],
                    [""videos"", 1, ""title""]
                ];
            }
        });
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0].$_absolutePath).toEqual([""videos"", 0]);
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Sleepy Test,"{'line': 340, 'column': 8, 'index': 12142}","it(""should honor response-stuffed paths with _useServerPaths == true."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet,
            wait: 100,
            onResults(data) {
                data.paths = [
                    [""videos"", 0, ""title""],
                    [""videos"", 1, ""title""]
                ];
            }
        });
        const model = new Model({ source, _useServerPaths: true }).batch(1);
        const onNext = jest.fn();
        const disposable1 = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);

        toObservable(model.
            get([""videos"", 1, ""title""])).
            subscribe(noOp, done);

        setTimeout(() => {
            disposable1.dispose();
        }, 30);

        setTimeout(() => {
            try {
                expect(model._root.cache.videos[0].$_absolutePath).toEqual([""videos"", 0]);
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-only.spec.js,Sleepy Test,"{'line': 381, 'column': 8, 'index': 13674}","it(""should be able to dispose one of two get requests.."", done => {
        const onGet = jest.fn();
        const source = new LocalDataSource(cacheGenerator(0, 2), {
            onGet
        });
        const model = new Model({ source }).batch();
        const onNext = jest.fn();
        const disposable = toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext, noOp, () => {
                throw new Error(""Should not of completed.  It was disposed."");
            }).
            subscribe(noOp, done);
        const onNext2 = jest.fn();
        toObservable(model.
            get([""videos"", 0, ""title""])).
            doAction(onNext2).
            subscribe(noOp, done);

        disposable.dispose();
        setTimeout(() => {
            try {
                expect(onNext).not.toHaveBeenCalled();
                expect(onGet).toHaveBeenCalledTimes(1);
                expect(onNext2).toHaveBeenCalledTimes(1);
                expect(strip(onNext2.mock.calls[0][0])).toEqual({
                    json: {
                        videos: {
                            0: {
                                title: ""Video 0""
                            }
                        }
                    }
                });
            } catch (e) {
                return done(e);
            }
            return done();
        }, 200);
    })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Conditional Test Logic,"{'line': 43, 'column': 16, 'index': 1289}","it('should onNext only once even if a subset of the requested values is found in the cache', function(done) {
        var model = new Model({
            cache: {
                paths: {
                    0: 'test',
                    1: 'test'
                }
            },
            source: new LocalDataSource({
                paths: {
                    2: Model.atom('test'),
                    3: Model.atom(undefined)
                }
            }, {materialize: true})
        });

        var onNextCount = 0;
        toObservable(model.
            get(['paths', {to:3}])).
            doAction(function(value) {

                onNextCount++;

                if (onNextCount === 1){
                    expect(strip(value)).toEqual({
                        json: {
                            paths: {
                                0: 'test',
                                1: 'test',
                                2: 'test'
                            }
                        }
                    });
                }
            }).subscribe(noOp, done, function(){
                expect(onNextCount).toBe(1);
                done();
            });
    })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Conditional Test Logic,"{'line': 365, 'column': 20, 'index': 14497}","it('should onNext twice if at least one value found in the cache - even if it is an atom of undefined', function(done) {
            var model = new Model({
                cache: {
                    paths: {
                        0: 'test',
                        1: 'test'
                    }
                },
                source: new LocalDataSource({
                    paths: {
                        2: Model.atom('test'),
                        3: Model.atom(undefined)
                    }
                }, {materialize: true})
            });

            var onNextCount = 0;
            toObservable(model.
                get(['paths', {to:3}]).
                progressively()).
                doAction(function(value) {

                    onNextCount++;
                    if (onNextCount === 1){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test'
                                }
                            }
                        });
                    }
                    else if (onNextCount === 2){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test',
                                    2: 'test'
                                }
                            }
                        });
                    }
                }).subscribe(noOp, done, function(){
                    expect(onNextCount).toBe(2);
                    done();
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Conditional Test Logic,"{'line': 375, 'column': 25, 'index': 14885}","it('should onNext twice if at least one value found in the cache - even if it is an atom of undefined', function(done) {
            var model = new Model({
                cache: {
                    paths: {
                        0: 'test',
                        1: 'test'
                    }
                },
                source: new LocalDataSource({
                    paths: {
                        2: Model.atom('test'),
                        3: Model.atom(undefined)
                    }
                }, {materialize: true})
            });

            var onNextCount = 0;
            toObservable(model.
                get(['paths', {to:3}]).
                progressively()).
                doAction(function(value) {

                    onNextCount++;
                    if (onNextCount === 1){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test'
                                }
                            }
                        });
                    }
                    else if (onNextCount === 2){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test',
                                    2: 'test'
                                }
                            }
                        });
                    }
                }).subscribe(noOp, done, function(){
                    expect(onNextCount).toBe(2);
                    done();
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Conditional Test Logic,"{'line': 400, 'column': 20, 'index': 15947}","it('should get multiple arguments with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Conditional Test Logic,"{'line': 448, 'column': 20, 'index': 17981}","it('should get complex path with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 366, 'column': 24, 'index': 14545}","it('should onNext twice if at least one value found in the cache - even if it is an atom of undefined', function(done) {
            var model = new Model({
                cache: {
                    paths: {
                        0: 'test',
                        1: 'test'
                    }
                },
                source: new LocalDataSource({
                    paths: {
                        2: Model.atom('test'),
                        3: Model.atom(undefined)
                    }
                }, {materialize: true})
            });

            var onNextCount = 0;
            toObservable(model.
                get(['paths', {to:3}]).
                progressively()).
                doAction(function(value) {

                    onNextCount++;
                    if (onNextCount === 1){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test'
                                }
                            }
                        });
                    }
                    else if (onNextCount === 2){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test',
                                    2: 'test'
                                }
                            }
                        });
                    }
                }).subscribe(noOp, done, function(){
                    expect(onNextCount).toBe(2);
                    done();
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 376, 'column': 24, 'index': 14933}","it('should onNext twice if at least one value found in the cache - even if it is an atom of undefined', function(done) {
            var model = new Model({
                cache: {
                    paths: {
                        0: 'test',
                        1: 'test'
                    }
                },
                source: new LocalDataSource({
                    paths: {
                        2: Model.atom('test'),
                        3: Model.atom(undefined)
                    }
                }, {materialize: true})
            });

            var onNextCount = 0;
            toObservable(model.
                get(['paths', {to:3}]).
                progressively()).
                doAction(function(value) {

                    onNextCount++;
                    if (onNextCount === 1){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test'
                                }
                            }
                        });
                    }
                    else if (onNextCount === 2){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test',
                                    2: 'test'
                                }
                            }
                        });
                    }
                }).subscribe(noOp, done, function(){
                    expect(onNextCount).toBe(2);
                    done();
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 401, 'column': 24, 'index': 15990}","it('should get multiple arguments with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 415, 'column': 24, 'index': 16569}","it('should get multiple arguments with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 449, 'column': 24, 'index': 18024}","it('should get complex path with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 463, 'column': 24, 'index': 18603}","it('should get complex path with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 568, 'column': 24, 'index': 22632}","it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 580, 'column': 24, 'index': 23118}","it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 616, 'column': 24, 'index': 24433}","it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 625, 'column': 24, 'index': 24776}","it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 656, 'column': 24, 'index': 25915}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 670, 'column': 24, 'index': 26672}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 711, 'column': 24, 'index': 28069}","it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 711, 'column': 24, 'index': 28069}","it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 716, 'column': 24, 'index': 28225}","it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Duplicate Assert,"{'line': 716, 'column': 24, 'index': 28225}","it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Eager Test,"{'line': 306, 'column': 12, 'index': 12048}","it('should get multiple arguments into a single _toJSONG response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Eager Test,"{'line': 313, 'column': 35, 'index': 12441}","it('should get multiple arguments into a single _toJSONG response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Eager Test,"{'line': 325, 'column': 12, 'index': 12961}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Eager Test,"{'line': 332, 'column': 35, 'index': 13325}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 91}",Unknown,steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 6, 'column': 0, 'index': 178}",Unknown,steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 12, 'column': 0, 'index': 423}",Unknown,steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 15, 'column': 0, 'index': 481}",Unknown,steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 21, 'column': 8, 'index': 721}","it('should onNext only once even if a subset of the requested values is found in the cache', function(done) {
        var model = new Model({
            cache: {
                paths: {
                    0: 'test',
                    1: 'test'
                }
            },
            source: new LocalDataSource({
                paths: {
                    2: Model.atom('test'),
                    3: Model.atom(undefined)
                }
            }, {materialize: true})
        });

        var onNextCount = 0;
        toObservable(model.
            get(['paths', {to:3}])).
            doAction(function(value) {

                onNextCount++;

                if (onNextCount === 1){
                    expect(strip(value)).toEqual({
                        json: {
                            paths: {
                                0: 'test',
                                1: 'test',
                                2: 'test'
                            }
                        }
                    });
                }
            }).subscribe(noOp, done, function(){
                expect(onNextCount).toBe(1);
                done();
            });
    })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 36, 'column': 8, 'index': 1115}","it('should onNext only once even if a subset of the requested values is found in the cache', function(done) {
        var model = new Model({
            cache: {
                paths: {
                    0: 'test',
                    1: 'test'
                }
            },
            source: new LocalDataSource({
                paths: {
                    2: Model.atom('test'),
                    3: Model.atom(undefined)
                }
            }, {materialize: true})
        });

        var onNextCount = 0;
        toObservable(model.
            get(['paths', {to:3}])).
            doAction(function(value) {

                onNextCount++;

                if (onNextCount === 1){
                    expect(strip(value)).toEqual({
                        json: {
                            paths: {
                                0: 'test',
                                1: 'test',
                                2: 'test'
                            }
                        }
                    });
                }
            }).subscribe(noOp, done, function(){
                expect(onNextCount).toBe(1);
                done();
            });
    })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 62, 'column': 12, 'index': 1960}","it('should get multiple arguments with multiple selector function args.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            var secondOnNext = jest.fn();
            toObservable(model.
                preload(['videos', 0, 'title'], ['videos', 1, 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(function() {
                    return model.get(['videos', 0, 'title'], ['videos', 1, 'title']);
                }).
                doAction(secondOnNext, noOp, function() {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'Video 0'
                                },
                                1: {
                                    title: 'Video 1'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 63, 'column': 12, 'index': 2047}","it('should get multiple arguments with multiple selector function args.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            var secondOnNext = jest.fn();
            toObservable(model.
                preload(['videos', 0, 'title'], ['videos', 1, 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(function() {
                    return model.get(['videos', 0, 'title'], ['videos', 1, 'title']);
                }).
                doAction(secondOnNext, noOp, function() {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'Video 0'
                                },
                                1: {
                                    title: 'Video 1'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 64, 'column': 12, 'index': 2083}","it('should get multiple arguments with multiple selector function args.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            var secondOnNext = jest.fn();
            toObservable(model.
                preload(['videos', 0, 'title'], ['videos', 1, 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(function() {
                    return model.get(['videos', 0, 'title'], ['videos', 1, 'title']);
                }).
                doAction(secondOnNext, noOp, function() {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'Video 0'
                                },
                                1: {
                                    title: 'Video 1'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 93, 'column': 12, 'index': 3298}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            var secondOnNext = jest.fn();
            toObservable(model.
                preload(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext).
                doAction(noOp, noOp, function() {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(function() {
                    return model.get(['lolomo', 0, {to: 1}, 'item', 'title']);
                }).
                doAction(secondOnNext, noOp, function() {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 94, 'column': 12, 'index': 3385}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            var secondOnNext = jest.fn();
            toObservable(model.
                preload(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext).
                doAction(noOp, noOp, function() {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(function() {
                    return model.get(['lolomo', 0, {to: 1}, 'item', 'title']);
                }).
                doAction(secondOnNext, noOp, function() {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 95, 'column': 12, 'index': 3421}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            var secondOnNext = jest.fn();
            toObservable(model.
                preload(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext).
                doAction(noOp, noOp, function() {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(function() {
                    return model.get(['lolomo', 0, {to: 1}, 'item', 'title']);
                }).
                doAction(secondOnNext, noOp, function() {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 132, 'column': 12, 'index': 5006}","it('should ensure empty paths do not cause dataSource requests {from:1, to:0}', function(done) {
            var onGet = jest.fn();
            var model = new Model({
                cache: { b: {} },
                source: new LocalDataSource({}, { onGet: onGet })
            });

            var modelGet = model.get(['b', { from: 1, to: 0 }, 'leaf']);
            var onNext = jest.fn();
            toObservable(modelGet).
                doAction(onNext, noOp, function() {
                    expect(onGet).not.toHaveBeenCalled();
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { b: {} }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 133, 'column': 12, 'index': 5041}","it('should ensure empty paths do not cause dataSource requests {from:1, to:0}', function(done) {
            var onGet = jest.fn();
            var model = new Model({
                cache: { b: {} },
                source: new LocalDataSource({}, { onGet: onGet })
            });

            var modelGet = model.get(['b', { from: 1, to: 0 }, 'leaf']);
            var onNext = jest.fn();
            toObservable(modelGet).
                doAction(onNext, noOp, function() {
                    expect(onGet).not.toHaveBeenCalled();
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { b: {} }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 138, 'column': 12, 'index': 5194}","it('should ensure empty paths do not cause dataSource requests {from:1, to:0}', function(done) {
            var onGet = jest.fn();
            var model = new Model({
                cache: { b: {} },
                source: new LocalDataSource({}, { onGet: onGet })
            });

            var modelGet = model.get(['b', { from: 1, to: 0 }, 'leaf']);
            var onNext = jest.fn();
            toObservable(modelGet).
                doAction(onNext, noOp, function() {
                    expect(onGet).not.toHaveBeenCalled();
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { b: {} }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 139, 'column': 12, 'index': 5267}","it('should ensure empty paths do not cause dataSource requests {from:1, to:0}', function(done) {
            var onGet = jest.fn();
            var model = new Model({
                cache: { b: {} },
                source: new LocalDataSource({}, { onGet: onGet })
            });

            var modelGet = model.get(['b', { from: 1, to: 0 }, 'leaf']);
            var onNext = jest.fn();
            toObservable(modelGet).
                doAction(onNext, noOp, function() {
                    expect(onGet).not.toHaveBeenCalled();
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { b: {} }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 151, 'column': 12, 'index': 5814}","it('should ensure empty paths do not cause dataSource requests [].', function(done) {
            var onGet = jest.fn();
            var model = new Model({
                cache: { b: {} },
                source: new LocalDataSource({}, { onGet: onGet })
            });

            var modelGet = model.get(['b', [], 'leaf']);
            var onNext = jest.fn();
            toObservable(modelGet).
                doAction(onNext, noOp, function() {
                    expect(onGet).not.toHaveBeenCalled();
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { b: {} }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 152, 'column': 12, 'index': 5849}","it('should ensure empty paths do not cause dataSource requests [].', function(done) {
            var onGet = jest.fn();
            var model = new Model({
                cache: { b: {} },
                source: new LocalDataSource({}, { onGet: onGet })
            });

            var modelGet = model.get(['b', [], 'leaf']);
            var onNext = jest.fn();
            toObservable(modelGet).
                doAction(onNext, noOp, function() {
                    expect(onGet).not.toHaveBeenCalled();
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { b: {} }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 157, 'column': 12, 'index': 6002}","it('should ensure empty paths do not cause dataSource requests [].', function(done) {
            var onGet = jest.fn();
            var model = new Model({
                cache: { b: {} },
                source: new LocalDataSource({}, { onGet: onGet })
            });

            var modelGet = model.get(['b', [], 'leaf']);
            var onNext = jest.fn();
            toObservable(modelGet).
                doAction(onNext, noOp, function() {
                    expect(onGet).not.toHaveBeenCalled();
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { b: {} }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 158, 'column': 12, 'index': 6059}","it('should ensure empty paths do not cause dataSource requests [].', function(done) {
            var onGet = jest.fn();
            var model = new Model({
                cache: { b: {} },
                source: new LocalDataSource({}, { onGet: onGet })
            });

            var modelGet = model.get(['b', [], 'leaf']);
            var onNext = jest.fn();
            toObservable(modelGet).
                doAction(onNext, noOp, function() {
                    expect(onGet).not.toHaveBeenCalled();
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { b: {} }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 171, 'column': 12, 'index': 6605}","it('should get multiple arguments into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 172, 'column': 12, 'index': 6692}","it('should get multiple arguments into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 200, 'column': 12, 'index': 7874}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 201, 'column': 12, 'index': 7961}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 229, 'column': 12, 'index': 9144}","it('should get a complex argument into a single arg and collect to max cache size.', function(done) {
            var model = new Model({
                cache: M(),
                source: new LocalDataSource(Cache()),
                maxSize: 0
            });
            var cache = model._root.cache;
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                finally(function() {
                    expect(cache['$size']).toBe(0);
                    done();
                }).
                subscribe(noOp, done, noOp);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 234, 'column': 12, 'index': 9305}","it('should get a complex argument into a single arg and collect to max cache size.', function(done) {
            var model = new Model({
                cache: M(),
                source: new LocalDataSource(Cache()),
                maxSize: 0
            });
            var cache = model._root.cache;
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                finally(function() {
                    expect(cache['$size']).toBe(0);
                    done();
                }).
                subscribe(noOp, done, noOp);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 235, 'column': 12, 'index': 9348}","it('should get a complex argument into a single arg and collect to max cache size.', function(done) {
            var model = new Model({
                cache: M(),
                source: new LocalDataSource(Cache()),
                maxSize: 0
            });
            var cache = model._root.cache;
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                finally(function() {
                    expect(cache['$size']).toBe(0);
                    done();
                }).
                subscribe(noOp, done, noOp);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 268, 'column': 12, 'index': 10728}","it('should ensure that a response where only materialized atoms come ' +
           'through still onNexts a value if one is present in cache.', function(done) {
            var model = new Model({
                cache: {
                    paths: {
                        0: 'test',
                        1: 'test'
                    }
                },
                source: new LocalDataSource({
                    paths: {
                        2: Model.atom(undefined),
                        3: Model.atom(undefined)
                    }
                }, {materialize: true})
            });

            var onNext = jest.fn();
            toObservable(model.
                get(['paths', {to:3}])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            paths: {
                                0: 'test',
                                1: 'test'
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 283, 'column': 12, 'index': 11181}","it('should ensure that a response where only materialized atoms come ' +
           'through still onNexts a value if one is present in cache.', function(done) {
            var model = new Model({
                cache: {
                    paths: {
                        0: 'test',
                        1: 'test'
                    }
                },
                source: new LocalDataSource({
                    paths: {
                        2: Model.atom(undefined),
                        3: Model.atom(undefined)
                    }
                }, {materialize: true})
            });

            var onNext = jest.fn();
            toObservable(model.
                get(['paths', {to:3}])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            paths: {
                                0: 'test',
                                1: 'test'
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 304, 'column': 12, 'index': 11925}","it('should get multiple arguments into a single _toJSONG response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 305, 'column': 12, 'index': 12012}","it('should get multiple arguments into a single _toJSONG response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 311, 'column': 20, 'index': 12321}","it('should get multiple arguments into a single _toJSONG response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 312, 'column': 20, 'index': 12383}","it('should get multiple arguments into a single _toJSONG response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 323, 'column': 12, 'index': 12838}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 324, 'column': 12, 'index': 12925}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 330, 'column': 20, 'index': 13205}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 331, 'column': 20, 'index': 13267}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 343, 'column': 12, 'index': 13821}","it('should onNext twice if at least one value found in the cache - even if it is an atom of undefined', function(done) {
            var model = new Model({
                cache: {
                    paths: {
                        0: 'test',
                        1: 'test'
                    }
                },
                source: new LocalDataSource({
                    paths: {
                        2: Model.atom('test'),
                        3: Model.atom(undefined)
                    }
                }, {materialize: true})
            });

            var onNextCount = 0;
            toObservable(model.
                get(['paths', {to:3}]).
                progressively()).
                doAction(function(value) {

                    onNextCount++;
                    if (onNextCount === 1){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test'
                                }
                            }
                        });
                    }
                    else if (onNextCount === 2){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test',
                                    2: 'test'
                                }
                            }
                        });
                    }
                }).subscribe(noOp, done, function(){
                    expect(onNextCount).toBe(2);
                    done();
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 358, 'column': 12, 'index': 14271}","it('should onNext twice if at least one value found in the cache - even if it is an atom of undefined', function(done) {
            var model = new Model({
                cache: {
                    paths: {
                        0: 'test',
                        1: 'test'
                    }
                },
                source: new LocalDataSource({
                    paths: {
                        2: Model.atom('test'),
                        3: Model.atom(undefined)
                    }
                }, {materialize: true})
            });

            var onNextCount = 0;
            toObservable(model.
                get(['paths', {to:3}]).
                progressively()).
                doAction(function(value) {

                    onNextCount++;
                    if (onNextCount === 1){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test'
                                }
                            }
                        });
                    }
                    else if (onNextCount === 2){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test',
                                    2: 'test'
                                }
                            }
                        });
                    }
                }).subscribe(noOp, done, function(){
                    expect(onNextCount).toBe(2);
                    done();
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 393, 'column': 12, 'index': 15600}","it('should get multiple arguments with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 394, 'column': 12, 'index': 15687}","it('should get multiple arguments with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 441, 'column': 12, 'index': 17663}","it('should get complex path with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 442, 'column': 12, 'index': 17750}","it('should get complex path with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 489, 'column': 12, 'index': 19681}","it('should get different response objects with multiple trips to the dataSource.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var revisions = [];
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    revisions.push(x);
                }, noOp, function() {
                    expect(revisions.length).toBe(2);
                    expect(revisions[1]).not.toBe(revisions[0]);
                    expect(revisions[1].json.lolomo[0]).not.toBe(revisions[0].json.lolomo[0]);
                    expect(revisions[1].json.lolomo[0][0]).toBe(revisions[0].json.lolomo[0][0]);

                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 490, 'column': 12, 'index': 19768}","it('should get different response objects with multiple trips to the dataSource.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var revisions = [];
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    revisions.push(x);
                }, noOp, function() {
                    expect(revisions.length).toBe(2);
                    expect(revisions[1]).not.toBe(revisions[0]);
                    expect(revisions[1].json.lolomo[0]).not.toBe(revisions[0].json.lolomo[0]);
                    expect(revisions[1].json.lolomo[0][0]).toBe(revisions[0].json.lolomo[0][0]);

                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 524, 'column': 12, 'index': 21029}","describe('Error Selector (during merge)', function() {

        function generateErrorSelectorSpy(expectedPath) {
            return jest.fn(function(path, atom) {

                // Needs to be asserted before mutation.
                expect(atom.$type).toBe('error');
                expect(atom.value).toEqual({message:'errormsg'});

                atom.$custom = 'custom';
                atom.value.customtype = 'customtype';

                return atom;
            });
        }

        function assertExpectedErrorPayload(e, expectedPath) {
            var path = e.path;
            var value = e.value;

            // To avoid hardcoding/scrubbing $size, and other internals
            expect(path).toEqual(expectedPath);

            expect(value.$type).toBe('error');
            expect(value.$custom).toBe('custom');
            expect(value.value).toEqual({
                message: 'errormsg',
                customtype: 'customtype'
            });
        }

        it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        });

        it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        });

        it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        });

        it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        });

        it('should safely merge references over existing branches', function(done) {
            var dataSource = new LocalDataSource({""shows"": {""80025172"": {""seasons"": {""current"": {""$type"": ""ref"",""value"": [""seasons"",""80025272""],""$size"": 52}}}},""seasons"": {""80025272"": {""episodes"": {""0"": {""$type"": ""ref"",""value"": [""episodes"",""80025313""],""$size"": 52}}}},""episodes"": {""80025313"": {""currentUser"": {""$type"": ""ref"",""value"": [""currentUser""],""$size"": 51}}},""currentUser"": {""localized"": {""preferences"": {""$type"": ""atom"",""value"": {""languages"": [""en""],""direction"": [""ltr""]},""$size"": 51}},""stringTable"": {""$type"": ""ref"",""value"": [""stringTables"",""en""],""$size"": 52}},""stringTables"": {""en"": {""detailsPopup"": {""expired"": {""$type"": ""atom"",""value"": ""Expired"",""$size"": 57}}}}});
            var originalGet = dataSource.get;
            dataSource.get = function() {
                return Rx.Observable.throw({
                    $type: 'error',
                    value: {
                        status: 404,
                        ""message"": ""Timed out""
                    }
                });
            };

            var model = new Model({
                _treatDataSourceErrorsAsJSONGraphErrors: true,
                source: dataSource,
                errorSelector : function(path, atom) {
                    var isError = path.indexOf('stringTable') !== -1;
                    var o = {
                        $type: !isError ? 'atom' : 'error',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            var fetch = toObservable(model.
                get(
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""localized"",""preferences""],
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""]
                ));

            var onNext = jest.fn();
            fetch.
                delay(1).
                catch(function(_) {
                    dataSource.get = originalGet;
                    model.invalidate([""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""])
                    return fetch;
                }).
                doAction(onNext).
                subscribe(noOp, done,
                    function() {
                        var expected = ['currentUser', 'localized'];
                        expect(model._root.cache.currentUser.localized.$_absolutePath).toEqual(expected);
                        expect(onNext.mock.calls[0][0].json.shows[80025172].seasons.current.episodes[0].currentUser.localized.$__path).toEqual(expected);
                        done();
                    });
        });
    })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 525, 'column': 12, 'index': 21060}","describe('Error Selector (during merge)', function() {

        function generateErrorSelectorSpy(expectedPath) {
            return jest.fn(function(path, atom) {

                // Needs to be asserted before mutation.
                expect(atom.$type).toBe('error');
                expect(atom.value).toEqual({message:'errormsg'});

                atom.$custom = 'custom';
                atom.value.customtype = 'customtype';

                return atom;
            });
        }

        function assertExpectedErrorPayload(e, expectedPath) {
            var path = e.path;
            var value = e.value;

            // To avoid hardcoding/scrubbing $size, and other internals
            expect(path).toEqual(expectedPath);

            expect(value.$type).toBe('error');
            expect(value.$custom).toBe('custom');
            expect(value.value).toEqual({
                message: 'errormsg',
                customtype: 'customtype'
            });
        }

        it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        });

        it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        });

        it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        });

        it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        });

        it('should safely merge references over existing branches', function(done) {
            var dataSource = new LocalDataSource({""shows"": {""80025172"": {""seasons"": {""current"": {""$type"": ""ref"",""value"": [""seasons"",""80025272""],""$size"": 52}}}},""seasons"": {""80025272"": {""episodes"": {""0"": {""$type"": ""ref"",""value"": [""episodes"",""80025313""],""$size"": 52}}}},""episodes"": {""80025313"": {""currentUser"": {""$type"": ""ref"",""value"": [""currentUser""],""$size"": 51}}},""currentUser"": {""localized"": {""preferences"": {""$type"": ""atom"",""value"": {""languages"": [""en""],""direction"": [""ltr""]},""$size"": 51}},""stringTable"": {""$type"": ""ref"",""value"": [""stringTables"",""en""],""$size"": 52}},""stringTables"": {""en"": {""detailsPopup"": {""expired"": {""$type"": ""atom"",""value"": ""Expired"",""$size"": 57}}}}});
            var originalGet = dataSource.get;
            dataSource.get = function() {
                return Rx.Observable.throw({
                    $type: 'error',
                    value: {
                        status: 404,
                        ""message"": ""Timed out""
                    }
                });
            };

            var model = new Model({
                _treatDataSourceErrorsAsJSONGraphErrors: true,
                source: dataSource,
                errorSelector : function(path, atom) {
                    var isError = path.indexOf('stringTable') !== -1;
                    var o = {
                        $type: !isError ? 'atom' : 'error',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            var fetch = toObservable(model.
                get(
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""localized"",""preferences""],
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""]
                ));

            var onNext = jest.fn();
            fetch.
                delay(1).
                catch(function(_) {
                    dataSource.get = originalGet;
                    model.invalidate([""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""])
                    return fetch;
                }).
                doAction(onNext).
                subscribe(noOp, done,
                    function() {
                        var expected = ['currentUser', 'localized'];
                        expect(model._root.cache.currentUser.localized.$_absolutePath).toEqual(expected);
                        expect(onNext.mock.calls[0][0].json.shows[80025172].seasons.current.episodes[0].currentUser.localized.$__path).toEqual(expected);
                        done();
                    });
        });
    })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 541, 'column': 12, 'index': 21600}","it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 543, 'column': 12, 'index': 21663}","it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 544, 'column': 12, 'index': 21697}","it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 548, 'column': 12, 'index': 21875}","it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 549, 'column': 12, 'index': 21914}","it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 550, 'column': 12, 'index': 21954}","it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 552, 'column': 12, 'index': 22026}","it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 588, 'column': 12, 'index': 23398}","it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 590, 'column': 12, 'index': 23461}","it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 591, 'column': 12, 'index': 23495}","it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 596, 'column': 12, 'index': 23676}","it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 597, 'column': 12, 'index': 23715}","it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 598, 'column': 12, 'index': 23755}","it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 600, 'column': 12, 'index': 23827}","it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 631, 'column': 12, 'index': 24994}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 633, 'column': 12, 'index': 25061}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 634, 'column': 12, 'index': 25095}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 639, 'column': 12, 'index': 25319}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 640, 'column': 12, 'index': 25358}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 641, 'column': 12, 'index': 25398}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 643, 'column': 12, 'index': 25470}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 677, 'column': 12, 'index': 26864}","it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 679, 'column': 12, 'index': 26927}","it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 680, 'column': 12, 'index': 26961}","it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 684, 'column': 12, 'index': 27139}","it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 685, 'column': 12, 'index': 27178}","it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 687, 'column': 12, 'index': 27219}","it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 691, 'column': 20, 'index': 27416}","it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 734, 'column': 12, 'index': 28906}","it('should safely merge references over existing branches', function(done) {
            var dataSource = new LocalDataSource({""shows"": {""80025172"": {""seasons"": {""current"": {""$type"": ""ref"",""value"": [""seasons"",""80025272""],""$size"": 52}}}},""seasons"": {""80025272"": {""episodes"": {""0"": {""$type"": ""ref"",""value"": [""episodes"",""80025313""],""$size"": 52}}}},""episodes"": {""80025313"": {""currentUser"": {""$type"": ""ref"",""value"": [""currentUser""],""$size"": 51}}},""currentUser"": {""localized"": {""preferences"": {""$type"": ""atom"",""value"": {""languages"": [""en""],""direction"": [""ltr""]},""$size"": 51}},""stringTable"": {""$type"": ""ref"",""value"": [""stringTables"",""en""],""$size"": 52}},""stringTables"": {""en"": {""detailsPopup"": {""expired"": {""$type"": ""atom"",""value"": ""Expired"",""$size"": 57}}}}});
            var originalGet = dataSource.get;
            dataSource.get = function() {
                return Rx.Observable.throw({
                    $type: 'error',
                    value: {
                        status: 404,
                        ""message"": ""Timed out""
                    }
                });
            };

            var model = new Model({
                _treatDataSourceErrorsAsJSONGraphErrors: true,
                source: dataSource,
                errorSelector : function(path, atom) {
                    var isError = path.indexOf('stringTable') !== -1;
                    var o = {
                        $type: !isError ? 'atom' : 'error',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            var fetch = toObservable(model.
                get(
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""localized"",""preferences""],
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""]
                ));

            var onNext = jest.fn();
            fetch.
                delay(1).
                catch(function(_) {
                    dataSource.get = originalGet;
                    model.invalidate([""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""])
                    return fetch;
                }).
                doAction(onNext).
                subscribe(noOp, done,
                    function() {
                        var expected = ['currentUser', 'localized'];
                        expect(model._root.cache.currentUser.localized.$_absolutePath).toEqual(expected);
                        expect(onNext.mock.calls[0][0].json.shows[80025172].seasons.current.episodes[0].currentUser.localized.$__path).toEqual(expected);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 735, 'column': 12, 'index': 29582}","it('should safely merge references over existing branches', function(done) {
            var dataSource = new LocalDataSource({""shows"": {""80025172"": {""seasons"": {""current"": {""$type"": ""ref"",""value"": [""seasons"",""80025272""],""$size"": 52}}}},""seasons"": {""80025272"": {""episodes"": {""0"": {""$type"": ""ref"",""value"": [""episodes"",""80025313""],""$size"": 52}}}},""episodes"": {""80025313"": {""currentUser"": {""$type"": ""ref"",""value"": [""currentUser""],""$size"": 51}}},""currentUser"": {""localized"": {""preferences"": {""$type"": ""atom"",""value"": {""languages"": [""en""],""direction"": [""ltr""]},""$size"": 51}},""stringTable"": {""$type"": ""ref"",""value"": [""stringTables"",""en""],""$size"": 52}},""stringTables"": {""en"": {""detailsPopup"": {""expired"": {""$type"": ""atom"",""value"": ""Expired"",""$size"": 57}}}}});
            var originalGet = dataSource.get;
            dataSource.get = function() {
                return Rx.Observable.throw({
                    $type: 'error',
                    value: {
                        status: 404,
                        ""message"": ""Timed out""
                    }
                });
            };

            var model = new Model({
                _treatDataSourceErrorsAsJSONGraphErrors: true,
                source: dataSource,
                errorSelector : function(path, atom) {
                    var isError = path.indexOf('stringTable') !== -1;
                    var o = {
                        $type: !isError ? 'atom' : 'error',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            var fetch = toObservable(model.
                get(
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""localized"",""preferences""],
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""]
                ));

            var onNext = jest.fn();
            fetch.
                delay(1).
                catch(function(_) {
                    dataSource.get = originalGet;
                    model.invalidate([""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""])
                    return fetch;
                }).
                doAction(onNext).
                subscribe(noOp, done,
                    function() {
                        var expected = ['currentUser', 'localized'];
                        expect(model._root.cache.currentUser.localized.$_absolutePath).toEqual(expected);
                        expect(onNext.mock.calls[0][0].json.shows[80025172].seasons.current.episodes[0].currentUser.localized.$__path).toEqual(expected);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 746, 'column': 12, 'index': 29922}","it('should safely merge references over existing branches', function(done) {
            var dataSource = new LocalDataSource({""shows"": {""80025172"": {""seasons"": {""current"": {""$type"": ""ref"",""value"": [""seasons"",""80025272""],""$size"": 52}}}},""seasons"": {""80025272"": {""episodes"": {""0"": {""$type"": ""ref"",""value"": [""episodes"",""80025313""],""$size"": 52}}}},""episodes"": {""80025313"": {""currentUser"": {""$type"": ""ref"",""value"": [""currentUser""],""$size"": 51}}},""currentUser"": {""localized"": {""preferences"": {""$type"": ""atom"",""value"": {""languages"": [""en""],""direction"": [""ltr""]},""$size"": 51}},""stringTable"": {""$type"": ""ref"",""value"": [""stringTables"",""en""],""$size"": 52}},""stringTables"": {""en"": {""detailsPopup"": {""expired"": {""$type"": ""atom"",""value"": ""Expired"",""$size"": 57}}}}});
            var originalGet = dataSource.get;
            dataSource.get = function() {
                return Rx.Observable.throw({
                    $type: 'error',
                    value: {
                        status: 404,
                        ""message"": ""Timed out""
                    }
                });
            };

            var model = new Model({
                _treatDataSourceErrorsAsJSONGraphErrors: true,
                source: dataSource,
                errorSelector : function(path, atom) {
                    var isError = path.indexOf('stringTable') !== -1;
                    var o = {
                        $type: !isError ? 'atom' : 'error',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            var fetch = toObservable(model.
                get(
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""localized"",""preferences""],
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""]
                ));

            var onNext = jest.fn();
            fetch.
                delay(1).
                catch(function(_) {
                    dataSource.get = originalGet;
                    model.invalidate([""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""])
                    return fetch;
                }).
                doAction(onNext).
                subscribe(noOp, done,
                    function() {
                        var expected = ['currentUser', 'localized'];
                        expect(model._root.cache.currentUser.localized.$_absolutePath).toEqual(expected);
                        expect(onNext.mock.calls[0][0].json.shows[80025172].seasons.current.episodes[0].currentUser.localized.$__path).toEqual(expected);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 750, 'column': 20, 'index': 30120}","it('should safely merge references over existing branches', function(done) {
            var dataSource = new LocalDataSource({""shows"": {""80025172"": {""seasons"": {""current"": {""$type"": ""ref"",""value"": [""seasons"",""80025272""],""$size"": 52}}}},""seasons"": {""80025272"": {""episodes"": {""0"": {""$type"": ""ref"",""value"": [""episodes"",""80025313""],""$size"": 52}}}},""episodes"": {""80025313"": {""currentUser"": {""$type"": ""ref"",""value"": [""currentUser""],""$size"": 51}}},""currentUser"": {""localized"": {""preferences"": {""$type"": ""atom"",""value"": {""languages"": [""en""],""direction"": [""ltr""]},""$size"": 51}},""stringTable"": {""$type"": ""ref"",""value"": [""stringTables"",""en""],""$size"": 52}},""stringTables"": {""en"": {""detailsPopup"": {""expired"": {""$type"": ""atom"",""value"": ""Expired"",""$size"": 57}}}}});
            var originalGet = dataSource.get;
            dataSource.get = function() {
                return Rx.Observable.throw({
                    $type: 'error',
                    value: {
                        status: 404,
                        ""message"": ""Timed out""
                    }
                });
            };

            var model = new Model({
                _treatDataSourceErrorsAsJSONGraphErrors: true,
                source: dataSource,
                errorSelector : function(path, atom) {
                    var isError = path.indexOf('stringTable') !== -1;
                    var o = {
                        $type: !isError ? 'atom' : 'error',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            var fetch = toObservable(model.
                get(
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""localized"",""preferences""],
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""]
                ));

            var onNext = jest.fn();
            fetch.
                delay(1).
                catch(function(_) {
                    dataSource.get = originalGet;
                    model.invalidate([""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""])
                    return fetch;
                }).
                doAction(onNext).
                subscribe(noOp, done,
                    function() {
                        var expected = ['currentUser', 'localized'];
                        expect(model._root.cache.currentUser.localized.$_absolutePath).toEqual(expected);
                        expect(onNext.mock.calls[0][0].json.shows[80025172].seasons.current.episodes[0].currentUser.localized.$__path).toEqual(expected);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 751, 'column': 20, 'index': 30190}","it('should safely merge references over existing branches', function(done) {
            var dataSource = new LocalDataSource({""shows"": {""80025172"": {""seasons"": {""current"": {""$type"": ""ref"",""value"": [""seasons"",""80025272""],""$size"": 52}}}},""seasons"": {""80025272"": {""episodes"": {""0"": {""$type"": ""ref"",""value"": [""episodes"",""80025313""],""$size"": 52}}}},""episodes"": {""80025313"": {""currentUser"": {""$type"": ""ref"",""value"": [""currentUser""],""$size"": 51}}},""currentUser"": {""localized"": {""preferences"": {""$type"": ""atom"",""value"": {""languages"": [""en""],""direction"": [""ltr""]},""$size"": 51}},""stringTable"": {""$type"": ""ref"",""value"": [""stringTables"",""en""],""$size"": 52}},""stringTables"": {""en"": {""detailsPopup"": {""expired"": {""$type"": ""atom"",""value"": ""Expired"",""$size"": 57}}}}});
            var originalGet = dataSource.get;
            dataSource.get = function() {
                return Rx.Observable.throw({
                    $type: 'error',
                    value: {
                        status: 404,
                        ""message"": ""Timed out""
                    }
                });
            };

            var model = new Model({
                _treatDataSourceErrorsAsJSONGraphErrors: true,
                source: dataSource,
                errorSelector : function(path, atom) {
                    var isError = path.indexOf('stringTable') !== -1;
                    var o = {
                        $type: !isError ? 'atom' : 'error',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            var fetch = toObservable(model.
                get(
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""localized"",""preferences""],
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""]
                ));

            var onNext = jest.fn();
            fetch.
                delay(1).
                catch(function(_) {
                    dataSource.get = originalGet;
                    model.invalidate([""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""])
                    return fetch;
                }).
                doAction(onNext).
                subscribe(noOp, done,
                    function() {
                        var expected = ['currentUser', 'localized'];
                        expect(model._root.cache.currentUser.localized.$_absolutePath).toEqual(expected);
                        expect(onNext.mock.calls[0][0].json.shows[80025172].seasons.current.episodes[0].currentUser.localized.$__path).toEqual(expected);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 763, 'column': 12, 'index': 30530}","it('should safely merge references over existing branches', function(done) {
            var dataSource = new LocalDataSource({""shows"": {""80025172"": {""seasons"": {""current"": {""$type"": ""ref"",""value"": [""seasons"",""80025272""],""$size"": 52}}}},""seasons"": {""80025272"": {""episodes"": {""0"": {""$type"": ""ref"",""value"": [""episodes"",""80025313""],""$size"": 52}}}},""episodes"": {""80025313"": {""currentUser"": {""$type"": ""ref"",""value"": [""currentUser""],""$size"": 51}}},""currentUser"": {""localized"": {""preferences"": {""$type"": ""atom"",""value"": {""languages"": [""en""],""direction"": [""ltr""]},""$size"": 51}},""stringTable"": {""$type"": ""ref"",""value"": [""stringTables"",""en""],""$size"": 52}},""stringTables"": {""en"": {""detailsPopup"": {""expired"": {""$type"": ""atom"",""value"": ""Expired"",""$size"": 57}}}}});
            var originalGet = dataSource.get;
            dataSource.get = function() {
                return Rx.Observable.throw({
                    $type: 'error',
                    value: {
                        status: 404,
                        ""message"": ""Timed out""
                    }
                });
            };

            var model = new Model({
                _treatDataSourceErrorsAsJSONGraphErrors: true,
                source: dataSource,
                errorSelector : function(path, atom) {
                    var isError = path.indexOf('stringTable') !== -1;
                    var o = {
                        $type: !isError ? 'atom' : 'error',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            var fetch = toObservable(model.
                get(
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""localized"",""preferences""],
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""]
                ));

            var onNext = jest.fn();
            fetch.
                delay(1).
                catch(function(_) {
                    dataSource.get = originalGet;
                    model.invalidate([""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""])
                    return fetch;
                }).
                doAction(onNext).
                subscribe(noOp, done,
                    function() {
                        var expected = ['currentUser', 'localized'];
                        expect(model._root.cache.currentUser.localized.$_absolutePath).toEqual(expected);
                        expect(onNext.mock.calls[0][0].json.shows[80025172].seasons.current.episodes[0].currentUser.localized.$__path).toEqual(expected);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 769, 'column': 12, 'index': 30854}","it('should safely merge references over existing branches', function(done) {
            var dataSource = new LocalDataSource({""shows"": {""80025172"": {""seasons"": {""current"": {""$type"": ""ref"",""value"": [""seasons"",""80025272""],""$size"": 52}}}},""seasons"": {""80025272"": {""episodes"": {""0"": {""$type"": ""ref"",""value"": [""episodes"",""80025313""],""$size"": 52}}}},""episodes"": {""80025313"": {""currentUser"": {""$type"": ""ref"",""value"": [""currentUser""],""$size"": 51}}},""currentUser"": {""localized"": {""preferences"": {""$type"": ""atom"",""value"": {""languages"": [""en""],""direction"": [""ltr""]},""$size"": 51}},""stringTable"": {""$type"": ""ref"",""value"": [""stringTables"",""en""],""$size"": 52}},""stringTables"": {""en"": {""detailsPopup"": {""expired"": {""$type"": ""atom"",""value"": ""Expired"",""$size"": 57}}}}});
            var originalGet = dataSource.get;
            dataSource.get = function() {
                return Rx.Observable.throw({
                    $type: 'error',
                    value: {
                        status: 404,
                        ""message"": ""Timed out""
                    }
                });
            };

            var model = new Model({
                _treatDataSourceErrorsAsJSONGraphErrors: true,
                source: dataSource,
                errorSelector : function(path, atom) {
                    var isError = path.indexOf('stringTable') !== -1;
                    var o = {
                        $type: !isError ? 'atom' : 'error',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            var fetch = toObservable(model.
                get(
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""localized"",""preferences""],
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""]
                ));

            var onNext = jest.fn();
            fetch.
                delay(1).
                catch(function(_) {
                    dataSource.get = originalGet;
                    model.invalidate([""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""])
                    return fetch;
                }).
                doAction(onNext).
                subscribe(noOp, done,
                    function() {
                        var expected = ['currentUser', 'localized'];
                        expect(model._root.cache.currentUser.localized.$_absolutePath).toEqual(expected);
                        expect(onNext.mock.calls[0][0].json.shows[80025172].seasons.current.episodes[0].currentUser.localized.$__path).toEqual(expected);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 780, 'column': 24, 'index': 31335}","it('should safely merge references over existing branches', function(done) {
            var dataSource = new LocalDataSource({""shows"": {""80025172"": {""seasons"": {""current"": {""$type"": ""ref"",""value"": [""seasons"",""80025272""],""$size"": 52}}}},""seasons"": {""80025272"": {""episodes"": {""0"": {""$type"": ""ref"",""value"": [""episodes"",""80025313""],""$size"": 52}}}},""episodes"": {""80025313"": {""currentUser"": {""$type"": ""ref"",""value"": [""currentUser""],""$size"": 51}}},""currentUser"": {""localized"": {""preferences"": {""$type"": ""atom"",""value"": {""languages"": [""en""],""direction"": [""ltr""]},""$size"": 51}},""stringTable"": {""$type"": ""ref"",""value"": [""stringTables"",""en""],""$size"": 52}},""stringTables"": {""en"": {""detailsPopup"": {""expired"": {""$type"": ""atom"",""value"": ""Expired"",""$size"": 57}}}}});
            var originalGet = dataSource.get;
            dataSource.get = function() {
                return Rx.Observable.throw({
                    $type: 'error',
                    value: {
                        status: 404,
                        ""message"": ""Timed out""
                    }
                });
            };

            var model = new Model({
                _treatDataSourceErrorsAsJSONGraphErrors: true,
                source: dataSource,
                errorSelector : function(path, atom) {
                    var isError = path.indexOf('stringTable') !== -1;
                    var o = {
                        $type: !isError ? 'atom' : 'error',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            var fetch = toObservable(model.
                get(
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""localized"",""preferences""],
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""]
                ));

            var onNext = jest.fn();
            fetch.
                delay(1).
                catch(function(_) {
                    dataSource.get = originalGet;
                    model.invalidate([""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""])
                    return fetch;
                }).
                doAction(onNext).
                subscribe(noOp, done,
                    function() {
                        var expected = ['currentUser', 'localized'];
                        expect(model._root.cache.currentUser.localized.$_absolutePath).toEqual(expected);
                        expect(onNext.mock.calls[0][0].json.shows[80025172].seasons.current.episodes[0].currentUser.localized.$__path).toEqual(expected);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 788, 'column': 8, 'index': 31780}","describe(""Cached data with timestamp"", function() {
        var t0 = Date.parse('2000/01/01');
        var t1 = t0 + 1;

        function remoteData() {
            return {
                videos: {
                    1: {
                        bookmark: Model.atom('remote value', {$timestamp: t0})
                    },
                    2: {
                        previous: Model.ref(['videos', 1])
                    }
                }
            };
        }

        it(""should not be replaced by data with an older timestamp"", function(done) {
            var cache = {
                videos: {
                    1: {
                        bookmark: Model.atom('cached value', {$timestamp: t1})
                    }
                }
            };
            var source = new LocalDataSource(remoteData());
            var model = new Model({cache: cache, source: source});
            model.getValue(['videos', 2, 'previous', 'bookmark']).
                then(function(value) {
                    expect(value).toBe('cached value');
                    done();
                }).
                catch(function(e) {
                    done(e);
                });
        });

        it(""when expired should be replaced by data with an older timestamp"", function(done) {
            var cache = {
                videos: {
                    1: {
                        bookmark: Model.atom('cached value', {$timestamp: t1, $expires: t1})
                    }
                }
            };
            var source = new LocalDataSource(remoteData());
            var model = new Model({cache: cache, source: source});
            model.getValue(['videos', 2, 'previous', 'bookmark']).
                then(function(value) {
                    expect(value).toBe('remote value');
                    done();
                }).
                catch(function(e) {
                    done(e);
                });
        });
    })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 789, 'column': 8, 'index': 31823}","describe(""Cached data with timestamp"", function() {
        var t0 = Date.parse('2000/01/01');
        var t1 = t0 + 1;

        function remoteData() {
            return {
                videos: {
                    1: {
                        bookmark: Model.atom('remote value', {$timestamp: t0})
                    },
                    2: {
                        previous: Model.ref(['videos', 1])
                    }
                }
            };
        }

        it(""should not be replaced by data with an older timestamp"", function(done) {
            var cache = {
                videos: {
                    1: {
                        bookmark: Model.atom('cached value', {$timestamp: t1})
                    }
                }
            };
            var source = new LocalDataSource(remoteData());
            var model = new Model({cache: cache, source: source});
            model.getValue(['videos', 2, 'previous', 'bookmark']).
                then(function(value) {
                    expect(value).toBe('cached value');
                    done();
                }).
                catch(function(e) {
                    done(e);
                });
        });

        it(""when expired should be replaced by data with an older timestamp"", function(done) {
            var cache = {
                videos: {
                    1: {
                        bookmark: Model.atom('cached value', {$timestamp: t1, $expires: t1})
                    }
                }
            };
            var source = new LocalDataSource(remoteData());
            var model = new Model({cache: cache, source: source});
            model.getValue(['videos', 2, 'previous', 'bookmark']).
                then(function(value) {
                    expect(value).toBe('remote value');
                    done();
                }).
                catch(function(e) {
                    done(e);
                });
        });
    })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 805, 'column': 12, 'index': 32295}","it(""should not be replaced by data with an older timestamp"", function(done) {
            var cache = {
                videos: {
                    1: {
                        bookmark: Model.atom('cached value', {$timestamp: t1})
                    }
                }
            };
            var source = new LocalDataSource(remoteData());
            var model = new Model({cache: cache, source: source});
            model.getValue(['videos', 2, 'previous', 'bookmark']).
                then(function(value) {
                    expect(value).toBe('cached value');
                    done();
                }).
                catch(function(e) {
                    done(e);
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 812, 'column': 12, 'index': 32506}","it(""should not be replaced by data with an older timestamp"", function(done) {
            var cache = {
                videos: {
                    1: {
                        bookmark: Model.atom('cached value', {$timestamp: t1})
                    }
                }
            };
            var source = new LocalDataSource(remoteData());
            var model = new Model({cache: cache, source: source});
            model.getValue(['videos', 2, 'previous', 'bookmark']).
                then(function(value) {
                    expect(value).toBe('cached value');
                    done();
                }).
                catch(function(e) {
                    done(e);
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 813, 'column': 12, 'index': 32566}","it(""should not be replaced by data with an older timestamp"", function(done) {
            var cache = {
                videos: {
                    1: {
                        bookmark: Model.atom('cached value', {$timestamp: t1})
                    }
                }
            };
            var source = new LocalDataSource(remoteData());
            var model = new Model({cache: cache, source: source});
            model.getValue(['videos', 2, 'previous', 'bookmark']).
                then(function(value) {
                    expect(value).toBe('cached value');
                    done();
                }).
                catch(function(e) {
                    done(e);
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 825, 'column': 12, 'index': 33036}","it(""when expired should be replaced by data with an older timestamp"", function(done) {
            var cache = {
                videos: {
                    1: {
                        bookmark: Model.atom('cached value', {$timestamp: t1, $expires: t1})
                    }
                }
            };
            var source = new LocalDataSource(remoteData());
            var model = new Model({cache: cache, source: source});
            model.getValue(['videos', 2, 'previous', 'bookmark']).
                then(function(value) {
                    expect(value).toBe('remote value');
                    done();
                }).
                catch(function(e) {
                    done(e);
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 832, 'column': 12, 'index': 33261}","it(""when expired should be replaced by data with an older timestamp"", function(done) {
            var cache = {
                videos: {
                    1: {
                        bookmark: Model.atom('cached value', {$timestamp: t1, $expires: t1})
                    }
                }
            };
            var source = new LocalDataSource(remoteData());
            var model = new Model({cache: cache, source: source});
            model.getValue(['videos', 2, 'previous', 'bookmark']).
                then(function(value) {
                    expect(value).toBe('remote value');
                    done();
                }).
                catch(function(e) {
                    done(e);
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Global Variable,"{'line': 833, 'column': 12, 'index': 33321}","it(""when expired should be replaced by data with an older timestamp"", function(done) {
            var cache = {
                videos: {
                    1: {
                        bookmark: Model.atom('cached value', {$timestamp: t1, $expires: t1})
                    }
                }
            };
            var source = new LocalDataSource(remoteData());
            var model = new Model({cache: cache, source: source});
            model.getValue(['videos', 2, 'previous', 'bookmark']).
                then(function(value) {
                    expect(value).toBe('remote value');
                    done();
                }).
                catch(function(e) {
                    done(e);
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 37, 'column': 8, 'index': 1144}","it('should onNext only once even if a subset of the requested values is found in the cache', function(done) {
        var model = new Model({
            cache: {
                paths: {
                    0: 'test',
                    1: 'test'
                }
            },
            source: new LocalDataSource({
                paths: {
                    2: Model.atom('test'),
                    3: Model.atom(undefined)
                }
            }, {materialize: true})
        });

        var onNextCount = 0;
        toObservable(model.
            get(['paths', {to:3}])).
            doAction(function(value) {

                onNextCount++;

                if (onNextCount === 1){
                    expect(strip(value)).toEqual({
                        json: {
                            paths: {
                                0: 'test',
                                1: 'test',
                                2: 'test'
                            }
                        }
                    });
                }
            }).subscribe(noOp, done, function(){
                expect(onNextCount).toBe(1);
                done();
            });
    })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 65, 'column': 12, 'index': 2125}","it('should get multiple arguments with multiple selector function args.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            var secondOnNext = jest.fn();
            toObservable(model.
                preload(['videos', 0, 'title'], ['videos', 1, 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(function() {
                    return model.get(['videos', 0, 'title'], ['videos', 1, 'title']);
                }).
                doAction(secondOnNext, noOp, function() {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'Video 0'
                                },
                                1: {
                                    title: 'Video 1'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 96, 'column': 12, 'index': 3463}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            var secondOnNext = jest.fn();
            toObservable(model.
                preload(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext).
                doAction(noOp, noOp, function() {
                    expect(onNext).not.toHaveBeenCalled();
                }).
                defaultIfEmpty({}).
                flatMap(function() {
                    return model.get(['lolomo', 0, {to: 1}, 'item', 'title']);
                }).
                doAction(secondOnNext, noOp, function() {
                    expect(secondOnNext).toHaveBeenCalledTimes(1);
                    expect(strip(secondOnNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 140, 'column': 12, 'index': 5303}","it('should ensure empty paths do not cause dataSource requests {from:1, to:0}', function(done) {
            var onGet = jest.fn();
            var model = new Model({
                cache: { b: {} },
                source: new LocalDataSource({}, { onGet: onGet })
            });

            var modelGet = model.get(['b', { from: 1, to: 0 }, 'leaf']);
            var onNext = jest.fn();
            toObservable(modelGet).
                doAction(onNext, noOp, function() {
                    expect(onGet).not.toHaveBeenCalled();
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { b: {} }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 159, 'column': 12, 'index': 6095}","it('should ensure empty paths do not cause dataSource requests [].', function(done) {
            var onGet = jest.fn();
            var model = new Model({
                cache: { b: {} },
                source: new LocalDataSource({}, { onGet: onGet })
            });

            var modelGet = model.get(['b', [], 'leaf']);
            var onNext = jest.fn();
            toObservable(modelGet).
                doAction(onNext, noOp, function() {
                    expect(onGet).not.toHaveBeenCalled();
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: { b: {} }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 173, 'column': 12, 'index': 6728}","it('should get multiple arguments into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 202, 'column': 12, 'index': 7997}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 236, 'column': 12, 'index': 9384}","it('should get a complex argument into a single arg and collect to max cache size.', function(done) {
            var model = new Model({
                cache: M(),
                source: new LocalDataSource(Cache()),
                maxSize: 0
            });
            var cache = model._root.cache;
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                finally(function() {
                    expect(cache['$size']).toBe(0);
                    done();
                }).
                subscribe(noOp, done, noOp);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 306, 'column': 12, 'index': 12048}","it('should get multiple arguments into a single _toJSONG response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 313, 'column': 35, 'index': 12441}","it('should get multiple arguments into a single _toJSONG response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 325, 'column': 12, 'index': 12961}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 332, 'column': 35, 'index': 13325}","it('should get a complex argument into a single arg.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    var out = strip(onNext.mock.calls[0][0]);
                    var expected = strip({
                        jsonGraph: cacheGenerator(0, 2),
                        paths: [['lolomo', 0, 0, 'item', 'title'],
                            ['lolomo', 0, 1, 'item', 'title']]
                    });
                    expect(out).toEqual(expected);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 359, 'column': 12, 'index': 14304}","it('should onNext twice if at least one value found in the cache - even if it is an atom of undefined', function(done) {
            var model = new Model({
                cache: {
                    paths: {
                        0: 'test',
                        1: 'test'
                    }
                },
                source: new LocalDataSource({
                    paths: {
                        2: Model.atom('test'),
                        3: Model.atom(undefined)
                    }
                }, {materialize: true})
            });

            var onNextCount = 0;
            toObservable(model.
                get(['paths', {to:3}]).
                progressively()).
                doAction(function(value) {

                    onNextCount++;
                    if (onNextCount === 1){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test'
                                }
                            }
                        });
                    }
                    else if (onNextCount === 2){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test',
                                    2: 'test'
                                }
                            }
                        });
                    }
                }).subscribe(noOp, done, function(){
                    expect(onNextCount).toBe(2);
                    done();
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 395, 'column': 12, 'index': 15714}","it('should get multiple arguments with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 443, 'column': 12, 'index': 17777}","it('should get complex path with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 491, 'column': 12, 'index': 19800}","it('should get different response objects with multiple trips to the dataSource.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var revisions = [];
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    revisions.push(x);
                }, noOp, function() {
                    expect(revisions.length).toBe(2);
                    expect(revisions[1]).not.toBe(revisions[0]);
                    expect(revisions[1].json.lolomo[0]).not.toBe(revisions[0].json.lolomo[0]);
                    expect(revisions[1].json.lolomo[0][0]).toBe(revisions[0].json.lolomo[0][0]);

                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 558, 'column': 12, 'index': 22224}","it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 606, 'column': 12, 'index': 24025}","it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 649, 'column': 12, 'index': 25668}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 704, 'column': 12, 'index': 27778}","it('should be allowed to change $type', function(done) {

            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();

            var model = new Model({
                cache : modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector : function(path, atom) {
                    var o = {
                        $type: 'atom',
                        $custom: 'custom',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            toObservable(model.
                boxValues().
                setValue(testPath, jsonGraph.error({message:'errormsg'}))).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).not.toHaveBeenCalled();
                        done();
                    },
                    function() {

                        expect(onErrorSpy).not.toHaveBeenCalled();
                        expect(onNextSpy).toHaveBeenCalledTimes(1);

                        expect(onNextSpy.mock.calls[0][0]).toEqual({
                            $type: 'atom',
                            $custom: 'custom',
                            value: {
                                message: 'errormsg',
                                customtype: 'customtype'
                            },
                            $size:51
                        });

                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Lazy Test,"{'line': 763, 'column': 24, 'index': 30542}","it('should safely merge references over existing branches', function(done) {
            var dataSource = new LocalDataSource({""shows"": {""80025172"": {""seasons"": {""current"": {""$type"": ""ref"",""value"": [""seasons"",""80025272""],""$size"": 52}}}},""seasons"": {""80025272"": {""episodes"": {""0"": {""$type"": ""ref"",""value"": [""episodes"",""80025313""],""$size"": 52}}}},""episodes"": {""80025313"": {""currentUser"": {""$type"": ""ref"",""value"": [""currentUser""],""$size"": 51}}},""currentUser"": {""localized"": {""preferences"": {""$type"": ""atom"",""value"": {""languages"": [""en""],""direction"": [""ltr""]},""$size"": 51}},""stringTable"": {""$type"": ""ref"",""value"": [""stringTables"",""en""],""$size"": 52}},""stringTables"": {""en"": {""detailsPopup"": {""expired"": {""$type"": ""atom"",""value"": ""Expired"",""$size"": 57}}}}});
            var originalGet = dataSource.get;
            dataSource.get = function() {
                return Rx.Observable.throw({
                    $type: 'error',
                    value: {
                        status: 404,
                        ""message"": ""Timed out""
                    }
                });
            };

            var model = new Model({
                _treatDataSourceErrorsAsJSONGraphErrors: true,
                source: dataSource,
                errorSelector : function(path, atom) {
                    var isError = path.indexOf('stringTable') !== -1;
                    var o = {
                        $type: !isError ? 'atom' : 'error',
                        value: {
                            message: atom.value.message,
                            customtype: 'customtype'
                        }
                    };

                    return o;
                }
            });

            var fetch = toObservable(model.
                get(
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""localized"",""preferences""],
                    [""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""]
                ));

            var onNext = jest.fn();
            fetch.
                delay(1).
                catch(function(_) {
                    dataSource.get = originalGet;
                    model.invalidate([""shows"",80025172,""seasons"",""current"",""episodes"",0,""currentUser"",""stringTable"",""detailsPopup"",""expired""])
                    return fetch;
                }).
                doAction(onNext).
                subscribe(noOp, done,
                    function() {
                        var expected = ['currentUser', 'localized'];
                        expect(model._root.cache.currentUser.localized.$_absolutePath).toEqual(expected);
                        expect(onNext.mock.calls[0][0].json.shows[80025172].seasons.current.episodes[0].currentUser.localized.$__path).toEqual(expected);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Magic Number,"{'line': 55, 'column': 41, 'index': 1749}","it('should onNext only once even if a subset of the requested values is found in the cache', function(done) {
        var model = new Model({
            cache: {
                paths: {
                    0: 'test',
                    1: 'test'
                }
            },
            source: new LocalDataSource({
                paths: {
                    2: Model.atom('test'),
                    3: Model.atom(undefined)
                }
            }, {materialize: true})
        });

        var onNextCount = 0;
        toObservable(model.
            get(['paths', {to:3}])).
            doAction(function(value) {

                onNextCount++;

                if (onNextCount === 1){
                    expect(strip(value)).toEqual({
                        json: {
                            paths: {
                                0: 'test',
                                1: 'test',
                                2: 'test'
                            }
                        }
                    });
                }
            }).subscribe(noOp, done, function(){
                expect(onNextCount).toBe(1);
                done();
            });
    })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Magic Number,"{'line': 260, 'column': 48, 'index': 10436}","it('should get a complex argument into a single arg and collect to max cache size.', function(done) {
            var model = new Model({
                cache: M(),
                source: new LocalDataSource(Cache()),
                maxSize: 0
            });
            var cache = model._root.cache;
            var onNext = jest.fn();
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(strip(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            lolomo: {
                                0: {
                                    0: {
                                        item: {
                                            title: 'Video 0'
                                        }
                                    },
                                    1: {
                                        item: {
                                            title: 'Video 1'
                                        }
                                    }
                                }
                            }
                        }
                    });
                }).
                finally(function() {
                    expect(cache['$size']).toBe(0);
                    done();
                }).
                subscribe(noOp, done, noOp);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Magic Number,"{'line': 387, 'column': 45, 'index': 15393}","it('should onNext twice if at least one value found in the cache - even if it is an atom of undefined', function(done) {
            var model = new Model({
                cache: {
                    paths: {
                        0: 'test',
                        1: 'test'
                    }
                },
                source: new LocalDataSource({
                    paths: {
                        2: Model.atom('test'),
                        3: Model.atom(undefined)
                    }
                }, {materialize: true})
            });

            var onNextCount = 0;
            toObservable(model.
                get(['paths', {to:3}]).
                progressively()).
                doAction(function(value) {

                    onNextCount++;
                    if (onNextCount === 1){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test'
                                }
                            }
                        });
                    }
                    else if (onNextCount === 2){
                        expect(strip(value)).toEqual({
                            json: {
                                paths: {
                                    0: 'test',
                                    1: 'test',
                                    2: 'test'
                                }
                            }
                        });
                    }
                }).subscribe(noOp, done, function(){
                    expect(onNextCount).toBe(2);
                    done();
                });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Magic Number,"{'line': 435, 'column': 39, 'index': 17445}","it('should get multiple arguments with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Magic Number,"{'line': 483, 'column': 39, 'index': 19479}","it('should get complex path with multiple trips to the dataSource into a single toJSON response.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var count = 0;
            toObservable(model.
                get(['lolomo', 0, {to: 1}, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    count++;
                    if (count === 1) {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        expect(strip(x)).toEqual({
                            json: {
                                lolomo: {
                                    0: {
                                        0: {
                                            item: {
                                                title: 'Video 0'
                                            }
                                        },
                                        1: {
                                            item: {
                                                title: 'Video 1'
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }, noOp, function() {
                    expect(count).toBe(2);
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Magic Number,"{'line': 497, 'column': 50, 'index': 20111}","it('should get different response objects with multiple trips to the dataSource.', function(done) {
            var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
            var revisions = [];
            toObservable(model.
                get(['lolomo', 0, 0, 'item', 'title'], ['lolomo', 0, 1, 'item', 'title']).
                progressively()).
                doAction(function(x) {
                    revisions.push(x);
                }, noOp, function() {
                    expect(revisions.length).toBe(2);
                    expect(revisions[1]).not.toBe(revisions[0]);
                    expect(revisions[1].json.lolomo[0]).not.toBe(revisions[0].json.lolomo[0]);
                    expect(revisions[1].json.lolomo[0][0]).toBe(revisions[0].json.lolomo[0][0]);

                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Magic Number,"{'line': 570, 'column': 46, 'index': 22724}","it('should get invoked with the right arguments for branches in cache', function(done) {

            // Cache has [lolomo,0,0,item]
            var testPath = ['lolomo',0,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();
            // [lolomo,0,0,item]->[videos,0]
            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).toHaveBeenCalledTimes(1);
                        expect(strip(onNextSpy.mock.calls[0][0])).toEqual({
                            json: {}
                        });
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Magic Number,"{'line': 618, 'column': 46, 'index': 24525}","it('should get invoked with the right arguments for branches not in cache', function(done) {

            // Cache doesn't have [lolomo,1,0,item]
            var testPath = ['lolomo',1,0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            // [lolomo,1,0,item]->[videos,10]
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(errorSelectorSpy).toHaveBeenCalledTimes(1);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(testPath);

                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(e.length).toBe(1);
                        assertExpectedErrorPayload(e[0], testPath);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-cache.spec.js,Magic Number,"{'line': 662, 'column': 46, 'index': 26303}","it('should get invoked with the correct error paths for a keyset', function(done) {
            var testPath = ['lolomo',[0,1],0,'item','errorPath'];

            var modelCache = M();
            var dataSourceCache = Cache();

            dataSourceCache.videos[0].errorPath = jsonGraph.error({message:'errormsg'});
            dataSourceCache.videos[10].errorPath = jsonGraph.error({message:'errormsg'});

            var onNextSpy = jest.fn();
            var onErrorSpy = jest.fn();
            var errorSelectorSpy = generateErrorSelectorSpy(testPath);

            var model = new Model({
                cache: modelCache,
                source: new LocalDataSource(dataSourceCache),
                errorSelector: errorSelectorSpy
            });

            toObservable(model.
                boxValues().
                get(testPath)).
                doAction(onNextSpy, onErrorSpy, noOp).
                subscribe(
                    noOp,
                    function(e) {
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);

                        expect(errorSelectorSpy).toHaveBeenCalledTimes(2);
                        expect(errorSelectorSpy.mock.calls[0][0]).toEqual(['lolomo',0,0,'item','errorPath']);
                        expect(errorSelectorSpy.mock.calls[1][0]).toEqual(['lolomo',1,0,'item','errorPath']);

                        expect(e.length).toBe(2);
                        assertExpectedErrorPayload(e[0], ['lolomo',0,0,'item','errorPath']);
                        assertExpectedErrorPayload(e[1], ['lolomo',1,0,'item','errorPath']);

                        done();
                    },
                    function() {
                        expect(onNextSpy).not.toHaveBeenCalled();
                        expect(onErrorSpy).toHaveBeenCalledTimes(1);
                        done();
                    });
        })",steel
/test/falcor/get/get.dataSource-and-bind.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/get/get.dataSource-and-bind.spec.js,Global Variable,"{'line': 3, 'column': 0, 'index': 67}",Unknown,steel
/test/falcor/get/get.dataSource-and-bind.spec.js,Global Variable,"{'line': 18, 'column': 8, 'index': 560}","it('should get a value from from dataSource when bound.', function(done) {
        var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
        model._root.unsafeMode = true;
        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            flatMap(function(x) {
                return model.
                    deref(x.json.lolomo[0]).
                    get([1, 'item', 'title']);
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        1: {
                            item: {
                                title: 'Video 1'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.dataSource-and-bind.spec.js,Global Variable,"{'line': 20, 'column': 8, 'index': 682}","it('should get a value from from dataSource when bound.', function(done) {
        var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
        model._root.unsafeMode = true;
        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            flatMap(function(x) {
                return model.
                    deref(x.json.lolomo[0]).
                    get([1, 'item', 'title']);
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        1: {
                            item: {
                                title: 'Video 1'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.dataSource-and-bind.spec.js,Global Variable,"{'line': 45, 'column': 8, 'index': 1557}","it('should get a value from from dataSource after cache purge.', function(done) {
        var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
        model._root.unsafeMode = true;
        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            map(function(x) {
                return model.
                    deref(x.json.lolomo[0]);
            }).
            doAction(function() {
                model.setCache({});
            }).
            flatMap(function(rowModel) {
                return rowModel.
                    get([1, 'item', 'title']);
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        1: {
                            item: {
                                title: 'Video 1'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.dataSource-and-bind.spec.js,Global Variable,"{'line': 47, 'column': 8, 'index': 1679}","it('should get a value from from dataSource after cache purge.', function(done) {
        var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
        model._root.unsafeMode = true;
        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            map(function(x) {
                return model.
                    deref(x.json.lolomo[0]);
            }).
            doAction(function() {
                model.setCache({});
            }).
            flatMap(function(rowModel) {
                return rowModel.
                    get([1, 'item', 'title']);
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        1: {
                            item: {
                                title: 'Video 1'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.dataSource-and-bind.spec.js,Lazy Test,"{'line': 21, 'column': 8, 'index': 714}","it('should get a value from from dataSource when bound.', function(done) {
        var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
        model._root.unsafeMode = true;
        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            flatMap(function(x) {
                return model.
                    deref(x.json.lolomo[0]).
                    get([1, 'item', 'title']);
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        1: {
                            item: {
                                title: 'Video 1'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.dataSource-and-bind.spec.js,Lazy Test,"{'line': 48, 'column': 8, 'index': 1711}","it('should get a value from from dataSource after cache purge.', function(done) {
        var model = new Model({cache: M(), source: new LocalDataSource(Cache())});
        model._root.unsafeMode = true;
        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            map(function(x) {
                return model.
                    deref(x.json.lolomo[0]);
            }).
            doAction(function() {
                model.setCache({});
            }).
            flatMap(function(rowModel) {
                return rowModel.
                    get([1, 'item', 'title']);
            }).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        1: {
                            item: {
                                title: 'Video 1'
                            }
                        }
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.clone.spec.js,Duplicate Assert,"{'line': 31, 'column': 8, 'index': 962}","it('should ensure that cache remains consistent amoung its clones.', function() {
        var source = new Model({
            cache: {
                lolomo: {
                    summary: 'this is a lolomo'
                }
            }
        });
        var clone = source._clone({});
        var resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'summary']], [{}]);
        var resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'summary']], [{}]);
        expect(resClone).toEqual(resSource);

        source.setCache({
            lolomo: {
                name: 'Terminator 2'
            }
        });
        resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'name']], [{}]);
        resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'name']], [{}]);
        expect(resClone).toEqual(resSource);
    })",steel
/test/falcor/get/get.clone.spec.js,Duplicate Assert,"{'line': 31, 'column': 8, 'index': 962}","it('should ensure that cache remains consistent amoung its clones.', function() {
        var source = new Model({
            cache: {
                lolomo: {
                    summary: 'this is a lolomo'
                }
            }
        });
        var clone = source._clone({});
        var resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'summary']], [{}]);
        var resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'summary']], [{}]);
        expect(resClone).toEqual(resSource);

        source.setCache({
            lolomo: {
                name: 'Terminator 2'
            }
        });
        resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'name']], [{}]);
        resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'name']], [{}]);
        expect(resClone).toEqual(resSource);
    })",steel
/test/falcor/get/get.clone.spec.js,Duplicate Assert,"{'line': 40, 'column': 8, 'index': 1292}","it('should ensure that cache remains consistent amoung its clones.', function() {
        var source = new Model({
            cache: {
                lolomo: {
                    summary: 'this is a lolomo'
                }
            }
        });
        var clone = source._clone({});
        var resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'summary']], [{}]);
        var resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'summary']], [{}]);
        expect(resClone).toEqual(resSource);

        source.setCache({
            lolomo: {
                name: 'Terminator 2'
            }
        });
        resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'name']], [{}]);
        resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'name']], [{}]);
        expect(resClone).toEqual(resSource);
    })",steel
/test/falcor/get/get.clone.spec.js,Duplicate Assert,"{'line': 40, 'column': 8, 'index': 1292}","it('should ensure that cache remains consistent amoung its clones.', function() {
        var source = new Model({
            cache: {
                lolomo: {
                    summary: 'this is a lolomo'
                }
            }
        });
        var clone = source._clone({});
        var resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'summary']], [{}]);
        var resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'summary']], [{}]);
        expect(resClone).toEqual(resSource);

        source.setCache({
            lolomo: {
                name: 'Terminator 2'
            }
        });
        resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'name']], [{}]);
        resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'name']], [{}]);
        expect(resClone).toEqual(resSource);
    })",steel
/test/falcor/get/get.clone.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 40}",Unknown,steel
/test/falcor/get/get.clone.spec.js,Global Variable,"{'line': 3, 'column': 0, 'index': 66}",Unknown,steel
/test/falcor/get/get.clone.spec.js,Global Variable,"{'line': 7, 'column': 8, 'index': 207}","it('should be able to use a model as a source.', function() {
        var source = new Model({
            cache: {
                lolomo: {
                    summary: {}
                }
            }
        }).asDataSource();

        var model = new Model({source: source});

        expect(model.batch().setCache);
    })",steel
/test/falcor/get/get.clone.spec.js,Global Variable,"{'line': 15, 'column': 8, 'index': 379}","it('should be able to use a model as a source.', function() {
        var source = new Model({
            cache: {
                lolomo: {
                    summary: {}
                }
            }
        }).asDataSource();

        var model = new Model({source: source});

        expect(model.batch().setCache);
    })",steel
/test/falcor/get/get.clone.spec.js,Global Variable,"{'line': 21, 'column': 8, 'index': 564}","it('should ensure that cache remains consistent amoung its clones.', function() {
        var source = new Model({
            cache: {
                lolomo: {
                    summary: 'this is a lolomo'
                }
            }
        });
        var clone = source._clone({});
        var resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'summary']], [{}]);
        var resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'summary']], [{}]);
        expect(resClone).toEqual(resSource);

        source.setCache({
            lolomo: {
                name: 'Terminator 2'
            }
        });
        resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'name']], [{}]);
        resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'name']], [{}]);
        expect(resClone).toEqual(resSource);
    })",steel
/test/falcor/get/get.clone.spec.js,Global Variable,"{'line': 28, 'column': 8, 'index': 736}","it('should ensure that cache remains consistent amoung its clones.', function() {
        var source = new Model({
            cache: {
                lolomo: {
                    summary: 'this is a lolomo'
                }
            }
        });
        var clone = source._clone({});
        var resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'summary']], [{}]);
        var resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'summary']], [{}]);
        expect(resClone).toEqual(resSource);

        source.setCache({
            lolomo: {
                name: 'Terminator 2'
            }
        });
        resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'name']], [{}]);
        resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'name']], [{}]);
        expect(resClone).toEqual(resSource);
    })",steel
/test/falcor/get/get.clone.spec.js,Global Variable,"{'line': 29, 'column': 8, 'index': 775}","it('should ensure that cache remains consistent amoung its clones.', function() {
        var source = new Model({
            cache: {
                lolomo: {
                    summary: 'this is a lolomo'
                }
            }
        });
        var clone = source._clone({});
        var resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'summary']], [{}]);
        var resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'summary']], [{}]);
        expect(resClone).toEqual(resSource);

        source.setCache({
            lolomo: {
                name: 'Terminator 2'
            }
        });
        resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'name']], [{}]);
        resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'name']], [{}]);
        expect(resClone).toEqual(resSource);
    })",steel
/test/falcor/get/get.clone.spec.js,Global Variable,"{'line': 30, 'column': 8, 'index': 870}","it('should ensure that cache remains consistent amoung its clones.', function() {
        var source = new Model({
            cache: {
                lolomo: {
                    summary: 'this is a lolomo'
                }
            }
        });
        var clone = source._clone({});
        var resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'summary']], [{}]);
        var resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'summary']], [{}]);
        expect(resClone).toEqual(resSource);

        source.setCache({
            lolomo: {
                name: 'Terminator 2'
            }
        });
        resSource = source._getPathValuesAsPathMap(source, [['lolomo', 'name']], [{}]);
        resClone = clone._getPathValuesAsPathMap(clone, [['lolomo', 'name']], [{}]);
        expect(resClone).toEqual(resSource);
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Conditional Test Logic,"{'line': 103, 'column': 16, 'index': 3935}","it('should report errors from a dataSource with _treatDataSourceErrorsAsJSONGraphErrors.', function(done) {
        var model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new Model({
                source: new ErrorDataSource(500, 'Oops!')
            }).asDataSource()
        });
        toObservable(model.
            get(['videos', 1234, 'summary'])).
            doAction(noOp, function(err) {
                expect(err).toEqual([{
                    path: ['videos', 1234, 'summary'],
                    value: {
                        message: 'Oops!',
                        status: 500
                    }
                }]);
            }).
            subscribe(noOp, function(err) {
                // ensure its the same error
                if (Array.isArray(err) && isPathValue(err[0])) {
                    done();
                } else {
                    done(err);
                }
            }, function() {
                done('On Completed was called. ' +
                     'OnError should have been called.');
            });
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Conditional Test Logic,"{'line': 134, 'column': 16, 'index': 5000}","it('should report errors from a dataSource.', function(done) {
        var outputError;
        var model = new Model({
            source: new Model({
                source: new ErrorDataSource(500, 'Oops!')
            }).asDataSource()
        });
        toObservable(model.
            get(['videos', 1234, 'summary'])).
            doAction(noOp, function(err) {
                outputError = err;
                expect(err).toEqual({
                    $type: ""error"",
                    value: {
                        message: 'Oops!',
                        status: 500
                    }
                });
            }).
            subscribe(noOp, function(err) {
                // ensure its the same error
                if (outputError === err) {
                    done();
                } else {
                    done(err);
                }
            }, function() {
                done('On Completed was called. ' +
                     'OnError should have been called.');
            });
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Eager Test,"{'line': 33, 'column': 48, 'index': 1292}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'Video 0'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Eager Test,"{'line': 37, 'column': 12, 'index': 1412}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'Video 0'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Eager Test,"{'line': 58, 'column': 48, 'index': 2240}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: atom('Video 0')
                                }
                            }
                        },
                        paths: [
                            ['videos', 0, 'title']
                        ]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Eager Test,"{'line': 62, 'column': 12, 'index': 2360}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: atom('Video 0')
                                }
                            }
                        },
                        paths: [
                            ['videos', 0, 'title']
                        ]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Eager Test,"{'line': 90, 'column': 8, 'index': 3460}","it('should report errors from a dataSource with _treatDataSourceErrorsAsJSONGraphErrors.', function(done) {
        var model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new Model({
                source: new ErrorDataSource(500, 'Oops!')
            }).asDataSource()
        });
        toObservable(model.
            get(['videos', 1234, 'summary'])).
            doAction(noOp, function(err) {
                expect(err).toEqual([{
                    path: ['videos', 1234, 'summary'],
                    value: {
                        message: 'Oops!',
                        status: 500
                    }
                }]);
            }).
            subscribe(noOp, function(err) {
                // ensure its the same error
                if (Array.isArray(err) && isPathValue(err[0])) {
                    done();
                } else {
                    done(err);
                }
            }, function() {
                done('On Completed was called. ' +
                     'OnError should have been called.');
            });
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Eager Test,"{'line': 103, 'column': 42, 'index': 3961}","it('should report errors from a dataSource with _treatDataSourceErrorsAsJSONGraphErrors.', function(done) {
        var model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new Model({
                source: new ErrorDataSource(500, 'Oops!')
            }).asDataSource()
        });
        toObservable(model.
            get(['videos', 1234, 'summary'])).
            doAction(noOp, function(err) {
                expect(err).toEqual([{
                    path: ['videos', 1234, 'summary'],
                    value: {
                        message: 'Oops!',
                        status: 500
                    }
                }]);
            }).
            subscribe(noOp, function(err) {
                // ensure its the same error
                if (Array.isArray(err) && isPathValue(err[0])) {
                    done();
                } else {
                    done(err);
                }
            }, function() {
                done('On Completed was called. ' +
                     'OnError should have been called.');
            });
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 3, 'column': 0, 'index': 67}",Unknown,steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 9, 'column': 0, 'index': 403}",Unknown,steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 14, 'column': 8, 'index': 592}","it('should return the correct empty envelope.', function(done) {
        var model = new Model({
            cache: {foo: 1}
        }).asDataSource();
        var onNext = jest.fn();
        toObservable(model.
            get([])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    jsonGraph: {},
                    paths: []
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 17, 'column': 8, 'index': 679}","it('should return the correct empty envelope.', function(done) {
        var model = new Model({
            cache: {foo: 1}
        }).asDataSource();
        var onNext = jest.fn();
        toObservable(model.
            get([])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    jsonGraph: {},
                    paths: []
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 31, 'column': 12, 'index': 1184}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'Video 0'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 36, 'column': 12, 'index': 1376}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'Video 0'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 56, 'column': 12, 'index': 2132}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: atom('Video 0')
                                }
                            }
                        },
                        paths: [
                            ['videos', 0, 'title']
                        ]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 61, 'column': 12, 'index': 2324}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: atom('Video 0')
                                }
                            }
                        },
                        paths: [
                            ['videos', 0, 'title']
                        ]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 84, 'column': 8, 'index': 3237}","it('should report errors from a dataSource with _treatDataSourceErrorsAsJSONGraphErrors.', function(done) {
        var model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new Model({
                source: new ErrorDataSource(500, 'Oops!')
            }).asDataSource()
        });
        toObservable(model.
            get(['videos', 1234, 'summary'])).
            doAction(noOp, function(err) {
                expect(err).toEqual([{
                    path: ['videos', 1234, 'summary'],
                    value: {
                        message: 'Oops!',
                        status: 500
                    }
                }]);
            }).
            subscribe(noOp, function(err) {
                // ensure its the same error
                if (Array.isArray(err) && isPathValue(err[0])) {
                    done();
                } else {
                    done(err);
                }
            }, function() {
                done('On Completed was called. ' +
                     'OnError should have been called.');
            });
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 114, 'column': 8, 'index': 4322}","it('should report errors from a dataSource.', function(done) {
        var outputError;
        var model = new Model({
            source: new Model({
                source: new ErrorDataSource(500, 'Oops!')
            }).asDataSource()
        });
        toObservable(model.
            get(['videos', 1234, 'summary'])).
            doAction(noOp, function(err) {
                outputError = err;
                expect(err).toEqual({
                    $type: ""error"",
                    value: {
                        message: 'Oops!',
                        status: 500
                    }
                });
            }).
            subscribe(noOp, function(err) {
                // ensure its the same error
                if (outputError === err) {
                    done();
                } else {
                    done(err);
                }
            }, function() {
                done('On Completed was called. ' +
                     'OnError should have been called.');
            });
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 115, 'column': 8, 'index': 4347}","it('should report errors from a dataSource.', function(done) {
        var outputError;
        var model = new Model({
            source: new Model({
                source: new ErrorDataSource(500, 'Oops!')
            }).asDataSource()
        });
        toObservable(model.
            get(['videos', 1234, 'summary'])).
            doAction(noOp, function(err) {
                outputError = err;
                expect(err).toEqual({
                    $type: ""error"",
                    value: {
                        message: 'Oops!',
                        status: 500
                    }
                });
            }).
            subscribe(noOp, function(err) {
                // ensure its the same error
                if (outputError === err) {
                    done();
                } else {
                    done(err);
                }
            }, function() {
                done('On Completed was called. ' +
                     'OnError should have been called.');
            });
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 145, 'column': 8, 'index': 5374}","it(""should get all missing paths in a single request"", function(done) {
        var serviceCalls = 0;
        var cacheModel = new Model({
            cache: {
                lolomo: {
                    summary: {
                        $type: ""atom"",
                        value: ""hello""
                    },
                    0: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-0""
                        }
                    },
                    1: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-1""
                        }
                    },
                    2: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-2""
                        }
                    }
                }
            }
        });
        var model = new Model({ source: {
            get: function(paths) {
                serviceCalls++;
                return cacheModel.get.apply(cacheModel, paths)._toJSONG();
            }
        }});


        var onNext = jest.fn();
        toObservable(model.
            get(""lolomo.summary"", ""lolomo[0..2].summary"")).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                var data = onNext.mock.calls[0][0];
                var json = data.json;
                var lolomo = json.lolomo;
                expect(lolomo.summary).toBeDefined();
                expect(lolomo[0].summary).toBeDefined();
                expect(lolomo[1].summary).toBeDefined();
                expect(lolomo[2].summary).toBeDefined();
                expect(serviceCalls).toBe(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 146, 'column': 8, 'index': 5404}","it(""should get all missing paths in a single request"", function(done) {
        var serviceCalls = 0;
        var cacheModel = new Model({
            cache: {
                lolomo: {
                    summary: {
                        $type: ""atom"",
                        value: ""hello""
                    },
                    0: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-0""
                        }
                    },
                    1: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-1""
                        }
                    },
                    2: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-2""
                        }
                    }
                }
            }
        });
        var model = new Model({ source: {
            get: function(paths) {
                serviceCalls++;
                return cacheModel.get.apply(cacheModel, paths)._toJSONG();
            }
        }});


        var onNext = jest.fn();
        toObservable(model.
            get(""lolomo.summary"", ""lolomo[0..2].summary"")).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                var data = onNext.mock.calls[0][0];
                var json = data.json;
                var lolomo = json.lolomo;
                expect(lolomo.summary).toBeDefined();
                expect(lolomo[0].summary).toBeDefined();
                expect(lolomo[1].summary).toBeDefined();
                expect(lolomo[2].summary).toBeDefined();
                expect(serviceCalls).toBe(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 174, 'column': 8, 'index': 6254}","it(""should get all missing paths in a single request"", function(done) {
        var serviceCalls = 0;
        var cacheModel = new Model({
            cache: {
                lolomo: {
                    summary: {
                        $type: ""atom"",
                        value: ""hello""
                    },
                    0: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-0""
                        }
                    },
                    1: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-1""
                        }
                    },
                    2: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-2""
                        }
                    }
                }
            }
        });
        var model = new Model({ source: {
            get: function(paths) {
                serviceCalls++;
                return cacheModel.get.apply(cacheModel, paths)._toJSONG();
            }
        }});


        var onNext = jest.fn();
        toObservable(model.
            get(""lolomo.summary"", ""lolomo[0..2].summary"")).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                var data = onNext.mock.calls[0][0];
                var json = data.json;
                var lolomo = json.lolomo;
                expect(lolomo.summary).toBeDefined();
                expect(lolomo[0].summary).toBeDefined();
                expect(lolomo[1].summary).toBeDefined();
                expect(lolomo[2].summary).toBeDefined();
                expect(serviceCalls).toBe(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 182, 'column': 8, 'index': 6467}","it(""should get all missing paths in a single request"", function(done) {
        var serviceCalls = 0;
        var cacheModel = new Model({
            cache: {
                lolomo: {
                    summary: {
                        $type: ""atom"",
                        value: ""hello""
                    },
                    0: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-0""
                        }
                    },
                    1: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-1""
                        }
                    },
                    2: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-2""
                        }
                    }
                }
            }
        });
        var model = new Model({ source: {
            get: function(paths) {
                serviceCalls++;
                return cacheModel.get.apply(cacheModel, paths)._toJSONG();
            }
        }});


        var onNext = jest.fn();
        toObservable(model.
            get(""lolomo.summary"", ""lolomo[0..2].summary"")).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                var data = onNext.mock.calls[0][0];
                var json = data.json;
                var lolomo = json.lolomo;
                expect(lolomo.summary).toBeDefined();
                expect(lolomo[0].summary).toBeDefined();
                expect(lolomo[1].summary).toBeDefined();
                expect(lolomo[2].summary).toBeDefined();
                expect(serviceCalls).toBe(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 187, 'column': 16, 'index': 6671}","it(""should get all missing paths in a single request"", function(done) {
        var serviceCalls = 0;
        var cacheModel = new Model({
            cache: {
                lolomo: {
                    summary: {
                        $type: ""atom"",
                        value: ""hello""
                    },
                    0: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-0""
                        }
                    },
                    1: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-1""
                        }
                    },
                    2: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-2""
                        }
                    }
                }
            }
        });
        var model = new Model({ source: {
            get: function(paths) {
                serviceCalls++;
                return cacheModel.get.apply(cacheModel, paths)._toJSONG();
            }
        }});


        var onNext = jest.fn();
        toObservable(model.
            get(""lolomo.summary"", ""lolomo[0..2].summary"")).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                var data = onNext.mock.calls[0][0];
                var json = data.json;
                var lolomo = json.lolomo;
                expect(lolomo.summary).toBeDefined();
                expect(lolomo[0].summary).toBeDefined();
                expect(lolomo[1].summary).toBeDefined();
                expect(lolomo[2].summary).toBeDefined();
                expect(serviceCalls).toBe(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 188, 'column': 16, 'index': 6723}","it(""should get all missing paths in a single request"", function(done) {
        var serviceCalls = 0;
        var cacheModel = new Model({
            cache: {
                lolomo: {
                    summary: {
                        $type: ""atom"",
                        value: ""hello""
                    },
                    0: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-0""
                        }
                    },
                    1: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-1""
                        }
                    },
                    2: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-2""
                        }
                    }
                }
            }
        });
        var model = new Model({ source: {
            get: function(paths) {
                serviceCalls++;
                return cacheModel.get.apply(cacheModel, paths)._toJSONG();
            }
        }});


        var onNext = jest.fn();
        toObservable(model.
            get(""lolomo.summary"", ""lolomo[0..2].summary"")).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                var data = onNext.mock.calls[0][0];
                var json = data.json;
                var lolomo = json.lolomo;
                expect(lolomo.summary).toBeDefined();
                expect(lolomo[0].summary).toBeDefined();
                expect(lolomo[1].summary).toBeDefined();
                expect(lolomo[2].summary).toBeDefined();
                expect(serviceCalls).toBe(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Global Variable,"{'line': 189, 'column': 16, 'index': 6761}","it(""should get all missing paths in a single request"", function(done) {
        var serviceCalls = 0;
        var cacheModel = new Model({
            cache: {
                lolomo: {
                    summary: {
                        $type: ""atom"",
                        value: ""hello""
                    },
                    0: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-0""
                        }
                    },
                    1: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-1""
                        }
                    },
                    2: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-2""
                        }
                    }
                }
            }
        });
        var model = new Model({ source: {
            get: function(paths) {
                serviceCalls++;
                return cacheModel.get.apply(cacheModel, paths)._toJSONG();
            }
        }});


        var onNext = jest.fn();
        toObservable(model.
            get(""lolomo.summary"", ""lolomo[0..2].summary"")).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                var data = onNext.mock.calls[0][0];
                var json = data.json;
                var lolomo = json.lolomo;
                expect(lolomo.summary).toBeDefined();
                expect(lolomo[0].summary).toBeDefined();
                expect(lolomo[1].summary).toBeDefined();
                expect(lolomo[2].summary).toBeDefined();
                expect(serviceCalls).toBe(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Lazy Test,"{'line': 18, 'column': 8, 'index': 711}","it('should return the correct empty envelope.', function(done) {
        var model = new Model({
            cache: {foo: 1}
        }).asDataSource();
        var onNext = jest.fn();
        toObservable(model.
            get([])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    jsonGraph: {},
                    paths: []
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Lazy Test,"{'line': 33, 'column': 48, 'index': 1292}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'Video 0'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Lazy Test,"{'line': 37, 'column': 12, 'index': 1412}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title'])).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: 'Video 0'
                                }
                            }
                        }
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Lazy Test,"{'line': 58, 'column': 48, 'index': 2240}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: atom('Video 0')
                                }
                            }
                        },
                        paths: [
                            ['videos', 0, 'title']
                        ]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Lazy Test,"{'line': 62, 'column': 12, 'index': 2360}","it('should get a value from falcor.', function(done) {
            var model = new Model({
                source: new Model({
                    source: new LocalDataSource(cacheGenerator(0, 1))
                }).asDataSource()
            });
            var onNext = jest.fn();
            toObservable(model.
                get(['videos', 0, 'title']).
                _toJSONG()).
                doAction(onNext, noOp, function() {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        jsonGraph: {
                            videos: {
                                0: {
                                    title: atom('Video 0')
                                }
                            }
                        },
                        paths: [
                            ['videos', 0, 'title']
                        ]
                    });
                }).
                subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Lazy Test,"{'line': 90, 'column': 8, 'index': 3460}","it('should report errors from a dataSource with _treatDataSourceErrorsAsJSONGraphErrors.', function(done) {
        var model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new Model({
                source: new ErrorDataSource(500, 'Oops!')
            }).asDataSource()
        });
        toObservable(model.
            get(['videos', 1234, 'summary'])).
            doAction(noOp, function(err) {
                expect(err).toEqual([{
                    path: ['videos', 1234, 'summary'],
                    value: {
                        message: 'Oops!',
                        status: 500
                    }
                }]);
            }).
            subscribe(noOp, function(err) {
                // ensure its the same error
                if (Array.isArray(err) && isPathValue(err[0])) {
                    done();
                } else {
                    done(err);
                }
            }, function() {
                done('On Completed was called. ' +
                     'OnError should have been called.');
            });
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Lazy Test,"{'line': 120, 'column': 8, 'index': 4511}","it('should report errors from a dataSource.', function(done) {
        var outputError;
        var model = new Model({
            source: new Model({
                source: new ErrorDataSource(500, 'Oops!')
            }).asDataSource()
        });
        toObservable(model.
            get(['videos', 1234, 'summary'])).
            doAction(noOp, function(err) {
                outputError = err;
                expect(err).toEqual({
                    $type: ""error"",
                    value: {
                        message: 'Oops!',
                        status: 500
                    }
                });
            }).
            subscribe(noOp, function(err) {
                // ensure its the same error
                if (outputError === err) {
                    done();
                } else {
                    done(err);
                }
            }, function() {
                done('On Completed was called. ' +
                     'OnError should have been called.');
            });
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Lazy Test,"{'line': 183, 'column': 8, 'index': 6499}","it(""should get all missing paths in a single request"", function(done) {
        var serviceCalls = 0;
        var cacheModel = new Model({
            cache: {
                lolomo: {
                    summary: {
                        $type: ""atom"",
                        value: ""hello""
                    },
                    0: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-0""
                        }
                    },
                    1: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-1""
                        }
                    },
                    2: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-2""
                        }
                    }
                }
            }
        });
        var model = new Model({ source: {
            get: function(paths) {
                serviceCalls++;
                return cacheModel.get.apply(cacheModel, paths)._toJSONG();
            }
        }});


        var onNext = jest.fn();
        toObservable(model.
            get(""lolomo.summary"", ""lolomo[0..2].summary"")).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                var data = onNext.mock.calls[0][0];
                var json = data.json;
                var lolomo = json.lolomo;
                expect(lolomo.summary).toBeDefined();
                expect(lolomo[0].summary).toBeDefined();
                expect(lolomo[1].summary).toBeDefined();
                expect(lolomo[2].summary).toBeDefined();
                expect(serviceCalls).toBe(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.cacheAsDataSource.spec.js,Magic Number,"{'line': 194, 'column': 42, 'index': 7054}","it(""should get all missing paths in a single request"", function(done) {
        var serviceCalls = 0;
        var cacheModel = new Model({
            cache: {
                lolomo: {
                    summary: {
                        $type: ""atom"",
                        value: ""hello""
                    },
                    0: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-0""
                        }
                    },
                    1: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-1""
                        }
                    },
                    2: {
                        summary: {
                            $type: ""atom"",
                            value: ""hello-2""
                        }
                    }
                }
            }
        });
        var model = new Model({ source: {
            get: function(paths) {
                serviceCalls++;
                return cacheModel.get.apply(cacheModel, paths)._toJSONG();
            }
        }});


        var onNext = jest.fn();
        toObservable(model.
            get(""lolomo.summary"", ""lolomo[0..2].summary"")).
            doAction(onNext).
            doAction(noOp, noOp, function() {
                var data = onNext.mock.calls[0][0];
                var json = data.json;
                var lolomo = json.lolomo;
                expect(lolomo.summary).toBeDefined();
                expect(lolomo[0].summary).toBeDefined();
                expect(lolomo[1].summary).toBeDefined();
                expect(lolomo[2].summary).toBeDefined();
                expect(serviceCalls).toBe(1);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/get/get.cache-only.spec.js,Conditional Test Logic,"{'line': 74, 'column': 20, 'index': 2842}","it(""should use a promise to get request."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            const onError = jest.fn();
            model
                .get([""videos"", 0, ""title""])
                .then(onNext, onError)
                .then(() => {
                    if (onError.mock.calls[0]) {
                        throw onError.mock.calls[0][0];
                    }

                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0"",
                                },
                            },
                        },
                    });
                })
                .then(() => {
                    done();
                }, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Eager Test,"{'line': 12, 'column': 23, 'index': 451}","it(""should get a value from falcor."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            toObservable(model.get([""videos"", 0, ""title""]))
                .doAction(onNext, noOp, () => {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0"",
                                },
                            },
                        },
                    });
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Eager Test,"{'line': 15, 'column': 12, 'index': 539}","it(""should get a value from falcor."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            toObservable(model.get([""videos"", 0, ""title""]))
                .doAction(onNext, noOp, () => {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0"",
                                },
                            },
                        },
                    });
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Eager Test,"{'line': 32, 'column': 23, 'index': 1250}","it(""should onNext, then complete on empty paths."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            toObservable(model.get([""videos"", [], ""title""]))
                .doAction(onNext, noOp, () => {
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {},
                        },
                    });
                    expect(onNext).toHaveBeenCalledTimes(1);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Eager Test,"{'line': 35, 'column': 12, 'index': 1338}","it(""should onNext, then complete on empty paths."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            toObservable(model.get([""videos"", [], ""title""]))
                .doAction(onNext, noOp, () => {
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {},
                        },
                    });
                    expect(onNext).toHaveBeenCalledTimes(1);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Eager Test,"{'line': 49, 'column': 23, 'index': 1888}","it(""should not void data on empty paths."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            toObservable(model.get([""videos"", 0, ""title""], [""videos"", [], ""title""]))
                .doAction(onNext, noOp, () => {
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: { 0: { title: ""Video 0"" } },
                        },
                    });
                    expect(onNext).toHaveBeenCalledTimes(1);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Eager Test,"{'line': 52, 'column': 12, 'index': 1976}","it(""should not void data on empty paths."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            toObservable(model.get([""videos"", 0, ""title""], [""videos"", [], ""title""]))
                .doAction(onNext, noOp, () => {
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: { 0: { title: ""Video 0"" } },
                        },
                    });
                    expect(onNext).toHaveBeenCalledTimes(1);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Eager Test,"{'line': 98, 'column': 23, 'index': 3632}","it(""should get a value from falcor."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 30),
            });
            const onNext = jest.fn();
            toObservable(
                model.get([""lolomo"", 0, 0, ""item"", ""title""])._toJSONG()
            )
                .doAction(onNext, noOp, () => {
                    const out = clean(onNext.mock.calls[0][0]);
                    const expected = clean({
                        jsonGraph: cacheGenerator(0, 1),
                        paths: [[""lolomo"", 0, 0, ""item"", ""title""]],
                    });
                    expect(out).toEqual(expected);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Eager Test,"{'line': 101, 'column': 12, 'index': 3721}","it(""should get a value from falcor."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 30),
            });
            const onNext = jest.fn();
            toObservable(
                model.get([""lolomo"", 0, 0, ""item"", ""title""])._toJSONG()
            )
                .doAction(onNext, noOp, () => {
                    const out = clean(onNext.mock.calls[0][0]);
                    const expected = clean({
                        jsonGraph: cacheGenerator(0, 1),
                        paths: [[""lolomo"", 0, 0, ""item"", ""title""]],
                    });
                    expect(out).toEqual(expected);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Eager Test,"{'line': 107, 'column': 35, 'index': 4013}","it(""should get a value from falcor."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 30),
            });
            const onNext = jest.fn();
            toObservable(
                model.get([""lolomo"", 0, 0, ""item"", ""title""])._toJSONG()
            )
                .doAction(onNext, noOp, () => {
                    const out = clean(onNext.mock.calls[0][0]);
                    const expected = clean({
                        jsonGraph: cacheGenerator(0, 1),
                        paths: [[""lolomo"", 0, 0, ""item"", ""title""]],
                    });
                    expect(out).toEqual(expected);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Exception Handling,"{'line': 75, 'column': 24, 'index': 2895}","it(""should use a promise to get request."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            const onError = jest.fn();
            model
                .get([""videos"", 0, ""title""])
                .then(onNext, onError)
                .then(() => {
                    if (onError.mock.calls[0]) {
                        throw onError.mock.calls[0][0];
                    }

                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0"",
                                },
                            },
                        },
                    });
                })
                .then(() => {
                    done();
                }, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Lazy Test,"{'line': 12, 'column': 23, 'index': 451}","it(""should get a value from falcor."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            toObservable(model.get([""videos"", 0, ""title""]))
                .doAction(onNext, noOp, () => {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0"",
                                },
                            },
                        },
                    });
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Lazy Test,"{'line': 15, 'column': 12, 'index': 539}","it(""should get a value from falcor."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            toObservable(model.get([""videos"", 0, ""title""]))
                .doAction(onNext, noOp, () => {
                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0"",
                                },
                            },
                        },
                    });
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Lazy Test,"{'line': 32, 'column': 23, 'index': 1250}","it(""should onNext, then complete on empty paths."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            toObservable(model.get([""videos"", [], ""title""]))
                .doAction(onNext, noOp, () => {
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {},
                        },
                    });
                    expect(onNext).toHaveBeenCalledTimes(1);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Lazy Test,"{'line': 35, 'column': 12, 'index': 1338}","it(""should onNext, then complete on empty paths."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            toObservable(model.get([""videos"", [], ""title""]))
                .doAction(onNext, noOp, () => {
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {},
                        },
                    });
                    expect(onNext).toHaveBeenCalledTimes(1);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Lazy Test,"{'line': 49, 'column': 23, 'index': 1888}","it(""should not void data on empty paths."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            toObservable(model.get([""videos"", 0, ""title""], [""videos"", [], ""title""]))
                .doAction(onNext, noOp, () => {
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: { 0: { title: ""Video 0"" } },
                        },
                    });
                    expect(onNext).toHaveBeenCalledTimes(1);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Lazy Test,"{'line': 52, 'column': 12, 'index': 1976}","it(""should not void data on empty paths."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            toObservable(model.get([""videos"", 0, ""title""], [""videos"", [], ""title""]))
                .doAction(onNext, noOp, () => {
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: { 0: { title: ""Video 0"" } },
                        },
                    });
                    expect(onNext).toHaveBeenCalledTimes(1);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Lazy Test,"{'line': 66, 'column': 23, 'index': 2575}","it(""should use a promise to get request."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 1),
            });
            const onNext = jest.fn();
            const onError = jest.fn();
            model
                .get([""videos"", 0, ""title""])
                .then(onNext, onError)
                .then(() => {
                    if (onError.mock.calls[0]) {
                        throw onError.mock.calls[0][0];
                    }

                    expect(onNext).toHaveBeenCalledTimes(1);
                    expect(clean(onNext.mock.calls[0][0])).toEqual({
                        json: {
                            videos: {
                                0: {
                                    title: ""Video 0"",
                                },
                            },
                        },
                    });
                })
                .then(() => {
                    done();
                }, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Lazy Test,"{'line': 98, 'column': 23, 'index': 3632}","it(""should get a value from falcor."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 30),
            });
            const onNext = jest.fn();
            toObservable(
                model.get([""lolomo"", 0, 0, ""item"", ""title""])._toJSONG()
            )
                .doAction(onNext, noOp, () => {
                    const out = clean(onNext.mock.calls[0][0]);
                    const expected = clean({
                        jsonGraph: cacheGenerator(0, 1),
                        paths: [[""lolomo"", 0, 0, ""item"", ""title""]],
                    });
                    expect(out).toEqual(expected);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/get/get.cache-only.spec.js,Lazy Test,"{'line': 101, 'column': 12, 'index': 3721}","it(""should get a value from falcor."", done => {
            const model = new Model({
                cache: cacheGenerator(0, 30),
            });
            const onNext = jest.fn();
            toObservable(
                model.get([""lolomo"", 0, 0, ""item"", ""title""])._toJSONG()
            )
                .doAction(onNext, noOp, () => {
                    const out = clean(onNext.mock.calls[0][0]);
                    const expected = clean({
                        jsonGraph: cacheGenerator(0, 1),
                        paths: [[""lolomo"", 0, 0, ""item"", ""title""]],
                    });
                    expect(out).toEqual(expected);
                })
                .subscribe(noOp, done, done);
        })",steel
/test/falcor/error/error.spec.js,Conditional Test Logic,"{'line': 19, 'column': 8, 'index': 620}",Unknown,steel
/test/falcor/error/error.spec.js,Conditional Test Logic,"{'line': 65, 'column': 16, 'index': 2195}","it(""should get a hard error from the DataSource with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            _treatDataSourceErrorsAsJSONGraphErrors: true
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {},
                            2: {},
                            3: {},
                            4: {},
                            5: {}
                        }
                    }
                });
                expect(err.length).toBe(6);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Conditional Test Logic,"{'line': 96, 'column': 16, 'index': 3118}","it(""should get a hard error from the DataSource."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout"")
        });
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(noOp, function(err) {
                // not in boxValue mode
                var expected = {
                    $type: ""error"",
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };

                expect(err).toEqual(expected);
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Conditional Test Logic,"{'line': 323, 'column': 16, 'index': 11041}","it('should allow for dataSources to immediately throw an error (set)', function(done) {
        var routes = {
            set: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            set({
                paths: [['titlesById', 242, 'rating']],
                jsonGraph: {
                    titlesById: {
                        242: {
                            rating: 5
                        }
                    }
                }
            })).
            doAction(onNext, onError).
            doAction(noOp, function() {
                expect(onNext).not.toHaveBeenCalled();
                expect(onError).toHaveBeenCalledTimes(1);
                expect(onError.mock.calls[0][0].name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Conditional Test Logic,"{'line': 351, 'column': 16, 'index': 12021}","it('should allow for dataSources to immediately throw an error (get)', function(done) {
        var routes = {
            get: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            get(['path', 'to', 'value'])).
            doAction(onNext, function(e) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                })
                expect(e.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Conditional Test Logic,"{'line': 374, 'column': 16, 'index': 12872}","it('should allow for dataSources to immediately throw an error (call)', function(done) {
        var routes = {
            call: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        toObservable(model.
            call(['videos', 1234, 'rating'], 5)).
            doAction(onNext).
            doAction(noOp, function(err) {
                expect(onNext).not.toHaveBeenCalled();
                expect(err.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Eager Test,"{'line': 33, 'column': 8, 'index': 1066}","it(""should get a hard error from the DataSource with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            _treatDataSourceErrorsAsJSONGraphErrors: true
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {},
                            2: {},
                            3: {},
                            4: {},
                            5: {}
                        }
                    }
                });
                expect(err.length).toBe(6);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Eager Test,"{'line': 65, 'column': 20, 'index': 2199}","it(""should get a hard error from the DataSource with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            _treatDataSourceErrorsAsJSONGraphErrors: true
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {},
                            2: {},
                            3: {},
                            4: {},
                            5: {}
                        }
                    }
                });
                expect(err.length).toBe(6);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Eager Test,"{'line': 80, 'column': 8, 'index': 2614}","it(""should get a hard error from the DataSource."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout"")
        });
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(noOp, function(err) {
                // not in boxValue mode
                var expected = {
                    $type: ""error"",
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };

                expect(err).toEqual(expected);
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Eager Test,"{'line': 96, 'column': 20, 'index': 3122}","it(""should get a hard error from the DataSource."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout"")
        });
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(noOp, function(err) {
                // not in boxValue mode
                var expected = {
                    $type: ""error"",
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };

                expect(err).toEqual(expected);
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Eager Test,"{'line': 305, 'column': 8, 'index': 10381}","it('should allow for dataSources to immediately throw an error (set)', function(done) {
        var routes = {
            set: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            set({
                paths: [['titlesById', 242, 'rating']],
                jsonGraph: {
                    titlesById: {
                        242: {
                            rating: 5
                        }
                    }
                }
            })).
            doAction(onNext, onError).
            doAction(noOp, function() {
                expect(onNext).not.toHaveBeenCalled();
                expect(onError).toHaveBeenCalledTimes(1);
                expect(onError.mock.calls[0][0].name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Eager Test,"{'line': 323, 'column': 20, 'index': 11045}","it('should allow for dataSources to immediately throw an error (set)', function(done) {
        var routes = {
            set: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            set({
                paths: [['titlesById', 242, 'rating']],
                jsonGraph: {
                    titlesById: {
                        242: {
                            rating: 5
                        }
                    }
                }
            })).
            doAction(onNext, onError).
            doAction(noOp, function() {
                expect(onNext).not.toHaveBeenCalled();
                expect(onError).toHaveBeenCalledTimes(1);
                expect(onError.mock.calls[0][0].name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Eager Test,"{'line': 339, 'column': 8, 'index': 11587}","it('should allow for dataSources to immediately throw an error (get)', function(done) {
        var routes = {
            get: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            get(['path', 'to', 'value'])).
            doAction(onNext, function(e) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                })
                expect(e.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Eager Test,"{'line': 351, 'column': 20, 'index': 12025}","it('should allow for dataSources to immediately throw an error (get)', function(done) {
        var routes = {
            get: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            get(['path', 'to', 'value'])).
            doAction(onNext, function(e) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                })
                expect(e.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Eager Test,"{'line': 366, 'column': 8, 'index': 12536}","it('should allow for dataSources to immediately throw an error (call)', function(done) {
        var routes = {
            call: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        toObservable(model.
            call(['videos', 1234, 'rating'], 5)).
            doAction(onNext).
            doAction(noOp, function(err) {
                expect(onNext).not.toHaveBeenCalled();
                expect(err.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Eager Test,"{'line': 374, 'column': 20, 'index': 12876}","it('should allow for dataSources to immediately throw an error (call)', function(done) {
        var routes = {
            call: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        toObservable(model.
            call(['videos', 1234, 'rating'], 5)).
            doAction(onNext).
            doAction(noOp, function(err) {
                expect(onNext).not.toHaveBeenCalled();
                expect(err.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 206}",Unknown,steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 6, 'column': 0, 'index': 232}",Unknown,steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 28, 'column': 8, 'index': 875}","it(""should get a hard error from the DataSource with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            _treatDataSourceErrorsAsJSONGraphErrors: true
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {},
                            2: {},
                            3: {},
                            4: {},
                            5: {}
                        }
                    }
                });
                expect(err.length).toBe(6);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 32, 'column': 8, 'index': 1034}","it(""should get a hard error from the DataSource with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            _treatDataSourceErrorsAsJSONGraphErrors: true
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {},
                            2: {},
                            3: {},
                            4: {},
                            5: {}
                        }
                    }
                });
                expect(err.length).toBe(6);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 51, 'column': 16, 'index': 1738}","it(""should get a hard error from the DataSource with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            _treatDataSourceErrorsAsJSONGraphErrors: true
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {},
                            2: {},
                            3: {},
                            4: {},
                            5: {}
                        }
                    }
                });
                expect(err.length).toBe(6);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 77, 'column': 8, 'index': 2514}","it(""should get a hard error from the DataSource."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout"")
        });
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(noOp, function(err) {
                // not in boxValue mode
                var expected = {
                    $type: ""error"",
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };

                expect(err).toEqual(expected);
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 84, 'column': 16, 'index': 2781}","it(""should get a hard error from the DataSource."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout"")
        });
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(noOp, function(err) {
                // not in boxValue mode
                var expected = {
                    $type: ""error"",
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };

                expect(err).toEqual(expected);
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 108, 'column': 8, 'index': 3516}","it(""should get a hard error from the DataSource with some data found in the cache with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new ErrorDataSource(503, ""Timeout""),
            cache: {
                test: {
                    0: {
                        summary: ""in cache""
                    },
                    5: {
                        summary: ""in cache""
                    }
                }
            }
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                // Ensure onNext is called correctly
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(err.length).toBe(4);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i + 1, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 122, 'column': 8, 'index': 3936}","it(""should get a hard error from the DataSource with some data found in the cache with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new ErrorDataSource(503, ""Timeout""),
            cache: {
                test: {
                    0: {
                        summary: ""in cache""
                    },
                    5: {
                        summary: ""in cache""
                    }
                }
            }
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                // Ensure onNext is called correctly
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(err.length).toBe(4);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i + 1, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 131, 'column': 16, 'index': 4292}","it(""should get a hard error from the DataSource with some data found in the cache with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new ErrorDataSource(503, ""Timeout""),
            cache: {
                test: {
                    0: {
                        summary: ""in cache""
                    },
                    5: {
                        summary: ""in cache""
                    }
                }
            }
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                // Ensure onNext is called correctly
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(err.length).toBe(4);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i + 1, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 147, 'column': 8, 'index': 4878}","it(""should get a hard error from the DataSource with some data found in the cache."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            cache: {
                test: {
                    0: {
                        summary: ""in cache""
                    },
                    5: {
                        summary: ""in cache""
                    }
                }
            }
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {
                                summary: 'in cache'
                            },
                            5: {
                                summary: 'in cache'
                            }
                        }
                    }
                });

                // not in boxValue mode
                var expected = {
                    $type: ""error"",
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                expect(err).toEqual(expected);
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 160, 'column': 8, 'index': 5239}","it(""should get a hard error from the DataSource with some data found in the cache."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            cache: {
                test: {
                    0: {
                        summary: ""in cache""
                    },
                    5: {
                        summary: ""in cache""
                    }
                }
            }
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {
                                summary: 'in cache'
                            },
                            5: {
                                summary: 'in cache'
                            }
                        }
                    }
                });

                // not in boxValue mode
                var expected = {
                    $type: ""error"",
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                expect(err).toEqual(expected);
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 180, 'column': 16, 'index': 5923}","it(""should get a hard error from the DataSource with some data found in the cache."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            cache: {
                test: {
                    0: {
                        summary: ""in cache""
                    },
                    5: {
                        summary: ""in cache""
                    }
                }
            }
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {
                                summary: 'in cache'
                            },
                            5: {
                                summary: 'in cache'
                            }
                        }
                    }
                });

                // not in boxValue mode
                var expected = {
                    $type: ""error"",
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                expect(err).toEqual(expected);
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 193, 'column': 8, 'index': 6347}","it(""should onNext when only receiving errors."", function(done) {
        var model = new Model({
            source: new Model({
                cache: {
                    test: {
                        0: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        },
                        1: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        }
                    }
                }
            }).asDataSource()
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 1}, ""summary""])).
            doAction(onNext, function(err) {

                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {}
                        }
                    }
                });

                // not in boxValue mode
                var expected = [
                    {""path"":[""test"",0,""summary""],""value"":{""message"":""Oops!"",""status"":500}},
                    {""path"":[""test"",1,""summary""],""value"":{""message"":""Oops!"",""status"":500}}
                ];
                expect(err).toEqual(expected);
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 219, 'column': 8, 'index': 7245}","it(""should onNext when only receiving errors."", function(done) {
        var model = new Model({
            source: new Model({
                cache: {
                    test: {
                        0: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        },
                        1: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        }
                    }
                }
            }).asDataSource()
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 1}, ""summary""])).
            doAction(onNext, function(err) {

                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {}
                        }
                    }
                });

                // not in boxValue mode
                var expected = [
                    {""path"":[""test"",0,""summary""],""value"":{""message"":""Oops!"",""status"":500}},
                    {""path"":[""test"",1,""summary""],""value"":{""message"":""Oops!"",""status"":500}}
                ];
                expect(err).toEqual(expected);
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 235, 'column': 16, 'index': 7767}","it(""should onNext when only receiving errors."", function(done) {
        var model = new Model({
            source: new Model({
                cache: {
                    test: {
                        0: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        },
                        1: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        }
                    }
                }
            }).asDataSource()
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 1}, ""summary""])).
            doAction(onNext, function(err) {

                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {}
                        }
                    }
                });

                // not in boxValue mode
                var expected = [
                    {""path"":[""test"",0,""summary""],""value"":{""message"":""Oops!"",""status"":500}},
                    {""path"":[""test"",1,""summary""],""value"":{""message"":""Oops!"",""status"":500}}
                ];
                expect(err).toEqual(expected);
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 245, 'column': 8, 'index': 8220}","it(""should onNext when receiving errors and missing paths."", function(done) {
        var model = new Model({
            source: new Model({
                cache: {
                    test: {
                        0: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        },
                        5: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        }
                    }
                }
            }).asDataSource()
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0]), 'json from onNext').toEqual({
                    json: {
                        test: {
                            0: {},
                            5: {}
                        }
                    }
                });

                // not in boxValue mode
                var expected = [
                    {""path"":[""test"",0,""summary""],""value"":{""message"":""Oops!"",""status"":500}},
                    {""path"":[""test"",5,""summary""],""value"":{""message"":""Oops!"",""status"":500}}
                ];
                expect(err).toEqual(expected);
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 271, 'column': 8, 'index': 9118}","it(""should onNext when receiving errors and missing paths."", function(done) {
        var model = new Model({
            source: new Model({
                cache: {
                    test: {
                        0: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        },
                        5: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        }
                    }
                }
            }).asDataSource()
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0]), 'json from onNext').toEqual({
                    json: {
                        test: {
                            0: {},
                            5: {}
                        }
                    }
                });

                // not in boxValue mode
                var expected = [
                    {""path"":[""test"",0,""summary""],""value"":{""message"":""Oops!"",""status"":500}},
                    {""path"":[""test"",5,""summary""],""value"":{""message"":""Oops!"",""status"":500}}
                ];
                expect(err).toEqual(expected);
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 287, 'column': 16, 'index': 9660}","it(""should onNext when receiving errors and missing paths."", function(done) {
        var model = new Model({
            source: new Model({
                cache: {
                    test: {
                        0: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        },
                        5: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        }
                    }
                }
            }).asDataSource()
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0]), 'json from onNext').toEqual({
                    json: {
                        test: {
                            0: {},
                            5: {}
                        }
                    }
                });

                // not in boxValue mode
                var expected = [
                    {""path"":[""test"",0,""summary""],""value"":{""message"":""Oops!"",""status"":500}},
                    {""path"":[""test"",5,""summary""],""value"":{""message"":""Oops!"",""status"":500}}
                ];
                expect(err).toEqual(expected);
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 297, 'column': 8, 'index': 10123}","it('should allow for dataSources to immediately throw an error (set)', function(done) {
        var routes = {
            set: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            set({
                paths: [['titlesById', 242, 'rating']],
                jsonGraph: {
                    titlesById: {
                        242: {
                            rating: 5
                        }
                    }
                }
            })).
            doAction(onNext, onError).
            doAction(noOp, function() {
                expect(onNext).not.toHaveBeenCalled();
                expect(onError).toHaveBeenCalledTimes(1);
                expect(onError.mock.calls[0][0].name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 302, 'column': 8, 'index': 10258}","it('should allow for dataSources to immediately throw an error (set)', function(done) {
        var routes = {
            set: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            set({
                paths: [['titlesById', 242, 'rating']],
                jsonGraph: {
                    titlesById: {
                        242: {
                            rating: 5
                        }
                    }
                }
            })).
            doAction(onNext, onError).
            doAction(noOp, function() {
                expect(onNext).not.toHaveBeenCalled();
                expect(onError).toHaveBeenCalledTimes(1);
                expect(onError.mock.calls[0][0].name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 303, 'column': 8, 'index': 10316}","it('should allow for dataSources to immediately throw an error (set)', function(done) {
        var routes = {
            set: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            set({
                paths: [['titlesById', 242, 'rating']],
                jsonGraph: {
                    titlesById: {
                        242: {
                            rating: 5
                        }
                    }
                }
            })).
            doAction(onNext, onError).
            doAction(noOp, function() {
                expect(onNext).not.toHaveBeenCalled();
                expect(onError).toHaveBeenCalledTimes(1);
                expect(onError.mock.calls[0][0].name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 304, 'column': 8, 'index': 10348}","it('should allow for dataSources to immediately throw an error (set)', function(done) {
        var routes = {
            set: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            set({
                paths: [['titlesById', 242, 'rating']],
                jsonGraph: {
                    titlesById: {
                        242: {
                            rating: 5
                        }
                    }
                }
            })).
            doAction(onNext, onError).
            doAction(noOp, function() {
                expect(onNext).not.toHaveBeenCalled();
                expect(onError).toHaveBeenCalledTimes(1);
                expect(onError.mock.calls[0][0].name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 331, 'column': 8, 'index': 11329}","it('should allow for dataSources to immediately throw an error (get)', function(done) {
        var routes = {
            get: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            get(['path', 'to', 'value'])).
            doAction(onNext, function(e) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                })
                expect(e.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 336, 'column': 8, 'index': 11464}","it('should allow for dataSources to immediately throw an error (get)', function(done) {
        var routes = {
            get: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            get(['path', 'to', 'value'])).
            doAction(onNext, function(e) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                })
                expect(e.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 337, 'column': 8, 'index': 11522}","it('should allow for dataSources to immediately throw an error (get)', function(done) {
        var routes = {
            get: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            get(['path', 'to', 'value'])).
            doAction(onNext, function(e) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                })
                expect(e.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 338, 'column': 8, 'index': 11554}","it('should allow for dataSources to immediately throw an error (get)', function(done) {
        var routes = {
            get: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            get(['path', 'to', 'value'])).
            doAction(onNext, function(e) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                })
                expect(e.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 359, 'column': 8, 'index': 12310}","it('should allow for dataSources to immediately throw an error (call)', function(done) {
        var routes = {
            call: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        toObservable(model.
            call(['videos', 1234, 'rating'], 5)).
            doAction(onNext).
            doAction(noOp, function(err) {
                expect(onNext).not.toHaveBeenCalled();
                expect(err.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 364, 'column': 8, 'index': 12446}","it('should allow for dataSources to immediately throw an error (call)', function(done) {
        var routes = {
            call: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        toObservable(model.
            call(['videos', 1234, 'rating'], 5)).
            doAction(onNext).
            doAction(noOp, function(err) {
                expect(onNext).not.toHaveBeenCalled();
                expect(err.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Global Variable,"{'line': 365, 'column': 8, 'index': 12504}","it('should allow for dataSources to immediately throw an error (call)', function(done) {
        var routes = {
            call: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        toObservable(model.
            call(['videos', 1234, 'rating'], 5)).
            doAction(onNext).
            doAction(noOp, function(err) {
                expect(onNext).not.toHaveBeenCalled();
                expect(err.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 33, 'column': 8, 'index': 1066}","it(""should get a hard error from the DataSource with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            _treatDataSourceErrorsAsJSONGraphErrors: true
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {},
                            2: {},
                            3: {},
                            4: {},
                            5: {}
                        }
                    }
                });
                expect(err.length).toBe(6);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 65, 'column': 20, 'index': 2199}","it(""should get a hard error from the DataSource with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            _treatDataSourceErrorsAsJSONGraphErrors: true
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {},
                            2: {},
                            3: {},
                            4: {},
                            5: {}
                        }
                    }
                });
                expect(err.length).toBe(6);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 80, 'column': 8, 'index': 2614}","it(""should get a hard error from the DataSource."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout"")
        });
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(noOp, function(err) {
                // not in boxValue mode
                var expected = {
                    $type: ""error"",
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };

                expect(err).toEqual(expected);
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 96, 'column': 20, 'index': 3122}","it(""should get a hard error from the DataSource."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout"")
        });
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(noOp, function(err) {
                // not in boxValue mode
                var expected = {
                    $type: ""error"",
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };

                expect(err).toEqual(expected);
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 123, 'column': 8, 'index': 3968}","it(""should get a hard error from the DataSource with some data found in the cache with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new ErrorDataSource(503, ""Timeout""),
            cache: {
                test: {
                    0: {
                        summary: ""in cache""
                    },
                    5: {
                        summary: ""in cache""
                    }
                }
            }
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                // Ensure onNext is called correctly
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(err.length).toBe(4);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i + 1, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 161, 'column': 8, 'index': 5271}","it(""should get a hard error from the DataSource with some data found in the cache."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            cache: {
                test: {
                    0: {
                        summary: ""in cache""
                    },
                    5: {
                        summary: ""in cache""
                    }
                }
            }
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {
                                summary: 'in cache'
                            },
                            5: {
                                summary: 'in cache'
                            }
                        }
                    }
                });

                // not in boxValue mode
                var expected = {
                    $type: ""error"",
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                expect(err).toEqual(expected);
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 220, 'column': 8, 'index': 7277}","it(""should onNext when only receiving errors."", function(done) {
        var model = new Model({
            source: new Model({
                cache: {
                    test: {
                        0: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        },
                        1: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        }
                    }
                }
            }).asDataSource()
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 1}, ""summary""])).
            doAction(onNext, function(err) {

                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {}
                        }
                    }
                });

                // not in boxValue mode
                var expected = [
                    {""path"":[""test"",0,""summary""],""value"":{""message"":""Oops!"",""status"":500}},
                    {""path"":[""test"",1,""summary""],""value"":{""message"":""Oops!"",""status"":500}}
                ];
                expect(err).toEqual(expected);
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 272, 'column': 8, 'index': 9150}","it(""should onNext when receiving errors and missing paths."", function(done) {
        var model = new Model({
            source: new Model({
                cache: {
                    test: {
                        0: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        },
                        5: {
                            summary: {
                                $type: 'error',
                                value: {
                                    message: 'Oops!',
                                    status: 500
                                }
                            }
                        }
                    }
                }
            }).asDataSource()
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0]), 'json from onNext').toEqual({
                    json: {
                        test: {
                            0: {},
                            5: {}
                        }
                    }
                });

                // not in boxValue mode
                var expected = [
                    {""path"":[""test"",0,""summary""],""value"":{""message"":""Oops!"",""status"":500}},
                    {""path"":[""test"",5,""summary""],""value"":{""message"":""Oops!"",""status"":500}}
                ];
                expect(err).toEqual(expected);
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 305, 'column': 8, 'index': 10381}","it('should allow for dataSources to immediately throw an error (set)', function(done) {
        var routes = {
            set: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            set({
                paths: [['titlesById', 242, 'rating']],
                jsonGraph: {
                    titlesById: {
                        242: {
                            rating: 5
                        }
                    }
                }
            })).
            doAction(onNext, onError).
            doAction(noOp, function() {
                expect(onNext).not.toHaveBeenCalled();
                expect(onError).toHaveBeenCalledTimes(1);
                expect(onError.mock.calls[0][0].name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 323, 'column': 20, 'index': 11045}","it('should allow for dataSources to immediately throw an error (set)', function(done) {
        var routes = {
            set: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            set({
                paths: [['titlesById', 242, 'rating']],
                jsonGraph: {
                    titlesById: {
                        242: {
                            rating: 5
                        }
                    }
                }
            })).
            doAction(onNext, onError).
            doAction(noOp, function() {
                expect(onNext).not.toHaveBeenCalled();
                expect(onError).toHaveBeenCalledTimes(1);
                expect(onError.mock.calls[0][0].name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 339, 'column': 8, 'index': 11587}","it('should allow for dataSources to immediately throw an error (get)', function(done) {
        var routes = {
            get: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            get(['path', 'to', 'value'])).
            doAction(onNext, function(e) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                })
                expect(e.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 351, 'column': 20, 'index': 12025}","it('should allow for dataSources to immediately throw an error (get)', function(done) {
        var routes = {
            get: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        var onError = jest.fn();
        toObservable(model.
            get(['path', 'to', 'value'])).
            doAction(onNext, function(e) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {

                    }
                })
                expect(e.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 366, 'column': 8, 'index': 12536}","it('should allow for dataSources to immediately throw an error (call)', function(done) {
        var routes = {
            call: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        toObservable(model.
            call(['videos', 1234, 'rating'], 5)).
            doAction(onNext).
            doAction(noOp, function(err) {
                expect(onNext).not.toHaveBeenCalled();
                expect(err.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Lazy Test,"{'line': 374, 'column': 20, 'index': 12876}","it('should allow for dataSources to immediately throw an error (call)', function(done) {
        var routes = {
            call: function() {
                return thisVarDoesNotExistAndThatsAFact;
            }
        };
        var model = new falcor.Model({ source: routes });
        var onNext = jest.fn();
        toObservable(model.
            call(['videos', 1234, 'rating'], 5)).
            doAction(onNext).
            doAction(noOp, function(err) {
                expect(onNext).not.toHaveBeenCalled();
                expect(err.name).toBe(InvalidSourceError.name);
            }).
            subscribe(noOp, function(e) {
                if (isAssertionError(e)) {
                    return done(e);
                }
                return done();
            }, done.bind(null, new Error('should not complete')));
    })",steel
/test/falcor/error/error.spec.js,Magic Number,"{'line': 49, 'column': 40, 'index': 1678}","it(""should get a hard error from the DataSource with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            source: new ErrorDataSource(503, ""Timeout""),
            _treatDataSourceErrorsAsJSONGraphErrors: true
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(clean(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        test: {
                            0: {},
                            1: {},
                            2: {},
                            3: {},
                            4: {},
                            5: {}
                        }
                    }
                });
                expect(err.length).toBe(6);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp,
            function(e) {
                if (isAssertionError(e)) {
                    done(e);
                } else {
                    done();
                }
            },
            function() {
                done('Should not onComplete');
            });
    })",steel
/test/falcor/error/error.spec.js,Magic Number,"{'line': 129, 'column': 40, 'index': 4232}","it(""should get a hard error from the DataSource with some data found in the cache with _treatDataSourceErrorsAsJSONGraphErrors."", function(done) {
        var model = new Model({
            _treatDataSourceErrorsAsJSONGraphErrors: true,
            source: new ErrorDataSource(503, ""Timeout""),
            cache: {
                test: {
                    0: {
                        summary: ""in cache""
                    },
                    5: {
                        summary: ""in cache""
                    }
                }
            }
        });
        var onNext = jest.fn();
        toObservable(model.
            get([""test"", {to: 5}, ""summary""])).
            doAction(onNext, function(err) {

                // Ensure onNext is called correctly
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(err.length).toBe(4);
                // not in boxValue mode
                var expected = {
                    path: [],
                    value: {
                        status: 503,
                        message: ""Timeout""
                    }
                };
                err.forEach(function(e, i) {
                    expected.path = [""test"", i + 1, ""summary""];
                    expect(e).toEqual(expected);
                });
            }).
            subscribe(noOp, doneOnError(done), errorOnCompleted(done));
    })",steel
/test/falcor/deref/deref.spec.js,Eager Test,"{'line': 10, 'column': 19, 'index': 341}","it('should deref on a __path cache response.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);

                expect(lolomoModel._path).toEqual(['lolomos', '1234']);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/deref/deref.spec.js,Eager Test,"{'line': 14, 'column': 8, 'index': 415}","it('should deref on a __path cache response.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);

                expect(lolomoModel._path).toEqual(['lolomos', '1234']);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/deref/deref.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 40}",Unknown,steel
/test/falcor/deref/deref.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 165}",Unknown,steel
/test/falcor/deref/deref.spec.js,Global Variable,"{'line': 9, 'column': 8, 'index': 298}","it('should deref on a __path cache response.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);

                expect(lolomoModel._path).toEqual(['lolomos', '1234']);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/deref/deref.spec.js,Global Variable,"{'line': 13, 'column': 8, 'index': 383}","it('should deref on a __path cache response.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);

                expect(lolomoModel._path).toEqual(['lolomos', '1234']);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/deref/deref.spec.js,Global Variable,"{'line': 19, 'column': 16, 'index': 610}","it('should deref on a __path cache response.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);

                expect(lolomoModel._path).toEqual(['lolomos', '1234']);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/deref/deref.spec.js,Global Variable,"{'line': 20, 'column': 16, 'index': 667}","it('should deref on a __path cache response.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        toObservable(model.
            get(['lolomo', 0, 0, 'item', 'title'])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);

                expect(lolomoModel._path).toEqual(['lolomos', '1234']);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Conditional Test Logic,"{'line': 165, 'column': 8, 'index': 5380}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Conditional Test Logic,"{'line': 172, 'column': 8, 'index': 5575}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Conditional Test Logic,"{'line': 190, 'column': 4, 'index': 6104}",Unknown,steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 40}",Unknown,steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 122}",Unknown,steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 11, 'column': 8, 'index': 467}","it('should have an invalid parent reference when derefd and fromWhenceYouCame is false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        });

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });

        expect(lolomoModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 12, 'column': 8, 'index': 510}","it('should have an invalid parent reference when derefd and fromWhenceYouCame is false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        });

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });

        expect(lolomoModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 16, 'column': 8, 'index': 580}","it('should have an invalid parent reference when derefd and fromWhenceYouCame is false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        });

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });

        expect(lolomoModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 22, 'column': 16, 'index': 756}","it('should have an invalid parent reference when derefd and fromWhenceYouCame is false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        });

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });

        expect(lolomoModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 29, 'column': 8, 'index': 1039}","it('should have an valid parent reference when derefd and fromWhenceYouCame is true.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });

        expect(lolomoModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 30, 'column': 8, 'index': 1082}","it('should have an valid parent reference when derefd and fromWhenceYouCame is true.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });

        expect(lolomoModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 34, 'column': 8, 'index': 1173}","it('should have an valid parent reference when derefd and fromWhenceYouCame is true.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });

        expect(lolomoModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 40, 'column': 16, 'index': 1349}","it('should have an valid parent reference when derefd and fromWhenceYouCame is true.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });

        expect(lolomoModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 47, 'column': 8, 'index': 1656}","it('should have an valid parent reference when derefd and fromWhenceYouCame is true with non reference keys.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: {
                a: {
                    b: {
                        c: 'hello world'
                    }
                }
            }
        })._fromWhenceYouCame();

        var aModel;

        // this is sync, no dataSource
        model.
            get(['a', 'b', 'c']).
            subscribe(function(x) {
                var a = x.json.a;
                aModel = model.deref(a);
            });

        expect(aModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 48, 'column': 8, 'index': 1699}","it('should have an valid parent reference when derefd and fromWhenceYouCame is true with non reference keys.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: {
                a: {
                    b: {
                        c: 'hello world'
                    }
                }
            }
        })._fromWhenceYouCame();

        var aModel;

        // this is sync, no dataSource
        model.
            get(['a', 'b', 'c']).
            subscribe(function(x) {
                var a = x.json.a;
                aModel = model.deref(a);
            });

        expect(aModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 58, 'column': 8, 'index': 1927}","it('should have an valid parent reference when derefd and fromWhenceYouCame is true with non reference keys.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: {
                a: {
                    b: {
                        c: 'hello world'
                    }
                }
            }
        })._fromWhenceYouCame();

        var aModel;

        // this is sync, no dataSource
        model.
            get(['a', 'b', 'c']).
            subscribe(function(x) {
                var a = x.json.a;
                aModel = model.deref(a);
            });

        expect(aModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 64, 'column': 16, 'index': 2080}","it('should have an valid parent reference when derefd and fromWhenceYouCame is true with non reference keys.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: {
                a: {
                    b: {
                        c: 'hello world'
                    }
                }
            }
        })._fromWhenceYouCame();

        var aModel;

        // this is sync, no dataSource
        model.
            get(['a', 'b', 'c']).
            subscribe(function(x) {
                var a = x.json.a;
                aModel = model.deref(a);
            });

        expect(aModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 71, 'column': 8, 'index': 2366}","it('should invalidate the derefs reference and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });
        model.invalidate(['lolomo']);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 72, 'column': 8, 'index': 2409}","it('should invalidate the derefs reference and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });
        model.invalidate(['lolomo']);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 76, 'column': 8, 'index': 2500}","it('should invalidate the derefs reference and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });
        model.invalidate(['lolomo']);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 82, 'column': 16, 'index': 2676}","it('should invalidate the derefs reference and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });
        model.invalidate(['lolomo']);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 91, 'column': 8, 'index': 3013}","it('should allow for set overwrite to signal derefs become invalid, but maintain derefd reference.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });
        model.
            set({
                path: ['lolomo'],
                value: Model.ref(['lolomos', '555'])
            }).
            subscribe();

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 92, 'column': 8, 'index': 3056}","it('should allow for set overwrite to signal derefs become invalid, but maintain derefd reference.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });
        model.
            set({
                path: ['lolomo'],
                value: Model.ref(['lolomos', '555'])
            }).
            subscribe();

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 96, 'column': 8, 'index': 3147}","it('should allow for set overwrite to signal derefs become invalid, but maintain derefd reference.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });
        model.
            set({
                path: ['lolomo'],
                value: Model.ref(['lolomos', '555'])
            }).
            subscribe();

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 102, 'column': 16, 'index': 3323}","it('should allow for set overwrite to signal derefs become invalid, but maintain derefd reference.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });
        model.
            set({
                path: ['lolomo'],
                value: Model.ref(['lolomos', '555'])
            }).
            subscribe();

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 116, 'column': 8, 'index': 3788}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 117, 'column': 8, 'index': 3831}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 125, 'column': 8, 'index': 4027}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 126, 'column': 8, 'index': 4052}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 133, 'column': 16, 'index': 4296}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 164, 'column': 8, 'index': 5340}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 170, 'column': 8, 'index': 5499}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 171, 'column': 8, 'index': 5535}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 187, 'column': 4, 'index': 6008}",Unknown,steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Global Variable,"{'line': 188, 'column': 4, 'index': 6036}",Unknown,steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Lazy Test,"{'line': 11, 'column': 20, 'index': 479}","it('should have an invalid parent reference when derefd and fromWhenceYouCame is false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        });

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });

        expect(lolomoModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Lazy Test,"{'line': 29, 'column': 20, 'index': 1051}","it('should have an valid parent reference when derefd and fromWhenceYouCame is true.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });

        expect(lolomoModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Lazy Test,"{'line': 47, 'column': 20, 'index': 1668}","it('should have an valid parent reference when derefd and fromWhenceYouCame is true with non reference keys.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: {
                a: {
                    b: {
                        c: 'hello world'
                    }
                }
            }
        })._fromWhenceYouCame();

        var aModel;

        // this is sync, no dataSource
        model.
            get(['a', 'b', 'c']).
            subscribe(function(x) {
                var a = x.json.a;
                aModel = model.deref(a);
            });

        expect(aModel._hasValidParentReference()).toBe(true);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Lazy Test,"{'line': 71, 'column': 20, 'index': 2378}","it('should invalidate the derefs reference and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });
        model.invalidate(['lolomo']);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Lazy Test,"{'line': 91, 'column': 20, 'index': 3025}","it('should allow for set overwrite to signal derefs become invalid, but maintain derefd reference.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache
        })._fromWhenceYouCame();

        var lolomoModel;

        // this is sync, no dataSource
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
            });
        model.
            set({
                path: ['lolomo'],
                value: Model.ref(['lolomos', '555'])
            }).
            subscribe();

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.hasValidParentReference.spec.js,Lazy Test,"{'line': 116, 'column': 20, 'index': 3800}","it('should set and exceed maxSize and maintain correct deref and hasValidParentReference becomes false.', function() {
        var cache = cacheGenerator(0, 30);
        var model = new Model({
            cache: cache,
            maxSize: 3600,

            // Only clean up 5% of the cache
            collectRatio: 0.95
        })._fromWhenceYouCame();

        var lolomoModel;
        var listModel;

        // this is sync, no dataSource
        // lolomo should be in the back of the cache again.
        model.
            get(['lolomo', {to:2}, {to:9}, 'item', 'title']).
            subscribe(function(x) {
                var lolomo = x.json.lolomo;
                lolomoModel = model.deref(lolomo);
                listModel = model.deref(lolomo[0]);
            });

        // Move the other references to the front of the LRU list.
        // One of the problems in dealing with small amounts of data / size
        // Is when things clean up, it causes side effects with references
        // and what was cleaned up.  But that is only in these single request
        // trivial tests
        lolomoModel.get([{to: 2}, 0, 'item']).subscribe();

        listModel.
            set({
                json: {
                    10: {
                        item: {
                            title: 'Running man',
                            rating: 5
                        }
                    },
                    11: {
                        item: {
                            title: 'Commando',
                            rating: 5
                        }
                    }
                }
            }).
            subscribe();

        var node = model._root[__head];
        while (node) {
            expect(node[__key]).not.toBe('lolomo');
            node = node[__next];
        }

        var foundA, foundB, foundC;
        var node = model._root[__head];
        while (node) {
            foundA = foundA || node.value[1] === 'A';
            foundB = foundB || node.value[1] === 'B';
            foundC = foundC || node.value[1] === 'C';
            node = node[__next];
        }
        expect(foundA).toBe(true);
        expect(foundB).toBe(true);
        expect(foundC).toBe(true);

        expect(lolomoModel._hasValidParentReference()).toBe(false);
    })",steel
/test/falcor/deref/deref.errors.spec.js,Conditional Test Logic,"{'line': 42, 'column': 28, 'index': 1616}","it('should error on a shorted deref path.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);
                model.
                    set({
                        json: {
                            lolomos: 'ohh no'
                        }
                    }).
                    subscribe();

                toObservable(lolomoModel.
                    get([0, 0, 'item', 'title'])).
                    doAction(onNext, function(err) {
                        expect(onNext).toHaveBeenCalledTimes(1);
                        expect(err.name).toBe(InvalidModelError.name);
                    }).
                    subscribe(
                        noOp,
                        function(err) {
                            if (isAssertionError(err)) {
                                return done(err);
                            }
                            done();
                        },
                        done.bind(null, new Error('onCompleted shouldnt be called')));
            });
    })",steel
/test/falcor/deref/deref.errors.spec.js,Duplicate Assert,"{'line': 21, 'column': 16, 'index': 811}","it('should error on a shorted deref path.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);
                model.
                    set({
                        json: {
                            lolomos: 'ohh no'
                        }
                    }).
                    subscribe();

                toObservable(lolomoModel.
                    get([0, 0, 'item', 'title'])).
                    doAction(onNext, function(err) {
                        expect(onNext).toHaveBeenCalledTimes(1);
                        expect(err.name).toBe(InvalidModelError.name);
                    }).
                    subscribe(
                        noOp,
                        function(err) {
                            if (isAssertionError(err)) {
                                return done(err);
                            }
                            done();
                        },
                        done.bind(null, new Error('onCompleted shouldnt be called')));
            });
    })",steel
/test/falcor/deref/deref.errors.spec.js,Duplicate Assert,"{'line': 36, 'column': 24, 'index': 1351}","it('should error on a shorted deref path.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);
                model.
                    set({
                        json: {
                            lolomos: 'ohh no'
                        }
                    }).
                    subscribe();

                toObservable(lolomoModel.
                    get([0, 0, 'item', 'title'])).
                    doAction(onNext, function(err) {
                        expect(onNext).toHaveBeenCalledTimes(1);
                        expect(err.name).toBe(InvalidModelError.name);
                    }).
                    subscribe(
                        noOp,
                        function(err) {
                            if (isAssertionError(err)) {
                                return done(err);
                            }
                            done();
                        },
                        done.bind(null, new Error('onCompleted shouldnt be called')));
            });
    })",steel
/test/falcor/deref/deref.errors.spec.js,Eager Test,"{'line': 14, 'column': 19, 'index': 613}","it('should error on a shorted deref path.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);
                model.
                    set({
                        json: {
                            lolomos: 'ohh no'
                        }
                    }).
                    subscribe();

                toObservable(lolomoModel.
                    get([0, 0, 'item', 'title'])).
                    doAction(onNext, function(err) {
                        expect(onNext).toHaveBeenCalledTimes(1);
                        expect(err.name).toBe(InvalidModelError.name);
                    }).
                    subscribe(
                        noOp,
                        function(err) {
                            if (isAssertionError(err)) {
                                return done(err);
                            }
                            done();
                        },
                        done.bind(null, new Error('onCompleted shouldnt be called')));
            });
    })",steel
/test/falcor/deref/deref.errors.spec.js,Eager Test,"{'line': 33, 'column': 16, 'index': 1197}","it('should error on a shorted deref path.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);
                model.
                    set({
                        json: {
                            lolomos: 'ohh no'
                        }
                    }).
                    subscribe();

                toObservable(lolomoModel.
                    get([0, 0, 'item', 'title'])).
                    doAction(onNext, function(err) {
                        expect(onNext).toHaveBeenCalledTimes(1);
                        expect(err.name).toBe(InvalidModelError.name);
                    }).
                    subscribe(
                        noOp,
                        function(err) {
                            if (isAssertionError(err)) {
                                return done(err);
                            }
                            done();
                        },
                        done.bind(null, new Error('onCompleted shouldnt be called')));
            });
    })",steel
/test/falcor/deref/deref.errors.spec.js,Eager Test,"{'line': 42, 'column': 32, 'index': 1620}","it('should error on a shorted deref path.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);
                model.
                    set({
                        json: {
                            lolomos: 'ohh no'
                        }
                    }).
                    subscribe();

                toObservable(lolomoModel.
                    get([0, 0, 'item', 'title'])).
                    doAction(onNext, function(err) {
                        expect(onNext).toHaveBeenCalledTimes(1);
                        expect(err.name).toBe(InvalidModelError.name);
                    }).
                    subscribe(
                        noOp,
                        function(err) {
                            if (isAssertionError(err)) {
                                return done(err);
                            }
                            done();
                        },
                        done.bind(null, new Error('onCompleted shouldnt be called')));
            });
    })",steel
/test/falcor/deref/deref.errors.spec.js,Exception Handling,"{'line': 52, 'column': 8, 'index': 1966}","it('should throw on invalid input.', function(done) {
        try {
            new Model().deref('testing');
        } catch (e) {
            expect(e.name).toBe(InvalidDerefInputError.name);
            return done();
        }
        done(new Error('should have thrown an error.'));
    })",steel
/test/falcor/deref/deref.errors.spec.js,Global Variable,"{'line': 4, 'column': 0, 'index': 202}",Unknown,steel
/test/falcor/deref/deref.errors.spec.js,Global Variable,"{'line': 6, 'column': 0, 'index': 284}",Unknown,steel
/test/falcor/deref/deref.errors.spec.js,Global Variable,"{'line': 13, 'column': 8, 'index': 570}","it('should error on a shorted deref path.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);
                model.
                    set({
                        json: {
                            lolomos: 'ohh no'
                        }
                    }).
                    subscribe();

                toObservable(lolomoModel.
                    get([0, 0, 'item', 'title'])).
                    doAction(onNext, function(err) {
                        expect(onNext).toHaveBeenCalledTimes(1);
                        expect(err.name).toBe(InvalidModelError.name);
                    }).
                    subscribe(
                        noOp,
                        function(err) {
                            if (isAssertionError(err)) {
                                return done(err);
                            }
                            done();
                        },
                        done.bind(null, new Error('onCompleted shouldnt be called')));
            });
    })",steel
/test/falcor/deref/deref.errors.spec.js,Global Variable,"{'line': 17, 'column': 8, 'index': 655}","it('should error on a shorted deref path.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);
                model.
                    set({
                        json: {
                            lolomos: 'ohh no'
                        }
                    }).
                    subscribe();

                toObservable(lolomoModel.
                    get([0, 0, 'item', 'title'])).
                    doAction(onNext, function(err) {
                        expect(onNext).toHaveBeenCalledTimes(1);
                        expect(err.name).toBe(InvalidModelError.name);
                    }).
                    subscribe(
                        noOp,
                        function(err) {
                            if (isAssertionError(err)) {
                                return done(err);
                            }
                            done();
                        },
                        done.bind(null, new Error('onCompleted shouldnt be called')));
            });
    })",steel
/test/falcor/deref/deref.errors.spec.js,Global Variable,"{'line': 23, 'column': 16, 'index': 869}","it('should error on a shorted deref path.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);
                model.
                    set({
                        json: {
                            lolomos: 'ohh no'
                        }
                    }).
                    subscribe();

                toObservable(lolomoModel.
                    get([0, 0, 'item', 'title'])).
                    doAction(onNext, function(err) {
                        expect(onNext).toHaveBeenCalledTimes(1);
                        expect(err.name).toBe(InvalidModelError.name);
                    }).
                    subscribe(
                        noOp,
                        function(err) {
                            if (isAssertionError(err)) {
                                return done(err);
                            }
                            done();
                        },
                        done.bind(null, new Error('onCompleted shouldnt be called')));
            });
    })",steel
/test/falcor/deref/deref.errors.spec.js,Global Variable,"{'line': 24, 'column': 16, 'index': 926}","it('should error on a shorted deref path.', function(done) {
        var model = new Model({
            cache: cacheGenerator(0, 1)
        });

        var onNext = jest.fn();
        model.
            get(['lolomo', 0, 0, 'item', 'title']).
            subscribe(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);

                var json = onNext.mock.calls[0][0].json;
                var lolomoModel = model.deref(json.lolomo);
                model.
                    set({
                        json: {
                            lolomos: 'ohh no'
                        }
                    }).
                    subscribe();

                toObservable(lolomoModel.
                    get([0, 0, 'item', 'title'])).
                    doAction(onNext, function(err) {
                        expect(onNext).toHaveBeenCalledTimes(1);
                        expect(err.name).toBe(InvalidModelError.name);
                    }).
                    subscribe(
                        noOp,
                        function(err) {
                            if (isAssertionError(err)) {
                                return done(err);
                            }
                            done();
                        },
                        done.bind(null, new Error('onCompleted shouldnt be called')));
            });
    })",steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 2, 'column': 0, 'index': 41}",Unknown,steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 5, 'column': 0, 'index': 193}",Unknown,steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 20, 'column': 8, 'index': 678}","it(""executes a remote call on a bound Model and sends the call and extra paths relative to the root"", function(done) {
        var model = new Model({
            source: {
                call: function(callPath, args, suffixes, extraPaths) {
                    expect(callPath).toEqual([""lists"", ""add""]);
                    expect(extraPaths).toEqual([[0, ""summary""]]);
                    done();

                    return {subscribe: noOp};
                }
            }
        });

        toObservable(model.
            _clone({ _path: [""lists""] }).
            call([""add""], [], [], [[0, ""summary""]])).
            subscribe(noOp, noOp, noOp);
    })",steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 39, 'column': 8, 'index': 1290}","it(""ensures that invalidations are ran."", function(done) {
        var model = new Model({
            source: {
                call: function(callPath, args, suffixes, extraPaths) {
                    return new ModelResponse(function(observer) {
                        observer.onNext({
                            jsonGraph: {
                                a: ""test""
                            },
                            paths: [[""a""]],
                            invalidated: [[""b""]]
                        });
                        observer.onCompleted();
                    });
                }
            },
            cache: {
                a: ""foo"",
                b: ""test""
            }
        });

        var onNext = jest.fn();
        var onNext2 = jest.fn();
        toObservable(model.
            call([""test""], [])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        a: ""test""
                    }
                });
            }).
            flatMap(function() {
                return model.
                    withoutDataSource().
                    get([""a""], [""b""]);
            }).
            doAction(onNext2, noOp, function() {
                expect(onNext2).toHaveBeenCalledTimes(1);
                expect(strip(onNext2.mock.calls[0][0])).toEqual({
                    json: {
                        a: ""test""
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 60, 'column': 8, 'index': 1963}","it(""ensures that invalidations are ran."", function(done) {
        var model = new Model({
            source: {
                call: function(callPath, args, suffixes, extraPaths) {
                    return new ModelResponse(function(observer) {
                        observer.onNext({
                            jsonGraph: {
                                a: ""test""
                            },
                            paths: [[""a""]],
                            invalidated: [[""b""]]
                        });
                        observer.onCompleted();
                    });
                }
            },
            cache: {
                a: ""foo"",
                b: ""test""
            }
        });

        var onNext = jest.fn();
        var onNext2 = jest.fn();
        toObservable(model.
            call([""test""], [])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        a: ""test""
                    }
                });
            }).
            flatMap(function() {
                return model.
                    withoutDataSource().
                    get([""a""], [""b""]);
            }).
            doAction(onNext2, noOp, function() {
                expect(onNext2).toHaveBeenCalledTimes(1);
                expect(strip(onNext2.mock.calls[0][0])).toEqual({
                    json: {
                        a: ""test""
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 61, 'column': 8, 'index': 1995}","it(""ensures that invalidations are ran."", function(done) {
        var model = new Model({
            source: {
                call: function(callPath, args, suffixes, extraPaths) {
                    return new ModelResponse(function(observer) {
                        observer.onNext({
                            jsonGraph: {
                                a: ""test""
                            },
                            paths: [[""a""]],
                            invalidated: [[""b""]]
                        });
                        observer.onCompleted();
                    });
                }
            },
            cache: {
                a: ""foo"",
                b: ""test""
            }
        });

        var onNext = jest.fn();
        var onNext2 = jest.fn();
        toObservable(model.
            call([""test""], [])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        a: ""test""
                    }
                });
            }).
            flatMap(function() {
                return model.
                    withoutDataSource().
                    get([""a""], [""b""]);
            }).
            doAction(onNext2, noOp, function() {
                expect(onNext2).toHaveBeenCalledTimes(1);
                expect(strip(onNext2.mock.calls[0][0])).toEqual({
                    json: {
                        a: ""test""
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 88, 'column': 8, 'index': 2955}","it(""should sent parsed arguments to the dataSource."", function(done) {
        var call = jest.fn(function() {
            return {
                subscribe: function(onNext, onError, onCompleted) {
                    onNext({jsonGraph: {
                        a: {
                            b: ""hello""
                        }
                    }, paths: [
                        [""a"", ""b""]
                    ]});
                    onCompleted();
                }
            };
        });
        var model = new Model({
            source: {
                call: call
            }
        });
        toObservable(model.
            call(""test.again"", [], [""oneSuffix.a"", ""twoSuffix.b""], [""onePath.a"", ""twoPath.b""])).
            doAction(noOp, noOp, function() {
                expect(call).toHaveBeenCalledTimes(1);

                var callArgs = call.mock.calls[0];
                expect(callArgs[0]).toEqual([""test"", ""again""]);
                expect(callArgs[1]).toEqual([]);
                expect(callArgs[2]).toEqual([
                    [""oneSuffix"", ""a""],
                    [""twoSuffix"", ""b""]
                ]);
                expect(callArgs[3]).toEqual([
                    [""onePath"", ""a""],
                    [""twoPath"", ""b""]
                ]);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 102, 'column': 8, 'index': 3391}","it(""should sent parsed arguments to the dataSource."", function(done) {
        var call = jest.fn(function() {
            return {
                subscribe: function(onNext, onError, onCompleted) {
                    onNext({jsonGraph: {
                        a: {
                            b: ""hello""
                        }
                    }, paths: [
                        [""a"", ""b""]
                    ]});
                    onCompleted();
                }
            };
        });
        var model = new Model({
            source: {
                call: call
            }
        });
        toObservable(model.
            call(""test.again"", [], [""oneSuffix.a"", ""twoSuffix.b""], [""onePath.a"", ""twoPath.b""])).
            doAction(noOp, noOp, function() {
                expect(call).toHaveBeenCalledTimes(1);

                var callArgs = call.mock.calls[0];
                expect(callArgs[0]).toEqual([""test"", ""again""]);
                expect(callArgs[1]).toEqual([]);
                expect(callArgs[2]).toEqual([
                    [""oneSuffix"", ""a""],
                    [""twoSuffix"", ""b""]
                ]);
                expect(callArgs[3]).toEqual([
                    [""onePath"", ""a""],
                    [""twoPath"", ""b""]
                ]);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 112, 'column': 16, 'index': 3733}","it(""should sent parsed arguments to the dataSource."", function(done) {
        var call = jest.fn(function() {
            return {
                subscribe: function(onNext, onError, onCompleted) {
                    onNext({jsonGraph: {
                        a: {
                            b: ""hello""
                        }
                    }, paths: [
                        [""a"", ""b""]
                    ]});
                    onCompleted();
                }
            };
        });
        var model = new Model({
            source: {
                call: call
            }
        });
        toObservable(model.
            call(""test.again"", [], [""oneSuffix.a"", ""twoSuffix.b""], [""onePath.a"", ""twoPath.b""])).
            doAction(noOp, noOp, function() {
                expect(call).toHaveBeenCalledTimes(1);

                var callArgs = call.mock.calls[0];
                expect(callArgs[0]).toEqual([""test"", ""again""]);
                expect(callArgs[1]).toEqual([]);
                expect(callArgs[2]).toEqual([
                    [""oneSuffix"", ""a""],
                    [""twoSuffix"", ""b""]
                ]);
                expect(callArgs[3]).toEqual([
                    [""onePath"", ""a""],
                    [""twoPath"", ""b""]
                ]);
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 128, 'column': 8, 'index': 4313}","it(""does not re-execute a call on multiple thens"", function(done) {
        var call = jest.fn(function() {
            return new ModelResponse(function(observer) {
                observer.onNext({
                    jsonGraph: { a: ""test"" },
                    paths: [[""a""]],
                    invalidated: []
                });
                observer.onCompleted();
            });
        });
        var model = new Model({
            source: { call: call }
        });

        var response = model.call([""add""], [], [], [[0, ""summary""]]);
        response.then();
        response.then(function() {
          expect(call).toHaveBeenCalledTimes(1);
          done();
        }).catch(done);
    })",steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 138, 'column': 8, 'index': 4651}","it(""does not re-execute a call on multiple thens"", function(done) {
        var call = jest.fn(function() {
            return new ModelResponse(function(observer) {
                observer.onNext({
                    jsonGraph: { a: ""test"" },
                    paths: [[""a""]],
                    invalidated: []
                });
                observer.onCompleted();
            });
        });
        var model = new Model({
            source: { call: call }
        });

        var response = model.call([""add""], [], [], [[0, ""summary""]]);
        response.then();
        response.then(function() {
          expect(call).toHaveBeenCalledTimes(1);
          done();
        }).catch(done);
    })",steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 142, 'column': 8, 'index': 4731}","it(""does not re-execute a call on multiple thens"", function(done) {
        var call = jest.fn(function() {
            return new ModelResponse(function(observer) {
                observer.onNext({
                    jsonGraph: { a: ""test"" },
                    paths: [[""a""]],
                    invalidated: []
                });
                observer.onCompleted();
            });
        });
        var model = new Model({
            source: { call: call }
        });

        var response = model.call([""add""], [], [], [[0, ""summary""]]);
        response.then();
        response.then(function() {
          expect(call).toHaveBeenCalledTimes(1);
          done();
        }).catch(done);
    })",steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 153, 'column': 8, 'index': 5064}","it(""should be consumable with RxJS 5"", function(done) {
        var response = new ModelResponse(function(observer) {
            observer.onNext({
                jsonGraph: { a: ""test"" },
                paths: [[""a""]],
                invalidated: []
            });
            observer.onCompleted();
        });

        var results = [];

        Rx5.Observable.from(response)
            .subscribe(
                function(value) { results.push(value); },
                null,
                function() {
                    expect(results).toEqual([{
                        jsonGraph: { a: ""test"" },
                        paths: [[""a""]],
                        invalidated: []
                    }]);
                    done();
                }
            );
    })",steel
/test/falcor/call/call.spec.js,Global Variable,"{'line': 162, 'column': 8, 'index': 5327}","it(""should be consumable with RxJS 5"", function(done) {
        var response = new ModelResponse(function(observer) {
            observer.onNext({
                jsonGraph: { a: ""test"" },
                paths: [[""a""]],
                invalidated: []
            });
            observer.onCompleted();
        });

        var results = [];

        Rx5.Observable.from(response)
            .subscribe(
                function(value) { results.push(value); },
                null,
                function() {
                    expect(results).toEqual([{
                        jsonGraph: { a: ""test"" },
                        paths: [[""a""]],
                        invalidated: []
                    }]);
                    done();
                }
            );
    })",steel
/test/falcor/call/call.spec.js,Lazy Test,"{'line': 32, 'column': 8, 'index': 1053}","it(""executes a remote call on a bound Model and sends the call and extra paths relative to the root"", function(done) {
        var model = new Model({
            source: {
                call: function(callPath, args, suffixes, extraPaths) {
                    expect(callPath).toEqual([""lists"", ""add""]);
                    expect(extraPaths).toEqual([[0, ""summary""]]);
                    done();

                    return {subscribe: noOp};
                }
            }
        });

        toObservable(model.
            _clone({ _path: [""lists""] }).
            call([""add""], [], [], [[0, ""summary""]])).
            subscribe(noOp, noOp, noOp);
    })",steel
/test/falcor/call/call.spec.js,Lazy Test,"{'line': 62, 'column': 8, 'index': 2028}","it(""ensures that invalidations are ran."", function(done) {
        var model = new Model({
            source: {
                call: function(callPath, args, suffixes, extraPaths) {
                    return new ModelResponse(function(observer) {
                        observer.onNext({
                            jsonGraph: {
                                a: ""test""
                            },
                            paths: [[""a""]],
                            invalidated: [[""b""]]
                        });
                        observer.onCompleted();
                    });
                }
            },
            cache: {
                a: ""foo"",
                b: ""test""
            }
        });

        var onNext = jest.fn();
        var onNext2 = jest.fn();
        toObservable(model.
            call([""test""], [])).
            doAction(onNext, noOp, function() {
                expect(onNext).toHaveBeenCalledTimes(1);
                expect(strip(onNext.mock.calls[0][0])).toEqual({
                    json: {
                        a: ""test""
                    }
                });
            }).
            flatMap(function() {
                return model.
                    withoutDataSource().
                    get([""a""], [""b""]);
            }).
            doAction(onNext2, noOp, function() {
                expect(onNext2).toHaveBeenCalledTimes(1);
                expect(strip(onNext2.mock.calls[0][0])).toEqual({
                    json: {
                        a: ""test""
                    }
                });
            }).
            subscribe(noOp, done, done);
    })",steel
/test/falcor/call/call.spec.js,Lazy Test,"{'line': 107, 'column': 8, 'index': 3498}","it(""should sent parsed arguments to the dataSource."", function(done) {
        var call = jest.fn(function() {
            return {
                subscribe: function(onNext, onError, onCompleted) {
                    onNext({jsonGraph: {
                        a: {
                            b: ""hello""
                        }
                    }, paths: [
                        [""a"", ""b""]
                    ]});
                    onCompleted();
                }
            };
        });
        var model = new Model({
            source: {
                call: call
            }
        });
        toObservable(model.
            call(""test.again"", [], [""oneSuffix.a"", ""twoSuffix.b""], [""onePath.a"", ""twoPath.b""])).
            doAction(noOp, noOp, function() {
                expect(call).toHaveBeenCalledTimes(1);

                var callArgs = call.mock.calls[0];
                expect(callArgs[0]).toEqual([""test"", ""again""]);
                expect(callArgs[1]).toEqual([]);
                expect(callArgs[2]).toEqual([
                    [""oneSuffix"", ""a""],
                    [""twoSuffix"", ""b""]
                ]);
                expect(callArgs[3]).toEqual([
                    [""onePath"", ""a""],
                    [""twoPath"", ""b""]
                ]);
            }).
            subscribe(noOp, done, done);
    })",steel
