file,type,line,method,source
/spec/parcels/parcel-error-handlers.spec.js,GeneralFixture,"{'startLine':135,'endLine':135}","beforeEach(() => {
          errs = [];
          singleSpa.addErrorHandler(handleError);
        })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':29,'endLine':29}","it(`should throw an error when bootstrapping fails`, async () => {
        const app = createApp();
        let shouldAppBeMounted = true;

        singleSpa.registerApplication(
          ""parcel-bootstrap-errors"",
          app,
          () => shouldAppBeMounted
        );
        await singleSpa.triggerAppChange();
        expect(app.mountCalls).toBe(1);

        const parcelConfig1 = createParcelConfig(""bootstrap"");
        parcelConfig1.name = ""bootstrap-error"";
        const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
          domElement: document.createElement(""div""),
        });

        // avoid unhandled rejection causing test failure
        parcel1.mountPromise.catch((err) => {});

        await parcel1.bootstrapPromise.catch((err) => {
          expect(err.appOrParcelName).toBe(""bootstrap-error"");
          expect(err.message).toMatch(`BOOTSTRAPPING`);
          expect(err.message.indexOf(`bootstrap-error`)).toBeGreaterThan(-1);
          expect(parcel1.getStatus()).toBe(""SKIP_BECAUSE_BROKEN"");
        });
      })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':104,'endLine':104}","it(`should throw an error that you can catch when a parcel fails to unmount outside an app lifecycle`, async () => {
          const app = createApp();
          let shouldAppBeMounted = true;

          singleSpa.registerApplication(
            ""parcel-unmount-parcel-errors"",
            app,
            () => shouldAppBeMounted
          );
          await singleSpa.triggerAppChange();

          expect(app.mountCalls).toBe(1);

          const parcelConfig1 = createParcelConfig(""unmount"");
          parcelConfig1.name = ""unmount-error1"";
          const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
            domElement: document.createElement(""div""),
          });

          // avoid unhandled rejections causing test failures
          parcel1.unmountPromise.catch((err) => {});

          await parcel1.mountPromise;
          expect(parcel1.getStatus()).toBe(""MOUNTED"");
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          // avoid unhandled rejection errors
          parcel1.unmount().catch((err) => {});

          expect(parcelConfig1.unmountCalls).toBe(0);
          try {
            await parcel1.unmountPromise;
          } catch (err) {
            expect(err.appOrParcelName).toBe(""unmount-error1"");
            expect(err.message.indexOf(`UNMOUNTING`)).toBeGreaterThan(-1);
            expect(err.message.indexOf(`unmount-error1`)).toBeGreaterThan(-1);
          }
          expect(parcel1.getStatus()).toBe(""SKIP_BECAUSE_BROKEN"");
        })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':113,'endLine':113}","it(`should throw an error that you can catch when a parcel fails to unmount outside an app lifecycle`, async () => {
          const app = createApp();
          let shouldAppBeMounted = true;

          singleSpa.registerApplication(
            ""parcel-unmount-parcel-errors"",
            app,
            () => shouldAppBeMounted
          );
          await singleSpa.triggerAppChange();

          expect(app.mountCalls).toBe(1);

          const parcelConfig1 = createParcelConfig(""unmount"");
          parcelConfig1.name = ""unmount-error1"";
          const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
            domElement: document.createElement(""div""),
          });

          // avoid unhandled rejections causing test failures
          parcel1.unmountPromise.catch((err) => {});

          await parcel1.mountPromise;
          expect(parcel1.getStatus()).toBe(""MOUNTED"");
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          // avoid unhandled rejection errors
          parcel1.unmount().catch((err) => {});

          expect(parcelConfig1.unmountCalls).toBe(0);
          try {
            await parcel1.unmountPromise;
          } catch (err) {
            expect(err.appOrParcelName).toBe(""unmount-error1"");
            expect(err.message.indexOf(`UNMOUNTING`)).toBeGreaterThan(-1);
            expect(err.message.indexOf(`unmount-error1`)).toBeGreaterThan(-1);
          }
          expect(parcel1.getStatus()).toBe(""SKIP_BECAUSE_BROKEN"");
        })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':163,'endLine':163}","it(`should throw an error when unmounting a parcel fails during app unmount`, async () => {
          const app = createApp();
          let shouldAppBeMounted = true;

          singleSpa.registerApplication(
            ""app-parcel-unmount-errors"",
            app,
            () => shouldAppBeMounted
          );

          await singleSpa.triggerAppChange();
          expect(app.mountCalls).toBe(1);

          const parcelConfig1 = createParcelConfig(""unmount"");
          parcelConfig1.name = ""unmount-error2"";
          const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
            domElement: document.createElement(""div""),
          });

          // avoid unhandled rejection causing test failures
          parcel1.unmountPromise.catch((err) => {});

          await parcel1.mountPromise;
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          shouldAppBeMounted = false;
          await singleSpa.triggerAppChange();

          try {
            await parcel1.unmountPromise;
            throw Error(""Expected unmount error"");
          } catch (err) {
            expect(err.appOrParcelName).toBe(""unmount-error2"");
            expect(err.message.indexOf(`UNMOUNTING`)).toBeGreaterThan(-1);
            expect(err.message.indexOf(`unmount-error2`)).toBeGreaterThan(-1);
          }

          expect(errs.length).toBe(1);
          expect(errs[0].appOrParcelName).toBe(""app-parcel-unmount-errors"");
          expect(errs[0].message).toMatch(
            /application 'app-parcel-unmount-errors' died in status NOT_MOUNTED: parcel 'unmount-error2' died in status UNMOUNTING: unmount error/
          );
        })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':216,'endLine':216}","it(`rejects the load promise if loading function returns a promise that resolves with undefined`, async () => {
      const parcel = singleSpa.mountRootParcel(() => Promise.resolve(), {
        domElement: document.createElement(""div""),
      });

      // avoid unhandled rejection errors
      parcel.bootstrapPromise.catch((err) => {});
      parcel.mountPromise.catch((err) => {});

      try {
        await parcel.loadPromise;
        throw new Error(""load promise should not have succeeded"");
      } catch (err) {
        expect(
          err.message.indexOf(""did not resolve with a parcel config"")
        ).toBeGreaterThan(-1);
      }
    })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':217,'endLine':217}","it(`rejects the load promise if loading function returns a promise that resolves with undefined`, async () => {
      const parcel = singleSpa.mountRootParcel(() => Promise.resolve(), {
        domElement: document.createElement(""div""),
      });

      // avoid unhandled rejection errors
      parcel.bootstrapPromise.catch((err) => {});
      parcel.mountPromise.catch((err) => {});

      try {
        await parcel.loadPromise;
        throw new Error(""load promise should not have succeeded"");
      } catch (err) {
        expect(
          err.message.indexOf(""did not resolve with a parcel config"")
        ).toBeGreaterThan(-1);
      }
    })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':231,'endLine':231}","it(`rejects the load promise if the config doesn't have a valid mount function`, async () => {
      const parcel = singleSpa.mountRootParcel(
        { bootstrap() {}, unmount() {} },
        { domElement: document.createElement(""div"") }
      );

      // avoid unhandled rejection errors
      parcel.bootstrapPromise.catch((err) => {});
      parcel.mountPromise.catch((err) => {});

      try {
        await parcel.loadPromise;
        throw new Error(""load promise should not have succeeded"");
      } catch (err) {
        expect(
          err.message.indexOf(""must have a valid mount function"")
        ).toBeGreaterThan(-1);
      }
    })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':231,'endLine':231}","it(`rejects the load promise if the config doesn't have a valid mount function`, async () => {
      const parcel = singleSpa.mountRootParcel(
        { bootstrap() {}, unmount() {} },
        { domElement: document.createElement(""div"") }
      );

      // avoid unhandled rejection errors
      parcel.bootstrapPromise.catch((err) => {});
      parcel.mountPromise.catch((err) => {});

      try {
        await parcel.loadPromise;
        throw new Error(""load promise should not have succeeded"");
      } catch (err) {
        expect(
          err.message.indexOf(""must have a valid mount function"")
        ).toBeGreaterThan(-1);
      }
    })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':236,'endLine':236}","it(`rejects the load promise if the config doesn't have a valid mount function`, async () => {
      const parcel = singleSpa.mountRootParcel(
        { bootstrap() {}, unmount() {} },
        { domElement: document.createElement(""div"") }
      );

      // avoid unhandled rejection errors
      parcel.bootstrapPromise.catch((err) => {});
      parcel.mountPromise.catch((err) => {});

      try {
        await parcel.loadPromise;
        throw new Error(""load promise should not have succeeded"");
      } catch (err) {
        expect(
          err.message.indexOf(""must have a valid mount function"")
        ).toBeGreaterThan(-1);
      }
    })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':237,'endLine':237}","it(`rejects the load promise if the config doesn't have a valid mount function`, async () => {
      const parcel = singleSpa.mountRootParcel(
        { bootstrap() {}, unmount() {} },
        { domElement: document.createElement(""div"") }
      );

      // avoid unhandled rejection errors
      parcel.bootstrapPromise.catch((err) => {});
      parcel.mountPromise.catch((err) => {});

      try {
        await parcel.loadPromise;
        throw new Error(""load promise should not have succeeded"");
      } catch (err) {
        expect(
          err.message.indexOf(""must have a valid mount function"")
        ).toBeGreaterThan(-1);
      }
    })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':251,'endLine':251}","it(`rejects the load promise if the config doesn't have a valid unmount function`, async () => {
      const parcel = singleSpa.mountRootParcel(
        { bootstrap() {}, mount() {} },
        { domElement: document.createElement(""div"") }
      );

      // avoid unhandled rejection errors
      parcel.bootstrapPromise.catch((err) => {});
      parcel.mountPromise.catch((err) => {});

      try {
        await parcel.loadPromise;
        throw new Error(""load promise should not have succeeded"");
      } catch (err) {
        expect(
          err.message.indexOf(""must have a valid unmount function"")
        ).toBeGreaterThan(-1);
      }
    })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':251,'endLine':251}","it(`rejects the load promise if the config doesn't have a valid unmount function`, async () => {
      const parcel = singleSpa.mountRootParcel(
        { bootstrap() {}, mount() {} },
        { domElement: document.createElement(""div"") }
      );

      // avoid unhandled rejection errors
      parcel.bootstrapPromise.catch((err) => {});
      parcel.mountPromise.catch((err) => {});

      try {
        await parcel.loadPromise;
        throw new Error(""load promise should not have succeeded"");
      } catch (err) {
        expect(
          err.message.indexOf(""must have a valid unmount function"")
        ).toBeGreaterThan(-1);
      }
    })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':256,'endLine':256}","it(`rejects the load promise if the config doesn't have a valid unmount function`, async () => {
      const parcel = singleSpa.mountRootParcel(
        { bootstrap() {}, mount() {} },
        { domElement: document.createElement(""div"") }
      );

      // avoid unhandled rejection errors
      parcel.bootstrapPromise.catch((err) => {});
      parcel.mountPromise.catch((err) => {});

      try {
        await parcel.loadPromise;
        throw new Error(""load promise should not have succeeded"");
      } catch (err) {
        expect(
          err.message.indexOf(""must have a valid unmount function"")
        ).toBeGreaterThan(-1);
      }
    })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':257,'endLine':257}","it(`rejects the load promise if the config doesn't have a valid unmount function`, async () => {
      const parcel = singleSpa.mountRootParcel(
        { bootstrap() {}, mount() {} },
        { domElement: document.createElement(""div"") }
      );

      // avoid unhandled rejection errors
      parcel.bootstrapPromise.catch((err) => {});
      parcel.mountPromise.catch((err) => {});

      try {
        await parcel.loadPromise;
        throw new Error(""load promise should not have succeeded"");
      } catch (err) {
        expect(
          err.message.indexOf(""must have a valid unmount function"")
        ).toBeGreaterThan(-1);
      }
    })",snuts
/spec/parcels/parcel-error-handlers.spec.js,NonFunctionalStatement,"{'startLine':333,'endLine':333}",Unknown,snuts
/spec/parcels/parcel-error-handlers.spec.js,SubOptimalAssert,"{'startLine':182,'endLine':182}","it(`should throw an error when unmounting a parcel fails during app unmount`, async () => {
          const app = createApp();
          let shouldAppBeMounted = true;

          singleSpa.registerApplication(
            ""app-parcel-unmount-errors"",
            app,
            () => shouldAppBeMounted
          );

          await singleSpa.triggerAppChange();
          expect(app.mountCalls).toBe(1);

          const parcelConfig1 = createParcelConfig(""unmount"");
          parcelConfig1.name = ""unmount-error2"";
          const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
            domElement: document.createElement(""div""),
          });

          // avoid unhandled rejection causing test failures
          parcel1.unmountPromise.catch((err) => {});

          await parcel1.mountPromise;
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          shouldAppBeMounted = false;
          await singleSpa.triggerAppChange();

          try {
            await parcel1.unmountPromise;
            throw Error(""Expected unmount error"");
          } catch (err) {
            expect(err.appOrParcelName).toBe(""unmount-error2"");
            expect(err.message.indexOf(`UNMOUNTING`)).toBeGreaterThan(-1);
            expect(err.message.indexOf(`unmount-error2`)).toBeGreaterThan(-1);
          }

          expect(errs.length).toBe(1);
          expect(errs[0].appOrParcelName).toBe(""app-parcel-unmount-errors"");
          expect(errs[0].message).toMatch(
            /application 'app-parcel-unmount-errors' died in status NOT_MOUNTED: parcel 'unmount-error2' died in status UNMOUNTING: unmount error/
          );
        })",snuts
/spec/parcels/parcel-error-handlers.spec.js,VerifyInSetup,"{'startLine':139,'endLine':141}","afterEach(() => {
          expect(singleSpa.removeErrorHandler(handleError)).toBe(true);
        })",snuts
/spec/parcels/mount-root-parcel.spec.js,NonFunctionalStatement,"{'startLine':103,'endLine':103}","it(`can mount a parcel missing the bootstrap lifecycle`, async () => {
    const parcelConfig = { async mount() {}, async unmount() {} };
    const parcel = singleSpa.mountRootParcel(parcelConfig, {
      domElement: document.createElement(""div""),
    });
    await parcel.mountPromise;
  })",snuts
/spec/parcels/mount-root-parcel.spec.js,NonFunctionalStatement,"{'startLine':103,'endLine':103}","it(`can mount a parcel missing the bootstrap lifecycle`, async () => {
    const parcelConfig = { async mount() {}, async unmount() {} };
    const parcel = singleSpa.mountRootParcel(parcelConfig, {
      domElement: document.createElement(""div""),
    });
    await parcel.mountPromise;
  })",snuts
/spec/parcels/mount-root-parcel.spec.js,NonFunctionalStatement,"{'startLine':113,'endLine':113}","it(`can mount a parcel that doesn't have the Object prototype`, async () => {
    // Simulate an ES module, which doesn't have the object prototype
    const parcelConfig = Object.create(null);
    parcelConfig.mount = async function () {};
    parcelConfig.unmount = async function () {};
    const parcel = singleSpa.mountRootParcel(parcelConfig, {
      domElement: document.createElement(""div""),
    });
    await parcel.mountPromise;
  })",snuts
/spec/parcels/mount-root-parcel.spec.js,NonFunctionalStatement,"{'startLine':114,'endLine':114}","it(`can mount a parcel that doesn't have the Object prototype`, async () => {
    // Simulate an ES module, which doesn't have the object prototype
    const parcelConfig = Object.create(null);
    parcelConfig.mount = async function () {};
    parcelConfig.unmount = async function () {};
    const parcel = singleSpa.mountRootParcel(parcelConfig, {
      domElement: document.createElement(""div""),
    });
    await parcel.mountPromise;
  })",snuts
/spec/parcels/mount-root-parcel.spec.js,SubOptimalAssert,"{'startLine':36,'endLine':36}","it(`doesn't resolve bootstrapPromise, mountPromise, or unmountPromise with any values`, () => {
    const parcelConfig = createParcelConfig();
    const parcel = singleSpa.mountRootParcel(parcelConfig, {
      domElement: document.createElement(""div""),
    });
    expect(parcel.getStatus()).toBe(singleSpa.NOT_BOOTSTRAPPED);

    return parcel.bootstrapPromise
      .then((value) => {
        expect(value).toBe(null);
        return parcel.mountPromise;
      })
      .then((value) => {
        expect(value).toBe(null);
        return Promise.all([parcel.unmountPromise, parcel.unmount()]);
      })
      .then((values) => {
        const [unmountPromiseValue, unmountValue] = values;
        expect(unmountPromiseValue).toBe(null);
        expect(unmountValue).toBe(null);
      });
  })",snuts
/spec/parcels/mount-root-parcel.spec.js,SubOptimalAssert,"{'startLine':40,'endLine':40}","it(`doesn't resolve bootstrapPromise, mountPromise, or unmountPromise with any values`, () => {
    const parcelConfig = createParcelConfig();
    const parcel = singleSpa.mountRootParcel(parcelConfig, {
      domElement: document.createElement(""div""),
    });
    expect(parcel.getStatus()).toBe(singleSpa.NOT_BOOTSTRAPPED);

    return parcel.bootstrapPromise
      .then((value) => {
        expect(value).toBe(null);
        return parcel.mountPromise;
      })
      .then((value) => {
        expect(value).toBe(null);
        return Promise.all([parcel.unmountPromise, parcel.unmount()]);
      })
      .then((values) => {
        const [unmountPromiseValue, unmountValue] = values;
        expect(unmountPromiseValue).toBe(null);
        expect(unmountValue).toBe(null);
      });
  })",snuts
/spec/parcels/mount-root-parcel.spec.js,SubOptimalAssert,"{'startLine':45,'endLine':45}","it(`doesn't resolve bootstrapPromise, mountPromise, or unmountPromise with any values`, () => {
    const parcelConfig = createParcelConfig();
    const parcel = singleSpa.mountRootParcel(parcelConfig, {
      domElement: document.createElement(""div""),
    });
    expect(parcel.getStatus()).toBe(singleSpa.NOT_BOOTSTRAPPED);

    return parcel.bootstrapPromise
      .then((value) => {
        expect(value).toBe(null);
        return parcel.mountPromise;
      })
      .then((value) => {
        expect(value).toBe(null);
        return Promise.all([parcel.unmountPromise, parcel.unmount()]);
      })
      .then((values) => {
        const [unmountPromiseValue, unmountValue] = values;
        expect(unmountPromiseValue).toBe(null);
        expect(unmountValue).toBe(null);
      });
  })",snuts
/spec/parcels/mount-root-parcel.spec.js,SubOptimalAssert,"{'startLine':46,'endLine':46}","it(`doesn't resolve bootstrapPromise, mountPromise, or unmountPromise with any values`, () => {
    const parcelConfig = createParcelConfig();
    const parcel = singleSpa.mountRootParcel(parcelConfig, {
      domElement: document.createElement(""div""),
    });
    expect(parcel.getStatus()).toBe(singleSpa.NOT_BOOTSTRAPPED);

    return parcel.bootstrapPromise
      .then((value) => {
        expect(value).toBe(null);
        return parcel.mountPromise;
      })
      .then((value) => {
        expect(value).toBe(null);
        return Promise.all([parcel.unmountPromise, parcel.unmount()]);
      })
      .then((values) => {
        const [unmountPromiseValue, unmountValue] = values;
        expect(unmountPromiseValue).toBe(null);
        expect(unmountValue).toBe(null);
      });
  })",snuts
/spec/parcels/mount-root-parcel.spec.js,SubOptimalAssert,"{'startLine':87,'endLine':87}","it(`allows you to update a parcel that has implemented the update lifecycle`, () => {
    const parcelConfig = createParcelConfig({ withUpdate: true });
    const parcel = singleSpa.mountRootParcel(parcelConfig, {
      domElement: document.createElement(""div""),
    });

    return parcel.mountPromise
      .then(() => expect(typeof parcel.update).toBe(""function""))
      .then(() => expect(parcelConfig.updateCalls).toBe(0))
      .then(() => parcel.update({}))
      .then((resolvedVal) => expect(resolvedVal).toBe(null))
      .then(() => expect(parcelConfig.updateCalls).toBe(1));
  })",snuts
/spec/parcels/app-mounts-parcel.spec.js,GeneralFixture,"{'startLine':11,'endLine':11}","beforeEach(() => {
    parcelConfig = null;
    shouldAppBeMounted = false;

    app = {
      bootstrapCalls: 0,
      bootstrap() {
        app.bootstrapCalls++;
        return Promise.resolve();
      },
      mountCalls: 0,
      mountProps: null,
      mount(props) {
        app.mountCalls++;
        app.mountProps = props;
        return Promise.resolve();
      },
      unmountCalls: 0,
      unmount() {
        app.unmountCalls++;
        return Promise.resolve();
      },
    };
  })",snuts
/spec/parcels/app-mounts-parcel.spec.js,GeneralFixture,"{'startLine':12,'endLine':12}","beforeEach(() => {
    parcelConfig = null;
    shouldAppBeMounted = false;

    app = {
      bootstrapCalls: 0,
      bootstrap() {
        app.bootstrapCalls++;
        return Promise.resolve();
      },
      mountCalls: 0,
      mountProps: null,
      mount(props) {
        app.mountCalls++;
        app.mountProps = props;
        return Promise.resolve();
      },
      unmountCalls: 0,
      unmount() {
        app.unmountCalls++;
        return Promise.resolve();
      },
    };
  })",snuts
/spec/parcels/app-mounts-parcel.spec.js,GeneralFixture,"{'startLine':14,'endLine':32}","beforeEach(() => {
    parcelConfig = null;
    shouldAppBeMounted = false;

    app = {
      bootstrapCalls: 0,
      bootstrap() {
        app.bootstrapCalls++;
        return Promise.resolve();
      },
      mountCalls: 0,
      mountProps: null,
      mount(props) {
        app.mountCalls++;
        app.mountProps = props;
        return Promise.resolve();
      },
      unmountCalls: 0,
      unmount() {
        app.unmountCalls++;
        return Promise.resolve();
      },
    };
  })",snuts
/spec/parcels/app-mounts-parcel.spec.js,NonFunctionalStatement,"{'startLine':313,'endLine':313}","it(`successfully unmounts a parcel that is unmounted before mount finishes`, async () => {
    let shouldAppBeMounted = false,
      parcel;

    singleSpa.registerApplication(
      ""immediate-unmount"",
      app,
      () => shouldAppBeMounted
    );

    parcelConfig = {
      mount: () =>
        new Promise((resolve) => {
          setTimeout(resolve, 50);
        }),
      async unmount() {},
    };

    shouldAppBeMounted = true;

    return singleSpa.triggerAppChange().then(() => {
      parcel = app.mountProps.mountParcel(parcelConfig, {
        domElement: document.createElement(""div""),
      });

      shouldAppBeMounted = false;
      return singleSpa.triggerAppChange();
    });
  })",snuts
/spec/parcels/app-mounts-parcel.spec.js,SubOptimalAssert,"{'startLine':215,'endLine':215}","it(`lets you remount the parcel after forcibly unmounting it`, () => {
    let shouldAppBeMounted = false,
      parcel;
    singleSpa.registerApplication(
      ""remount-parcel"",
      app,
      () => shouldAppBeMounted
    );
    parcelConfig = createParcelConfig();

    shouldAppBeMounted = true;

    return singleSpa
      .triggerAppChange()
      .then(() => {
        parcel = app.mountProps.mountParcel(parcelConfig, {
          domElement: document.createElement(""div""),
        });
        return parcel.mountPromise;
      })
      .then(() =>
        parcel.unmount().then((value) => {
          // The mount promise isn't resolved with anything in particular
          expect(value).toBe(null);
        })
      )
      .then(() => {
        expect(parcel.getStatus()).toBe(singleSpa.NOT_MOUNTED);
        return parcel.mount().then((value) => {
          // The mount promise isn't resolved with anything in particular
          expect(value).toBe(null);
        });
      })
      .then(() => {
        expect(parcel.getStatus()).toBe(singleSpa.MOUNTED);
        shouldAppBeMounted = false;
        return singleSpa.triggerAppChange();
      })
      .then(() => {
        expect(parcel.getStatus()).toBe(singleSpa.NOT_MOUNTED);
        expect(app.unmountCalls).toBe(1);
      });
  })",snuts
/spec/parcels/app-mounts-parcel.spec.js,SubOptimalAssert,"{'startLine':222,'endLine':222}","it(`lets you remount the parcel after forcibly unmounting it`, () => {
    let shouldAppBeMounted = false,
      parcel;
    singleSpa.registerApplication(
      ""remount-parcel"",
      app,
      () => shouldAppBeMounted
    );
    parcelConfig = createParcelConfig();

    shouldAppBeMounted = true;

    return singleSpa
      .triggerAppChange()
      .then(() => {
        parcel = app.mountProps.mountParcel(parcelConfig, {
          domElement: document.createElement(""div""),
        });
        return parcel.mountPromise;
      })
      .then(() =>
        parcel.unmount().then((value) => {
          // The mount promise isn't resolved with anything in particular
          expect(value).toBe(null);
        })
      )
      .then(() => {
        expect(parcel.getStatus()).toBe(singleSpa.NOT_MOUNTED);
        return parcel.mount().then((value) => {
          // The mount promise isn't resolved with anything in particular
          expect(value).toBe(null);
        });
      })
      .then(() => {
        expect(parcel.getStatus()).toBe(singleSpa.MOUNTED);
        shouldAppBeMounted = false;
        return singleSpa.triggerAppChange();
      })
      .then(() => {
        expect(parcel.getStatus()).toBe(singleSpa.NOT_MOUNTED);
        expect(app.unmountCalls).toBe(1);
      });
  })",snuts
/spec/apis/unregister-application.spec.js,GeneralFixture,"{'startLine':10,'endLine':20}","beforeEach(() => {
    app = {
      mount() {
        return Promise.resolve();
      },
      unmount() {
        return Promise.resolve();
      },
      bootstrap() {
        return Promise.resolve();
      },
    };
  })",snuts
/spec/apis/timeout-apis.spec.js,GeneralFixture,"{'startLine':7,'endLine':7}","beforeAll(() => {
    consoleWarnSpy = jest.spyOn(console, ""warn"");
    consoleErrSpy = jest.spyOn(console, ""error"");
    jest.useFakeTimers();
    singleSpa.start();
  })",snuts
/spec/apis/timeout-apis.spec.js,GeneralFixture,"{'startLine':8,'endLine':8}","beforeAll(() => {
    consoleWarnSpy = jest.spyOn(console, ""warn"");
    consoleErrSpy = jest.spyOn(console, ""error"");
    jest.useFakeTimers();
    singleSpa.start();
  })",snuts
/spec/apis/start-api.spec.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}","it(`does not throw an error before start() is called`, async () => {
    jest.spyOn(console, ""warn"");

    jest.advanceTimersByTime(5000);
    expect(console.warn).not.toHaveBeenCalled();

    registerApplication({
      name: ""app1"",
      app: {
        async mount() {},
        async unmount() {},
      },
      activeWhen: ""/"",
    });
    jest.advanceTimersByTime(5000);

    expect(console.warn).toHaveBeenCalled();
    console.warn.mockRestore();
  })",snuts
/spec/apis/start-api.spec.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}","it(`does not throw an error before start() is called`, async () => {
    jest.spyOn(console, ""warn"");

    jest.advanceTimersByTime(5000);
    expect(console.warn).not.toHaveBeenCalled();

    registerApplication({
      name: ""app1"",
      app: {
        async mount() {},
        async unmount() {},
      },
      activeWhen: ""/"",
    });
    jest.advanceTimersByTime(5000);

    expect(console.warn).toHaveBeenCalled();
    console.warn.mockRestore();
  })",snuts
/spec/apis/single-spa-events-api.spec.js,GeneralFixture,"{'startLine':73,'endLine':73}","beforeEach(() => {
      window.location.hash = ``;
      boom = false;
    })",snuts
/spec/apis/single-spa-events-api.spec.js,NonFunctionalStatement,"{'startLine':544,'endLine':544}","it(`allows you to cancel a pushState navigation event in the before-routing-event handler`, async () => {
      await singleSpa.triggerAppChange(""/"");

      const app = { async mount() {}, async unmount() {} };
      singleSpa.registerApplication({
        name: ""cancel-pushstate"",
        app,
        activeWhen: ""/cancel-pushstate"",
      });

      const beforeRoutingEvent = (evt) => {
        window.removeEventListener(
          ""single-spa:before-routing-event"",
          beforeRoutingEvent
        );
        expect(evt.detail.oldUrl).toMatch(/http:\/\/localhost\/(#\/)?/);
        expect(evt.detail.newUrl).toBe(""http://localhost/cancel-pushstate"");

        if (new URL(evt.detail.newUrl).pathname === ""/cancel-pushstate"") {
          evt.detail.cancelNavigation();
        }
      };

      await singleSpa.triggerAppChange();

      window.addEventListener(
        ""single-spa:before-routing-event"",
        beforeRoutingEvent
      );

      const originalStatus = singleSpa.getAppStatus(""russell"");
      const originalUrl = window.location.href;

      expect(originalStatus).toMatch(/NOT_MOUNTED|NOT_LOADED/);

      singleSpa.navigateToUrl(""/cancel-pushstate"");

      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""russell"")).toBe(originalStatus);
      expect(window.location.href).toBe(originalUrl);
    })",snuts
/spec/apis/single-spa-events-api.spec.js,NonFunctionalStatement,"{'startLine':544,'endLine':544}","it(`allows you to cancel a pushState navigation event in the before-routing-event handler`, async () => {
      await singleSpa.triggerAppChange(""/"");

      const app = { async mount() {}, async unmount() {} };
      singleSpa.registerApplication({
        name: ""cancel-pushstate"",
        app,
        activeWhen: ""/cancel-pushstate"",
      });

      const beforeRoutingEvent = (evt) => {
        window.removeEventListener(
          ""single-spa:before-routing-event"",
          beforeRoutingEvent
        );
        expect(evt.detail.oldUrl).toMatch(/http:\/\/localhost\/(#\/)?/);
        expect(evt.detail.newUrl).toBe(""http://localhost/cancel-pushstate"");

        if (new URL(evt.detail.newUrl).pathname === ""/cancel-pushstate"") {
          evt.detail.cancelNavigation();
        }
      };

      await singleSpa.triggerAppChange();

      window.addEventListener(
        ""single-spa:before-routing-event"",
        beforeRoutingEvent
      );

      const originalStatus = singleSpa.getAppStatus(""russell"");
      const originalUrl = window.location.href;

      expect(originalStatus).toMatch(/NOT_MOUNTED|NOT_LOADED/);

      singleSpa.navigateToUrl(""/cancel-pushstate"");

      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""russell"")).toBe(originalStatus);
      expect(window.location.href).toBe(originalUrl);
    })",snuts
/spec/apis/single-spa-events-api.spec.js,NonFunctionalStatement,"{'startLine':591,'endLine':591}","it(`does not fire single-spa events during the reroute back to originalUrl after cancelation`, async () => {
      let preCancelation = [],
        postCancelation = [],
        cancelationStarted = false;

      singleSpa.registerApplication({
        name: ""cancel-navigation-silent-reroute"",
        app: {
          async mount() {},
          async unmount() {},
        },
        activeWhen: [""/""],
      });

      singleSpa.navigateToUrl(""/"");
      await singleSpa.triggerAppChange();

      window.addEventListener(""single-spa:before-routing-event"", countEvents);
      window.addEventListener(
        ""single-spa:before-mount-routing-event"",
        countEvents
      );
      window.addEventListener(""single-spa:before-app-change"", countEvents);
      window.addEventListener(""single-spa:before-no-app-change"", countEvents);
      window.addEventListener(""single-spa:app-change"", countEvents);
      window.addEventListener(""single-spa:no-app-change"", countEvents);
      window.addEventListener(""single-spa:routing-event"", countEvents);

      window.addEventListener(
        ""single-spa:before-routing-event"",
        cancelTheNavigation
      );

      let cancelationFinished,
        cancelationFinishedPromise = new Promise(
          (r) => (cancelationFinished = r)
        );

      singleSpa.navigateToUrl(""/app1"");

      await cancelationFinishedPromise;

      window.removeEventListener(
        ""single-spa:before-routing-event"",
        countEvents
      );
      window.removeEventListener(
        ""single-spa:before-mount-routing-event"",
        countEvents
      );
      window.removeEventListener(""single-spa:before-app-change"", countEvents);
      window.removeEventListener(
        ""single-spa:before-no-app-change"",
        countEvents
      );
      window.removeEventListener(""single-spa:app-change"", countEvents);
      window.removeEventListener(""single-spa:no-app-change"", countEvents);
      window.removeEventListener(""single-spa:routing-event"", countEvents);
      window.removeEventListener(
        ""single-spa:before-routing-event"",
        cancelTheNavigation
      );

      // Give time for single-spa to actually cancel the navigation
      await tick();

      // Cancelation causes two reroutes, and therefore two before-no-app-change and two before-routing-events
      expect(preCancelation).toEqual([
        ""single-spa:before-no-app-change"",
        ""single-spa:before-routing-event"",
      ]);
      expect(postCancelation).toEqual([]);
      expect(location.pathname).toEqual(""/"");

      function countEvents(evt) {
        (cancelationStarted ? postCancelation : preCancelation).push(evt.type);
      }

      function cancelTheNavigation(evt) {
        window.removeEventListener(
          ""single-spa:before-routing-event"",
          cancelTheNavigation
        );
        expect(new URL(evt.detail.oldUrl).pathname).toEqual(""/"");
        expect(new URL(evt.detail.newUrl).pathname).toEqual(""/app1"");
        evt.detail.cancelNavigation();
        cancelationStarted = true;
        cancelationFinished();
      }
    })",snuts
/spec/apis/single-spa-events-api.spec.js,NonFunctionalStatement,"{'startLine':592,'endLine':592}","it(`does not fire single-spa events during the reroute back to originalUrl after cancelation`, async () => {
      let preCancelation = [],
        postCancelation = [],
        cancelationStarted = false;

      singleSpa.registerApplication({
        name: ""cancel-navigation-silent-reroute"",
        app: {
          async mount() {},
          async unmount() {},
        },
        activeWhen: [""/""],
      });

      singleSpa.navigateToUrl(""/"");
      await singleSpa.triggerAppChange();

      window.addEventListener(""single-spa:before-routing-event"", countEvents);
      window.addEventListener(
        ""single-spa:before-mount-routing-event"",
        countEvents
      );
      window.addEventListener(""single-spa:before-app-change"", countEvents);
      window.addEventListener(""single-spa:before-no-app-change"", countEvents);
      window.addEventListener(""single-spa:app-change"", countEvents);
      window.addEventListener(""single-spa:no-app-change"", countEvents);
      window.addEventListener(""single-spa:routing-event"", countEvents);

      window.addEventListener(
        ""single-spa:before-routing-event"",
        cancelTheNavigation
      );

      let cancelationFinished,
        cancelationFinishedPromise = new Promise(
          (r) => (cancelationFinished = r)
        );

      singleSpa.navigateToUrl(""/app1"");

      await cancelationFinishedPromise;

      window.removeEventListener(
        ""single-spa:before-routing-event"",
        countEvents
      );
      window.removeEventListener(
        ""single-spa:before-mount-routing-event"",
        countEvents
      );
      window.removeEventListener(""single-spa:before-app-change"", countEvents);
      window.removeEventListener(
        ""single-spa:before-no-app-change"",
        countEvents
      );
      window.removeEventListener(""single-spa:app-change"", countEvents);
      window.removeEventListener(""single-spa:no-app-change"", countEvents);
      window.removeEventListener(""single-spa:routing-event"", countEvents);
      window.removeEventListener(
        ""single-spa:before-routing-event"",
        cancelTheNavigation
      );

      // Give time for single-spa to actually cancel the navigation
      await tick();

      // Cancelation causes two reroutes, and therefore two before-no-app-change and two before-routing-events
      expect(preCancelation).toEqual([
        ""single-spa:before-no-app-change"",
        ""single-spa:before-routing-event"",
      ]);
      expect(postCancelation).toEqual([]);
      expect(location.pathname).toEqual(""/"");

      function countEvents(evt) {
        (cancelationStarted ? postCancelation : preCancelation).push(evt.type);
      }

      function cancelTheNavigation(evt) {
        window.removeEventListener(
          ""single-spa:before-routing-event"",
          cancelTheNavigation
        );
        expect(new URL(evt.detail.oldUrl).pathname).toEqual(""/"");
        expect(new URL(evt.detail.newUrl).pathname).toEqual(""/app1"");
        evt.detail.cancelNavigation();
        cancelationStarted = true;
        cancelationFinished();
      }
    })",snuts
/spec/apis/single-spa-events-api.spec.js,NonFunctionalStatement,"{'startLine':793,'endLine':793}","describe(`cancelNavigation`, () => {
    it(`allows you to cancel a hash navigation event in the before-routing-event handler`, async () => {
      const beforeRoutingEvent = (evt) => {
        expect(evt.detail.oldUrl).toMatch(/http:\/\/localhost\/(#\/)?/);
        expect(evt.detail.newUrl).toBe(""http://localhost/#/russell"");

        if (new URL(evt.detail.newUrl).hash === ""#/russell"") {
          evt.detail.cancelNavigation();
        }
      };

      window.addEventListener(
        ""single-spa:before-routing-event"",
        beforeRoutingEvent
      );

      const originalStatus = singleSpa.getAppStatus(""russell"");
      const originalUrl = window.location.href;

      expect(originalStatus).toMatch(/NOT_MOUNTED|NOT_LOADED/);

      window.location.hash = `#/russell`;

      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""russell"")).toBe(originalStatus);
      expect(window.location.href).toBe(originalUrl);
      window.removeEventListener(
        ""single-spa:before-routing-event"",
        beforeRoutingEvent
      );
    });

    it(`allows you to cancel a pushState navigation event in the before-routing-event handler`, async () => {
      await singleSpa.triggerAppChange(""/"");

      const app = { async mount() {}, async unmount() {} };
      singleSpa.registerApplication({
        name: ""cancel-pushstate"",
        app,
        activeWhen: ""/cancel-pushstate"",
      });

      const beforeRoutingEvent = (evt) => {
        window.removeEventListener(
          ""single-spa:before-routing-event"",
          beforeRoutingEvent
        );
        expect(evt.detail.oldUrl).toMatch(/http:\/\/localhost\/(#\/)?/);
        expect(evt.detail.newUrl).toBe(""http://localhost/cancel-pushstate"");

        if (new URL(evt.detail.newUrl).pathname === ""/cancel-pushstate"") {
          evt.detail.cancelNavigation();
        }
      };

      await singleSpa.triggerAppChange();

      window.addEventListener(
        ""single-spa:before-routing-event"",
        beforeRoutingEvent
      );

      const originalStatus = singleSpa.getAppStatus(""russell"");
      const originalUrl = window.location.href;

      expect(originalStatus).toMatch(/NOT_MOUNTED|NOT_LOADED/);

      singleSpa.navigateToUrl(""/cancel-pushstate"");

      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""russell"")).toBe(originalStatus);
      expect(window.location.href).toBe(originalUrl);
    });

    it(`does not fire single-spa events during the reroute back to originalUrl after cancelation`, async () => {
      let preCancelation = [],
        postCancelation = [],
        cancelationStarted = false;

      singleSpa.registerApplication({
        name: ""cancel-navigation-silent-reroute"",
        app: {
          async mount() {},
          async unmount() {},
        },
        activeWhen: [""/""],
      });

      singleSpa.navigateToUrl(""/"");
      await singleSpa.triggerAppChange();

      window.addEventListener(""single-spa:before-routing-event"", countEvents);
      window.addEventListener(
        ""single-spa:before-mount-routing-event"",
        countEvents
      );
      window.addEventListener(""single-spa:before-app-change"", countEvents);
      window.addEventListener(""single-spa:before-no-app-change"", countEvents);
      window.addEventListener(""single-spa:app-change"", countEvents);
      window.addEventListener(""single-spa:no-app-change"", countEvents);
      window.addEventListener(""single-spa:routing-event"", countEvents);

      window.addEventListener(
        ""single-spa:before-routing-event"",
        cancelTheNavigation
      );

      let cancelationFinished,
        cancelationFinishedPromise = new Promise(
          (r) => (cancelationFinished = r)
        );

      singleSpa.navigateToUrl(""/app1"");

      await cancelationFinishedPromise;

      window.removeEventListener(
        ""single-spa:before-routing-event"",
        countEvents
      );
      window.removeEventListener(
        ""single-spa:before-mount-routing-event"",
        countEvents
      );
      window.removeEventListener(""single-spa:before-app-change"", countEvents);
      window.removeEventListener(
        ""single-spa:before-no-app-change"",
        countEvents
      );
      window.removeEventListener(""single-spa:app-change"", countEvents);
      window.removeEventListener(""single-spa:no-app-change"", countEvents);
      window.removeEventListener(""single-spa:routing-event"", countEvents);
      window.removeEventListener(
        ""single-spa:before-routing-event"",
        cancelTheNavigation
      );

      // Give time for single-spa to actually cancel the navigation
      await tick();

      // Cancelation causes two reroutes, and therefore two before-no-app-change and two before-routing-events
      expect(preCancelation).toEqual([
        ""single-spa:before-no-app-change"",
        ""single-spa:before-routing-event"",
      ]);
      expect(postCancelation).toEqual([]);
      expect(location.pathname).toEqual(""/"");

      function countEvents(evt) {
        (cancelationStarted ? postCancelation : preCancelation).push(evt.type);
      }

      function cancelTheNavigation(evt) {
        window.removeEventListener(
          ""single-spa:before-routing-event"",
          cancelTheNavigation
        );
        expect(new URL(evt.detail.oldUrl).pathname).toEqual(""/"");
        expect(new URL(evt.detail.newUrl).pathname).toEqual(""/app1"");
        evt.detail.cancelNavigation();
        cancelationStarted = true;
        cancelationFinished();
      }
    });

    it(
      `cancels if you call with no arguments`,
      cancelNavigationTest({
        shouldCancel: true,
        cancelValue: undefined,
        name: ""undefined-cancel"",
      })
    );

    it(
      `cancels if you call with true`,
      cancelNavigationTest({
        shouldCancel: true,
        cancelValue: true,
        name: ""true-cancel"",
      })
    );

    it(
      `cancels if you call with truthy value`,
      cancelNavigationTest({
        shouldCancel: true,
        cancelValue: {},
        name: ""truthy-cancel"",
      })
    );

    it(
      `doesn't cancel navigation if you call with false`,
      cancelNavigationTest({
        shouldCancel: false,
        cancelValue: false,
        name: ""false-cancel"",
      })
    );

    it(
      `doesn't cancel navigation if you call with null`,
      cancelNavigationTest({
        shouldCancel: false,
        cancelValue: null,
        name: ""null-cancel"",
      })
    );

    it(
      `doesn't cancel navigation if you call with falsy value`,
      cancelNavigationTest({
        shouldCancel: false,
        cancelValue: """",
        name: ""empty-string-cancel"",
      })
    );

    // https://github.com/single-spa/single-spa/issues/670
    it(
      `allows for async navigation cancelation`,
      cancelNavigationTest({
        shouldCancel: true,
        cancelValue: () => Promise.resolve(true),
        name: ""async-cancel"",
      })
    );

    it(
      `allows for delayed, async navigation cancelation`,
      cancelNavigationTest({
        shouldCancel: true,
        cancelValue: () =>
          new Promise((resolve) => {
            setTimeout(() => {
              resolve(true);
            }, 10);
          }),
        name: ""async-delayed-cancel"",
      })
    );

    it(
      `doesn't cancel with promise rejection`,
      cancelNavigationTest({
        cancelValue: () => Promise.reject(),
        shouldCancel: false,
        name: ""async-cancel-rejection"",
      })
    );

    it(
      `doesn't cancel with promise that resolves with a false value`,
      cancelNavigationTest({
        cancelValue: Promise.resolve(false),
        shouldCancel: false,
        name: ""async-cancel-false"",
      })
    );

    it(
      `doesn't cancel with promise that resolves with a falsy value`,
      cancelNavigationTest({
        cancelValue: Promise.resolve(""""),
        shouldCancel: false,
        name: ""async-cancel-falsy"",
      })
    );

    it(
      `doesn't cancel with promise that resolves with undefined`,
      cancelNavigationTest({
        cancelValue: Promise.resolve(undefined),
        shouldCancel: false,
        name: ""async-cancel-undefined"",
      })
    );

    function cancelNavigationTest({ cancelValue, shouldCancel, name }) {
      return async function () {
        singleSpa.registerApplication({
          name,
          app: {
            async mount() {},
            async unmount() {},
          },
          activeWhen: [""/""],
        });

        singleSpa.navigateToUrl(""/"");
        await singleSpa.triggerAppChange();

        window.addEventListener(
          ""single-spa:before-routing-event"",
          cancelTheNavigation
        );

        singleSpa.navigateToUrl(""/app1"");
        await singleSpa.triggerAppChange();

        window.removeEventListener(
          ""single-spa:before-routing-event"",
          cancelTheNavigation
        );

        expect(location.pathname).toEqual(shouldCancel ? ""/"" : ""/app1"");

        function cancelTheNavigation(evt) {
          evt.detail.cancelNavigation(
            typeof cancelValue === ""function"" ? cancelValue() : cancelValue
          );
        }
      };
    }
  })",snuts
/spec/apis/single-spa-events-api.spec.js,NonFunctionalStatement,"{'startLine':794,'endLine':794}","describe(`cancelNavigation`, () => {
    it(`allows you to cancel a hash navigation event in the before-routing-event handler`, async () => {
      const beforeRoutingEvent = (evt) => {
        expect(evt.detail.oldUrl).toMatch(/http:\/\/localhost\/(#\/)?/);
        expect(evt.detail.newUrl).toBe(""http://localhost/#/russell"");

        if (new URL(evt.detail.newUrl).hash === ""#/russell"") {
          evt.detail.cancelNavigation();
        }
      };

      window.addEventListener(
        ""single-spa:before-routing-event"",
        beforeRoutingEvent
      );

      const originalStatus = singleSpa.getAppStatus(""russell"");
      const originalUrl = window.location.href;

      expect(originalStatus).toMatch(/NOT_MOUNTED|NOT_LOADED/);

      window.location.hash = `#/russell`;

      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""russell"")).toBe(originalStatus);
      expect(window.location.href).toBe(originalUrl);
      window.removeEventListener(
        ""single-spa:before-routing-event"",
        beforeRoutingEvent
      );
    });

    it(`allows you to cancel a pushState navigation event in the before-routing-event handler`, async () => {
      await singleSpa.triggerAppChange(""/"");

      const app = { async mount() {}, async unmount() {} };
      singleSpa.registerApplication({
        name: ""cancel-pushstate"",
        app,
        activeWhen: ""/cancel-pushstate"",
      });

      const beforeRoutingEvent = (evt) => {
        window.removeEventListener(
          ""single-spa:before-routing-event"",
          beforeRoutingEvent
        );
        expect(evt.detail.oldUrl).toMatch(/http:\/\/localhost\/(#\/)?/);
        expect(evt.detail.newUrl).toBe(""http://localhost/cancel-pushstate"");

        if (new URL(evt.detail.newUrl).pathname === ""/cancel-pushstate"") {
          evt.detail.cancelNavigation();
        }
      };

      await singleSpa.triggerAppChange();

      window.addEventListener(
        ""single-spa:before-routing-event"",
        beforeRoutingEvent
      );

      const originalStatus = singleSpa.getAppStatus(""russell"");
      const originalUrl = window.location.href;

      expect(originalStatus).toMatch(/NOT_MOUNTED|NOT_LOADED/);

      singleSpa.navigateToUrl(""/cancel-pushstate"");

      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""russell"")).toBe(originalStatus);
      expect(window.location.href).toBe(originalUrl);
    });

    it(`does not fire single-spa events during the reroute back to originalUrl after cancelation`, async () => {
      let preCancelation = [],
        postCancelation = [],
        cancelationStarted = false;

      singleSpa.registerApplication({
        name: ""cancel-navigation-silent-reroute"",
        app: {
          async mount() {},
          async unmount() {},
        },
        activeWhen: [""/""],
      });

      singleSpa.navigateToUrl(""/"");
      await singleSpa.triggerAppChange();

      window.addEventListener(""single-spa:before-routing-event"", countEvents);
      window.addEventListener(
        ""single-spa:before-mount-routing-event"",
        countEvents
      );
      window.addEventListener(""single-spa:before-app-change"", countEvents);
      window.addEventListener(""single-spa:before-no-app-change"", countEvents);
      window.addEventListener(""single-spa:app-change"", countEvents);
      window.addEventListener(""single-spa:no-app-change"", countEvents);
      window.addEventListener(""single-spa:routing-event"", countEvents);

      window.addEventListener(
        ""single-spa:before-routing-event"",
        cancelTheNavigation
      );

      let cancelationFinished,
        cancelationFinishedPromise = new Promise(
          (r) => (cancelationFinished = r)
        );

      singleSpa.navigateToUrl(""/app1"");

      await cancelationFinishedPromise;

      window.removeEventListener(
        ""single-spa:before-routing-event"",
        countEvents
      );
      window.removeEventListener(
        ""single-spa:before-mount-routing-event"",
        countEvents
      );
      window.removeEventListener(""single-spa:before-app-change"", countEvents);
      window.removeEventListener(
        ""single-spa:before-no-app-change"",
        countEvents
      );
      window.removeEventListener(""single-spa:app-change"", countEvents);
      window.removeEventListener(""single-spa:no-app-change"", countEvents);
      window.removeEventListener(""single-spa:routing-event"", countEvents);
      window.removeEventListener(
        ""single-spa:before-routing-event"",
        cancelTheNavigation
      );

      // Give time for single-spa to actually cancel the navigation
      await tick();

      // Cancelation causes two reroutes, and therefore two before-no-app-change and two before-routing-events
      expect(preCancelation).toEqual([
        ""single-spa:before-no-app-change"",
        ""single-spa:before-routing-event"",
      ]);
      expect(postCancelation).toEqual([]);
      expect(location.pathname).toEqual(""/"");

      function countEvents(evt) {
        (cancelationStarted ? postCancelation : preCancelation).push(evt.type);
      }

      function cancelTheNavigation(evt) {
        window.removeEventListener(
          ""single-spa:before-routing-event"",
          cancelTheNavigation
        );
        expect(new URL(evt.detail.oldUrl).pathname).toEqual(""/"");
        expect(new URL(evt.detail.newUrl).pathname).toEqual(""/app1"");
        evt.detail.cancelNavigation();
        cancelationStarted = true;
        cancelationFinished();
      }
    });

    it(
      `cancels if you call with no arguments`,
      cancelNavigationTest({
        shouldCancel: true,
        cancelValue: undefined,
        name: ""undefined-cancel"",
      })
    );

    it(
      `cancels if you call with true`,
      cancelNavigationTest({
        shouldCancel: true,
        cancelValue: true,
        name: ""true-cancel"",
      })
    );

    it(
      `cancels if you call with truthy value`,
      cancelNavigationTest({
        shouldCancel: true,
        cancelValue: {},
        name: ""truthy-cancel"",
      })
    );

    it(
      `doesn't cancel navigation if you call with false`,
      cancelNavigationTest({
        shouldCancel: false,
        cancelValue: false,
        name: ""false-cancel"",
      })
    );

    it(
      `doesn't cancel navigation if you call with null`,
      cancelNavigationTest({
        shouldCancel: false,
        cancelValue: null,
        name: ""null-cancel"",
      })
    );

    it(
      `doesn't cancel navigation if you call with falsy value`,
      cancelNavigationTest({
        shouldCancel: false,
        cancelValue: """",
        name: ""empty-string-cancel"",
      })
    );

    // https://github.com/single-spa/single-spa/issues/670
    it(
      `allows for async navigation cancelation`,
      cancelNavigationTest({
        shouldCancel: true,
        cancelValue: () => Promise.resolve(true),
        name: ""async-cancel"",
      })
    );

    it(
      `allows for delayed, async navigation cancelation`,
      cancelNavigationTest({
        shouldCancel: true,
        cancelValue: () =>
          new Promise((resolve) => {
            setTimeout(() => {
              resolve(true);
            }, 10);
          }),
        name: ""async-delayed-cancel"",
      })
    );

    it(
      `doesn't cancel with promise rejection`,
      cancelNavigationTest({
        cancelValue: () => Promise.reject(),
        shouldCancel: false,
        name: ""async-cancel-rejection"",
      })
    );

    it(
      `doesn't cancel with promise that resolves with a false value`,
      cancelNavigationTest({
        cancelValue: Promise.resolve(false),
        shouldCancel: false,
        name: ""async-cancel-false"",
      })
    );

    it(
      `doesn't cancel with promise that resolves with a falsy value`,
      cancelNavigationTest({
        cancelValue: Promise.resolve(""""),
        shouldCancel: false,
        name: ""async-cancel-falsy"",
      })
    );

    it(
      `doesn't cancel with promise that resolves with undefined`,
      cancelNavigationTest({
        cancelValue: Promise.resolve(undefined),
        shouldCancel: false,
        name: ""async-cancel-undefined"",
      })
    );

    function cancelNavigationTest({ cancelValue, shouldCancel, name }) {
      return async function () {
        singleSpa.registerApplication({
          name,
          app: {
            async mount() {},
            async unmount() {},
          },
          activeWhen: [""/""],
        });

        singleSpa.navigateToUrl(""/"");
        await singleSpa.triggerAppChange();

        window.addEventListener(
          ""single-spa:before-routing-event"",
          cancelTheNavigation
        );

        singleSpa.navigateToUrl(""/app1"");
        await singleSpa.triggerAppChange();

        window.removeEventListener(
          ""single-spa:before-routing-event"",
          cancelTheNavigation
        );

        expect(location.pathname).toEqual(shouldCancel ? ""/"" : ""/app1"");

        function cancelTheNavigation(evt) {
          evt.detail.cancelNavigation(
            typeof cancelValue === ""function"" ? cancelValue() : cancelValue
          );
        }
      };
    }
  })",snuts
/spec/apis/register-application.spec.js,NonFunctionalStatement,"{'startLine':175,'endLine':175}","it(""should succeed when I pass in a function for custom props"", () => {
      expect(() => {
        singleSpa.registerApplication(
          ""custom-props-fn-1"",
          app,
          () => true,
          () => {}
        );
      }).not.toThrow();
      expect(() => {
        singleSpa.registerApplication({
          name: ""custom-props-fn-2"",
          app,
          activeWhen: () => true,
          customProps: () => {},
        });
      }).not.toThrow();
    })",snuts
/spec/apis/register-application.spec.js,NonFunctionalStatement,"{'startLine':183,'endLine':183}","it(""should succeed when I pass in a function for custom props"", () => {
      expect(() => {
        singleSpa.registerApplication(
          ""custom-props-fn-1"",
          app,
          () => true,
          () => {}
        );
      }).not.toThrow();
      expect(() => {
        singleSpa.registerApplication({
          name: ""custom-props-fn-2"",
          app,
          activeWhen: () => true,
          customProps: () => {},
        });
      }).not.toThrow();
    })",snuts
/spec/apis/navigate-to-url.spec.js,SubOptimalAssert,"{'startLine':149,'endLine':149}","it(""should fire a popstate event when history.pushState is called"", function () {
    return singleSpa.triggerAppChange().then(() => {
      return new Promise((resolve, reject) => {
        const newHistoryState = { why: ""hello"" };
        window.addEventListener(""popstate"", popstateListener);
        window.history.pushState(newHistoryState, ""title"", ""/new-url"");
        function popstateListener(evt) {
          expect(evt instanceof PopStateEvent).toBe(true);
          expect(window.location.pathname).toBe(""/new-url"");
          expect(evt.state).toBe(newHistoryState);
          expect(evt.singleSpa).toBe(true);
          expect(evt.singleSpaTrigger).toBe(""pushState"");
          window.removeEventListener(""popstate"", popstateListener);
          resolve();
        }
      });
    });
  })",snuts
/spec/apis/navigate-to-url.spec.js,SubOptimalAssert,"{'startLine':176,'endLine':176}","it(""should fire a popstate event when history.replaceState is called"", async function () {
    history.replaceState(history.state, """", ""/"");

    await singleSpa.triggerAppChange();

    await new Promise((resolve, reject) => {
      const newHistoryState = { yoshi: ""best"" };
      window.addEventListener(""popstate"", popstateListener);
      window.history.replaceState(newHistoryState, """", ""/new-url"");

      function popstateListener(evt) {
        expect(evt instanceof PopStateEvent).toBe(true);
        expect(window.location.pathname).toBe(""/new-url"");
        expect(evt.state).toBe(newHistoryState);
        expect(evt.singleSpa).toBe(true);
        expect(evt.singleSpaTrigger).toBe(""replaceState"");
        window.removeEventListener(""popstate"", popstateListener);
        resolve();
      }
    });
  })",snuts
/spec/apis/multiple-instances.spec.js,GeneralFixture,"{'startLine':5,'endLine':5}","beforeEach(() => {
    consoleWarnSpy = jest.spyOn(console, ""warn"");
  })",snuts
/spec/apis/multiple-instances.spec.js,NonFunctionalStatement,"{'startLine':14,'endLine':14}","it(`should log a warning to the console when you load single-spa on a page that already has loaded single-spa`, async () => {
    // This is how we ""fool"" single-spa into thinking it was already loaded on the page
    window.singleSpaNavigate = function () {};

    expect(consoleWarnSpy).not.toHaveBeenCalled();

    await import(""single-spa"");

    expect(consoleWarnSpy).toHaveBeenCalledWith(
      ""single-spa minified message #41: single-spa has been loaded twice on the page. This can result in unexpected behavior. See https://single-spa.js.org/error/?code=41""
    );
  })",snuts
/spec/apis/error-handlers.spec.js,GeneralFixture,"{'startLine':15,'endLine':15}","beforeEach(() => {
    errs = [];
    singleSpa.addErrorHandler(handleError);
  })",snuts
/spec/apis/error-handlers.spec.js,NonFunctionalStatement,"{'startLine':177,'endLine':177}","it(`only throws one error when the application or parcel fails to mount`, async () => {
    const app = {
      async bootstrap() {},
      async mount() {
        throw Error(""the mount failed"");
      },
      async unmount() {
        throw Error(""the unmount failed"");
      },
    };
    location.hash = ""#"";
    await singleSpa.triggerAppChange();
    singleSpa.registerApplication(""one-error-only"", app, (location) =>
      location.hash.startsWith(""#one-error-only"")
    );
    location.hash = ""#one-error-only"";
    await singleSpa.triggerAppChange();

    expect(errs.length).toBe(1);
    expect(errs[0].message).toMatch(""the mount failed"");
    expect(errs[0].message).not.toMatch(""the unmount"");
  })",snuts
/spec/apis/error-handlers.spec.js,SubOptimalAssert,"{'startLine':33,'endLine':33}","it(`reports an error during load`, () => {
    singleSpa.registerApplication(
      ""load-error"",
      () => Promise.reject(""Could not load this one""),
      (location) => location.hash === ""#load-error""
    );

    location.hash = ""#load-error"";

    return singleSpa.triggerAppChange().then(() => {
      expect(errs.length).toBe(1);
      expect(errs[0].appOrParcelName).toBe(""load-error"");
      expect(errs[0].message).toMatch(
        `'load-error' died in status LOADING_SOURCE_CODE: ""Could not load this one""`
      );
      expect(singleSpa.getAppStatus(""load-error"")).toBe(singleSpa.LOAD_ERROR);
    });
  })",snuts
/spec/apis/error-handlers.spec.js,SubOptimalAssert,"{'startLine':64,'endLine':64}","it(`reports an error during bootstrap`, () => {
    const app = {
      bootstrap() {
        return Promise.reject(new Error(`couldn't bootstrap`));
      },
      mount() {
        return Promise.resolve();
      },
      unmount() {
        return Promise.resolve();
      },
    };

    singleSpa.registerApplication(
      ""bootstrap-error"",
      app,
      (location) => location.hash === ""#bootstrap-error""
    );

    location.hash = ""#bootstrap-error"";

    return singleSpa.triggerAppChange().then(() => {
      expect(errs.length).toBe(1);
      expect(errs[0].appOrParcelName).toBe(""bootstrap-error"");
      expect(errs[0].message).toMatch(
        `'bootstrap-error' died in status BOOTSTRAPPING: couldn't bootstrap`
      );
      expect(singleSpa.getAppStatus(""bootstrap-error"")).toBe(
        singleSpa.SKIP_BECAUSE_BROKEN
      );
    });
  })",snuts
/spec/apis/error-handlers.spec.js,SubOptimalAssert,"{'startLine':97,'endLine':97}","it(`reports an error during mount`, () => {
    const app = {
      bootstrap() {
        return Promise.resolve();
      },
      mount() {
        return Promise.reject(`couldn't mount`);
      },
      unmount() {
        return Promise.resolve();
      },
    };

    singleSpa.registerApplication(
      ""mount-error"",
      app,
      (location) => location.hash === ""#mount-error""
    );

    location.hash = ""#mount-error"";

    return singleSpa.triggerAppChange().then(() => {
      expect(errs.length).toBe(1);
      expect(errs[0].appOrParcelName).toBe(""mount-error"");
      expect(
        errs[0].message.indexOf(
          `'mount-error' died in status NOT_MOUNTED: ""couldn't mount""`
        )
      ).toBeGreaterThan(-1);
    });
  })",snuts
/spec/apis/error-handlers.spec.js,SubOptimalAssert,"{'startLine':135,'endLine':135}","it(`reports an error during unmount`, () => {
    const app = {
      bootstrap() {
        return Promise.resolve();
      },
      mount() {
        return Promise.resolve();
      },
      unmount() {
        return Promise.reject(new Error(`couldn't unmount`));
      },
    };

    singleSpa.registerApplication(
      ""unmount-error"",
      app,
      (location) => location.hash === ""#unmount-error""
    );

    location.hash = ""#unmount-error"";

    return singleSpa
      .triggerAppChange()
      .then(() => {
        location.hash = ""#something-else"";
        return singleSpa.triggerAppChange();
      })
      .then(() => {
        expect(errs.length).toBe(1);
        expect(errs[0].appOrParcelName).toBe(""unmount-error"");
        expect(
          errs[0].message.indexOf(
            `'unmount-error' died in status UNMOUNTING: couldn't unmount`
          )
        ).toBeGreaterThan(-1);
      });
  })",snuts
/spec/apis/error-handlers.spec.js,SubOptimalAssert,"{'startLine':165,'endLine':165}","it(`reports an error during activity functions`, () => {
    const app = {
      bootstrap() {
        return Promise.resolve();
      },
      mount() {
        return Promise.resolve();
      },
      unmount() {
        return Promise.resolve();
      },
    };

    singleSpa.registerApplication(""activity-error"", app, (location) => {
      throw new Error(""bad activity function"");
    });

    location.hash = ""#activity-error"";

    return singleSpa.triggerAppChange().then(() => {
      expect(errs.length).toBe(1);
      expect(errs[0].appOrParcelName).toBe(""activity-error"");
      expect(
        errs[0].message.indexOf(
          `'activity-error' died in status NOT_LOADED: bad activity function`
        )
      ).toBeGreaterThan(-1);
    });
  })",snuts
/spec/apis/error-handlers.spec.js,SubOptimalAssert,"{'startLine':193,'endLine':193}","it(`only throws one error when the application or parcel fails to mount`, async () => {
    const app = {
      async bootstrap() {},
      async mount() {
        throw Error(""the mount failed"");
      },
      async unmount() {
        throw Error(""the unmount failed"");
      },
    };
    location.hash = ""#"";
    await singleSpa.triggerAppChange();
    singleSpa.registerApplication(""one-error-only"", app, (location) =>
      location.hash.startsWith(""#one-error-only"")
    );
    location.hash = ""#one-error-only"";
    await singleSpa.triggerAppChange();

    expect(errs.length).toBe(1);
    expect(errs[0].message).toMatch(""the mount failed"");
    expect(errs[0].message).not.toMatch(""the unmount"");
  })",snuts
/spec/apis/error-handlers.spec.js,VerifyInSetup,"{'startLine':19,'endLine':21}","afterEach(() => {
    expect(singleSpa.removeErrorHandler(handleError)).toBe(true);
  })",snuts
/spec/apis/delayed-start-popstate.spec.js,GeneralFixture,"{'startLine':17,'endLine':17}","beforeEach(() => {
    numPopstates = 0;
    window.addEventListener(""popstate"", popstateListener);
  })",snuts
/spec/apps/unmount-times-out-dies/unmount-times-out-dies.spec.js,GeneralFixture,"{'startLine':24,'endLine':24}","beforeEach(() => {
    location.hash = ""#"";

    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./unmount-times-out-dies.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/unmount-times-out/unmount-times-out.spec.js,GeneralFixture,"{'startLine':22,'endLine':22}","beforeEach(() => {
    errs = [];
    singleSpa.addErrorHandler(handleError);

    location.hash = ""#"";

    return import(""./unmount-times-out.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/unmount-rejects/unmount-rejects.spec.js,GeneralFixture,"{'startLine':24,'endLine':24}","beforeEach(() => {
    location.hash = ""#"";

    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./unmount-rejects.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/warning-timeouts/warning-timeouts.spec.js,GeneralFixture,"{'startLine':19,'endLine':19}","beforeAll(() => {
    singleSpa.registerApplication(
      ""warning-timeouts"",
      () => import(""./warning-timeouts.app""),
      (location) => location.hash === activeHash
    );
    singleSpa.start();
    consoleWarnSpy = jest.spyOn(console, ""warn"");
    jest.useFakeTimers();
    window.addEventListener(""fake-timers-advance"", advanceTimers);
  })",snuts
/spec/apps/warning-timeouts/warning-timeouts.spec.js,GeneralFixture,"{'startLine':31,'endLine':31}","beforeEach(() => {
    errs = [];
    singleSpa.addErrorHandler(handleError);

    location.hash = ""#"";

    return import(""./warning-timeouts.app"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/warning-timeouts/warning-timeouts.spec.js,SubOptimalAssert,"{'startLine':51,'endLine':51}","it(`doesn't warn if everything resolves before the default warning setting`, async () => {
    location.hash = activeHash;

    await controlledAppChange();
    expect(singleSpa.getAppStatus(""warning-timeouts"")).toEqual(""MOUNTED"");
    expect(errs.length).toBe(0);
    expect(consoleWarnSpy).not.toHaveBeenCalled();

    location.hash = ""#not-warning-timeouts"";

    await controlledAppChange();
    expect(singleSpa.getAppStatus(""warning-timeouts"")).toEqual(""NOT_MOUNTED"");
    expect(errs.length).toBe(0);
    expect(consoleWarnSpy).not.toHaveBeenCalled();
  })",snuts
/spec/apps/warning-timeouts/warning-timeouts.spec.js,SubOptimalAssert,"{'startLine':58,'endLine':58}","it(`doesn't warn if everything resolves before the default warning setting`, async () => {
    location.hash = activeHash;

    await controlledAppChange();
    expect(singleSpa.getAppStatus(""warning-timeouts"")).toEqual(""MOUNTED"");
    expect(errs.length).toBe(0);
    expect(consoleWarnSpy).not.toHaveBeenCalled();

    location.hash = ""#not-warning-timeouts"";

    await controlledAppChange();
    expect(singleSpa.getAppStatus(""warning-timeouts"")).toEqual(""NOT_MOUNTED"");
    expect(errs.length).toBe(0);
    expect(consoleWarnSpy).not.toHaveBeenCalled();
  })",snuts
/spec/apps/warning-timeouts/warning-timeouts.spec.js,SubOptimalAssert,"{'startLine':68,'endLine':68}","it(`does warn if things don't resolve until after the default warning setting`, async () => {
    myApp.setDelay(3);
    location.hash = activeHash;

    await controlledAppChange();
    expect(singleSpa.getAppStatus(""warning-timeouts"")).toEqual(""MOUNTED"");
    expect(errs.length).toBe(0);
    expectWarning(
      `single-spa minified message #31: Lifecycle function bootstrap for application warning-timeouts lifecycle did not resolve or reject for 4000 ms. See https://single-spa.js.org/error/?code=31&arg=bootstrap&arg=application&arg=warning-timeouts&arg=4000`
    );
    expectWarning(
      `single-spa minified message #31: Lifecycle function mount for application warning-timeouts lifecycle did not resolve or reject for 3000 ms. See https://single-spa.js.org/error/?code=31&arg=mount&arg=application&arg=warning-timeouts&arg=3000`
    );

    location.hash = ""#not-warning-timeouts"";

    await controlledAppChange();
    expect(singleSpa.getAppStatus(""warning-timeouts"")).toEqual(""NOT_MOUNTED"");
    expect(errs.length).toBe(0);
  })",snuts
/spec/apps/warning-timeouts/warning-timeouts.spec.js,SubOptimalAssert,"{'startLine':80,'endLine':80}","it(`does warn if things don't resolve until after the default warning setting`, async () => {
    myApp.setDelay(3);
    location.hash = activeHash;

    await controlledAppChange();
    expect(singleSpa.getAppStatus(""warning-timeouts"")).toEqual(""MOUNTED"");
    expect(errs.length).toBe(0);
    expectWarning(
      `single-spa minified message #31: Lifecycle function bootstrap for application warning-timeouts lifecycle did not resolve or reject for 4000 ms. See https://single-spa.js.org/error/?code=31&arg=bootstrap&arg=application&arg=warning-timeouts&arg=4000`
    );
    expectWarning(
      `single-spa minified message #31: Lifecycle function mount for application warning-timeouts lifecycle did not resolve or reject for 3000 ms. See https://single-spa.js.org/error/?code=31&arg=mount&arg=application&arg=warning-timeouts&arg=3000`
    );

    location.hash = ""#not-warning-timeouts"";

    await controlledAppChange();
    expect(singleSpa.getAppStatus(""warning-timeouts"")).toEqual(""NOT_MOUNTED"");
    expect(errs.length).toBe(0);
  })",snuts
/spec/apps/register-with-object/register-with-object.spec.js,GeneralFixture,"{'startLine':33,'endLine':33}","beforeEach(() => {
    location.hash = ""#not-register-with-object"";

    bootstrapped = false;
    mounted = false;
  })",snuts
/spec/apps/register-with-object/register-with-object.spec.js,GeneralFixture,"{'startLine':34,'endLine':34}","beforeEach(() => {
    location.hash = ""#not-register-with-object"";

    bootstrapped = false;
    mounted = false;
  })",snuts
/spec/apps/profiler-basic/profiler-routing-start.spec.js,NonFunctionalStatement,"{'startLine':16,'endLine':16}","beforeEach(async () => {
    app = {
      bootstrap: async () => {},
      mount: async () => {},
      unmount: async () => {},
    };

    shouldMount = true;

    singleSpa.getAppNames().forEach(singleSpa.unregisterApplication);

    await singleSpa.triggerAppChange();

    // Unfortunately calling triggerAppChange results in things happening
    // after it finishes, so we need to wait for those to finish
    await tick(25);

    clearProfilerData();
  })",snuts
/spec/apps/profiler-basic/profiler-routing-start.spec.js,NonFunctionalStatement,"{'startLine':17,'endLine':17}","beforeEach(async () => {
    app = {
      bootstrap: async () => {},
      mount: async () => {},
      unmount: async () => {},
    };

    shouldMount = true;

    singleSpa.getAppNames().forEach(singleSpa.unregisterApplication);

    await singleSpa.triggerAppChange();

    // Unfortunately calling triggerAppChange results in things happening
    // after it finishes, so we need to wait for those to finish
    await tick(25);

    clearProfilerData();
  })",snuts
/spec/apps/profiler-basic/profiler-routing-start.spec.js,NonFunctionalStatement,"{'startLine':18,'endLine':18}","beforeEach(async () => {
    app = {
      bootstrap: async () => {},
      mount: async () => {},
      unmount: async () => {},
    };

    shouldMount = true;

    singleSpa.getAppNames().forEach(singleSpa.unregisterApplication);

    await singleSpa.triggerAppChange();

    // Unfortunately calling triggerAppChange results in things happening
    // after it finishes, so we need to wait for those to finish
    await tick(25);

    clearProfilerData();
  })",snuts
/spec/apps/profiler-basic/profiler-routing-start.spec.js,SubOptimalAssert,"{'startLine':36,'endLine':36}","it(""fires successful unmountAndUnload profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""unmountAndUnload"");
    expect(profilesBefore.length).toBe(0);

    singleSpa.registerApplication({
      name: ""unmountAndUnload profiler success"",
      app,
      activeWhen: () => shouldMount,
    });

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""unmountAndUnload"");
    expect(profilesAfter.length).toBeGreaterThan(0);
    expect(profilesAfter[0].operationSucceeded).toBe(true);
  })",snuts
/spec/apps/profiler-basic/profiler-routing-start.spec.js,SubOptimalAssert,"{'startLine':53,'endLine':53}","it(""fires successful loadAndMount profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""loadAndMount"");
    expect(profilesBefore.length).toBe(0);

    singleSpa.registerApplication({
      name: ""loadAndMount profiler success"",
      app,
      activeWhen: () => shouldMount,
    });

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""loadAndMount"");
    expect(profilesAfter.length).toBeGreaterThan(0);
    expect(profilesAfter[0].operationSucceeded).toBe(true);
  })",snuts
/spec/apps/profiler-basic/profiler-routing-start.spec.js,SubOptimalAssert,"{'startLine':70,'endLine':70}","it(""fires navigationCanceled profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""navigationCanceled"");
    expect(profilesBefore.length).toBe(0);

    window.addEventListener(
      ""single-spa:before-routing-event"",
      handleBeforeRouting
    );

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""navigationCanceled"");
    expect(profilesAfter.length).toBe(1);

    window.removeEventListener(
      ""single-spa:before-routing-event"",
      handleBeforeRouting
    );

    function handleBeforeRouting(evt) {
      evt.detail.cancelNavigation();
    }
  })",snuts
/spec/apps/profiler-basic/profiler-routing-start.spec.js,SubOptimalAssert,"{'startLine':80,'endLine':80}","it(""fires navigationCanceled profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""navigationCanceled"");
    expect(profilesBefore.length).toBe(0);

    window.addEventListener(
      ""single-spa:before-routing-event"",
      handleBeforeRouting
    );

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""navigationCanceled"");
    expect(profilesAfter.length).toBe(1);

    window.removeEventListener(
      ""single-spa:before-routing-event"",
      handleBeforeRouting
    );

    function handleBeforeRouting(evt) {
      evt.detail.cancelNavigation();
    }
  })",snuts
/spec/apps/profiler-basic/profiler-routing-no-start.spec.js,NonFunctionalStatement,"{'startLine':12,'endLine':12}","beforeEach(async () => {
    app = {
      bootstrap: async () => {},
      mount: async () => {},
      unmount: async () => {},
    };

    shouldMount = true;

    singleSpa.getAppNames().forEach(singleSpa.unregisterApplication);

    await singleSpa.triggerAppChange();

    clearProfilerData();
  })",snuts
/spec/apps/profiler-basic/profiler-routing-no-start.spec.js,NonFunctionalStatement,"{'startLine':13,'endLine':13}","beforeEach(async () => {
    app = {
      bootstrap: async () => {},
      mount: async () => {},
      unmount: async () => {},
    };

    shouldMount = true;

    singleSpa.getAppNames().forEach(singleSpa.unregisterApplication);

    await singleSpa.triggerAppChange();

    clearProfilerData();
  })",snuts
/spec/apps/profiler-basic/profiler-routing-no-start.spec.js,NonFunctionalStatement,"{'startLine':14,'endLine':14}","beforeEach(async () => {
    app = {
      bootstrap: async () => {},
      mount: async () => {},
      unmount: async () => {},
    };

    shouldMount = true;

    singleSpa.getAppNames().forEach(singleSpa.unregisterApplication);

    await singleSpa.triggerAppChange();

    clearProfilerData();
  })",snuts
/spec/apps/profiler-basic/profiler-routing-no-start.spec.js,SubOptimalAssert,"{'startLine':28,'endLine':28}","it(""fires successful loadApp profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""loadApps"");
    expect(profilesBefore.length).toBe(0);

    singleSpa.registerApplication({
      name: ""loadApp profiler success"",
      app,
      activeWhen: () => shouldMount,
    });

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""loadApps"");
    expect(profilesAfter.length).toBeGreaterThan(0);
    expect(profilesAfter[0].operationSucceeded).toBe(true);
  })",snuts
/spec/apps/profiler-basic/profiler-routing-no-start.spec.js,SubOptimalAssert,"{'startLine':47,'endLine':47}","xit(""fires failed loadApp profiler"", async () => {
    const profilesBefore = getProfilerEventsByKind(""loadApps"");
    expect(profilesBefore.length).toBe(0);

    singleSpa.registerApplication({
      name: ""loadApp profiler fail"",
      app: async () => {
        console.log(""failling"");
        throw Error(""failed"");
      },
      activeWhen: () => shouldMount,
    });

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""loadApps"");
    console.log(getProfilerData());
    expect(profilesAfter.length).toBeGreaterThan(0);
    expect(profilesAfter.some((p) => !p.operationSucceeded)).toBe(true);
  })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,GeneralFixture,"{'startLine':18,'endLine':23}","beforeEach(() => {
      app = {
        bootstrap: jest.fn(() => Promise.resolve()),
        mount: jest.fn(() => Promise.resolve()),
        unmount: jest.fn(() => Promise.resolve()),
        unload: jest.fn(() => Promise.resolve()),
      };

      loadApp = jest.fn(() => Promise.resolve(app));

      singleSpa.registerApplication({
        name: ""profiler-basics"",
        app: loadApp,
        activeWhen: () => shouldMount,
      });
      shouldMount = false;
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,GeneralFixture,"{'startLine':25,'endLine':25}","beforeEach(() => {
      app = {
        bootstrap: jest.fn(() => Promise.resolve()),
        mount: jest.fn(() => Promise.resolve()),
        unmount: jest.fn(() => Promise.resolve()),
        unload: jest.fn(() => Promise.resolve()),
      };

      loadApp = jest.fn(() => Promise.resolve(app));

      singleSpa.registerApplication({
        name: ""profiler-basics"",
        app: loadApp,
        activeWhen: () => shouldMount,
      });
      shouldMount = false;
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,GeneralFixture,"{'startLine':32,'endLine':32}","beforeEach(() => {
      app = {
        bootstrap: jest.fn(() => Promise.resolve()),
        mount: jest.fn(() => Promise.resolve()),
        unmount: jest.fn(() => Promise.resolve()),
        unload: jest.fn(() => Promise.resolve()),
      };

      loadApp = jest.fn(() => Promise.resolve(app));

      singleSpa.registerApplication({
        name: ""profiler-basics"",
        app: loadApp,
        activeWhen: () => shouldMount,
      });
      shouldMount = false;
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,NonFunctionalStatement,"{'startLine':229,'endLine':229}","it(`captures unloadErr error profile events`, async () => {
      app.unload.mockImplementationOnce(() =>
        Promise.reject(Error(""Unload errr""))
      );
      const profilesBefore = getProfilerEventsByKind(""unload"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      shouldMount = false;
      await singleSpa.triggerAppChange();
      clearProfilerData();
      try {
        await singleSpa.unloadApplication(""profiler-basics"", {
          waitForUnmount: false,
        });
        fail(""Expected unload err"");
      } catch (err) {}

      await singleSpa.triggerAppChange();

      expect(singleSpa.getAppStatus(""profiler-basics"")).toBe(
        singleSpa.SKIP_BECAUSE_BROKEN
      );

      const profilesAfter = getProfilerEventsByKind(""unload"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(false);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,NonFunctionalStatement,"{'startLine':251,'endLine':251}","beforeEach(() => {
      clearProfilerData();

      parcelConfig = {
        async bootstrap() {},
        async mount() {},
        async update() {},
        async unmount() {},
        name: ""profiler-basics"",
      };

      props = {
        domElement: document.createElement(""div""),
      };
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,NonFunctionalStatement,"{'startLine':252,'endLine':252}","beforeEach(() => {
      clearProfilerData();

      parcelConfig = {
        async bootstrap() {},
        async mount() {},
        async update() {},
        async unmount() {},
        name: ""profiler-basics"",
      };

      props = {
        domElement: document.createElement(""div""),
      };
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,NonFunctionalStatement,"{'startLine':253,'endLine':253}","beforeEach(() => {
      clearProfilerData();

      parcelConfig = {
        async bootstrap() {},
        async mount() {},
        async update() {},
        async unmount() {},
        name: ""profiler-basics"",
      };

      props = {
        domElement: document.createElement(""div""),
      };
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,NonFunctionalStatement,"{'startLine':254,'endLine':254}","beforeEach(() => {
      clearProfilerData();

      parcelConfig = {
        async bootstrap() {},
        async mount() {},
        async update() {},
        async unmount() {},
        name: ""profiler-basics"",
      };

      props = {
        domElement: document.createElement(""div""),
      };
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,NonFunctionalStatement,"{'startLine':314,'endLine':314}","describe(""routing profiler events"", () => {})",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':47,'endLine':47}","it(`captures load profile events`, async () => {
      const loadProfilesBefore = getProfilerEventsByKind(""load"");
      expect(loadProfilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.MOUNTED
      );
      const loadProfilesAfter = getProfilerEventsByKind(""load"");

      expect(loadProfilesAfter.length).toBe(1);
      expect(loadProfilesAfter[0].operationSucceeded).toBe(true);
      expect(!Number.isNaN(loadProfilesAfter[0].start)).toBe(true);
      expect(!Number.isNaN(loadProfilesAfter[0].end)).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':56,'endLine':56}","it(`captures load profile events`, async () => {
      const loadProfilesBefore = getProfilerEventsByKind(""load"");
      expect(loadProfilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.MOUNTED
      );
      const loadProfilesAfter = getProfilerEventsByKind(""load"");

      expect(loadProfilesAfter.length).toBe(1);
      expect(loadProfilesAfter[0].operationSucceeded).toBe(true);
      expect(!Number.isNaN(loadProfilesAfter[0].start)).toBe(true);
      expect(!Number.isNaN(loadProfilesAfter[0].end)).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':68,'endLine':68}","it(`captures load error profile events`, async () => {
      loadApp.mockImplementationOnce(() =>
        Promise.reject(Error(""Failed to load""))
      );

      const loadProfilesBefore = getProfilerEventsByKind(""load"");
      expect(loadProfilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.LOAD_ERROR
      );
      const loadProfilesAfter = getProfilerEventsByKind(""load"");

      expect(loadProfilesAfter.length).toBe(1);
      expect(loadProfilesAfter[0].operationSucceeded).toBe(false);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':77,'endLine':77}","it(`captures load error profile events`, async () => {
      loadApp.mockImplementationOnce(() =>
        Promise.reject(Error(""Failed to load""))
      );

      const loadProfilesBefore = getProfilerEventsByKind(""load"");
      expect(loadProfilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.LOAD_ERROR
      );
      const loadProfilesAfter = getProfilerEventsByKind(""load"");

      expect(loadProfilesAfter.length).toBe(1);
      expect(loadProfilesAfter[0].operationSucceeded).toBe(false);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':83,'endLine':83}","it(`captures bootstrap profile events`, async () => {
      const profilesBefore = getProfilerEventsByKind(""bootstrap"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      expect(singleSpa.checkActivityFunctions()).toContain(""profiler-basics"");
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.MOUNTED
      );
      const profilesAfter = getProfilerEventsByKind(""bootstrap"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':93,'endLine':93}","it(`captures bootstrap profile events`, async () => {
      const profilesBefore = getProfilerEventsByKind(""bootstrap"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      expect(singleSpa.checkActivityFunctions()).toContain(""profiler-basics"");
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.MOUNTED
      );
      const profilesAfter = getProfilerEventsByKind(""bootstrap"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':103,'endLine':103}","it(`captures bootstrap error profile events`, async () => {
      app.bootstrap.mockImplementationOnce(() =>
        Promise.reject(Error(""Bootstrap err""))
      );

      const profilesBefore = getProfilerEventsByKind(""bootstrap"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      expect(singleSpa.checkActivityFunctions()).toContain(""profiler-basics"");
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.SKIP_BECAUSE_BROKEN
      );
      const profilesAfter = getProfilerEventsByKind(""bootstrap"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(false);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':113,'endLine':113}","it(`captures bootstrap error profile events`, async () => {
      app.bootstrap.mockImplementationOnce(() =>
        Promise.reject(Error(""Bootstrap err""))
      );

      const profilesBefore = getProfilerEventsByKind(""bootstrap"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      expect(singleSpa.checkActivityFunctions()).toContain(""profiler-basics"");
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.SKIP_BECAUSE_BROKEN
      );
      const profilesAfter = getProfilerEventsByKind(""bootstrap"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(false);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':119,'endLine':119}","it(`captures mount profile events`, async () => {
      const profilesBefore = getProfilerEventsByKind(""mount"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      expect(singleSpa.checkActivityFunctions()).toContain(""profiler-basics"");
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.MOUNTED
      );
      const profilesAfter = getProfilerEventsByKind(""mount"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':129,'endLine':129}","it(`captures mount profile events`, async () => {
      const profilesBefore = getProfilerEventsByKind(""mount"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      expect(singleSpa.checkActivityFunctions()).toContain(""profiler-basics"");
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.MOUNTED
      );
      const profilesAfter = getProfilerEventsByKind(""mount"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':139,'endLine':139}","it(`captures mount error profile events`, async () => {
      app.mount.mockImplementationOnce(() =>
        Promise.reject(Error(""Mount err""))
      );

      const profilesBefore = getProfilerEventsByKind(""mount"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      expect(singleSpa.checkActivityFunctions()).toContain(""profiler-basics"");
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.SKIP_BECAUSE_BROKEN
      );
      const profilesAfter = getProfilerEventsByKind(""mount"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(false);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':149,'endLine':149}","it(`captures mount error profile events`, async () => {
      app.mount.mockImplementationOnce(() =>
        Promise.reject(Error(""Mount err""))
      );

      const profilesBefore = getProfilerEventsByKind(""mount"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      expect(singleSpa.checkActivityFunctions()).toContain(""profiler-basics"");
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.SKIP_BECAUSE_BROKEN
      );
      const profilesAfter = getProfilerEventsByKind(""mount"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(false);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':155,'endLine':155}","it(`captures unmount profile events`, async () => {
      const profilesBefore = getProfilerEventsByKind(""unmount"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      shouldMount = false;
      await singleSpa.triggerAppChange();

      const profilesAfter = getProfilerEventsByKind(""unmount"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':164,'endLine':164}","it(`captures unmount profile events`, async () => {
      const profilesBefore = getProfilerEventsByKind(""unmount"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      shouldMount = false;
      await singleSpa.triggerAppChange();

      const profilesAfter = getProfilerEventsByKind(""unmount"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':173,'endLine':173}","it(`captures unmount error profile events`, async () => {
      app.unmount.mockImplementationOnce(() =>
        Promise.reject(Error(""Mount errr""))
      );
      const profilesBefore = getProfilerEventsByKind(""unmount"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      shouldMount = false;
      await singleSpa.triggerAppChange();

      expect(singleSpa.getAppStatus(""profiler-basics"")).toBe(
        singleSpa.SKIP_BECAUSE_BROKEN
      );

      const profilesAfter = getProfilerEventsByKind(""unmount"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(false);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':186,'endLine':186}","it(`captures unmount error profile events`, async () => {
      app.unmount.mockImplementationOnce(() =>
        Promise.reject(Error(""Mount errr""))
      );
      const profilesBefore = getProfilerEventsByKind(""unmount"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      shouldMount = false;
      await singleSpa.triggerAppChange();

      expect(singleSpa.getAppStatus(""profiler-basics"")).toBe(
        singleSpa.SKIP_BECAUSE_BROKEN
      );

      const profilesAfter = getProfilerEventsByKind(""unmount"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(false);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':192,'endLine':192}","it(`captures unload profile events`, async () => {
      const profilesBefore = getProfilerEventsByKind(""unload"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      shouldMount = false;
      await singleSpa.unloadApplication(""profiler-basics"", {
        waitForUnmount: false,
      });
      await singleSpa.triggerAppChange();
      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.NOT_LOADED
      );

      const profilesAfter = getProfilerEventsByKind(""unload"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':208,'endLine':208}","it(`captures unload profile events`, async () => {
      const profilesBefore = getProfilerEventsByKind(""unload"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      shouldMount = false;
      await singleSpa.unloadApplication(""profiler-basics"", {
        waitForUnmount: false,
      });
      await singleSpa.triggerAppChange();
      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""profiler-basics"")).toEqual(
        singleSpa.NOT_LOADED
      );

      const profilesAfter = getProfilerEventsByKind(""unload"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':217,'endLine':217}","it(`captures unloadErr error profile events`, async () => {
      app.unload.mockImplementationOnce(() =>
        Promise.reject(Error(""Unload errr""))
      );
      const profilesBefore = getProfilerEventsByKind(""unload"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      shouldMount = false;
      await singleSpa.triggerAppChange();
      clearProfilerData();
      try {
        await singleSpa.unloadApplication(""profiler-basics"", {
          waitForUnmount: false,
        });
        fail(""Expected unload err"");
      } catch (err) {}

      await singleSpa.triggerAppChange();

      expect(singleSpa.getAppStatus(""profiler-basics"")).toBe(
        singleSpa.SKIP_BECAUSE_BROKEN
      );

      const profilesAfter = getProfilerEventsByKind(""unload"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(false);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':239,'endLine':239}","it(`captures unloadErr error profile events`, async () => {
      app.unload.mockImplementationOnce(() =>
        Promise.reject(Error(""Unload errr""))
      );
      const profilesBefore = getProfilerEventsByKind(""unload"");
      expect(profilesBefore.length).toBe(0);

      shouldMount = true;
      await singleSpa.triggerAppChange();
      shouldMount = false;
      await singleSpa.triggerAppChange();
      clearProfilerData();
      try {
        await singleSpa.unloadApplication(""profiler-basics"", {
          waitForUnmount: false,
        });
        fail(""Expected unload err"");
      } catch (err) {}

      await singleSpa.triggerAppChange();

      expect(singleSpa.getAppStatus(""profiler-basics"")).toBe(
        singleSpa.SKIP_BECAUSE_BROKEN
      );

      const profilesAfter = getProfilerEventsByKind(""unload"");

      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(false);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':265,'endLine':265}","it(""captures successful bootstrap events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""bootstrap"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.bootstrapPromise;

      const profilesAfter = getProfilerEventsByKind(""bootstrap"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':271,'endLine':271}","it(""captures successful bootstrap events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""bootstrap"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.bootstrapPromise;

      const profilesAfter = getProfilerEventsByKind(""bootstrap"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':277,'endLine':277}","it(""captures successful mount events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""mount"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.mountPromise;

      const profilesAfter = getProfilerEventsByKind(""mount"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':283,'endLine':283}","it(""captures successful mount events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""mount"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.mountPromise;

      const profilesAfter = getProfilerEventsByKind(""mount"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':289,'endLine':289}","it(""captures successful update events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""update"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.mountPromise;
      await parcel.update(props);

      const profilesAfter = getProfilerEventsByKind(""update"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':296,'endLine':296}","it(""captures successful update events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""update"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.mountPromise;
      await parcel.update(props);

      const profilesAfter = getProfilerEventsByKind(""update"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':302,'endLine':302}","it(""captures successful unmount events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""unmount"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.mountPromise;
      await parcel.unmount();

      const profilesAfter = getProfilerEventsByKind(""unmount"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/profiler-basic/profiler-basic.spec.js,SubOptimalAssert,"{'startLine':309,'endLine':309}","it(""captures successful unmount events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""unmount"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.mountPromise;
      await parcel.unmount();

      const profilesAfter = getProfilerEventsByKind(""unmount"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",snuts
/spec/apps/no-object-prototype/no-object-prototype.spec.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}","beforeAll(() => {
    // ES Modules don't have the Object prototype, but should still work as applications
    const app = Object.create(null);
    app.bootstrap = async function () {};
    app.mount = async function () {};
    app.unmount = async function () {};

    singleSpa.registerApplication({
      name: ""no-object-prototype"",
      app,
      activeWhen: (location) => location.hash === activeHash,
    });

    singleSpa.start();
  })",snuts
/spec/apps/no-object-prototype/no-object-prototype.spec.js,NonFunctionalStatement,"{'startLine':12,'endLine':12}","beforeAll(() => {
    // ES Modules don't have the Object prototype, but should still work as applications
    const app = Object.create(null);
    app.bootstrap = async function () {};
    app.mount = async function () {};
    app.unmount = async function () {};

    singleSpa.registerApplication({
      name: ""no-object-prototype"",
      app,
      activeWhen: (location) => location.hash === activeHash,
    });

    singleSpa.start();
  })",snuts
/spec/apps/no-object-prototype/no-object-prototype.spec.js,NonFunctionalStatement,"{'startLine':13,'endLine':13}","beforeAll(() => {
    // ES Modules don't have the Object prototype, but should still work as applications
    const app = Object.create(null);
    app.bootstrap = async function () {};
    app.mount = async function () {};
    app.unmount = async function () {};

    singleSpa.registerApplication({
      name: ""no-object-prototype"",
      app,
      activeWhen: (location) => location.hash === activeHash,
    });

    singleSpa.start();
  })",snuts
/spec/apps/mounting-status/mounting-status.spec.js,GeneralFixture,"{'startLine':16,'endLine':16}","beforeAll(async () => {
    singleSpa.registerApplication({
      name: ""mounting-status"",
      app: () => import(""./mounting-status.app.js""),
      activeWhen: (location) => location.hash === activeHash,
    });
    singleSpa.start();

    app = await import(""./mounting-status.app.js"");
  })",snuts
/spec/apps/mount-times-out-dies/mount-times-out-dies.spec.js,GeneralFixture,"{'startLine':24,'endLine':24}","beforeEach(() => {
    location.hash = ""#"";

    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./mount-times-out-dies.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/mount-times-out/mount-times-out.spec.js,GeneralFixture,"{'startLine':24,'endLine':24}","beforeEach(() => {
    location.hash = ""#"";

    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./mount-times-out.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/mount-fails/mount-fails.spec.js,GeneralFixture,"{'startLine':24,'endLine':24}","beforeEach(() => {
    location.hash = `#`;

    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./mount-fails.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/mount-rejects/mount-rejects.spec.js,GeneralFixture,"{'startLine':24,'endLine':24}","beforeEach(() => {
    location.hash = `#`;

    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./mount-rejects.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/mount-before-other-loads/mount-before-other-loads.spec.js,GeneralFixture,"{'startLine':11,'endLine':11}","beforeEach(() => {
    errs = [];
    singleSpa.addErrorHandler(handleError);
  })",snuts
/spec/apps/mount-before-other-loads/mount-before-other-loads.spec.js,SubOptimalAssert,"{'startLine':72,'endLine':72}","it(`will mount an application before loading another application finishes`, async () => {
    location.hash = ""#mount-before-other-loads"";

    const appChangeResultBeforeStart = await singleSpa.triggerAppChange();
    expect(appChangeResultBeforeStart).toEqual([]);

    let order = [];

    const slowApp = {
      bootstrap: async () => {
        order.push(""slow:bootstrap"");
      },
      mount: async () => {
        order.push(""slow:mount"");
      },
      unmount: async () => {
        order.push(""slow:unmount"");
      },
    };

    const fastApp = {
      bootstrap: async () => {
        order.push(""fast:bootstrap"");
      },
      mount: async () => {
        order.push(""fast:mount"");
      },
      unmount: async () => {
        order.push(""fast:unmount"");
      },
    };

    singleSpa.registerApplication(
      ""slow-load"",
      () =>
        new Promise((resolve) => {
          setTimeout(() => {
            order.push(""slow:load"");
            resolve(slowApp);
          }, 30);
        }),
      (location) => location.hash.startsWith(""#mount-before-other-loads"")
    );

    singleSpa.registerApplication(
      ""fast-load"",
      async () => {
        order.push(""fast:load"");
        return fastApp;
      },
      (location) => location.hash.startsWith(""#mount-before-other-loads"")
    );

    expect(errs.length).toBe(0);
    expect(order).toEqual([]);
    singleSpa.start();
    await singleSpa.triggerAppChange();
    expect(errs.length).toBe(0);
    expect(order).toEqual([
      ""fast:load"",
      ""fast:bootstrap"",
      ""fast:mount"",
      ""slow:load"",
      ""slow:bootstrap"",
      ""slow:mount"",
    ]);
  })",snuts
/spec/apps/mount-before-other-loads/mount-before-other-loads.spec.js,SubOptimalAssert,"{'startLine':76,'endLine':76}","it(`will mount an application before loading another application finishes`, async () => {
    location.hash = ""#mount-before-other-loads"";

    const appChangeResultBeforeStart = await singleSpa.triggerAppChange();
    expect(appChangeResultBeforeStart).toEqual([]);

    let order = [];

    const slowApp = {
      bootstrap: async () => {
        order.push(""slow:bootstrap"");
      },
      mount: async () => {
        order.push(""slow:mount"");
      },
      unmount: async () => {
        order.push(""slow:unmount"");
      },
    };

    const fastApp = {
      bootstrap: async () => {
        order.push(""fast:bootstrap"");
      },
      mount: async () => {
        order.push(""fast:mount"");
      },
      unmount: async () => {
        order.push(""fast:unmount"");
      },
    };

    singleSpa.registerApplication(
      ""slow-load"",
      () =>
        new Promise((resolve) => {
          setTimeout(() => {
            order.push(""slow:load"");
            resolve(slowApp);
          }, 30);
        }),
      (location) => location.hash.startsWith(""#mount-before-other-loads"")
    );

    singleSpa.registerApplication(
      ""fast-load"",
      async () => {
        order.push(""fast:load"");
        return fastApp;
      },
      (location) => location.hash.startsWith(""#mount-before-other-loads"")
    );

    expect(errs.length).toBe(0);
    expect(order).toEqual([]);
    singleSpa.start();
    await singleSpa.triggerAppChange();
    expect(errs.length).toBe(0);
    expect(order).toEqual([
      ""fast:load"",
      ""fast:bootstrap"",
      ""fast:mount"",
      ""slow:load"",
      ""slow:bootstrap"",
      ""slow:mount"",
    ]);
  })",snuts
/spec/apps/lifecycle-props-function/lifecycle-props-function.spec.js,GeneralFixture,"{'startLine':23,'endLine':23}","beforeEach(async () => {
    const app = await import(""./lifecycle-props-function.app.js"");
    myApp = app;
    app.reset();
    customProps = {};

    jest.spyOn(console, ""warn"");
  })",snuts
/spec/apps/lifecycle-props-function/lifecycle-props-function.spec.js,GeneralFixture,"{'startLine':25,'endLine':25}","beforeEach(async () => {
    const app = await import(""./lifecycle-props-function.app.js"");
    myApp = app;
    app.reset();
    customProps = {};

    jest.spyOn(console, ""warn"");
  })",snuts
/spec/apps/partial-rerouting/partial-rerouting.spec.js,VerboseStatement,"{'startLine':14,'endLine':60}","it(""shouldn't bootstrap and mount app if the route has been changed while app was loading, but if the user navigates back it should be bootstrapped and mounted successfully"", async () => {
    const activeHash = ""#partial-rerouting"";

    let bootstrapped = false;
    let mounted = false;
    let unmounted = false;

    const app = {
      async bootstrap() {
        bootstrapped = true;
      },
      async mount() {
        mounted = true;
      },
      async unmount() {
        unmounted = true;
      },
    };

    singleSpa.registerApplication(
      ""partial-rerouting"",
      () => delay().then(() => app),
      (location) => location.hash === activeHash
    );

    location.hash = activeHash;

    const promise = singleSpa.triggerAppChange();

    singleSpa.navigateToUrl(""#another-url"");
    await Promise.all([singleSpa.triggerAppChange(), promise]);

    expect(bootstrapped).toBeFalsy();
    expect(mounted).toBeFalsy();
    expect(unmounted).toBeFalsy();

    singleSpa.navigateToUrl(activeHash);
    await singleSpa.triggerAppChange();

    expect(bootstrapped).toBeTruthy();
    expect(mounted).toBeTruthy();

    singleSpa.navigateToUrl(""#another-url"");
    await singleSpa.triggerAppChange();

    expect(unmounted).toBeTruthy();
  })",snuts
/spec/apps/partial-rerouting/partial-rerouting.spec.js,VerboseStatement,"{'startLine':62,'endLine':128}","it(""should bootstrap and mount second app succcessfully, but should skip bootstrapping and mounting first app if the route has been changed"", async () => {
    let firstAppBootstrapped = false,
      firstAppMounted = false,
      firstAppUnmounted = false;

    const firstApp = {
      async bootstrap() {
        firstAppBootstrapped = true;
      },
      async mount() {
        firstAppMounted = true;
      },
      async unmount() {
        firstAppUnmounted = true;
      },
    };

    let secondAppBootstrapped = false,
      secondAppMounted = false,
      secondAppUnmounted = false;

    const secondApp = {
      async bootstrap() {
        secondAppBootstrapped = true;
      },
      async mount() {
        secondAppMounted = true;
      },
      async unmount() {
        secondAppUnmounted = true;
      },
    };

    const firstAppActiveHash = ""#first-app"";
    const secondAppActiveHash = ""#second-app"";

    singleSpa.registerApplication(
      ""first-app"",
      () => delay().then(() => firstApp),
      (location) => location.hash === firstAppActiveHash
    );

    singleSpa.registerApplication(
      ""second-app"",
      () => Promise.resolve(secondApp),
      (location) => location.hash === secondAppActiveHash
    );

    location.hash = firstAppActiveHash;

    const promise = singleSpa.triggerAppChange();

    singleSpa.navigateToUrl(secondAppActiveHash);
    await Promise.all([singleSpa.triggerAppChange(), promise]);

    expect(firstAppBootstrapped).toBeFalsy();
    expect(secondAppBootstrapped).toBeTruthy();
    expect(secondAppMounted).toBeTruthy();
    expect(secondAppUnmounted).toBeFalsy();

    singleSpa.navigateToUrl(firstAppActiveHash);
    await singleSpa.triggerAppChange();

    expect(secondAppUnmounted).toBeTruthy();
    expect(firstAppBootstrapped).toBeTruthy();
    expect(firstAppMounted).toBeTruthy();
  })",snuts
/spec/apps/invalid-unload/invalid-unload.spec.js,GeneralFixture,"{'startLine':24,'endLine':24}","beforeEach(() => {
    location.hash = """";

    errs = [];
    singleSpa.addErrorHandler(handleError);

    return singleSpa.triggerAppChange();
  })",snuts
/spec/apps/invalid-unmount/invalid-unmount.spec.js,GeneralFixture,"{'startLine':24,'endLine':24}","beforeEach(() => {
    location.hash = ""#"";

    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./invalid-unmount.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/invalid-no-unmount/invalid-no-unmount.spec.js,GeneralFixture,"{'startLine':25,'endLine':25}","beforeEach(() => {
    location.hash = activeHash;

    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./invalid-no-unmount.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/invalid-mount/invalid-mount.spec.js,GeneralFixture,"{'startLine':22,'endLine':22}","beforeEach(() => {
    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./invalid-mount.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/invalid-load-function/invalid-load-function.spec.js,ConditionalTestLogic,"{'startLine':103,'endLine':109}","it(""It retries loading an application that previously failed"", () => {
    let count = 0;
    function loadFunction() {
      count++;
      if (count === 1) return Promise.reject(`It didn't load`);
      else
        return Promise.resolve({
          bootstrap: () => new Promise(),
          mount: () => new Promise(),
          unmount: () => new Promise(),
        });
    }
    singleSpa.registerApplication(""invalid-load-4"", loadFunction, (location) =>
      location.hash.includes(""#invalid-load-function"")
    );

    location.hash = ""#invalid-load-function"";

    return singleSpa.triggerAppChange().then(() => {
      expect(errs.length).toBeGreaterThan(0);
      expect(errs[0].appOrParcelName).toBe(""invalid-load-4"");
      expect(errs[0].message.indexOf(`It didn't load`)).toBeGreaterThan(-1);

      location.hash = ""#invalid-load-function-1"";

      return new Promise((resolve) => setTimeout(resolve, 201)).then(() =>
        singleSpa.triggerAppChange().then(() => {
          expect(singleSpa.getAppStatus(""invalid-load-4"")).toBe(
            singleSpa.NOT_BOOTSTRAPPED
          );
        })
      );
    });
  })",snuts
/spec/apps/invalid-bootstrap/invalid-bootstrap.spec.js,GeneralFixture,"{'startLine':25,'endLine':25}","beforeEach(() => {
    location.hash = activeHash;

    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./invalid-bootstrap.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/bootstrap-times-out/bootstrap-times-out.spec.js,GeneralFixture,"{'startLine':23,'endLine':23}","beforeEach(() => {
    location.hash = ""#"";

    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./bootstrap-times-out.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/bootstrap-times-out/bootstrap-times-out.spec.js,SubOptimalAssert,"{'startLine':47,'endLine':47}","it(`is just waited for if dieOnTimeout is false`, () => {
    location.hash = ""#bootstrap-times-out"";

    return singleSpa.triggerAppChange().then(() => {
      expect(myApp.wasBootstrapped()).toEqual(true);
      expect(myApp.wasMounted()).toEqual(true);
      expect(singleSpa.getMountedApps()).toEqual([
        ""./bootstrap-times-out.app.js"",
      ]);
      expect(singleSpa.getAppStatus(""./bootstrap-times-out.app.js"")).toEqual(
        singleSpa.MOUNTED
      );
      expect(errs.length).toBe(0);
    });
  })",snuts
/spec/apps/bootstrap-times-out-dies/bootstrap-times-out-dies.spec.js,GeneralFixture,"{'startLine':23,'endLine':23}","beforeEach(() => {
    location.hash = ""#"";

    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./bootstrap-times-out-dies.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/bootstrap-rejects/bootstrap-rejects.spec.js,GeneralFixture,"{'startLine':21,'endLine':21}","beforeEach(() => {
    errs = [];
    singleSpa.addErrorHandler(handleError);

    return import(""./bootstrap-rejects.app.js"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  })",snuts
/spec/apps/bootstrap-rejects/bootstrap-rejects.spec.js,SubOptimalAssert,"{'startLine':37,'endLine':37}","it(`puts the app into SKIP_BECAUSE_BROKEN, fires a window event, and doesn't mount it`, () => {
    location.hash = ""#bootstrap-rejects"";

    return singleSpa.triggerAppChange().then(() => {
      expect(errs.length).toBe(1);
      expect(myApp.wasBootstrapped()).toEqual(true);
      expect(myApp.wasMounted()).toEqual(false);
      expect(singleSpa.getMountedApps()).toEqual([]);
      expect(singleSpa.getAppStatus(""./bootstrap-rejects.app.js"")).toEqual(
        singleSpa.SKIP_BECAUSE_BROKEN
      );
    });
  })",snuts
/spec/apps/no-bootstrap/no-bootstrap.app.js,NonFunctionalStatement,"{'startLine':1,'endLine':1}",Unknown,snuts
/spec/apps/no-bootstrap/no-bootstrap.app.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/spec/apps/mounting-status/mounting-status.app.js,NonFunctionalStatement,"{'startLine':6,'endLine':6}",Unknown,snuts
/spec/apps/mounting-status/mounting-status.app.js,NonFunctionalStatement,"{'startLine':11,'endLine':11}",Unknown,snuts
/spec/apps/delayed-start/delayed-start.app.js,NonFunctionalStatement,"{'startLine':1,'endLine':1}",Unknown,snuts
/spec/apps/delayed-start/delayed-start.app.js,NonFunctionalStatement,"{'startLine':3,'endLine':3}",Unknown,snuts
/spec/apps/delayed-start/delayed-start.app.js,NonFunctionalStatement,"{'startLine':5,'endLine':5}",Unknown,snuts
/spec/parcels/parcel-mounts-parcel.spec.js,Duplicate Assert,"{'line': 31, 'column': 10, 'index': 896}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Duplicate Assert,"{'line': 39, 'column': 12, 'index': 1265}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Duplicate Assert,"{'line': 45, 'column': 12, 'index': 1419}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Duplicate Assert,"{'line': 46, 'column': 12, 'index': 1475}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 19, 'column': 34, 'index': 489}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 29, 'column': 52, 'index': 830}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 30, 'column': 48, 'index': 882}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 31, 'column': 50, 'index': 936}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 37, 'column': 54, 'index': 1195}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 38, 'column': 50, 'index': 1249}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 39, 'column': 52, 'index': 1305}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 45, 'column': 52, 'index': 1459}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 46, 'column': 52, 'index': 1515}","it(""can mount a parcel as a child of a parcel and unmount both together"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-mounts-parcels"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          expect(parcelConfig1.bootstrapCalls).toBe(1);
          expect(parcelConfig1.mountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(0);

          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            expect(parcelConfig2.bootstrapCalls).toBe(1);
            expect(parcelConfig2.mountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(0);
          });
        })
        .then(() => parcel1.unmount())
        .then(() => {
          {
            expect(parcelConfig1.unmountCalls).toBe(1);
            expect(parcelConfig2.unmountCalls).toBe(1);
          }
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 63, 'column': 34, 'index': 1901}","it(""unmounts parcels recursively deep when an app unmounts"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-unmounts-recursive"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcelConfig3 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            const parcel3 = parcelConfig2.mountProps.mountParcel(
              parcelConfig3,
              { domElement: document.createElement(""div"") }
            );
            return parcel3.mountPromise;
          });
        })
        .then(() => {
          shouldAppBeMounted = false;
          return singleSpa.triggerAppChange();
        })
        .then(() => {
          expect(app.unmountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(1);
          expect(parcelConfig2.unmountCalls).toBe(1);
          expect(parcelConfig3.unmountCalls).toBe(1);
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 90, 'column': 40, 'index': 2856}","it(""unmounts parcels recursively deep when an app unmounts"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-unmounts-recursive"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcelConfig3 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            const parcel3 = parcelConfig2.mountProps.mountParcel(
              parcelConfig3,
              { domElement: document.createElement(""div"") }
            );
            return parcel3.mountPromise;
          });
        })
        .then(() => {
          shouldAppBeMounted = false;
          return singleSpa.triggerAppChange();
        })
        .then(() => {
          expect(app.unmountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(1);
          expect(parcelConfig2.unmountCalls).toBe(1);
          expect(parcelConfig3.unmountCalls).toBe(1);
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 91, 'column': 50, 'index': 2910}","it(""unmounts parcels recursively deep when an app unmounts"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-unmounts-recursive"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcelConfig3 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            const parcel3 = parcelConfig2.mountProps.mountParcel(
              parcelConfig3,
              { domElement: document.createElement(""div"") }
            );
            return parcel3.mountPromise;
          });
        })
        .then(() => {
          shouldAppBeMounted = false;
          return singleSpa.triggerAppChange();
        })
        .then(() => {
          expect(app.unmountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(1);
          expect(parcelConfig2.unmountCalls).toBe(1);
          expect(parcelConfig3.unmountCalls).toBe(1);
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 92, 'column': 50, 'index': 2964}","it(""unmounts parcels recursively deep when an app unmounts"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-unmounts-recursive"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcelConfig3 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            const parcel3 = parcelConfig2.mountProps.mountParcel(
              parcelConfig3,
              { domElement: document.createElement(""div"") }
            );
            return parcel3.mountPromise;
          });
        })
        .then(() => {
          shouldAppBeMounted = false;
          return singleSpa.triggerAppChange();
        })
        .then(() => {
          expect(app.unmountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(1);
          expect(parcelConfig2.unmountCalls).toBe(1);
          expect(parcelConfig3.unmountCalls).toBe(1);
        });
    });
  })",steel
/spec/parcels/parcel-mounts-parcel.spec.js,Magic Number,"{'line': 93, 'column': 50, 'index': 3018}","it(""unmounts parcels recursively deep when an app unmounts"", () => {
    const app = createApp();
    let shouldAppBeMounted = true;

    singleSpa.registerApplication(
      ""parcel-unmounts-recursive"",
      app,
      () => shouldAppBeMounted
    );

    return singleSpa.triggerAppChange().then(() => {
      expect(app.mountCalls).toBe(1);

      const parcelConfig1 = createParcelConfig();
      const parcelConfig2 = createParcelConfig();
      const parcelConfig3 = createParcelConfig();
      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {
        domElement: document.createElement(""div""),
      });

      return parcel1.mountPromise
        .then(() => {
          const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {
            domElement: document.createElement(""div""),
          });
          return parcel2.mountPromise.then(() => {
            const parcel3 = parcelConfig2.mountProps.mountParcel(
              parcelConfig3,
              { domElement: document.createElement(""div"") }
            );
            return parcel3.mountPromise;
          });
        })
        .then(() => {
          shouldAppBeMounted = false;
          return singleSpa.triggerAppChange();
        })
        .then(() => {
          expect(app.unmountCalls).toBe(1);
          expect(parcelConfig1.unmountCalls).toBe(1);
          expect(parcelConfig2.unmountCalls).toBe(1);
          expect(parcelConfig3.unmountCalls).toBe(1);
        });
    });
  })",steel
/spec/parcels/parcel-error-handlers.spec.js,Conditional Test Logic,"{'line': 299, 'column': 6, 'index': 9726}",Unknown,steel
/spec/parcels/parcel-error-handlers.spec.js,Conditional Test Logic,"{'line': 309, 'column': 6, 'index': 10021}",Unknown,steel
/spec/parcels/parcel-error-handlers.spec.js,Conditional Test Logic,"{'line': 319, 'column': 6, 'index': 10322}",Unknown,steel
/spec/parcels/mount-root-parcel.spec.js,Conditional Test Logic,"{'line': 152, 'column': 2, 'index': 5165}",Unknown,steel
/spec/apps/warning-timeouts/warning-timeouts.spec.js,Conditional Test Logic,"{'line': 86, 'column': 4, 'index': 2876}","describe(`warning-timeouts app`, () => {
  let errs, myApp, consoleWarnSpy;

  function handleError(err) {
    errs.push(err);
  }

  beforeAll(() => {
    singleSpa.registerApplication(
      ""warning-timeouts"",
      () => import(""./warning-timeouts.app""),
      (location) => location.hash === activeHash
    );
    singleSpa.start();
    consoleWarnSpy = jest.spyOn(console, ""warn"");
    jest.useFakeTimers();
    window.addEventListener(""fake-timers-advance"", advanceTimers);
  });

  afterAll(() => {
    consoleWarnSpy.mockRestore();
    jest.useRealTimers();
    window.removeEventListener(""fake-timers-advance"", advanceTimers);
  });

  beforeEach(() => {
    errs = [];
    singleSpa.addErrorHandler(handleError);

    location.hash = ""#"";

    return import(""./warning-timeouts.app"")
      .then((app) => (myApp = app))
      .then((app) => app.reset());
  });

  afterEach(() => {
    singleSpa.removeErrorHandler(handleError);
    return singleSpa.unloadApplication(""warning-timeouts"");
  });

  it(`doesn't warn if everything resolves before the default warning setting`, async () => {
    location.hash = activeHash;

    await controlledAppChange();
    expect(singleSpa.getAppStatus(""warning-timeouts"")).toEqual(""MOUNTED"");
    expect(errs.length).toBe(0);
    expect(consoleWarnSpy).not.toHaveBeenCalled();

    location.hash = ""#not-warning-timeouts"";

    await controlledAppChange();
    expect(singleSpa.getAppStatus(""warning-timeouts"")).toEqual(""NOT_MOUNTED"");
    expect(errs.length).toBe(0);
    expect(consoleWarnSpy).not.toHaveBeenCalled();
  });

  it(`does warn if things don't resolve until after the default warning setting`, async () => {
    myApp.setDelay(3);
    location.hash = activeHash;

    await controlledAppChange();
    expect(singleSpa.getAppStatus(""warning-timeouts"")).toEqual(""MOUNTED"");
    expect(errs.length).toBe(0);
    expectWarning(
      `single-spa minified message #31: Lifecycle function bootstrap for application warning-timeouts lifecycle did not resolve or reject for 4000 ms. See https://single-spa.js.org/error/?code=31&arg=bootstrap&arg=application&arg=warning-timeouts&arg=4000`
    );
    expectWarning(
      `single-spa minified message #31: Lifecycle function mount for application warning-timeouts lifecycle did not resolve or reject for 3000 ms. See https://single-spa.js.org/error/?code=31&arg=mount&arg=application&arg=warning-timeouts&arg=3000`
    );

    location.hash = ""#not-warning-timeouts"";

    await controlledAppChange();
    expect(singleSpa.getAppStatus(""warning-timeouts"")).toEqual(""NOT_MOUNTED"");
    expect(errs.length).toBe(0);
  });

  function expectWarning(message) {
    expect(consoleWarnSpy).toHaveBeenCalled();
    const found = consoleWarnSpy.mock.calls.some((call) => call[0] === message);
    if (!found) {
      expect(consoleWarnSpy).toHaveBeenCalledWith(message);
    }
  }
})",steel
/spec/apps/profiler-basic/profiler-routing-start.spec.js,Magic Number,"{'line': 36, 'column': 39, 'index': 920}","it(""fires successful unmountAndUnload profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""unmountAndUnload"");
    expect(profilesBefore.length).toBe(0);

    singleSpa.registerApplication({
      name: ""unmountAndUnload profiler success"",
      app,
      activeWhen: () => shouldMount,
    });

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""unmountAndUnload"");
    expect(profilesAfter.length).toBeGreaterThan(0);
    expect(profilesAfter[0].operationSucceeded).toBe(true);
  })",steel
/spec/apps/profiler-basic/profiler-routing-start.spec.js,Magic Number,"{'line': 47, 'column': 49, 'index': 1228}","it(""fires successful unmountAndUnload profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""unmountAndUnload"");
    expect(profilesBefore.length).toBe(0);

    singleSpa.registerApplication({
      name: ""unmountAndUnload profiler success"",
      app,
      activeWhen: () => shouldMount,
    });

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""unmountAndUnload"");
    expect(profilesAfter.length).toBeGreaterThan(0);
    expect(profilesAfter[0].operationSucceeded).toBe(true);
  })",steel
/spec/apps/profiler-basic/profiler-routing-start.spec.js,Magic Number,"{'line': 53, 'column': 39, 'index': 1474}","it(""fires successful loadAndMount profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""loadAndMount"");
    expect(profilesBefore.length).toBe(0);

    singleSpa.registerApplication({
      name: ""loadAndMount profiler success"",
      app,
      activeWhen: () => shouldMount,
    });

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""loadAndMount"");
    expect(profilesAfter.length).toBeGreaterThan(0);
    expect(profilesAfter[0].operationSucceeded).toBe(true);
  })",steel
/spec/apps/profiler-basic/profiler-routing-start.spec.js,Magic Number,"{'line': 64, 'column': 49, 'index': 1774}","it(""fires successful loadAndMount profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""loadAndMount"");
    expect(profilesBefore.length).toBe(0);

    singleSpa.registerApplication({
      name: ""loadAndMount profiler success"",
      app,
      activeWhen: () => shouldMount,
    });

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""loadAndMount"");
    expect(profilesAfter.length).toBeGreaterThan(0);
    expect(profilesAfter[0].operationSucceeded).toBe(true);
  })",steel
/spec/apps/profiler-basic/profiler-routing-start.spec.js,Magic Number,"{'line': 70, 'column': 39, 'index': 2021}","it(""fires navigationCanceled profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""navigationCanceled"");
    expect(profilesBefore.length).toBe(0);

    window.addEventListener(
      ""single-spa:before-routing-event"",
      handleBeforeRouting
    );

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""navigationCanceled"");
    expect(profilesAfter.length).toBe(1);

    window.removeEventListener(
      ""single-spa:before-routing-event"",
      handleBeforeRouting
    );

    function handleBeforeRouting(evt) {
      evt.detail.cancelNavigation();
    }
  })",steel
/spec/apps/profiler-basic/profiler-routing-start.spec.js,Magic Number,"{'line': 80, 'column': 38, 'index': 2282}","it(""fires navigationCanceled profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""navigationCanceled"");
    expect(profilesBefore.length).toBe(0);

    window.addEventListener(
      ""single-spa:before-routing-event"",
      handleBeforeRouting
    );

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""navigationCanceled"");
    expect(profilesAfter.length).toBe(1);

    window.removeEventListener(
      ""single-spa:before-routing-event"",
      handleBeforeRouting
    );

    function handleBeforeRouting(evt) {
      evt.detail.cancelNavigation();
    }
  })",steel
/spec/apps/profiler-basic/profiler-routing-no-start.spec.js,Magic Number,"{'line': 28, 'column': 39, 'index': 694}","it(""fires successful loadApp profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""loadApps"");
    expect(profilesBefore.length).toBe(0);

    singleSpa.registerApplication({
      name: ""loadApp profiler success"",
      app,
      activeWhen: () => shouldMount,
    });

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""loadApps"");
    expect(profilesAfter.length).toBeGreaterThan(0);
    expect(profilesAfter[0].operationSucceeded).toBe(true);
  })",steel
/spec/apps/profiler-basic/profiler-routing-no-start.spec.js,Magic Number,"{'line': 39, 'column': 49, 'index': 985}","it(""fires successful loadApp profiler events"", async () => {
    const profilesBefore = getProfilerEventsByKind(""loadApps"");
    expect(profilesBefore.length).toBe(0);

    singleSpa.registerApplication({
      name: ""loadApp profiler success"",
      app,
      activeWhen: () => shouldMount,
    });

    await singleSpa.triggerAppChange();

    const profilesAfter = getProfilerEventsByKind(""loadApps"");
    expect(profilesAfter.length).toBeGreaterThan(0);
    expect(profilesAfter[0].operationSucceeded).toBe(true);
  })",steel
/spec/apps/profiler-basic/profiler-basic.spec.js,Magic Number,"{'line': 265, 'column': 41, 'index': 8452}","it(""captures successful bootstrap events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""bootstrap"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.bootstrapPromise;

      const profilesAfter = getProfilerEventsByKind(""bootstrap"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",steel
/spec/apps/profiler-basic/profiler-basic.spec.js,Magic Number,"{'line': 271, 'column': 40, 'index': 8680}","it(""captures successful bootstrap events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""bootstrap"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.bootstrapPromise;

      const profilesAfter = getProfilerEventsByKind(""bootstrap"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",steel
/spec/apps/profiler-basic/profiler-basic.spec.js,Magic Number,"{'line': 277, 'column': 41, 'index': 8926}","it(""captures successful mount events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""mount"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.mountPromise;

      const profilesAfter = getProfilerEventsByKind(""mount"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",steel
/spec/apps/profiler-basic/profiler-basic.spec.js,Magic Number,"{'line': 283, 'column': 40, 'index': 9146}","it(""captures successful mount events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""mount"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.mountPromise;

      const profilesAfter = getProfilerEventsByKind(""mount"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",steel
/spec/apps/profiler-basic/profiler-basic.spec.js,Magic Number,"{'line': 289, 'column': 41, 'index': 9394}","it(""captures successful update events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""update"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.mountPromise;
      await parcel.update(props);

      const profilesAfter = getProfilerEventsByKind(""update"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",steel
/spec/apps/profiler-basic/profiler-basic.spec.js,Magic Number,"{'line': 296, 'column': 40, 'index': 9649}","it(""captures successful update events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""update"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.mountPromise;
      await parcel.update(props);

      const profilesAfter = getProfilerEventsByKind(""update"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",steel
/spec/apps/profiler-basic/profiler-basic.spec.js,Magic Number,"{'line': 302, 'column': 41, 'index': 9899}","it(""captures successful unmount events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""unmount"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.mountPromise;
      await parcel.unmount();

      const profilesAfter = getProfilerEventsByKind(""unmount"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",steel
/spec/apps/profiler-basic/profiler-basic.spec.js,Magic Number,"{'line': 309, 'column': 40, 'index': 10151}","it(""captures successful unmount events"", async () => {
      const profilesBefore = getProfilerEventsByKind(""unmount"", ""parcel"");
      expect(profilesBefore.length).toBe(0);

      const parcel = singleSpa.mountRootParcel(parcelConfig, props);
      await parcel.mountPromise;
      await parcel.unmount();

      const profilesAfter = getProfilerEventsByKind(""unmount"", ""parcel"");
      expect(profilesAfter.length).toBe(1);
      expect(profilesAfter[0].operationSucceeded).toBe(true);
    })",steel
/spec/apps/partial-rerouting/partial-rerouting.spec.js,Duplicate Assert,"{'line': 46, 'column': 4, 'index': 1134}","it(""shouldn't bootstrap and mount app if the route has been changed while app was loading, but if the user navigates back it should be bootstrapped and mounted successfully"", async () => {
    const activeHash = ""#partial-rerouting"";

    let bootstrapped = false;
    let mounted = false;
    let unmounted = false;

    const app = {
      async bootstrap() {
        bootstrapped = true;
      },
      async mount() {
        mounted = true;
      },
      async unmount() {
        unmounted = true;
      },
    };

    singleSpa.registerApplication(
      ""partial-rerouting"",
      () => delay().then(() => app),
      (location) => location.hash === activeHash
    );

    location.hash = activeHash;

    const promise = singleSpa.triggerAppChange();

    singleSpa.navigateToUrl(""#another-url"");
    await Promise.all([singleSpa.triggerAppChange(), promise]);

    expect(bootstrapped).toBeFalsy();
    expect(mounted).toBeFalsy();
    expect(unmounted).toBeFalsy();

    singleSpa.navigateToUrl(activeHash);
    await singleSpa.triggerAppChange();

    expect(bootstrapped).toBeTruthy();
    expect(mounted).toBeTruthy();

    singleSpa.navigateToUrl(""#another-url"");
    await singleSpa.triggerAppChange();

    expect(unmounted).toBeTruthy();
  })",steel
/spec/apps/partial-rerouting/partial-rerouting.spec.js,Duplicate Assert,"{'line': 47, 'column': 4, 'index': 1172}","it(""shouldn't bootstrap and mount app if the route has been changed while app was loading, but if the user navigates back it should be bootstrapped and mounted successfully"", async () => {
    const activeHash = ""#partial-rerouting"";

    let bootstrapped = false;
    let mounted = false;
    let unmounted = false;

    const app = {
      async bootstrap() {
        bootstrapped = true;
      },
      async mount() {
        mounted = true;
      },
      async unmount() {
        unmounted = true;
      },
    };

    singleSpa.registerApplication(
      ""partial-rerouting"",
      () => delay().then(() => app),
      (location) => location.hash === activeHash
    );

    location.hash = activeHash;

    const promise = singleSpa.triggerAppChange();

    singleSpa.navigateToUrl(""#another-url"");
    await Promise.all([singleSpa.triggerAppChange(), promise]);

    expect(bootstrapped).toBeFalsy();
    expect(mounted).toBeFalsy();
    expect(unmounted).toBeFalsy();

    singleSpa.navigateToUrl(activeHash);
    await singleSpa.triggerAppChange();

    expect(bootstrapped).toBeTruthy();
    expect(mounted).toBeTruthy();

    singleSpa.navigateToUrl(""#another-url"");
    await singleSpa.triggerAppChange();

    expect(unmounted).toBeTruthy();
  })",steel
/spec/apps/partial-rerouting/partial-rerouting.spec.js,Duplicate Assert,"{'line': 48, 'column': 4, 'index': 1205}","it(""shouldn't bootstrap and mount app if the route has been changed while app was loading, but if the user navigates back it should be bootstrapped and mounted successfully"", async () => {
    const activeHash = ""#partial-rerouting"";

    let bootstrapped = false;
    let mounted = false;
    let unmounted = false;

    const app = {
      async bootstrap() {
        bootstrapped = true;
      },
      async mount() {
        mounted = true;
      },
      async unmount() {
        unmounted = true;
      },
    };

    singleSpa.registerApplication(
      ""partial-rerouting"",
      () => delay().then(() => app),
      (location) => location.hash === activeHash
    );

    location.hash = activeHash;

    const promise = singleSpa.triggerAppChange();

    singleSpa.navigateToUrl(""#another-url"");
    await Promise.all([singleSpa.triggerAppChange(), promise]);

    expect(bootstrapped).toBeFalsy();
    expect(mounted).toBeFalsy();
    expect(unmounted).toBeFalsy();

    singleSpa.navigateToUrl(activeHash);
    await singleSpa.triggerAppChange();

    expect(bootstrapped).toBeTruthy();
    expect(mounted).toBeTruthy();

    singleSpa.navigateToUrl(""#another-url"");
    await singleSpa.triggerAppChange();

    expect(unmounted).toBeTruthy();
  })",steel
/spec/apps/partial-rerouting/partial-rerouting.spec.js,Duplicate Assert,"{'line': 53, 'column': 4, 'index': 1323}","it(""shouldn't bootstrap and mount app if the route has been changed while app was loading, but if the user navigates back it should be bootstrapped and mounted successfully"", async () => {
    const activeHash = ""#partial-rerouting"";

    let bootstrapped = false;
    let mounted = false;
    let unmounted = false;

    const app = {
      async bootstrap() {
        bootstrapped = true;
      },
      async mount() {
        mounted = true;
      },
      async unmount() {
        unmounted = true;
      },
    };

    singleSpa.registerApplication(
      ""partial-rerouting"",
      () => delay().then(() => app),
      (location) => location.hash === activeHash
    );

    location.hash = activeHash;

    const promise = singleSpa.triggerAppChange();

    singleSpa.navigateToUrl(""#another-url"");
    await Promise.all([singleSpa.triggerAppChange(), promise]);

    expect(bootstrapped).toBeFalsy();
    expect(mounted).toBeFalsy();
    expect(unmounted).toBeFalsy();

    singleSpa.navigateToUrl(activeHash);
    await singleSpa.triggerAppChange();

    expect(bootstrapped).toBeTruthy();
    expect(mounted).toBeTruthy();

    singleSpa.navigateToUrl(""#another-url"");
    await singleSpa.triggerAppChange();

    expect(unmounted).toBeTruthy();
  })",steel
/spec/apps/partial-rerouting/partial-rerouting.spec.js,Duplicate Assert,"{'line': 54, 'column': 4, 'index': 1362}","it(""shouldn't bootstrap and mount app if the route has been changed while app was loading, but if the user navigates back it should be bootstrapped and mounted successfully"", async () => {
    const activeHash = ""#partial-rerouting"";

    let bootstrapped = false;
    let mounted = false;
    let unmounted = false;

    const app = {
      async bootstrap() {
        bootstrapped = true;
      },
      async mount() {
        mounted = true;
      },
      async unmount() {
        unmounted = true;
      },
    };

    singleSpa.registerApplication(
      ""partial-rerouting"",
      () => delay().then(() => app),
      (location) => location.hash === activeHash
    );

    location.hash = activeHash;

    const promise = singleSpa.triggerAppChange();

    singleSpa.navigateToUrl(""#another-url"");
    await Promise.all([singleSpa.triggerAppChange(), promise]);

    expect(bootstrapped).toBeFalsy();
    expect(mounted).toBeFalsy();
    expect(unmounted).toBeFalsy();

    singleSpa.navigateToUrl(activeHash);
    await singleSpa.triggerAppChange();

    expect(bootstrapped).toBeTruthy();
    expect(mounted).toBeTruthy();

    singleSpa.navigateToUrl(""#another-url"");
    await singleSpa.triggerAppChange();

    expect(unmounted).toBeTruthy();
  })",steel
/spec/apps/partial-rerouting/partial-rerouting.spec.js,Duplicate Assert,"{'line': 59, 'column': 4, 'index': 1483}","it(""shouldn't bootstrap and mount app if the route has been changed while app was loading, but if the user navigates back it should be bootstrapped and mounted successfully"", async () => {
    const activeHash = ""#partial-rerouting"";

    let bootstrapped = false;
    let mounted = false;
    let unmounted = false;

    const app = {
      async bootstrap() {
        bootstrapped = true;
      },
      async mount() {
        mounted = true;
      },
      async unmount() {
        unmounted = true;
      },
    };

    singleSpa.registerApplication(
      ""partial-rerouting"",
      () => delay().then(() => app),
      (location) => location.hash === activeHash
    );

    location.hash = activeHash;

    const promise = singleSpa.triggerAppChange();

    singleSpa.navigateToUrl(""#another-url"");
    await Promise.all([singleSpa.triggerAppChange(), promise]);

    expect(bootstrapped).toBeFalsy();
    expect(mounted).toBeFalsy();
    expect(unmounted).toBeFalsy();

    singleSpa.navigateToUrl(activeHash);
    await singleSpa.triggerAppChange();

    expect(bootstrapped).toBeTruthy();
    expect(mounted).toBeTruthy();

    singleSpa.navigateToUrl(""#another-url"");
    await singleSpa.triggerAppChange();

    expect(unmounted).toBeTruthy();
  })",steel
/spec/apps/partial-rerouting/partial-rerouting.spec.js,Duplicate Assert,"{'line': 117, 'column': 4, 'index': 2985}","it(""should bootstrap and mount second app succcessfully, but should skip bootstrapping and mounting first app if the route has been changed"", async () => {
    let firstAppBootstrapped = false,
      firstAppMounted = false,
      firstAppUnmounted = false;

    const firstApp = {
      async bootstrap() {
        firstAppBootstrapped = true;
      },
      async mount() {
        firstAppMounted = true;
      },
      async unmount() {
        firstAppUnmounted = true;
      },
    };

    let secondAppBootstrapped = false,
      secondAppMounted = false,
      secondAppUnmounted = false;

    const secondApp = {
      async bootstrap() {
        secondAppBootstrapped = true;
      },
      async mount() {
        secondAppMounted = true;
      },
      async unmount() {
        secondAppUnmounted = true;
      },
    };

    const firstAppActiveHash = ""#first-app"";
    const secondAppActiveHash = ""#second-app"";

    singleSpa.registerApplication(
      ""first-app"",
      () => delay().then(() => firstApp),
      (location) => location.hash === firstAppActiveHash
    );

    singleSpa.registerApplication(
      ""second-app"",
      () => Promise.resolve(secondApp),
      (location) => location.hash === secondAppActiveHash
    );

    location.hash = firstAppActiveHash;

    const promise = singleSpa.triggerAppChange();

    singleSpa.navigateToUrl(secondAppActiveHash);
    await Promise.all([singleSpa.triggerAppChange(), promise]);

    expect(firstAppBootstrapped).toBeFalsy();
    expect(secondAppBootstrapped).toBeTruthy();
    expect(secondAppMounted).toBeTruthy();
    expect(secondAppUnmounted).toBeFalsy();

    singleSpa.navigateToUrl(firstAppActiveHash);
    await singleSpa.triggerAppChange();

    expect(secondAppUnmounted).toBeTruthy();
    expect(firstAppBootstrapped).toBeTruthy();
    expect(firstAppMounted).toBeTruthy();
  })",steel
/spec/apps/partial-rerouting/partial-rerouting.spec.js,Duplicate Assert,"{'line': 120, 'column': 4, 'index': 3122}","it(""should bootstrap and mount second app succcessfully, but should skip bootstrapping and mounting first app if the route has been changed"", async () => {
    let firstAppBootstrapped = false,
      firstAppMounted = false,
      firstAppUnmounted = false;

    const firstApp = {
      async bootstrap() {
        firstAppBootstrapped = true;
      },
      async mount() {
        firstAppMounted = true;
      },
      async unmount() {
        firstAppUnmounted = true;
      },
    };

    let secondAppBootstrapped = false,
      secondAppMounted = false,
      secondAppUnmounted = false;

    const secondApp = {
      async bootstrap() {
        secondAppBootstrapped = true;
      },
      async mount() {
        secondAppMounted = true;
      },
      async unmount() {
        secondAppUnmounted = true;
      },
    };

    const firstAppActiveHash = ""#first-app"";
    const secondAppActiveHash = ""#second-app"";

    singleSpa.registerApplication(
      ""first-app"",
      () => delay().then(() => firstApp),
      (location) => location.hash === firstAppActiveHash
    );

    singleSpa.registerApplication(
      ""second-app"",
      () => Promise.resolve(secondApp),
      (location) => location.hash === secondAppActiveHash
    );

    location.hash = firstAppActiveHash;

    const promise = singleSpa.triggerAppChange();

    singleSpa.navigateToUrl(secondAppActiveHash);
    await Promise.all([singleSpa.triggerAppChange(), promise]);

    expect(firstAppBootstrapped).toBeFalsy();
    expect(secondAppBootstrapped).toBeTruthy();
    expect(secondAppMounted).toBeTruthy();
    expect(secondAppUnmounted).toBeFalsy();

    singleSpa.navigateToUrl(firstAppActiveHash);
    await singleSpa.triggerAppChange();

    expect(secondAppUnmounted).toBeTruthy();
    expect(firstAppBootstrapped).toBeTruthy();
    expect(firstAppMounted).toBeTruthy();
  })",steel
/spec/apps/partial-rerouting/partial-rerouting.spec.js,Duplicate Assert,"{'line': 125, 'column': 4, 'index': 3257}","it(""should bootstrap and mount second app succcessfully, but should skip bootstrapping and mounting first app if the route has been changed"", async () => {
    let firstAppBootstrapped = false,
      firstAppMounted = false,
      firstAppUnmounted = false;

    const firstApp = {
      async bootstrap() {
        firstAppBootstrapped = true;
      },
      async mount() {
        firstAppMounted = true;
      },
      async unmount() {
        firstAppUnmounted = true;
      },
    };

    let secondAppBootstrapped = false,
      secondAppMounted = false,
      secondAppUnmounted = false;

    const secondApp = {
      async bootstrap() {
        secondAppBootstrapped = true;
      },
      async mount() {
        secondAppMounted = true;
      },
      async unmount() {
        secondAppUnmounted = true;
      },
    };

    const firstAppActiveHash = ""#first-app"";
    const secondAppActiveHash = ""#second-app"";

    singleSpa.registerApplication(
      ""first-app"",
      () => delay().then(() => firstApp),
      (location) => location.hash === firstAppActiveHash
    );

    singleSpa.registerApplication(
      ""second-app"",
      () => Promise.resolve(secondApp),
      (location) => location.hash === secondAppActiveHash
    );

    location.hash = firstAppActiveHash;

    const promise = singleSpa.triggerAppChange();

    singleSpa.navigateToUrl(secondAppActiveHash);
    await Promise.all([singleSpa.triggerAppChange(), promise]);

    expect(firstAppBootstrapped).toBeFalsy();
    expect(secondAppBootstrapped).toBeTruthy();
    expect(secondAppMounted).toBeTruthy();
    expect(secondAppUnmounted).toBeFalsy();

    singleSpa.navigateToUrl(firstAppActiveHash);
    await singleSpa.triggerAppChange();

    expect(secondAppUnmounted).toBeTruthy();
    expect(firstAppBootstrapped).toBeTruthy();
    expect(firstAppMounted).toBeTruthy();
  })",steel
/spec/apps/partial-rerouting/partial-rerouting.spec.js,Duplicate Assert,"{'line': 126, 'column': 4, 'index': 3302}","it(""should bootstrap and mount second app succcessfully, but should skip bootstrapping and mounting first app if the route has been changed"", async () => {
    let firstAppBootstrapped = false,
      firstAppMounted = false,
      firstAppUnmounted = false;

    const firstApp = {
      async bootstrap() {
        firstAppBootstrapped = true;
      },
      async mount() {
        firstAppMounted = true;
      },
      async unmount() {
        firstAppUnmounted = true;
      },
    };

    let secondAppBootstrapped = false,
      secondAppMounted = false,
      secondAppUnmounted = false;

    const secondApp = {
      async bootstrap() {
        secondAppBootstrapped = true;
      },
      async mount() {
        secondAppMounted = true;
      },
      async unmount() {
        secondAppUnmounted = true;
      },
    };

    const firstAppActiveHash = ""#first-app"";
    const secondAppActiveHash = ""#second-app"";

    singleSpa.registerApplication(
      ""first-app"",
      () => delay().then(() => firstApp),
      (location) => location.hash === firstAppActiveHash
    );

    singleSpa.registerApplication(
      ""second-app"",
      () => Promise.resolve(secondApp),
      (location) => location.hash === secondAppActiveHash
    );

    location.hash = firstAppActiveHash;

    const promise = singleSpa.triggerAppChange();

    singleSpa.navigateToUrl(secondAppActiveHash);
    await Promise.all([singleSpa.triggerAppChange(), promise]);

    expect(firstAppBootstrapped).toBeFalsy();
    expect(secondAppBootstrapped).toBeTruthy();
    expect(secondAppMounted).toBeTruthy();
    expect(secondAppUnmounted).toBeFalsy();

    singleSpa.navigateToUrl(firstAppActiveHash);
    await singleSpa.triggerAppChange();

    expect(secondAppUnmounted).toBeTruthy();
    expect(firstAppBootstrapped).toBeTruthy();
    expect(firstAppMounted).toBeTruthy();
  })",steel
/spec/apps/invalid-load-function/invalid-load-function.spec.js,Conditional Test Logic,"{'line': 103, 'column': 6, 'index': 2949}","it(""It retries loading an application that previously failed"", () => {
    let count = 0;
    function loadFunction() {
      count++;
      if (count === 1) return Promise.reject(`It didn't load`);
      else
        return Promise.resolve({
          bootstrap: () => new Promise(),
          mount: () => new Promise(),
          unmount: () => new Promise(),
        });
    }
    singleSpa.registerApplication(""invalid-load-4"", loadFunction, (location) =>
      location.hash.includes(""#invalid-load-function"")
    );

    location.hash = ""#invalid-load-function"";

    return singleSpa.triggerAppChange().then(() => {
      expect(errs.length).toBeGreaterThan(0);
      expect(errs[0].appOrParcelName).toBe(""invalid-load-4"");
      expect(errs[0].message.indexOf(`It didn't load`)).toBeGreaterThan(-1);

      location.hash = ""#invalid-load-function-1"";

      return new Promise((resolve) => setTimeout(resolve, 201)).then(() =>
        singleSpa.triggerAppChange().then(() => {
          expect(singleSpa.getAppStatus(""invalid-load-4"")).toBe(
            singleSpa.NOT_BOOTSTRAPPED
          );
        })
      );
    });
  })",steel
/spec/apps/invalid-load-function/invalid-load-function.spec.js,Magic Number,"{'line': 34, 'column': 42, 'index': 778}","it(""Dies if the load function returns nothing"", () => {
    function loadFunction() {
      // return nothing
    }
    singleSpa.registerApplication(
      ""invalid-load-1"",
      loadFunction,
      (location) => location.hash === ""#invalid-load-function""
    );

    location.hash = ""#invalid-load-function"";

    return singleSpa.triggerAppChange().then(() => {
      expect(errs.length).toBeGreaterThan(0);
      expect(errs[0].appOrParcelName).toBe(""invalid-load-1"");
      expect(
        errs[0].message.indexOf(
          ""single-spa loading function did not return a promise. Check the second argument to registerApplication""
        )
      ).toBeGreaterThan(-1);
      expect(singleSpa.getAppStatus(""invalid-load-1"")).toBe(
        singleSpa.SKIP_BECAUSE_BROKEN
      );
    });
  })",steel
/spec/apps/invalid-load-function/invalid-load-function.spec.js,Magic Number,"{'line': 60, 'column': 42, 'index': 1602}","it(""Dies if the load function returns a function instead of a promise"", () => {
    function loadFunction() {
      // return nothing
    }
    singleSpa.registerApplication(
      ""invalid-load-2"",
      loadFunction,
      (location) => location.hash === ""#invalid-load-function""
    );

    location.hash = ""#invalid-load-function"";

    return singleSpa.triggerAppChange().then(() => {
      expect(errs.length).toBeGreaterThan(0);
      expect(errs[0].appOrParcelName).toBe(""invalid-load-2"");
      expect(
        errs[0].message.indexOf(
          ""single-spa loading function did not return a promise. Check the second argument to registerApplication""
        )
      ).toBeGreaterThan(-1);
      expect(singleSpa.getAppStatus(""invalid-load-2"")).toBe(
        singleSpa.SKIP_BECAUSE_BROKEN
      );
    });
  })",steel
/spec/apps/invalid-load-function/invalid-load-function.spec.js,Magic Number,"{'line': 86, 'column': 42, 'index': 2416}","it(""Dies if the load function returns a non-thenable object"", () => {
    function loadFunction() {
      // return nothing
    }
    singleSpa.registerApplication(
      ""invalid-load-3"",
      loadFunction,
      (location) => location.hash === ""#invalid-load-function""
    );

    location.hash = ""#invalid-load-function"";

    return singleSpa.triggerAppChange().then(() => {
      expect(errs.length).toBeGreaterThan(0);
      expect(errs[0].appOrParcelName).toBe(""invalid-load-3"");
      expect(
        errs[0].message.indexOf(
          ""single-spa loading function did not return a promise. Check the second argument to registerApplication""
        )
      ).toBeGreaterThan(-1);
      expect(singleSpa.getAppStatus(""invalid-load-3"")).toBe(
        singleSpa.SKIP_BECAUSE_BROKEN
      );
    });
  })",steel
/spec/apps/invalid-load-function/invalid-load-function.spec.js,Magic Number,"{'line': 118, 'column': 42, 'index': 3474}","it(""It retries loading an application that previously failed"", () => {
    let count = 0;
    function loadFunction() {
      count++;
      if (count === 1) return Promise.reject(`It didn't load`);
      else
        return Promise.resolve({
          bootstrap: () => new Promise(),
          mount: () => new Promise(),
          unmount: () => new Promise(),
        });
    }
    singleSpa.registerApplication(""invalid-load-4"", loadFunction, (location) =>
      location.hash.includes(""#invalid-load-function"")
    );

    location.hash = ""#invalid-load-function"";

    return singleSpa.triggerAppChange().then(() => {
      expect(errs.length).toBeGreaterThan(0);
      expect(errs[0].appOrParcelName).toBe(""invalid-load-4"");
      expect(errs[0].message.indexOf(`It didn't load`)).toBeGreaterThan(-1);

      location.hash = ""#invalid-load-function-1"";

      return new Promise((resolve) => setTimeout(resolve, 201)).then(() =>
        singleSpa.triggerAppChange().then(() => {
          expect(singleSpa.getAppStatus(""invalid-load-4"")).toBe(
            singleSpa.NOT_BOOTSTRAPPED
          );
        })
      );
    });
  })",steel
/spec/apps/invalid-load-function/invalid-load-function.spec.js,Sleepy Test,"{'line': 124, 'column': 38, 'index': 3707}","it(""It retries loading an application that previously failed"", () => {
    let count = 0;
    function loadFunction() {
      count++;
      if (count === 1) return Promise.reject(`It didn't load`);
      else
        return Promise.resolve({
          bootstrap: () => new Promise(),
          mount: () => new Promise(),
          unmount: () => new Promise(),
        });
    }
    singleSpa.registerApplication(""invalid-load-4"", loadFunction, (location) =>
      location.hash.includes(""#invalid-load-function"")
    );

    location.hash = ""#invalid-load-function"";

    return singleSpa.triggerAppChange().then(() => {
      expect(errs.length).toBeGreaterThan(0);
      expect(errs[0].appOrParcelName).toBe(""invalid-load-4"");
      expect(errs[0].message.indexOf(`It didn't load`)).toBeGreaterThan(-1);

      location.hash = ""#invalid-load-function-1"";

      return new Promise((resolve) => setTimeout(resolve, 201)).then(() =>
        singleSpa.triggerAppChange().then(() => {
          expect(singleSpa.getAppStatus(""invalid-load-4"")).toBe(
            singleSpa.NOT_BOOTSTRAPPED
          );
        })
      );
    });
  })",steel
/spec/apps/happy-active-when/happy-active-when.spec.js,Conditional Test Logic,"{'line': 42, 'column': 4, 'index': 1183}","it(`goes through the whole lifecycle successfully on multiple activeWhen conditions`, async () => {
    singleSpa.start();
    expect(myApp.isMounted()).toEqual(false);
    expect(singleSpa.getMountedApps()).toEqual([]);

    const validPaths = [
      ""/pathname"",
      ""/#/appWithRegularPrefix"",
      ""/specificCriteria"",
      ""/resource/1/subresource/1"",
      ""/#/hashResource/1/hashSubResource/1"",
      ""pathname/#/subpath/1/another"",
    ];

    for (let index = 0; index < validPaths.length; index++) {
      singleSpa.navigateToUrl(validPaths[index] + ""/anything/everything"");
      await singleSpa.triggerAppChange();
      expectMyAppToBeMounted();

      singleSpa.navigateToUrl(""/#/unregisteredPath"");
      await singleSpa.triggerAppChange();
      expectMyAppToBeUnmounted();
    }
  })",steel
/spec/apps/delayed-start/delayed-start.spec.js,Duplicate Assert,"{'line': 21, 'column': 4, 'index': 572}","it(""will mount an application that began loading before start() was called"", async () => {
    let loadPromise;

    singleSpa.registerApplication({
      name: ""delayed-start"",
      app: () =>
        (loadPromise = (async () => {
          // wait a tick before resolving the promise
          await tick();
          return await import(""./delayed-start.app"");
        })()),
      activeWhen: () => true,
    });

    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(singleSpa.NOT_LOADED);

    await tick();

    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(
      singleSpa.LOADING_SOURCE_CODE
    );

    await singleSpa.triggerAppChange();

    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(
      singleSpa.NOT_BOOTSTRAPPED
    );

    singleSpa.start();

    await Promise.all([loadPromise, routingEvent()]);

    // Before fixing https://github.com/single-spa/single-spa/issues/555,
    // this assertion failed - status was NOT_BOOTSTRAPPED
    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(singleSpa.MOUNTED);
  })",steel
/spec/apps/delayed-start/delayed-start.spec.js,Duplicate Assert,"{'line': 25, 'column': 4, 'index': 672}","it(""will mount an application that began loading before start() was called"", async () => {
    let loadPromise;

    singleSpa.registerApplication({
      name: ""delayed-start"",
      app: () =>
        (loadPromise = (async () => {
          // wait a tick before resolving the promise
          await tick();
          return await import(""./delayed-start.app"");
        })()),
      activeWhen: () => true,
    });

    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(singleSpa.NOT_LOADED);

    await tick();

    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(
      singleSpa.LOADING_SOURCE_CODE
    );

    await singleSpa.triggerAppChange();

    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(
      singleSpa.NOT_BOOTSTRAPPED
    );

    singleSpa.start();

    await Promise.all([loadPromise, routingEvent()]);

    // Before fixing https://github.com/single-spa/single-spa/issues/555,
    // this assertion failed - status was NOT_BOOTSTRAPPED
    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(singleSpa.MOUNTED);
  })",steel
/spec/apps/delayed-start/delayed-start.spec.js,Duplicate Assert,"{'line': 31, 'column': 4, 'index': 815}","it(""will mount an application that began loading before start() was called"", async () => {
    let loadPromise;

    singleSpa.registerApplication({
      name: ""delayed-start"",
      app: () =>
        (loadPromise = (async () => {
          // wait a tick before resolving the promise
          await tick();
          return await import(""./delayed-start.app"");
        })()),
      activeWhen: () => true,
    });

    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(singleSpa.NOT_LOADED);

    await tick();

    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(
      singleSpa.LOADING_SOURCE_CODE
    );

    await singleSpa.triggerAppChange();

    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(
      singleSpa.NOT_BOOTSTRAPPED
    );

    singleSpa.start();

    await Promise.all([loadPromise, routingEvent()]);

    // Before fixing https://github.com/single-spa/single-spa/issues/555,
    // this assertion failed - status was NOT_BOOTSTRAPPED
    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(singleSpa.MOUNTED);
  })",steel
/spec/apps/delayed-start/delayed-start.spec.js,Duplicate Assert,"{'line': 41, 'column': 4, 'index': 1126}","it(""will mount an application that began loading before start() was called"", async () => {
    let loadPromise;

    singleSpa.registerApplication({
      name: ""delayed-start"",
      app: () =>
        (loadPromise = (async () => {
          // wait a tick before resolving the promise
          await tick();
          return await import(""./delayed-start.app"");
        })()),
      activeWhen: () => true,
    });

    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(singleSpa.NOT_LOADED);

    await tick();

    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(
      singleSpa.LOADING_SOURCE_CODE
    );

    await singleSpa.triggerAppChange();

    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(
      singleSpa.NOT_BOOTSTRAPPED
    );

    singleSpa.start();

    await Promise.all([loadPromise, routingEvent()]);

    // Before fixing https://github.com/single-spa/single-spa/issues/555,
    // this assertion failed - status was NOT_BOOTSTRAPPED
    expect(singleSpa.getAppStatus(""delayed-start"")).toBe(singleSpa.MOUNTED);
  })",steel
/spec/apis/timeout-apis.spec.js,Conditional Test Logic,"{'line': 159, 'column': 4, 'index': 5125}","describe(""global timeout configuration"", () => {
  let consoleWarnSpy, consoleErrSpy, parcel;

  beforeAll(() => {
    consoleWarnSpy = jest.spyOn(console, ""warn"");
    consoleErrSpy = jest.spyOn(console, ""error"");
    jest.useFakeTimers();
    singleSpa.start();
  });

  afterAll(() => {
    consoleWarnSpy.mockRestore();
    consoleErrSpy.mockRestore();
    jest.useRealTimers();
  });

  afterEach(() => {
    consoleWarnSpy.mockReset();
    consoleErrSpy.mockReset();
    jest.clearAllTimers();
  });

  describe(""setBootstrapMaxTime"", () => {
    afterEach(() => {
      singleSpa.setBootstrapMaxTime(5000, false, 1000);
    });

    it(`respects the millis configuration option`, async () => {
      singleSpa.setBootstrapMaxTime(5, false, 1000);

      await controlledParcelActions(
        (parcel) => parcel.bootstrapPromise,
        ""bootstrap-0"",
        3
      );
      expect(consoleErrSpy).not.toHaveBeenCalled();

      await controlledParcelActions(
        (parcel) => parcel.bootstrapPromise,
        ""bootstrap-1"",
        10
      );
      expectError(
        `single-spa minified message #31: Lifecycle function bootstrap for parcel bootstrap-1 lifecycle did not resolve or reject for 5 ms. See https://single-spa.js.org/error/?code=31&arg=bootstrap&arg=parcel&arg=bootstrap-1&arg=5`
      );
    });

    it(`respects warningMillis configuration option`, async () => {
      singleSpa.setBootstrapMaxTime(15, false, 5);

      await controlledParcelActions(
        (parcel) => parcel.bootstrapPromise,
        ""bootstrap-2"",
        0
      );
      expect(consoleWarnSpy).not.toHaveBeenCalled();

      await controlledParcelActions(
        (parcel) => parcel.bootstrapPromise,
        ""bootstrap-3"",
        10
      );
      expectWarning(
        `single-spa minified message #31: Lifecycle function bootstrap for parcel bootstrap-3 lifecycle did not resolve or reject for 15 ms. See https://single-spa.js.org/error/?code=31&arg=bootstrap&arg=parcel&arg=bootstrap-3&arg=15`
      );
    });
  });

  describe(""setMountMaxTime"", () => {
    afterEach(() => {
      singleSpa.setMountMaxTime(5000, false, 1000);
    });

    it(`respects the millis configuration option`, async () => {
      singleSpa.setMountMaxTime(5, false, 1000);

      await controlledParcelActions(
        (parcel) => parcel.mountPromise,
        ""mount-0"",
        0,
        3
      );
      expect(consoleErrSpy).not.toHaveBeenCalled();

      await controlledParcelActions(
        (parcel) => parcel.mountPromise,
        ""mount-1"",
        0,
        10
      );
      expectError(
        `single-spa minified message #31: Lifecycle function mount for parcel mount-1 lifecycle did not resolve or reject for 5 ms. See https://single-spa.js.org/error/?code=31&arg=mount&arg=parcel&arg=mount-1&arg=5`
      );
    });

    it(`respects warningMillis configuration option`, async () => {
      singleSpa.setMountMaxTime(15, false, 5);

      await controlledParcelActions(
        (parcel) => parcel.mountPromise,
        ""mount-2"",
        0,
        3
      );
      expect(consoleWarnSpy).not.toHaveBeenCalled();

      await controlledParcelActions(
        (parcel) => parcel.mountPromise,
        ""mount-3"",
        0,
        10
      );
      expectWarning(
        `single-spa minified message #31: Lifecycle function mount for parcel mount-3 lifecycle did not resolve or reject for 15 ms. See https://single-spa.js.org/error/?code=31&arg=mount&arg=parcel&arg=mount-3&arg=15`
      );
    });
  });

  describe(""setUnmountMaxTime"", () => {
    const unmount = async (parcel) => {
      await parcel.mountPromise;
      await parcel.unmount();
    };

    afterEach(() => {
      singleSpa.setUnmountMaxTime(5000, false, 1000);
    });

    it(`respects the millis configuration option`, async () => {
      singleSpa.setUnmountMaxTime(5, false, 1000);

      await controlledParcelActions(unmount, ""unmount-0"", 0, 0, 0, 3);
      expect(consoleErrSpy).not.toHaveBeenCalled();

      await controlledParcelActions(unmount, ""unmount-1"", 0, 0, 0, 10);
      expectError(
        `single-spa minified message #31: Lifecycle function unmount for parcel unmount-1 lifecycle did not resolve or reject for 5 ms. See https://single-spa.js.org/error/?code=31&arg=unmount&arg=parcel&arg=unmount-1&arg=5`
      );
    });

    it(`respects warningMillis configuration option`, async () => {
      singleSpa.setUnmountMaxTime(15, false, 5);

      await controlledParcelActions(unmount, ""unmount-2"", 0, 0, 0, 3);
      expect(consoleWarnSpy).not.toHaveBeenCalled();

      await controlledParcelActions(unmount, ""unmount-3"", 0, 0, 0, 10);
      expectWarning(
        `single-spa minified message #31: Lifecycle function unmount for parcel unmount-3 lifecycle did not resolve or reject for 15 ms. See https://single-spa.js.org/error/?code=31&arg=unmount&arg=parcel&arg=unmount-3&arg=15`
      );
    });
  });

  function expectWarning(message) {
    expect(consoleWarnSpy).toHaveBeenCalled();
    const found = consoleWarnSpy.mock.calls.some((call) => call[0] === message);
    if (!found) {
      expect(consoleWarnSpy).toHaveBeenCalledWith(message);
    }
  }

  function expectError(message) {
    expect(consoleErrSpy).toHaveBeenCalled();
    const found = consoleErrSpy.mock.calls.some((call) => call[0] === message);
    if (!found) {
      expect(consoleErrSpy).toHaveBeenCalledWith(message);
    }
  }
})",steel
/spec/apis/timeout-apis.spec.js,Conditional Test Logic,"{'line': 167, 'column': 4, 'index': 5374}","describe(""global timeout configuration"", () => {
  let consoleWarnSpy, consoleErrSpy, parcel;

  beforeAll(() => {
    consoleWarnSpy = jest.spyOn(console, ""warn"");
    consoleErrSpy = jest.spyOn(console, ""error"");
    jest.useFakeTimers();
    singleSpa.start();
  });

  afterAll(() => {
    consoleWarnSpy.mockRestore();
    consoleErrSpy.mockRestore();
    jest.useRealTimers();
  });

  afterEach(() => {
    consoleWarnSpy.mockReset();
    consoleErrSpy.mockReset();
    jest.clearAllTimers();
  });

  describe(""setBootstrapMaxTime"", () => {
    afterEach(() => {
      singleSpa.setBootstrapMaxTime(5000, false, 1000);
    });

    it(`respects the millis configuration option`, async () => {
      singleSpa.setBootstrapMaxTime(5, false, 1000);

      await controlledParcelActions(
        (parcel) => parcel.bootstrapPromise,
        ""bootstrap-0"",
        3
      );
      expect(consoleErrSpy).not.toHaveBeenCalled();

      await controlledParcelActions(
        (parcel) => parcel.bootstrapPromise,
        ""bootstrap-1"",
        10
      );
      expectError(
        `single-spa minified message #31: Lifecycle function bootstrap for parcel bootstrap-1 lifecycle did not resolve or reject for 5 ms. See https://single-spa.js.org/error/?code=31&arg=bootstrap&arg=parcel&arg=bootstrap-1&arg=5`
      );
    });

    it(`respects warningMillis configuration option`, async () => {
      singleSpa.setBootstrapMaxTime(15, false, 5);

      await controlledParcelActions(
        (parcel) => parcel.bootstrapPromise,
        ""bootstrap-2"",
        0
      );
      expect(consoleWarnSpy).not.toHaveBeenCalled();

      await controlledParcelActions(
        (parcel) => parcel.bootstrapPromise,
        ""bootstrap-3"",
        10
      );
      expectWarning(
        `single-spa minified message #31: Lifecycle function bootstrap for parcel bootstrap-3 lifecycle did not resolve or reject for 15 ms. See https://single-spa.js.org/error/?code=31&arg=bootstrap&arg=parcel&arg=bootstrap-3&arg=15`
      );
    });
  });

  describe(""setMountMaxTime"", () => {
    afterEach(() => {
      singleSpa.setMountMaxTime(5000, false, 1000);
    });

    it(`respects the millis configuration option`, async () => {
      singleSpa.setMountMaxTime(5, false, 1000);

      await controlledParcelActions(
        (parcel) => parcel.mountPromise,
        ""mount-0"",
        0,
        3
      );
      expect(consoleErrSpy).not.toHaveBeenCalled();

      await controlledParcelActions(
        (parcel) => parcel.mountPromise,
        ""mount-1"",
        0,
        10
      );
      expectError(
        `single-spa minified message #31: Lifecycle function mount for parcel mount-1 lifecycle did not resolve or reject for 5 ms. See https://single-spa.js.org/error/?code=31&arg=mount&arg=parcel&arg=mount-1&arg=5`
      );
    });

    it(`respects warningMillis configuration option`, async () => {
      singleSpa.setMountMaxTime(15, false, 5);

      await controlledParcelActions(
        (parcel) => parcel.mountPromise,
        ""mount-2"",
        0,
        3
      );
      expect(consoleWarnSpy).not.toHaveBeenCalled();

      await controlledParcelActions(
        (parcel) => parcel.mountPromise,
        ""mount-3"",
        0,
        10
      );
      expectWarning(
        `single-spa minified message #31: Lifecycle function mount for parcel mount-3 lifecycle did not resolve or reject for 15 ms. See https://single-spa.js.org/error/?code=31&arg=mount&arg=parcel&arg=mount-3&arg=15`
      );
    });
  });

  describe(""setUnmountMaxTime"", () => {
    const unmount = async (parcel) => {
      await parcel.mountPromise;
      await parcel.unmount();
    };

    afterEach(() => {
      singleSpa.setUnmountMaxTime(5000, false, 1000);
    });

    it(`respects the millis configuration option`, async () => {
      singleSpa.setUnmountMaxTime(5, false, 1000);

      await controlledParcelActions(unmount, ""unmount-0"", 0, 0, 0, 3);
      expect(consoleErrSpy).not.toHaveBeenCalled();

      await controlledParcelActions(unmount, ""unmount-1"", 0, 0, 0, 10);
      expectError(
        `single-spa minified message #31: Lifecycle function unmount for parcel unmount-1 lifecycle did not resolve or reject for 5 ms. See https://single-spa.js.org/error/?code=31&arg=unmount&arg=parcel&arg=unmount-1&arg=5`
      );
    });

    it(`respects warningMillis configuration option`, async () => {
      singleSpa.setUnmountMaxTime(15, false, 5);

      await controlledParcelActions(unmount, ""unmount-2"", 0, 0, 0, 3);
      expect(consoleWarnSpy).not.toHaveBeenCalled();

      await controlledParcelActions(unmount, ""unmount-3"", 0, 0, 0, 10);
      expectWarning(
        `single-spa minified message #31: Lifecycle function unmount for parcel unmount-3 lifecycle did not resolve or reject for 15 ms. See https://single-spa.js.org/error/?code=31&arg=unmount&arg=parcel&arg=unmount-3&arg=15`
      );
    });
  });

  function expectWarning(message) {
    expect(consoleWarnSpy).toHaveBeenCalled();
    const found = consoleWarnSpy.mock.calls.some((call) => call[0] === message);
    if (!found) {
      expect(consoleWarnSpy).toHaveBeenCalledWith(message);
    }
  }

  function expectError(message) {
    expect(consoleErrSpy).toHaveBeenCalled();
    const found = consoleErrSpy.mock.calls.some((call) => call[0] === message);
    if (!found) {
      expect(consoleErrSpy).toHaveBeenCalledWith(message);
    }
  }
})",steel
/spec/apis/single-spa-events-api.spec.js,Conditional Test Logic,"{'line': 114, 'column': 8, 'index': 2964}","xit(`doesn't destroy single-spa when you throw an error inside of an event listener`, async () => {
      const counterFn = jest.fn();
      let finish,
        finishPromise = new Promise((r) => (finish = r));

      process.on(""uncaughtException"", errHandler);

      // If the counterFn had been called thrice, it means all listener be invoked.
      function doneIfAllListenerHadBeenInvoked() {
        if (counterFn.mock.calls.length === 3) {
          process.off(""uncaughtException"", errHandler);
          finish();
        }
      }

      function listener() {
        window.removeEventListener(""single-spa:routing-event"", listener);
        throw Error(""Mwahaha I threw an error in an event listener"");
      }
      window.addEventListener(""single-spa:routing-event"", listener);

      function hashchangeListenerWithErr() {
        window.removeEventListener(""hashchange"", hashchangeListenerWithErr);
        throw Error(""Mwahaha I threw an error in an hashchange event listener"");
      }
      window.addEventListener(""hashchange"", hashchangeListenerWithErr);

      function hashchangeListener() {
        counterFn();
        window.removeEventListener(""hashchange"", hashchangeListener);
        doneIfAllListenerHadBeenInvoked();
      }
      window.addEventListener(""hashchange"", hashchangeListener);

      try {
        await singleSpa.triggerAppChange();
        window.location.hash = ""#/hashchange"";
      } catch {
        window.removeEventListener(""single-spa:routing-event"", listener);
        window.removeEventListener(""hashchange"", hashchangeListener);
        window.removeEventListener(""hashchange"", hashchangeListenerWithErr);
        process.off(""uncaughtException"", errHandler);
        throw err;
      }

      await finishPromise;

      function errHandler(err) {
        counterFn();
        console.error(err);
        doneIfAllListenerHadBeenInvoked();
      }
    })",steel
/spec/apis/single-spa-events-api.spec.js,Conditional Test Logic,"{'line': 515, 'column': 8, 'index': 16281}","it(`allows you to cancel a hash navigation event in the before-routing-event handler`, async () => {
      const beforeRoutingEvent = (evt) => {
        expect(evt.detail.oldUrl).toMatch(/http:\/\/localhost\/(#\/)?/);
        expect(evt.detail.newUrl).toBe(""http://localhost/#/russell"");

        if (new URL(evt.detail.newUrl).hash === ""#/russell"") {
          evt.detail.cancelNavigation();
        }
      };

      window.addEventListener(
        ""single-spa:before-routing-event"",
        beforeRoutingEvent
      );

      const originalStatus = singleSpa.getAppStatus(""russell"");
      const originalUrl = window.location.href;

      expect(originalStatus).toMatch(/NOT_MOUNTED|NOT_LOADED/);

      window.location.hash = `#/russell`;

      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""russell"")).toBe(originalStatus);
      expect(window.location.href).toBe(originalUrl);
      window.removeEventListener(
        ""single-spa:before-routing-event"",
        beforeRoutingEvent
      );
    })",steel
/spec/apis/single-spa-events-api.spec.js,Conditional Test Logic,"{'line': 559, 'column': 8, 'index': 17694}","it(`allows you to cancel a pushState navigation event in the before-routing-event handler`, async () => {
      await singleSpa.triggerAppChange(""/"");

      const app = { async mount() {}, async unmount() {} };
      singleSpa.registerApplication({
        name: ""cancel-pushstate"",
        app,
        activeWhen: ""/cancel-pushstate"",
      });

      const beforeRoutingEvent = (evt) => {
        window.removeEventListener(
          ""single-spa:before-routing-event"",
          beforeRoutingEvent
        );
        expect(evt.detail.oldUrl).toMatch(/http:\/\/localhost\/(#\/)?/);
        expect(evt.detail.newUrl).toBe(""http://localhost/cancel-pushstate"");

        if (new URL(evt.detail.newUrl).pathname === ""/cancel-pushstate"") {
          evt.detail.cancelNavigation();
        }
      };

      await singleSpa.triggerAppChange();

      window.addEventListener(
        ""single-spa:before-routing-event"",
        beforeRoutingEvent
      );

      const originalStatus = singleSpa.getAppStatus(""russell"");
      const originalUrl = window.location.href;

      expect(originalStatus).toMatch(/NOT_MOUNTED|NOT_LOADED/);

      singleSpa.navigateToUrl(""/cancel-pushstate"");

      await singleSpa.triggerAppChange();
      expect(singleSpa.getAppStatus(""russell"")).toBe(originalStatus);
      expect(window.location.href).toBe(originalUrl);
    })",steel
/spec/apis/event-listeners.spec.js,Conditional Test Logic,"{'line': 11, 'column': 6, 'index': 343}","it(`calls hashchange and popstate event listeners even when single-spa is not started`, (done) => {
    let hashchangeCalled = false,
      popstateCalled = false;

    function hashchange() {
      if (window.location.hash === ""#/a-new-hash"") hashchangeCalled = true;

      checkTestComplete();
    }

    function popstate() {
      if (window.location.hash === ""#/a-new-hash"") popstateCalled = true;

      checkTestComplete();
    }

    window.addEventListener(""hashchange"", hashchange);
    window.addEventListener(""popstate"", popstate);

    window.location.hash = ""#/a-new-hash"";

    function checkTestComplete() {
      if (isIE()) {
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/3740423/
        cleanupAndFinish();
      } else if (hashchangeCalled && popstateCalled) {
        // Wait for both hashchange and popstate events
        cleanupAndFinish();
      }
    }

    function cleanupAndFinish() {
      window.removeEventListener(""hashchange"", hashchange);
      window.removeEventListener(""popstate"", popstate);
      done();
    }
  })",steel
/spec/apis/event-listeners.spec.js,Conditional Test Logic,"{'line': 17, 'column': 6, 'index': 480}","it(`calls hashchange and popstate event listeners even when single-spa is not started`, (done) => {
    let hashchangeCalled = false,
      popstateCalled = false;

    function hashchange() {
      if (window.location.hash === ""#/a-new-hash"") hashchangeCalled = true;

      checkTestComplete();
    }

    function popstate() {
      if (window.location.hash === ""#/a-new-hash"") popstateCalled = true;

      checkTestComplete();
    }

    window.addEventListener(""hashchange"", hashchange);
    window.addEventListener(""popstate"", popstate);

    window.location.hash = ""#/a-new-hash"";

    function checkTestComplete() {
      if (isIE()) {
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/3740423/
        cleanupAndFinish();
      } else if (hashchangeCalled && popstateCalled) {
        // Wait for both hashchange and popstate events
        cleanupAndFinish();
      }
    }

    function cleanupAndFinish() {
      window.removeEventListener(""hashchange"", hashchange);
      window.removeEventListener(""popstate"", popstate);
      done();
    }
  })",steel
/spec/apis/event-listeners.spec.js,Conditional Test Logic,"{'line': 28, 'column': 6, 'index': 775}","it(`calls hashchange and popstate event listeners even when single-spa is not started`, (done) => {
    let hashchangeCalled = false,
      popstateCalled = false;

    function hashchange() {
      if (window.location.hash === ""#/a-new-hash"") hashchangeCalled = true;

      checkTestComplete();
    }

    function popstate() {
      if (window.location.hash === ""#/a-new-hash"") popstateCalled = true;

      checkTestComplete();
    }

    window.addEventListener(""hashchange"", hashchange);
    window.addEventListener(""popstate"", popstate);

    window.location.hash = ""#/a-new-hash"";

    function checkTestComplete() {
      if (isIE()) {
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/3740423/
        cleanupAndFinish();
      } else if (hashchangeCalled && popstateCalled) {
        // Wait for both hashchange and popstate events
        cleanupAndFinish();
      }
    }

    function cleanupAndFinish() {
      window.removeEventListener(""hashchange"", hashchange);
      window.removeEventListener(""popstate"", popstate);
      done();
    }
  })",steel
/spec/apis/event-listeners.spec.js,Conditional Test Logic,"{'line': 31, 'column': 13, 'index': 919}","it(`calls hashchange and popstate event listeners even when single-spa is not started`, (done) => {
    let hashchangeCalled = false,
      popstateCalled = false;

    function hashchange() {
      if (window.location.hash === ""#/a-new-hash"") hashchangeCalled = true;

      checkTestComplete();
    }

    function popstate() {
      if (window.location.hash === ""#/a-new-hash"") popstateCalled = true;

      checkTestComplete();
    }

    window.addEventListener(""hashchange"", hashchange);
    window.addEventListener(""popstate"", popstate);

    window.location.hash = ""#/a-new-hash"";

    function checkTestComplete() {
      if (isIE()) {
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/3740423/
        cleanupAndFinish();
      } else if (hashchangeCalled && popstateCalled) {
        // Wait for both hashchange and popstate events
        cleanupAndFinish();
      }
    }

    function cleanupAndFinish() {
      window.removeEventListener(""hashchange"", hashchange);
      window.removeEventListener(""popstate"", popstate);
      done();
    }
  })",steel
/spec/apis/event-listeners.spec.js,Conditional Test Logic,"{'line': 78, 'column': 6, 'index': 2357}","it(`calls all of the enqueued hashchange listeners even when the first event given to singleSpa is a popstate event`, (done) => {
    let hashchangeCalled = false,
      popstateCalled = false;

    function hashchange() {
      hashchangeCalled = true;
      checkTestComplete();
    }

    function popstate() {
      popstateCalled = true;
      checkTestComplete();
    }

    window.addEventListener(""hashchange"", hashchange);
    window.addEventListener(""popstate"", popstate);

    /* This will first trigger a PopStateEvent, and then a HashChangeEvent. The
     * hashchange event will be queued and not actually given to any event listeners
     * until single-spa is sure that those event listeners won't screw anything up.
     * The bug described in https://github.com/single-spa/single-spa/issues/74 explains
     * why this test is necessary.
     */
    window.location.hash = ""#/a-hash-single-spa-is-started"";

    function checkTestComplete() {
      if (isIE()) {
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/3740423/
        cleanupAndFinish(); // popstate isn't ever going to be called
      } else if (hashchangeCalled && popstateCalled) {
        // Wait for both hashchange and popstate events
        cleanupAndFinish();
      }
    }

    function cleanupAndFinish() {
      window.removeEventListener(""hashchange"", hashchange);
      window.removeEventListener(""popstate"", popstate);
      done();
    }
  })",steel
/spec/apis/event-listeners.spec.js,Conditional Test Logic,"{'line': 81, 'column': 13, 'index': 2543}","it(`calls all of the enqueued hashchange listeners even when the first event given to singleSpa is a popstate event`, (done) => {
    let hashchangeCalled = false,
      popstateCalled = false;

    function hashchange() {
      hashchangeCalled = true;
      checkTestComplete();
    }

    function popstate() {
      popstateCalled = true;
      checkTestComplete();
    }

    window.addEventListener(""hashchange"", hashchange);
    window.addEventListener(""popstate"", popstate);

    /* This will first trigger a PopStateEvent, and then a HashChangeEvent. The
     * hashchange event will be queued and not actually given to any event listeners
     * until single-spa is sure that those event listeners won't screw anything up.
     * The bug described in https://github.com/single-spa/single-spa/issues/74 explains
     * why this test is necessary.
     */
    window.location.hash = ""#/a-hash-single-spa-is-started"";

    function checkTestComplete() {
      if (isIE()) {
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/3740423/
        cleanupAndFinish(); // popstate isn't ever going to be called
      } else if (hashchangeCalled && popstateCalled) {
        // Wait for both hashchange and popstate events
        cleanupAndFinish();
      }
    }

    function cleanupAndFinish() {
      window.removeEventListener(""hashchange"", hashchange);
      window.removeEventListener(""popstate"", popstate);
      done();
    }
  })",steel
/spec/apis/delayed-start-popstate.spec.js,Conditional Test Logic,"{'line': 7, 'column': 4, 'index': 162}","describe(`delayed-start-popstate`, () => {
  let numPopstates = 0;

  function popstateListener(evt) {
    if (evt.singleSpa) {
      numPopstates++;
    }
  }

  beforeAll(() => {
    history.pushState(history.state, document.title, ""/"");
  });

  beforeEach(() => {
    numPopstates = 0;
    window.addEventListener(""popstate"", popstateListener);
  });

  afterEach(() => {
    window.removeEventListener(""popstate"", popstateListener);
  });

  it(`fires artificial popstate events only after start() is called`, async () => {
    await triggerAppChange();
    expect(numPopstates).toBe(0);

    history.pushState(history.state, document.title, ""/delayed1"");
    await triggerAppChange();

    expect(numPopstates).toBe(0);

    start();

    await triggerAppChange();
    expect(numPopstates).toBe(0);

    history.pushState(history.state, document.title, ""/delayed2"");
    await triggerAppChange();

    expect(numPopstates).toBe(1);
  });
})",steel
/node-spec/nodejs.spec.js,Unknown Test,"{'column': 4, 'line': 39}","it(""doesn't die if you call singleSpa.start()"", () => {
      singleSpa.start();
    })",steel
