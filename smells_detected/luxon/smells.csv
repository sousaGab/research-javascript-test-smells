file,type,line,method,source
/test/zones/invalid.test.js,AnonymousTest,"{'startLine':4,'endLine':15}","test(""InvalidZone"", () => {
  const zone = new InvalidZone(""foo"");

  expect(zone.type).toBe(""invalid"");
  expect(zone.name).toBe(""foo"");
  expect(zone.offsetName()).toBe(null); // the abstract class states this returns a string, yet InvalidZones return null :(
  expect(zone.formatOffset(0, ""short"")).toBe("""");
  expect(zone.isUniversal).toBe(false);
  expect(zone.offset()).toBe(NaN);
  expect(zone.isValid).toBe(false);
  expect(zone.equals(zone)).toBe(false); // always false even if it has the same name
})",snuts
/test/zones/invalid.test.js,SubOptimalAssert,"{'startLine':9,'endLine':9}","test(""InvalidZone"", () => {
  const zone = new InvalidZone(""foo"");

  expect(zone.type).toBe(""invalid"");
  expect(zone.name).toBe(""foo"");
  expect(zone.offsetName()).toBe(null); // the abstract class states this returns a string, yet InvalidZones return null :(
  expect(zone.formatOffset(0, ""short"")).toBe("""");
  expect(zone.isUniversal).toBe(false);
  expect(zone.offset()).toBe(NaN);
  expect(zone.isValid).toBe(false);
  expect(zone.equals(zone)).toBe(false); // always false even if it has the same name
})",snuts
/test/zones/fixedOffset.test.js,SubOptimalAssert,"{'startLine':36,'endLine':36}","test(""FixedOffsetZone.parseSpecifier returns null for invalid data"", () => {
  expect(FixedOffsetZone.parseSpecifier()).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(null)).toBe(null);
  expect(FixedOffsetZone.parseSpecifier("""")).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(""foo"")).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(""UTC+blorp"")).toBe(null);
})",snuts
/test/zones/fixedOffset.test.js,SubOptimalAssert,"{'startLine':37,'endLine':37}","test(""FixedOffsetZone.parseSpecifier returns null for invalid data"", () => {
  expect(FixedOffsetZone.parseSpecifier()).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(null)).toBe(null);
  expect(FixedOffsetZone.parseSpecifier("""")).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(""foo"")).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(""UTC+blorp"")).toBe(null);
})",snuts
/test/zones/fixedOffset.test.js,SubOptimalAssert,"{'startLine':38,'endLine':38}","test(""FixedOffsetZone.parseSpecifier returns null for invalid data"", () => {
  expect(FixedOffsetZone.parseSpecifier()).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(null)).toBe(null);
  expect(FixedOffsetZone.parseSpecifier("""")).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(""foo"")).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(""UTC+blorp"")).toBe(null);
})",snuts
/test/zones/fixedOffset.test.js,SubOptimalAssert,"{'startLine':39,'endLine':39}","test(""FixedOffsetZone.parseSpecifier returns null for invalid data"", () => {
  expect(FixedOffsetZone.parseSpecifier()).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(null)).toBe(null);
  expect(FixedOffsetZone.parseSpecifier("""")).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(""foo"")).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(""UTC+blorp"")).toBe(null);
})",snuts
/test/zones/fixedOffset.test.js,SubOptimalAssert,"{'startLine':40,'endLine':40}","test(""FixedOffsetZone.parseSpecifier returns null for invalid data"", () => {
  expect(FixedOffsetZone.parseSpecifier()).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(null)).toBe(null);
  expect(FixedOffsetZone.parseSpecifier("""")).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(""foo"")).toBe(null);
  expect(FixedOffsetZone.parseSpecifier(""UTC+blorp"")).toBe(null);
})",snuts
/test/zones/IANA.test.js,AnonymousTest,"{'startLine':19,'endLine':29}","test(""IANAZone.isValidSpecifier"", () => {
  expect(IANAZone.isValidSpecifier(""America/New_York"")).toBe(true);
  // this used to return true but now returns false, because we just defer to isValidZone
  expect(IANAZone.isValidSpecifier(""Fantasia/Castle"")).toBe(false);
  expect(IANAZone.isValidSpecifier(""Sport~~blorp"")).toBe(false);
  expect(IANAZone.isValidSpecifier(""Etc/GMT+8"")).toBe(true);
  expect(IANAZone.isValidSpecifier(""Etc/GMT-8"")).toBe(true);
  expect(IANAZone.isValidSpecifier(""Etc/GMT-0"")).toBe(true);
  expect(IANAZone.isValidSpecifier(""Etc/GMT-1"")).toBe(true);
  expect(IANAZone.isValidSpecifier(null)).toBe(false);
})",snuts
/test/zones/IANA.test.js,AnonymousTest,"{'startLine':31,'endLine':39}","test(""IANAZone.isValidZone"", () => {
  expect(IANAZone.isValidZone(""America/New_York"")).toBe(true);
  expect(IANAZone.isValidZone(""Fantasia/Castle"")).toBe(false);
  expect(IANAZone.isValidZone(""Sport~~blorp"")).toBe(false);
  expect(IANAZone.isValidZone("""")).toBe(false);
  expect(IANAZone.isValidZone(undefined)).toBe(false);
  expect(IANAZone.isValidZone(null)).toBe(false);
  expect(IANAZone.isValidZone(4)).toBe(false);
})",snuts
/test/interval/many.test.js,AnonymousTest,"{'startLine':220,'endLine':231}","test(""Interval#engulfs"", () => {
  const i = todayFrom(9, 12);

  expect(i.engulfs(todayFrom(13, 15), ""wholly later"")).toBeFalsy();
  expect(i.engulfs(todayFrom(11, 15), ""partially later"")).toBeFalsy();
  expect(i.engulfs(todayFrom(6, 8), ""wholly earlier"")).toBeFalsy();
  expect(i.engulfs(todayFrom(6, 10), ""partially earlier"")).toBeFalsy();
  expect(i.engulfs(todayFrom(8, 13), ""engulfed"")).toBeFalsy();

  expect(i.engulfs(todayFrom(10, 11), ""engulfing"")).toBeTruthy();
  expect(i.engulfs(todayFrom(9, 12), ""equal"")).toBeTruthy();
})",snuts
/test/interval/many.test.js,AnonymousTest,"{'startLine':241,'endLine':246}","test(""Interval#abutsStart"", () => {
  expect(todayFrom(9, 10).abutsStart(todayFrom(10, 11))).toBeTruthy();
  expect(todayFrom(9, 10).abutsStart(todayFrom(11, 12))).toBeFalsy();
  expect(todayFrom(9, 10).abutsStart(todayFrom(8, 11))).toBeFalsy();
  expect(todayFrom(9, 10).abutsStart(todayFrom(9, 10))).toBeFalsy();
})",snuts
/test/interval/many.test.js,AnonymousTest,"{'startLine':256,'endLine':261}","test(""Interval#abutsEnd"", () => {
  expect(todayFrom(9, 11).abutsEnd(todayFrom(8, 9))).toBeTruthy();
  expect(todayFrom(9, 11).abutsEnd(todayFrom(8, 10))).toBeFalsy();
  expect(todayFrom(9, 11).abutsEnd(todayFrom(7, 8))).toBeFalsy();
  expect(todayFrom(9, 11).abutsEnd(todayFrom(9, 11))).toBeFalsy();
})",snuts
/test/interval/many.test.js,ConditionalTestLogic,"{'startLine':372,'endLine':376}","test(""Interval#split by works across varying length months"", () => {
  Helpers.withDefaultZone(""Europe/London"", () => {
    const start = DateTime.fromISO(""2019-12-30T00:00:00.000+00:00"");
    const end = DateTime.fromISO(""2020-05-02T23:30:00.000+00:00"");
    const interval = Interval.fromDateTimes(start, end);

    const months = interval.splitBy(Duration.fromISO(""P1M""));
    expect(months.length).toEqual(5);

    for (let i = 0; i < months.length; i++) {
      const month = months[i];
      const expectedStart = start.plus({ month: i });
      const expectedEnd = start.plus({ month: i + 1 });

      expect(month.start).toEqual(expectedStart);

      if (expectedEnd > end) {
        expect(month.end).toEqual(end);
      } else {
        expect(month.end).toEqual(expectedEnd);
      }
    }
  });
})",snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':75,'endLine':75}","test(""Interval#intersection returns null if there's no intersection"", () => {
  expect(todayFrom(5, 8).intersection(todayFrom(3, 4))).toBe(null);
})",snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':103,'endLine':103}","test(""Interval.merge returns the minimal set of intervals"", () => {
  const list = [
      todayFrom(5, 8),
      todayFrom(4, 7),
      todayFrom(10, 11),
      todayFrom(11, 12),
      todayFrom(13, 15),
    ],
    results = Interval.merge(list);

  expect(results.length).toBe(3);
  expect(results[0] && results[0].equals(todayFrom(4, 8))).toBeTruthy();
  expect(results[1] && results[1].equals(todayFrom(10, 12))).toBeTruthy();
  expect(results[2] && results[2].equals(todayFrom(13, 15))).toBeTruthy();
})",snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':118,'endLine':118}",Unknown,snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':174,'endLine':174}",Unknown,snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':273,'endLine':273}","test(""Interval#splitAt breaks up the interval"", () => {
  const split = todayFrom(8, 13).splitAt(Helpers.atHour(9), Helpers.atHour(11));
  expect(split.length).toBe(3);
  expect(split[0].equals(todayFrom(8, 9))).toBeTruthy();
  expect(split[1].equals(todayFrom(9, 11))).toBeTruthy();
  expect(split[2].equals(todayFrom(11, 13))).toBeTruthy();
})",snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':286,'endLine':286}","test(""Interval#splitAt ignores times outside the interval"", () => {
  const allBefore = todayFrom(8, 13).splitAt(Helpers.atHour(7));
  expect(allBefore.length).toBe(1);
  expect(allBefore[0]).toEqual(todayFrom(8, 13));

  const allAfter = todayFrom(8, 13).splitAt(Helpers.atHour(14));
  expect(allAfter.length).toBe(1);
  expect(allAfter[0]).toEqual(todayFrom(8, 13));

  const oneBeforeOneDuring = todayFrom(8, 13).splitAt(Helpers.atHour(7), Helpers.atHour(11));
  expect(oneBeforeOneDuring.length).toBe(2);
  expect(oneBeforeOneDuring[0]).toEqual(todayFrom(8, 11));
  expect(oneBeforeOneDuring[1]).toEqual(todayFrom(11, 13));

  const oneAfterOneDuring = todayFrom(8, 13).splitAt(Helpers.atHour(11), Helpers.atHour(15));
  expect(oneAfterOneDuring.length).toBe(2);
  expect(oneAfterOneDuring[0]).toEqual(todayFrom(8, 11));
  expect(oneAfterOneDuring[1]).toEqual(todayFrom(11, 13));
})",snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':290,'endLine':290}","test(""Interval#splitAt ignores times outside the interval"", () => {
  const allBefore = todayFrom(8, 13).splitAt(Helpers.atHour(7));
  expect(allBefore.length).toBe(1);
  expect(allBefore[0]).toEqual(todayFrom(8, 13));

  const allAfter = todayFrom(8, 13).splitAt(Helpers.atHour(14));
  expect(allAfter.length).toBe(1);
  expect(allAfter[0]).toEqual(todayFrom(8, 13));

  const oneBeforeOneDuring = todayFrom(8, 13).splitAt(Helpers.atHour(7), Helpers.atHour(11));
  expect(oneBeforeOneDuring.length).toBe(2);
  expect(oneBeforeOneDuring[0]).toEqual(todayFrom(8, 11));
  expect(oneBeforeOneDuring[1]).toEqual(todayFrom(11, 13));

  const oneAfterOneDuring = todayFrom(8, 13).splitAt(Helpers.atHour(11), Helpers.atHour(15));
  expect(oneAfterOneDuring.length).toBe(2);
  expect(oneAfterOneDuring[0]).toEqual(todayFrom(8, 11));
  expect(oneAfterOneDuring[1]).toEqual(todayFrom(11, 13));
})",snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':294,'endLine':294}","test(""Interval#splitAt ignores times outside the interval"", () => {
  const allBefore = todayFrom(8, 13).splitAt(Helpers.atHour(7));
  expect(allBefore.length).toBe(1);
  expect(allBefore[0]).toEqual(todayFrom(8, 13));

  const allAfter = todayFrom(8, 13).splitAt(Helpers.atHour(14));
  expect(allAfter.length).toBe(1);
  expect(allAfter[0]).toEqual(todayFrom(8, 13));

  const oneBeforeOneDuring = todayFrom(8, 13).splitAt(Helpers.atHour(7), Helpers.atHour(11));
  expect(oneBeforeOneDuring.length).toBe(2);
  expect(oneBeforeOneDuring[0]).toEqual(todayFrom(8, 11));
  expect(oneBeforeOneDuring[1]).toEqual(todayFrom(11, 13));

  const oneAfterOneDuring = todayFrom(8, 13).splitAt(Helpers.atHour(11), Helpers.atHour(15));
  expect(oneAfterOneDuring.length).toBe(2);
  expect(oneAfterOneDuring[0]).toEqual(todayFrom(8, 11));
  expect(oneAfterOneDuring[1]).toEqual(todayFrom(11, 13));
})",snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':299,'endLine':299}","test(""Interval#splitAt ignores times outside the interval"", () => {
  const allBefore = todayFrom(8, 13).splitAt(Helpers.atHour(7));
  expect(allBefore.length).toBe(1);
  expect(allBefore[0]).toEqual(todayFrom(8, 13));

  const allAfter = todayFrom(8, 13).splitAt(Helpers.atHour(14));
  expect(allAfter.length).toBe(1);
  expect(allAfter[0]).toEqual(todayFrom(8, 13));

  const oneBeforeOneDuring = todayFrom(8, 13).splitAt(Helpers.atHour(7), Helpers.atHour(11));
  expect(oneBeforeOneDuring.length).toBe(2);
  expect(oneBeforeOneDuring[0]).toEqual(todayFrom(8, 11));
  expect(oneBeforeOneDuring[1]).toEqual(todayFrom(11, 13));

  const oneAfterOneDuring = todayFrom(8, 13).splitAt(Helpers.atHour(11), Helpers.atHour(15));
  expect(oneAfterOneDuring.length).toBe(2);
  expect(oneAfterOneDuring[0]).toEqual(todayFrom(8, 11));
  expect(oneAfterOneDuring[1]).toEqual(todayFrom(11, 13));
})",snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':327,'endLine':327}","test(""Interval#splitBy accepts an object"", () => {
  const split = todayFrom(8, 13).splitBy({ hours: 2 });
  expect(split.length).toBe(3);
  expect(split[0].equals(todayFrom(8, 10))).toBeTruthy();
  expect(split[1].equals(todayFrom(10, 12))).toBeTruthy();
  expect(split[2].equals(todayFrom(12, 13))).toBeTruthy();
})",snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':335,'endLine':335}","test(""Interval#splitBy accepts a duration"", () => {
  const split = todayFrom(8, 13).splitBy(Duration.fromObject({ hours: 2 }));
  expect(split.length).toBe(3);
  expect(split[0].equals(todayFrom(8, 10))).toBeTruthy();
  expect(split[1].equals(todayFrom(10, 12))).toBeTruthy();
  expect(split[2].equals(todayFrom(12, 13))).toBeTruthy();
})",snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':386,'endLine':386}","test(""Interval#divideEqually should split a 4 hour period into 4 contiguous 1-hour parts"", () => {
  const split = todayFrom(5, 9).divideEqually(4);
  expect(split.length).toBe(4);
  expect(split[0].equals(todayFrom(5, 6))).toBeTruthy();
  expect(split[3].equals(todayFrom(8, 9))).toBeTruthy();
})",snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':394,'endLine':394}","test(""Interval#divideEqually should split a 1m30s into 3 30-second parts"", () => {
  const after = (i, m, s) => Interval.after(i, Duration.fromObject({ minutes: m, seconds: s })),
    split = after(Helpers.atHour(9), 1, 30).divideEqually(3);
  expect(split.length).toBe(3);
  expect(split[0].equals(after(Helpers.atHour(9), 0, 30))).toBeTruthy();
  expect(split[2].equals(after(Helpers.atHour(9).plus({ minutes: 1 }), 0, 30))).toBeTruthy();
})",snuts
/test/interval/many.test.js,SubOptimalAssert,"{'startLine':402,'endLine':402}","test(""Interval#divideEqually always gives you the right number of parts"", () => {
  const int = Interval.after(Helpers.atHour(9), { minutes: 7 }),
    split = int.divideEqually(17);
  expect(split.length).toBe(17);
})",snuts
/test/interval/many.test.js,VerboseStatement,"{'startLine':284,'endLine':302}","test(""Interval#splitAt ignores times outside the interval"", () => {
  const allBefore = todayFrom(8, 13).splitAt(Helpers.atHour(7));
  expect(allBefore.length).toBe(1);
  expect(allBefore[0]).toEqual(todayFrom(8, 13));

  const allAfter = todayFrom(8, 13).splitAt(Helpers.atHour(14));
  expect(allAfter.length).toBe(1);
  expect(allAfter[0]).toEqual(todayFrom(8, 13));

  const oneBeforeOneDuring = todayFrom(8, 13).splitAt(Helpers.atHour(7), Helpers.atHour(11));
  expect(oneBeforeOneDuring.length).toBe(2);
  expect(oneBeforeOneDuring[0]).toEqual(todayFrom(8, 11));
  expect(oneBeforeOneDuring[1]).toEqual(todayFrom(11, 13));

  const oneAfterOneDuring = todayFrom(8, 13).splitAt(Helpers.atHour(11), Helpers.atHour(15));
  expect(oneAfterOneDuring.length).toBe(2);
  expect(oneAfterOneDuring[0]).toEqual(todayFrom(8, 11));
  expect(oneAfterOneDuring[1]).toEqual(todayFrom(11, 13));
})",snuts
/test/interval/getters.test.js,SubOptimalAssert,"{'startLine':14,'endLine':14}","test(""Interval.start returns null for invalid intervals"", () => {
  expect(invalid.start).toBe(null);
})",snuts
/test/interval/getters.test.js,SubOptimalAssert,"{'startLine':22,'endLine':22}","test(""Interval.end returns null for invalid intervals"", () => {
  expect(invalid.end).toBe(null);
})",snuts
/test/interval/format.test.js,IdenticalTestDescription,"{'startLine':226,'endLine':230}","test(""Interval#toFormat accepts date formats"", () => {
  expect(interval.toFormat(""EEE, LLL dd, yyyy"", { separator: "" until "" })).toBe(
    ""Tue, May 25, 1982 until Fri, Oct 14, 1983""
  );
})",snuts
/test/impl/english.test.js,AnonymousTest,"{'startLine':5,'endLine':8}","test(""today"", () => {
  expect(formatRelativeTime(""days"", 0, ""auto"")).toBe(""today"");
  expect(formatRelativeTime(""days"", 0, ""always"")).toBe(""in 0 days"");
})",snuts
/test/impl/english.test.js,AnonymousTest,"{'startLine':10,'endLine':13}","test(""tomorrow"", () => {
  expect(formatRelativeTime(""days"", 1, ""auto"")).toBe(""tomorrow"");
  expect(formatRelativeTime(""days"", 1, ""always"")).toBe(""in 1 day"");
})",snuts
/test/impl/english.test.js,AnonymousTest,"{'startLine':15,'endLine':18}","test(""yesterday"", () => {
  expect(formatRelativeTime(""days"", -1, ""auto"")).toBe(""yesterday"");
  expect(formatRelativeTime(""days"", -1, ""always"")).toBe(""1 day ago"");
})",snuts
/test/impl/english.test.js,AnonymousTest,"{'startLine':35,'endLine':41}","test(""this month"", () => {
  expect(formatRelativeTime(""months"", 0, ""auto"")).toBe(""this month"");
  expect(formatRelativeTime(""months"", 0, ""always"")).toBe(""in 0 months"");
  expect(formatRelativeTime(""months"", -0, ""always"")).toBe(""0 months ago"");
  expect(formatRelativeTime(""months"", 0, ""always"", true)).toBe(""in 0 mo."");
  expect(formatRelativeTime(""months"", -0, ""always"", true)).toBe(""0 mo. ago"");
})",snuts
/test/impl/english.test.js,AnonymousTest,"{'startLine':43,'endLine':48}","test(""next month"", () => {
  expect(formatRelativeTime(""months"", 1, ""auto"")).toBe(""next month"");
  expect(formatRelativeTime(""months"", 1, ""auto"", true)).toBe(""next month"");
  expect(formatRelativeTime(""months"", 1, ""always"")).toBe(""in 1 month"");
  expect(formatRelativeTime(""months"", 1, ""always"", true)).toBe(""in 1 mo."");
})",snuts
/test/impl/english.test.js,AnonymousTest,"{'startLine':50,'endLine':55}","test(""last month"", () => {
  expect(formatRelativeTime(""months"", -1, ""auto"")).toBe(""last month"");
  expect(formatRelativeTime(""months"", -1, ""auto"", true)).toBe(""last month"");
  expect(formatRelativeTime(""months"", -1, ""always"")).toBe(""1 month ago"");
  expect(formatRelativeTime(""months"", -1, ""always"", true)).toBe(""1 mo. ago"");
})",snuts
/test/impl/english.test.js,AnonymousTest,"{'startLine':83,'endLine':107}","test(""formatString"", () => {
  expect(formatString(Formats.DATE_SHORT)).toBe(""M/d/yyyy"");
  expect(formatString(Formats.DATE_MED)).toBe(""LLL d, yyyy"");
  expect(formatString(Formats.DATE_MED_WITH_WEEKDAY)).toBe(""EEE, LLL d, yyyy"");
  expect(formatString(Formats.DATE_FULL)).toBe(""LLLL d, yyyy"");
  expect(formatString(Formats.DATE_HUGE)).toBe(""EEEE, LLLL d, yyyy"");
  expect(formatString(Formats.TIME_SIMPLE)).toBe(""h:mm a"");
  expect(formatString(Formats.TIME_WITH_SECONDS)).toBe(""h:mm:ss a"");
  expect(formatString(Formats.TIME_WITH_SHORT_OFFSET)).toBe(""h:mm a"");
  expect(formatString(Formats.TIME_WITH_LONG_OFFSET)).toBe(""h:mm a"");
  expect(formatString(Formats.TIME_24_SIMPLE)).toBe(""HH:mm"");
  expect(formatString(Formats.TIME_24_WITH_SECONDS)).toBe(""HH:mm:ss"");
  expect(formatString(Formats.TIME_24_WITH_SHORT_OFFSET)).toBe(""HH:mm"");
  expect(formatString(Formats.TIME_24_WITH_LONG_OFFSET)).toBe(""HH:mm"");
  expect(formatString(Formats.DATETIME_SHORT)).toBe(""M/d/yyyy, h:mm a"");
  expect(formatString(Formats.DATETIME_MED)).toBe(""LLL d, yyyy, h:mm a"");
  expect(formatString(Formats.DATETIME_FULL)).toBe(""LLLL d, yyyy, h:mm a"");
  expect(formatString(Formats.DATETIME_HUGE)).toBe(""EEEE, LLLL d, yyyy, h:mm a"");
  expect(formatString(Formats.DATETIME_SHORT_WITH_SECONDS)).toBe(""M/d/yyyy, h:mm:ss a"");
  expect(formatString(Formats.DATETIME_MED_WITH_SECONDS)).toBe(""LLL d, yyyy, h:mm:ss a"");
  expect(formatString(Formats.DATETIME_MED_WITH_WEEKDAY)).toBe(""EEE, d LLL yyyy, h:mm a"");
  expect(formatString(Formats.DATETIME_FULL_WITH_SECONDS)).toBe(""LLLL d, yyyy, h:mm:ss a"");
  expect(formatString(Formats.DATETIME_HUGE_WITH_SECONDS)).toBe(""EEEE, LLLL d, yyyy, h:mm:ss a"");
  expect(formatString(""Default"")).toBe(""EEEE, LLLL d, yyyy, h:mm a"");
})",snuts
/test/impl/english.test.js,AnonymousTest,"{'startLine':109,'endLine':123}","test(""weekdays"", () => {
  expect(weekdays(""narrow"")).toStrictEqual([""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]);
  expect(weekdays(""short"")).toStrictEqual([""Mon"", ""Tue"", ""Wed"", ""Thu"", ""Fri"", ""Sat"", ""Sun""]);
  expect(weekdays(""long"")).toStrictEqual([
    ""Monday"",
    ""Tuesday"",
    ""Wednesday"",
    ""Thursday"",
    ""Friday"",
    ""Saturday"",
    ""Sunday"",
  ]);
  expect(weekdays(""numeric"")).toStrictEqual([""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7""]);
  expect(weekdays(null)).toStrictEqual(null);
})",snuts
/test/impl/english.test.js,AnonymousTest,"{'startLine':125,'endLine':130}","test(""eras"", () => {
  expect(eras(""narrow"")).toStrictEqual([""B"", ""A""]);
  expect(eras(""short"")).toStrictEqual([""BC"", ""AD""]);
  expect(eras(""long"")).toStrictEqual([""Before Christ"", ""Anno Domini""]);
  expect(eras(""default"")).toStrictEqual(null);
})",snuts
/test/impl/english.test.js,IdenticalTestDescription,"{'startLine':69,'endLine':74}","test(""in 1 hour"", () => {
  expect(formatRelativeTime(""hours"", 1, ""auto"")).toBe(""in 1 hour"");
  expect(formatRelativeTime(""hours"", 1, ""auto"", true)).toBe(""in 1 hr."");
  expect(formatRelativeTime(""hours"", 1, ""always"")).toBe(""in 1 hour"");
  expect(formatRelativeTime(""hours"", 1, ""always"", true)).toBe(""in 1 hr."");
})",snuts
/test/impl/english.test.js,VerboseStatement,"{'startLine':83,'endLine':107}","test(""formatString"", () => {
  expect(formatString(Formats.DATE_SHORT)).toBe(""M/d/yyyy"");
  expect(formatString(Formats.DATE_MED)).toBe(""LLL d, yyyy"");
  expect(formatString(Formats.DATE_MED_WITH_WEEKDAY)).toBe(""EEE, LLL d, yyyy"");
  expect(formatString(Formats.DATE_FULL)).toBe(""LLLL d, yyyy"");
  expect(formatString(Formats.DATE_HUGE)).toBe(""EEEE, LLLL d, yyyy"");
  expect(formatString(Formats.TIME_SIMPLE)).toBe(""h:mm a"");
  expect(formatString(Formats.TIME_WITH_SECONDS)).toBe(""h:mm:ss a"");
  expect(formatString(Formats.TIME_WITH_SHORT_OFFSET)).toBe(""h:mm a"");
  expect(formatString(Formats.TIME_WITH_LONG_OFFSET)).toBe(""h:mm a"");
  expect(formatString(Formats.TIME_24_SIMPLE)).toBe(""HH:mm"");
  expect(formatString(Formats.TIME_24_WITH_SECONDS)).toBe(""HH:mm:ss"");
  expect(formatString(Formats.TIME_24_WITH_SHORT_OFFSET)).toBe(""HH:mm"");
  expect(formatString(Formats.TIME_24_WITH_LONG_OFFSET)).toBe(""HH:mm"");
  expect(formatString(Formats.DATETIME_SHORT)).toBe(""M/d/yyyy, h:mm a"");
  expect(formatString(Formats.DATETIME_MED)).toBe(""LLL d, yyyy, h:mm a"");
  expect(formatString(Formats.DATETIME_FULL)).toBe(""LLLL d, yyyy, h:mm a"");
  expect(formatString(Formats.DATETIME_HUGE)).toBe(""EEEE, LLLL d, yyyy, h:mm a"");
  expect(formatString(Formats.DATETIME_SHORT_WITH_SECONDS)).toBe(""M/d/yyyy, h:mm:ss a"");
  expect(formatString(Formats.DATETIME_MED_WITH_SECONDS)).toBe(""LLL d, yyyy, h:mm:ss a"");
  expect(formatString(Formats.DATETIME_MED_WITH_WEEKDAY)).toBe(""EEE, d LLL yyyy, h:mm a"");
  expect(formatString(Formats.DATETIME_FULL_WITH_SECONDS)).toBe(""LLLL d, yyyy, h:mm:ss a"");
  expect(formatString(Formats.DATETIME_HUGE_WITH_SECONDS)).toBe(""EEEE, LLLL d, yyyy, h:mm:ss a"");
  expect(formatString(""Default"")).toBe(""EEEE, LLLL d, yyyy, h:mm a"");
})",snuts
/test/duration/units.test.js,AnonymousTest,"{'startLine':166,'endLine':171}","test(""Duration#normalize de-overflows"", () => {
  const dur = Duration.fromObject({ years: 2, days: 5000 }).normalize();
  expect(dur.years).toBe(15);
  expect(dur.days).toBe(255);
  expect(dur.toObject()).toEqual({ years: 15, days: 255 });
})",snuts
/test/duration/parse.test.js,VerboseStatement,"{'startLine':23,'endLine':38}","test(""Duration.fromISO can parse mixed or negative durations"", () => {
  check(""P-5Y-3M"", { years: -5, months: -3 });
  check(""PT-54M32S"", { minutes: -54, seconds: 32 });
  check(""P-3DT54M-32S"", { days: -3, minutes: 54, seconds: -32 });
  check(""P1YT-34000S"", { years: 1, seconds: -34000 });
  check(""P-1W1DT13H23M34S"", { weeks: -1, days: 1, hours: 13, minutes: 23, seconds: 34 });
  check(""P-2W"", { weeks: -2 });
  check(""-P1D"", { days: -1 });
  check(""-P5Y3M"", { years: -5, months: -3 });
  check(""-P-5Y-3M"", { years: 5, months: 3 });
  check(""-P-1W1DT13H-23M34S"", { weeks: 1, days: -1, hours: -13, minutes: 23, seconds: -34 });
  check(""PT-1.5S"", { seconds: -1, milliseconds: -500 });
  check(""PT-0.5S"", { seconds: 0, milliseconds: -500 });
  check(""PT1.5S"", { seconds: 1, milliseconds: 500 });
  check(""PT0.5S"", { seconds: 0, milliseconds: 500 });
})",snuts
/test/duration/invalid.test.js,AnonymousTest,"{'startLine':12,'endLine':19}","test(""throwOnInvalid throws"", () => {
  try {
    Settings.throwOnInvalid = true;
    expect(() => Duration.invalid(""because"")).toThrow();
  } finally {
    Settings.throwOnInvalid = false;
  }
})",snuts
/test/duration/format.test.js,SubOptimalAssert,"{'startLine':60,'endLine':60}","test(""Duration#toISO returns null for invalid durations"", () => {
  expect(Duration.invalid(""because"").toISO()).toBe(null);
})",snuts
/test/duration/format.test.js,SubOptimalAssert,"{'startLine':116,'endLine':116}","test(""Duration#toISOTime returns null if the value is outside the range of one day"", () => {
  expect(Duration.fromObject({ hours: 24 }).toISOTime()).toBe(null);
  expect(Duration.fromObject({ milliseconds: -1 }).toISOTime()).toBe(null);
})",snuts
/test/duration/format.test.js,SubOptimalAssert,"{'startLine':117,'endLine':117}","test(""Duration#toISOTime returns null if the value is outside the range of one day"", () => {
  expect(Duration.fromObject({ hours: 24 }).toISOTime()).toBe(null);
  expect(Duration.fromObject({ milliseconds: -1 }).toISOTime()).toBe(null);
})",snuts
/test/duration/equality.test.js,AnonymousTest,"{'startLine':4,'endLine':7}","test(""equals self"", () => {
  const l = Duration.fromObject({ years: 5, days: 6 });
  expect(l.equals(l)).toBe(true);
})",snuts
/test/datetime/zone.test.js,SubOptimalAssert,"{'startLine':218,'endLine':218}","test(""DateTime#setZone handles negative years"", () => {
  const dt = DateTime.fromMillis(-84753824400000).setZone(""Europe/Rome"");
  expect(dt.year).toBe(-716);
  expect(dt.offset < 60).toBe(true);
})",snuts
/test/datetime/zone.test.js,SubOptimalAssert,"{'startLine':283,'endLine':283}","test(""DateTime#offsetNameLong returns null for invalid times"", () => {
  const zoned = DateTime.invalid(""because"");
  expect(zoned.offsetNameLong).toBe(null);
})",snuts
/test/datetime/zone.test.js,SubOptimalAssert,"{'startLine':288,'endLine':288}","test(""DateTime#offsetNameShort returns null for invalid times"", () => {
  const zoned = DateTime.invalid(""because"");
  expect(zoned.offsetNameShort).toBe(null);
})",snuts
/test/datetime/zone.test.js,SubOptimalAssert,"{'startLine':339,'endLine':339}","test(""invalid DateTimes have no zone"", () => {
  expect(DateTime.invalid(""because"").zoneName).toBe(null);
})",snuts
/test/datetime/zone.test.js,VerboseStatement,"{'startLine':165,'endLine':183}","test(""DateTime#setZone accepts a keepLocalTime option"", () => {
  const zoned = dt().toUTC().setZone(""America/Los_Angeles"", { keepLocalTime: true });
  expect(zoned.zoneName).toBe(""America/Los_Angeles"");
  expect(zoned.year).toBe(1982);
  expect(zoned.month).toBe(5);
  expect(zoned.day).toBe(25);
  expect(zoned.hour).toBe(4);
  expect(zoned.isOffsetFixed).toBe(false);

  const zonedMore = zoned.setZone(""America/New_York"", {
    keepLocalTime: true,
  });
  expect(zonedMore.zoneName).toBe(""America/New_York"");
  expect(zonedMore.year).toBe(1982);
  expect(zonedMore.month).toBe(5);
  expect(zonedMore.day).toBe(25);
  expect(zonedMore.hour).toBe(4);
  expect(zonedMore.isOffsetFixed).toBe(false);
})",snuts
/test/datetime/tokenParse.test.js,CommentsOnlyTest,"{'startLine':345,'endLine':345}","test(""DateTime.fromFormat() parses offsets"", () => {})",snuts
/test/datetime/tokenParse.test.js,IdenticalTestDescription,"{'startLine':1188,'endLine':1191}","test(""DateTime.parseFormatForOpts returns a parsing format"", () => {
  const format = DateTime.parseFormatForOpts("""");
  expect(format).toBeNull();
})",snuts
/test/datetime/tokenParse.test.js,ConditionalTestLogic,"{'startLine':566,'endLine':574}","test(""DateTime.fromFormat() parses fixed offsets"", () => {
  const formats = [
    [""Z"", ""-4""],
    [""ZZ"", ""-4:00""],
    [""ZZZ"", ""-0400""],
  ];

  for (const i in formats) {
    if (Object.prototype.hasOwnProperty.call(formats, i)) {
      const [format, example] = formats[i],
        dt = DateTime.fromFormat(
          `1982/05/25 09:10:11.445 ${example}`,
          `yyyy/MM/dd HH:mm:ss.SSS ${format}`
        );
      expect(dt.toUTC().hour).toBe(13);
      expect(dt.toUTC().minute).toBe(10);
    }
  }
})",snuts
/test/datetime/tokenParse.test.js,ConditionalTestLogic,"{'startLine':586,'endLine':596}","test(""DateTime.fromFormat() with setZone parses fixed offsets and sets it"", () => {
  const formats = [
    [""Z"", ""-4""],
    [""ZZ"", ""-4:00""],
    [""ZZZ"", ""-0400""],
  ];

  for (const i in formats) {
    if (Object.prototype.hasOwnProperty.call(formats, i)) {
      const [format, example] = formats[i],
        dt = DateTime.fromFormat(
          `1982/05/25 09:10:11.445 ${example}`,
          `yyyy/MM/dd HH:mm:ss.SSS ${format}`,
          { setZone: true }
        );
      expect(dt.offset).toBe(-4 * 60);
      expect(dt.toUTC().hour).toBe(13);
      expect(dt.toUTC().minute).toBe(10);
    }
  }
})",snuts
/test/datetime/tokenParse.test.js,ConditionalTestLogic,"{'startLine':779,'endLine':787}","test(""DateTime.fromFormat() parses localized macro tokens"", () => {
  const formatGroups = [
    {
      formats: [""D"", ""DD"", ""DDD"", ""DDDD""],
      expectEqual: {
        year: true,
        month: true,
        day: true,
      },
    },

    {
      formats: [""t"", ""T""],
      expectEqual: {
        hour: true,
        minute: true,
      },
    },
    {
      formats: [""tt"", ""TT""],
      expectEqual: {
        hour: true,
        minute: true,
        second: true,
      },
    },

    {
      formats: [""F"", ""FF""],
      expectEqual: {
        year: true,
        month: true,
        day: true,
        hour: true,
        minute: true,
        second: true,
      },
    },

    // Parsing time zone names like `EDT` or `Eastern Daylight Time` is not supported
    {
      formats: [""ttt"", ""tttt"", ""TTT"", ""TTTT"", ""FFF"", ""FFFF""],
      expectInvalid: true,
    },
  ];

  const sampleDateTime = DateTime.fromMillis(1555555555555);

  for (const { formats, expectEqual, expectInvalid } of formatGroups) {
    for (const locale of [null, ""en-gb"", ""de""]) {
      for (const format of formats) {
        const formatted = sampleDateTime.toFormat(format, { locale });
        const parsed = DateTime.fromFormat(formatted, format, { locale });

        if (expectInvalid) {
          expect(parsed.isValid).toBe(false);
        } else {
          expect(parsed.isValid).toBe(true);

          for (const key of Object.keys(expectEqual)) {
            expect(parsed[key]).toBe(sampleDateTime[key]);
          }
        }
      }
    }
  }
})",snuts
/test/datetime/tokenParse.test.js,NonFunctionalStatement,"{'startLine':345,'endLine':345}","test(""DateTime.fromFormat() parses offsets"", () => {})",snuts
/test/datetime/tokenParse.test.js,VerboseStatement,"{'startLine':27,'endLine':45}","test(""DateTime.fromFormat() parses with variable-length input"", () => {
  let i = DateTime.fromFormat(""1982/05/03 09:07:05.004"", ""y/M/d H:m:s.S"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(3);
  expect(i.hour).toBe(9);
  expect(i.minute).toBe(7);
  expect(i.second).toBe(5);
  expect(i.millisecond).toBe(4);

  i = DateTime.fromFormat(""82/5/3 9:7:5.4"", ""yy/M/d H:m:s.S"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(3);
  expect(i.hour).toBe(9);
  expect(i.minute).toBe(7);
  expect(i.second).toBe(5);
  expect(i.millisecond).toBe(4);
})",snuts
/test/datetime/tokenParse.test.js,VerboseStatement,"{'startLine':47,'endLine':71}","test(""DateTime.fromFormat() parses meridiems"", () => {
  let i = DateTime.fromFormat(""1982/05/25 9 PM"", ""yyyy/MM/dd h a"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(25);
  expect(i.hour).toBe(21);

  i = DateTime.fromFormat(""1982/05/25 9 AM"", ""yyyy/MM/dd h a"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(25);
  expect(i.hour).toBe(9);

  i = DateTime.fromFormat(""1982/05/25 12 AM"", ""yyyy/MM/dd h a"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(25);
  expect(i.hour).toBe(0);

  i = DateTime.fromFormat(""1982/05/25 12 PM"", ""yyyy/MM/dd h a"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(25);
  expect(i.hour).toBe(12);
})",snuts
/test/datetime/tokenParse.test.js,VerboseStatement,"{'startLine':241,'endLine':271}","test(""DateTime.fromFormat() parses standalone month names"", () => {
  let i = DateTime.fromFormat(""May 25 1982"", ""LLLL dd yyyy"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(25);

  i = DateTime.fromFormat(""Sep 25 1982"", ""LLL dd yyyy"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(9);
  expect(i.day).toBe(25);

  i = DateTime.fromFormat(""5 25 1982"", ""L dd yyyy"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(25);

  i = DateTime.fromFormat(""05 25 1982"", ""LL dd yyyy"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(25);

  i = DateTime.fromFormat(""mai 25 1982"", ""LLLL dd yyyy"", { locale: ""fr"" });
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(25);

  i = DateTime.fromFormat(""janv. 25 1982"", ""LLL dd yyyy"", { locale: ""fr"" });
  expect(i.year).toBe(1982);
  expect(i.month).toBe(1);
  expect(i.day).toBe(25);
})",snuts
/test/datetime/tokenParse.test.js,VerboseStatement,"{'startLine':273,'endLine':303}","test(""DateTime.fromFormat() parses format month names"", () => {
  let i = DateTime.fromFormat(""May 25 1982"", ""MMMM dd yyyy"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(25);

  i = DateTime.fromFormat(""Sep 25 1982"", ""MMM dd yyyy"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(9);
  expect(i.day).toBe(25);

  i = DateTime.fromFormat(""5 25 1982"", ""M dd yyyy"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(25);

  i = DateTime.fromFormat(""05 25 1982"", ""MM dd yyyy"");
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(25);

  i = DateTime.fromFormat(""mai 25 1982"", ""MMMM dd yyyy"", { locale: ""fr"" });
  expect(i.year).toBe(1982);
  expect(i.month).toBe(5);
  expect(i.day).toBe(25);

  i = DateTime.fromFormat(""janv. 25 1982"", ""MMM dd yyyy"", { locale: ""fr"" });
  expect(i.year).toBe(1982);
  expect(i.month).toBe(1);
  expect(i.day).toBe(25);
})",snuts
/test/datetime/tokenParse.test.js,VerboseStatement,"{'startLine':389,'endLine':409}","test(""DateTime.fromFormat() parses ordinals"", () => {
  let d = DateTime.fromFormat(""2016 200"", ""yyyy ooo"");
  expect(d.year).toBe(2016);
  expect(d.ordinal).toBe(200);

  d = DateTime.fromFormat(""2016 200"", ""yyyy ooo"");
  expect(d.year).toBe(2016);
  expect(d.ordinal).toBe(200);

  d = DateTime.fromFormat(""2016 016"", ""yyyy ooo"");
  expect(d.year).toBe(2016);
  expect(d.ordinal).toBe(16);

  d = DateTime.fromFormat(""2016 200"", ""yyyy o"");
  expect(d.year).toBe(2016);
  expect(d.ordinal).toBe(200);

  d = DateTime.fromFormat(""2016 16"", ""yyyy o"");
  expect(d.year).toBe(2016);
  expect(d.ordinal).toBe(16);
})",snuts
/test/datetime/tokenParse.test.js,VerboseStatement,"{'startLine':656,'endLine':689}","test(""DateTime.fromFormat() maintains offset that belongs to time zone during overlap"", () => {
  // On this day, 02:30 exists for both offsets, due to DST ending.
  let i = DateTime.fromFormat(
    ""2021-04-04T02:30:00.000+11:00[Australia/Sydney]"",
    ""yyyy-MM-dd'T'HH:mm:ss.SSSZZ[z]"",
    { setZone: true }
  );
  expect(i.isValid).toBe(true);
  expect(i.year).toBe(2021);
  expect(i.month).toBe(4);
  expect(i.day).toBe(4);
  expect(i.hour).toBe(2);
  expect(i.minute).toBe(30);
  expect(i.second).toBe(0);
  expect(i.millisecond).toBe(0);
  expect(i.offset).toBe(660); //+11:00
  expect(i.zoneName).toBe(""Australia/Sydney"");

  i = DateTime.fromFormat(
    ""2021-04-04T02:30:00.000+10:00[Australia/Sydney]"",
    ""yyyy-MM-dd'T'HH:mm:ss.SSSZZ[z]"",
    { setZone: true }
  );
  expect(i.isValid).toBe(true);
  expect(i.year).toBe(2021);
  expect(i.month).toBe(4);
  expect(i.day).toBe(4);
  expect(i.hour).toBe(2);
  expect(i.minute).toBe(30);
  expect(i.second).toBe(0);
  expect(i.millisecond).toBe(0);
  expect(i.offset).toBe(600); //+10:00
  expect(i.zoneName).toBe(""Australia/Sydney"");
})",snuts
/test/datetime/tokenParse.test.js,VerboseStatement,"{'startLine':902,'endLine':1151}","test(""DateTime.fromFormatExplain() parses localized string with numberingSystem correctly"", () => {
  const cldr = cldrMajorVersion();
  const ex1 = DateTime.fromFormatExplain(
    cldr && cldr < 46
      ? ""೦೩-ಏಪ್ರಿಲ್-೨೦೧೯ ೧೨:೨೬:೦೭ ಅಪರಾಹ್ನ Asia/Calcutta""
      : ""೦೩-ಏಪ್ರಿಲ್-೨೦೧೯ ೧೨:೨೬:೦೭ PM Asia/Calcutta"",
    ""dd-MMMM-yyyy hh:mm:ss a z"",
    { locale: ""kn"", numberingSystem: ""knda"" }
  );
  expect(ex1.rawMatches).toBeInstanceOf(Array);
  expect(ex1.matches).toBeInstanceOf(Object);
  expect(keyCount(ex1.matches)).toBe(8);
  expect(ex1.result).toBeInstanceOf(Object);
  expect(keyCount(ex1.result)).toBe(6);
  expect(ex1.matches).toEqual({
    M: 4,
    a: 1,
    d: 3,
    h: 12,
    m: 26,
    s: 7,
    y: 2019,
    z: ""Asia/Calcutta"",
  });

  const ex2 = DateTime.fromFormatExplain(
    ""〇三-四-二〇一九 一二:三四:四九 下午 Asia/Shanghai"",
    ""dd-MMMM-yyyy hh:mm:ss a z"",
    { locale: ""zh"", numberingSystem: ""hanidec"" }
  );
  expect(ex2.rawMatches).toBeInstanceOf(Array);
  expect(ex2.matches).toBeInstanceOf(Object);
  expect(keyCount(ex2.matches)).toBe(8);
  expect(ex2.result).toBeInstanceOf(Object);
  expect(keyCount(ex2.result)).toBe(6);
  expect(ex2.matches).toEqual({
    M: 4,
    a: 1,
    d: 3,
    h: 12,
    m: 34,
    s: 49,
    y: 2019,
    z: ""Asia/Shanghai"",
  });

  const ex3 = DateTime.fromFormatExplain(""٠٣-أبريل-٢٠١٩ ٠٣:٤٦:٠١ م"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    locale: ""ar"",
    numberingSystem: ""arab"",
  });
  expect(ex3.rawMatches).toBeInstanceOf(Array);
  expect(ex3.matches).toBeInstanceOf(Object);
  expect(keyCount(ex3.matches)).toBe(7);
  expect(ex3.result).toBeInstanceOf(Object);
  expect(keyCount(ex3.result)).toBe(6);
  expect(ex3.matches).toEqual({
    M: 4,
    a: 1,
    d: 3,
    h: 15,
    m: 46,
    s: 1,
    y: 2019,
  });

  const ex4 = DateTime.fromFormatExplain(""۰۳-أبريل-۲۰۱۹ ۰۳:۴۷:۲۱ م"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    locale: ""ar"",
    numberingSystem: ""arabext"",
  });
  expect(ex4.rawMatches).toBeInstanceOf(Array);
  expect(ex4.matches).toBeInstanceOf(Object);
  expect(keyCount(ex4.matches)).toBe(7);
  expect(ex4.result).toBeInstanceOf(Object);
  expect(keyCount(ex4.result)).toBe(6);

  const ex5 = DateTime.fromFormatExplain(""᭐᭓-April-᭒᭐᭑᭙ ᭐᭒:᭔᭔:᭐᭗ PM"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    locale: ""id"",
    numberingSystem: ""bali"",
  });
  expect(ex5.rawMatches).toBeInstanceOf(Array);
  expect(ex5.matches).toBeInstanceOf(Object);
  expect(keyCount(ex5.matches)).toBe(7);
  expect(ex5.result).toBeInstanceOf(Object);
  expect(keyCount(ex5.result)).toBe(6);

  const ex6 = DateTime.fromFormatExplain(""০৩ এপ্রিল ২০১৯ ১২.৫৭"", ""dd MMMM yyyy hh.mm"", {
    locale: ""bn"",
    numberingSystem: ""beng"",
  });
  expect(ex6.rawMatches).toBeInstanceOf(Array);
  expect(ex6.matches).toBeInstanceOf(Object);
  expect(keyCount(ex6.matches)).toBe(5);
  expect(ex6.result).toBeInstanceOf(Object);
  expect(keyCount(ex6.result)).toBe(5);
  expect(ex6.matches).toEqual({
    M: 4,
    d: 3,
    h: 12,
    m: 57,
    y: 2019,
  });

  const ex7 = DateTime.fromFormatExplain(
    ""０３-April-２０１９ ０２:４７:０４ PM"",
    ""dd-MMMM-yyyy hh:mm:ss a"",
    {
      locale: ""en-US"",
      numberingSystem: ""fullwide"",
    }
  );
  expect(ex7.rawMatches).toBeInstanceOf(Array);
  expect(ex7.matches).toBeInstanceOf(Object);
  expect(keyCount(ex7.matches)).toBe(7);
  expect(ex7.result).toBeInstanceOf(Object);
  expect(keyCount(ex7.result)).toBe(6);

  const ex8 = DateTime.fromFormatExplain(""०३-April-२०१९ ०२:५३:१९ PM"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    numberingSystem: ""deva"",
  });
  expect(ex8.rawMatches).toBeInstanceOf(Array);
  expect(ex8.matches).toBeInstanceOf(Object);
  expect(keyCount(ex8.matches)).toBe(7);
  expect(ex8.result).toBeInstanceOf(Object);
  expect(keyCount(ex8.result)).toBe(6);

  const ex9 = DateTime.fromFormatExplain(""૦૩-એપ્રિલ-૨૦૧૯ ૦૨:૫૫:૨૧ PM"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    locale: ""gu"",
    numberingSystem: ""gujr"",
  });
  expect(ex9.rawMatches).toBeInstanceOf(Array);
  expect(ex9.matches).toBeInstanceOf(Object);
  expect(keyCount(ex9.matches)).toBe(7);
  expect(ex9.result).toBeInstanceOf(Object);
  expect(keyCount(ex9.result)).toBe(6);

  const ex10 = DateTime.fromFormatExplain(""០៣-April-២០១៩ ០៣:៤៩:២០ PM"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    numberingSystem: ""khmr"",
  });
  expect(ex10.rawMatches).toBeInstanceOf(Array);
  expect(ex10.matches).toBeInstanceOf(Object);
  expect(keyCount(ex10.matches)).toBe(7);
  expect(ex10.result).toBeInstanceOf(Object);
  expect(keyCount(ex10.result)).toBe(6);

  const ex11 = DateTime.fromFormatExplain(""໐໓-April-໒໐໑໙ ໐໓:໕໒:໑໑ PM"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    numberingSystem: ""laoo"",
  });
  expect(ex11.rawMatches).toBeInstanceOf(Array);
  expect(ex11.matches).toBeInstanceOf(Object);
  expect(keyCount(ex11.matches)).toBe(7);
  expect(ex11.result).toBeInstanceOf(Object);
  expect(keyCount(ex11.result)).toBe(6);

  const ex12 = DateTime.fromFormatExplain(""᥆᥉-April-᥈᥆᥇᥏ ᥆᥉:᥋᥉:᥇᥎ PM"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    numberingSystem: ""limb"",
  });
  expect(ex12.rawMatches).toBeInstanceOf(Array);
  expect(ex12.matches).toBeInstanceOf(Object);
  expect(keyCount(ex12.matches)).toBe(7);
  expect(ex12.result).toBeInstanceOf(Object);
  expect(keyCount(ex12.result)).toBe(6);

  const ex13 = DateTime.fromFormatExplain(""൦൩-ഏപ്രിൽ-൨൦൧൯ ൦൩:൫൪:൦൮ PM"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    locale: ""ml"",
    numberingSystem: ""mlym"",
  });
  expect(ex13.rawMatches).toBeInstanceOf(Array);
  expect(ex13.matches).toBeInstanceOf(Object);
  expect(keyCount(ex13.matches)).toBe(7);
  expect(ex13.result).toBeInstanceOf(Object);
  expect(keyCount(ex13.result)).toBe(6);

  const ex14 = DateTime.fromFormatExplain(""᠐᠓-April-᠒᠐᠑᠙ ᠐᠓:᠕᠖:᠑᠙ PM"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    numberingSystem: ""mong"",
  });
  expect(ex14.rawMatches).toBeInstanceOf(Array);
  expect(ex14.matches).toBeInstanceOf(Object);
  expect(keyCount(ex14.matches)).toBe(7);
  expect(ex14.result).toBeInstanceOf(Object);
  expect(keyCount(ex14.result)).toBe(6);

  const ex15 = DateTime.fromFormatExplain(""୦୩-April-୨୦୧୯ ୦୩:୫୮:୪୩ PM"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    numberingSystem: ""orya"",
  });
  expect(ex15.rawMatches).toBeInstanceOf(Array);
  expect(ex15.matches).toBeInstanceOf(Object);
  expect(keyCount(ex15.matches)).toBe(7);
  expect(ex15.result).toBeInstanceOf(Object);
  expect(keyCount(ex15.result)).toBe(6);

  const ex16 = DateTime.fromFormatExplain(
    cldr && cldr < 45 ? ""௦௩-ஏப்ரல்-௨௦௧௯ ௦௪:௦௦:௪௧ பிற்பகல்"" : ""௦௩-ஏப்ரல்-௨௦௧௯ ௦௪:௦௦:௪௧ PM"",
    ""dd-MMMM-yyyy hh:mm:ss a"",
    {
      locale: ""ta"",
      numberingSystem: ""tamldec"",
    }
  );
  expect(ex16.rawMatches).toBeInstanceOf(Array);
  expect(ex16.matches).toBeInstanceOf(Object);
  expect(keyCount(ex16.matches)).toBe(7);
  expect(ex16.result).toBeInstanceOf(Object);
  expect(keyCount(ex16.result)).toBe(6);

  const ex17 = DateTime.fromFormatExplain(
    ""౦౩-ఏప్రిల్-౨౦౧౯ ౦౪:౦౧:౩౩ PM"",
    ""dd-MMMM-yyyy hh:mm:ss a"",
    {
      locale: ""te"",
      numberingSystem: ""telu"",
    }
  );
  expect(ex17.rawMatches).toBeInstanceOf(Array);
  expect(ex17.matches).toBeInstanceOf(Object);
  expect(keyCount(ex17.matches)).toBe(7);
  expect(ex17.result).toBeInstanceOf(Object);
  expect(keyCount(ex17.result)).toBe(6);

  const ex18 = DateTime.fromFormatExplain(
    ""๐๓-เมษายน-๒๐๑๙ ๐๔:๐๒:๒๔ หลังเที่ยง"",
    ""dd-MMMM-yyyy hh:mm:ss a"",
    {
      locale: ""th"",
      numberingSystem: ""thai"",
    }
  );
  expect(ex18.rawMatches).toBeInstanceOf(Array);
  expect(ex18.matches).toBeInstanceOf(Object);
  expect(keyCount(ex18.matches)).toBe(7);
  expect(ex18.result).toBeInstanceOf(Object);
  expect(keyCount(ex18.result)).toBe(6);

  const ex19 = DateTime.fromFormatExplain(""༠༣-April-༢༠༡༩ ༠༤:༠༣:༢༥ PM"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    numberingSystem: ""tibt"",
  });
  expect(ex19.rawMatches).toBeInstanceOf(Array);
  expect(ex19.matches).toBeInstanceOf(Object);
  expect(keyCount(ex19.matches)).toBe(7);
  expect(ex19.result).toBeInstanceOf(Object);
  expect(keyCount(ex19.result)).toBe(6);

  const ex20 = DateTime.fromFormatExplain(""၀၃-April-၂၀၁၉ ၀၄:၁၀:၀၁ PM"", ""dd-MMMM-yyyy hh:mm:ss a"", {
    numberingSystem: ""mymr"",
  });
  expect(ex20.rawMatches).toBeInstanceOf(Array);
  expect(ex20.matches).toBeInstanceOf(Object);
  expect(keyCount(ex20.matches)).toBe(7);
  expect(ex20.result).toBeInstanceOf(Object);
  expect(keyCount(ex20.result)).toBe(6);
})",snuts
/test/datetime/toFormat.test.js,AnonymousTest,"{'startLine':561,'endLine':564}","test(""DateTime#toFormat('n')"", () => {
  expect(DateTime.fromISO(""2012-01-01"", { locale: ""de-DE"" }).toFormat(""n"")).toBe(""52"");
  expect(DateTime.fromISO(""2012-01-01"", { locale: ""en-US"" }).toFormat(""n"")).toBe(""1"");
})",snuts
/test/datetime/toFormat.test.js,AnonymousTest,"{'startLine':566,'endLine':569}","test(""DateTime#toFormat('nn')"", () => {
  expect(DateTime.fromISO(""2012-01-01"", { locale: ""de-DE"" }).toFormat(""nn"")).toBe(""52"");
  expect(DateTime.fromISO(""2012-01-01"", { locale: ""en-US"" }).toFormat(""nn"")).toBe(""01"");
})",snuts
/test/datetime/toFormat.test.js,AnonymousTest,"{'startLine':571,'endLine':574}","test(""DateTime#toFormat('ii')"", () => {
  expect(DateTime.fromISO(""2012-01-01"", { locale: ""de-DE"" }).toFormat(""ii"")).toBe(""11"");
  expect(DateTime.fromISO(""2012-01-01"", { locale: ""en-US"" }).toFormat(""ii"")).toBe(""12"");
})",snuts
/test/datetime/toFormat.test.js,AnonymousTest,"{'startLine':576,'endLine':579}","test(""DateTime#toFormat('iiii')"", () => {
  expect(DateTime.fromISO(""2012-01-01"", { locale: ""de-DE"" }).toFormat(""iiii"")).toBe(""2011"");
  expect(DateTime.fromISO(""2012-01-01"", { locale: ""en-US"" }).toFormat(""iiii"")).toBe(""2012"");
})",snuts
/test/datetime/toFormat.test.js,CommentsOnlyTest,"{'startLine':400,'endLine':406}","test(""DateTime#toFormat('ttt') returns a medium time representation"", () => {
  // these seem to fail on Travis
  // expect(dt.toFormat('ttt')).toBe('9:23:54 AM GMT');
  // expect(dt.set({ hour: 13 }).toFormat('ttt')).toBe('1:23:54 PM GMT');
  // expect(dt.reconfigure({ locale: 'fr' }).toFormat('ttt')).toBe('09:23:54 UTC');
  // expect(dt.set({ hour: 13 }).reconfigure({ locale: 'fr' }).toFormat('ttt')).toBe('13:23:54 UTC');
})",snuts
/test/datetime/toFormat.test.js,CommentsOnlyTest,"{'startLine':408,'endLine':414}","test(""DateTime#toFormat('TTT') returns a medium time representation"", () => {
  // these seem to fail on Travis
  // expect(dt.toFormat('TTT')).toBe('09:23:54 GMT');
  // expect(dt.set({ hour: 13 }).toFormat('TTT')).toBe('13:23:54 GMT');
  // expect(dt.reconfigure({locale: 'fr' }).toFormat('TTT')).toBe('09:23:54 UTC');
  // expect(dt.set({hour: 13 }).reconfigure({ locale: 'fr' }).toFormat('TTT')).toBe('13:23:54 UTC');
})",snuts
/test/datetime/toFormat.test.js,IdenticalTestDescription,"{'startLine':264,'endLine':270}","test(""DateTime#toFormat('yyyy') returns the padded full year"", () => {
  const bigDt = DateTime.fromObject({ year: 36000 });
  expect(bigDt.toFormat(""yyyy"")).toBe(""36000"");

  const lilDt = DateTime.fromObject({ year: 17 });
  expect(lilDt.toFormat(""yyyy"")).toBe(""0017"");
})",snuts
/test/datetime/set.test.js,IdenticalTestDescription,"{'startLine':138,'endLine':151}","test(""DateTime#set({ localWeekday }) handles crossing over into the previous year"", () => {
  const modified = DateTime.local(2022, 1, 1, 9, 23, 54, 123, { locale: ""en-US"" }).set({
    localWeekday: 2,
  });
  expect(modified.localWeekday).toBe(2);
  expect(modified.weekday).toBe(1);
  expect(modified.year).toBe(2021);
  expect(modified.month).toBe(12);
  expect(modified.day).toBe(27);
  expect(modified.hour).toBe(9);
  expect(modified.minute).toBe(23);
  expect(modified.second).toBe(54);
  expect(modified.millisecond).toBe(123);
})",snuts
/test/datetime/set.test.js,IdenticalTestDescription,"{'startLine':215,'endLine':235}","test(""DateTime#set({ localWeekNumber }) sets the date to the same weekday of the target weekNumber (custom weekSettings)"", () => {
  withDefaultWeekSettings(
    {
      firstDay: 7,
      weekend: [6, 7],
      minimalDays: 1,
    },
    () => {
      const modified = dtFactory().set({ localWeekNumber: 2 });
      expect(modified.weekday).toBe(2); // still tuesday
      expect(modified.localWeekNumber).toBe(2);
      expect(modified.year).toBe(1982);
      expect(modified.month).toBe(1);
      expect(modified.day).toBe(5);
      expect(modified.hour).toBe(9);
      expect(modified.minute).toBe(23);
      expect(modified.second).toBe(54);
      expect(modified.millisecond).toBe(123);
    }
  );
})",snuts
/test/datetime/relative.test.js,SubOptimalAssert,"{'startLine':246,'endLine':246}","test(""DateTime#toRelative returns null when used on an invalid date"", () => {
  expect(DateTime.invalid(""not valid"").toRelative()).toBe(null);
})",snuts
/test/datetime/relative.test.js,SubOptimalAssert,"{'startLine':287,'endLine':287}","test(""DateTime#toRelativeCalendar returns null when used on an invalid date"", () => {
  expect(DateTime.invalid(""not valid"").toRelativeCalendar()).toBe(null);
})",snuts
/test/datetime/relative.test.js,VerboseStatement,"{'startLine':11,'endLine':30}","test(""DateTime#toRelative works down through the units"", () => {
  const base = DateTime.fromObject({ year: 1983, month: 10, day: 14 });
  expect(base.plus({ minutes: 1 }).toRelative({ base })).toBe(""in 1 minute"");
  expect(base.plus({ minutes: 5 }).toRelative({ base })).toBe(""in 5 minutes"");
  expect(base.plus({ minutes: 65 }).toRelative({ base })).toBe(""in 1 hour"");
  expect(base.plus({ minutes: 165 }).toRelative({ base })).toBe(""in 2 hours"");
  expect(base.plus({ hours: 24 }).toRelative({ base })).toBe(""in 1 day"");
  expect(base.plus({ days: 3 }).toRelative({ base })).toBe(""in 3 days"");
  expect(base.plus({ months: 5 }).toRelative({ base })).toBe(""in 5 months"");
  expect(base.plus({ months: 15 }).toRelative({ base })).toBe(""in 1 year"");

  expect(base.minus({ minutes: 1 }).toRelative({ base })).toBe(""1 minute ago"");
  expect(base.minus({ minutes: 5 }).toRelative({ base })).toBe(""5 minutes ago"");
  expect(base.minus({ minutes: 65 }).toRelative({ base })).toBe(""1 hour ago"");
  expect(base.minus({ minutes: 165 }).toRelative({ base })).toBe(""2 hours ago"");
  expect(base.minus({ hours: 24 }).toRelative({ base })).toBe(""1 day ago"");
  expect(base.minus({ days: 3 }).toRelative({ base })).toBe(""3 days ago"");
  expect(base.minus({ months: 5 }).toRelative({ base })).toBe(""5 months ago"");
  expect(base.minus({ months: 15 }).toRelative({ base })).toBe(""1 year ago"");
})",snuts
/test/datetime/relative.test.js,VerboseStatement,"{'startLine':46,'endLine':112}","test(""DateTime#toRelative takes a rounding argument"", () => {
  const base = DateTime.fromObject({ year: 1983, month: 10, day: 14 });
  expect(base.plus({ hours: 2, milliseconds: -1 }).toRelative({ base, rounding: ""expand"" })).toBe(
    ""in 2 hours""
  );
  expect(base.plus({ hours: 2, milliseconds: 1 }).toRelative({ base, rounding: ""expand"" })).toBe(
    ""in 3 hours""
  );
  expect(base.minus({ hours: 2, milliseconds: -1 }).toRelative({ base, rounding: ""expand"" })).toBe(
    ""2 hours ago""
  );
  expect(base.minus({ hours: 2, milliseconds: 1 }).toRelative({ base, rounding: ""expand"" })).toBe(
    ""3 hours ago""
  );

  expect(base.plus({ hours: 2, milliseconds: -1 }).toRelative({ base, rounding: ""trunc"" })).toBe(
    ""in 1 hour""
  );
  expect(base.plus({ hours: 2, milliseconds: 1 }).toRelative({ base, rounding: ""trunc"" })).toBe(
    ""in 2 hours""
  );
  expect(base.minus({ hours: 2, milliseconds: -1 }).toRelative({ base, rounding: ""trunc"" })).toBe(
    ""1 hour ago""
  );
  expect(base.minus({ hours: 2, milliseconds: 1 }).toRelative({ base, rounding: ""trunc"" })).toBe(
    ""2 hours ago""
  );

  expect(base.plus({ hours: 2, milliseconds: -1 }).toRelative({ base, rounding: ""round"" })).toBe(
    ""in 2 hours""
  );
  expect(base.plus({ hours: 2, milliseconds: 1 }).toRelative({ base, rounding: ""round"" })).toBe(
    ""in 2 hours""
  );
  expect(base.minus({ hours: 2, milliseconds: -1 }).toRelative({ base, rounding: ""round"" })).toBe(
    ""2 hours ago""
  );
  expect(base.minus({ hours: 2, milliseconds: 1 }).toRelative({ base, rounding: ""round"" })).toBe(
    ""2 hours ago""
  );

  expect(base.plus({ hours: 2, milliseconds: -1 }).toRelative({ base, rounding: ""floor"" })).toBe(
    ""in 1 hour""
  );
  expect(base.plus({ hours: 2, milliseconds: 1 }).toRelative({ base, rounding: ""floor"" })).toBe(
    ""in 2 hours""
  );
  expect(base.minus({ hours: 2, milliseconds: -1 }).toRelative({ base, rounding: ""floor"" })).toBe(
    ""2 hours ago""
  );
  expect(base.minus({ hours: 2, milliseconds: 1 }).toRelative({ base, rounding: ""floor"" })).toBe(
    ""3 hours ago""
  );

  expect(base.plus({ hours: 2, milliseconds: -1 }).toRelative({ base, rounding: ""ceil"" })).toBe(
    ""in 2 hours""
  );
  expect(base.plus({ hours: 2, milliseconds: 1 }).toRelative({ base, rounding: ""ceil"" })).toBe(
    ""in 3 hours""
  );
  expect(base.minus({ hours: 2, milliseconds: -1 }).toRelative({ base, rounding: ""ceil"" })).toBe(
    ""1 hour ago""
  );
  expect(base.minus({ hours: 2, milliseconds: 1 }).toRelative({ base, rounding: ""ceil"" })).toBe(
    ""2 hours ago""
  );
})",snuts
/test/datetime/relative.test.js,VerboseStatement,"{'startLine':114,'endLine':182}","test(""DateTime#toRelative takes a round and a rounding argument"", () => {
  const base = DateTime.fromObject({ year: 1983, month: 10, day: 14 });
  expect(
    base.plus({ hours: 2, milliseconds: -1 }).toRelative({ base, round: false, rounding: ""expand"" })
  ).toBe(""in 2 hours"");
  expect(
    base.plus({ hours: 2, milliseconds: 1 }).toRelative({ base, round: false, rounding: ""expand"" })
  ).toBe(""in 2.01 hours"");
  expect(
    base
      .minus({ hours: 2, milliseconds: -1 })
      .toRelative({ base, round: false, rounding: ""expand"" })
  ).toBe(""2 hours ago"");
  expect(
    base.minus({ hours: 2, milliseconds: 1 }).toRelative({ base, round: false, rounding: ""expand"" })
  ).toBe(""2.01 hours ago"");

  expect(
    base.plus({ hours: 2, milliseconds: -1 }).toRelative({ base, round: false, rounding: ""trunc"" })
  ).toBe(""in 1.99 hours"");
  expect(
    base.plus({ hours: 2, milliseconds: 1 }).toRelative({ base, round: false, rounding: ""trunc"" })
  ).toBe(""in 2 hours"");
  expect(
    base.minus({ hours: 2, milliseconds: -1 }).toRelative({ base, round: false, rounding: ""trunc"" })
  ).toBe(""1.99 hours ago"");
  expect(
    base.minus({ hours: 2, milliseconds: 1 }).toRelative({ base, round: false, rounding: ""trunc"" })
  ).toBe(""2 hours ago"");

  expect(
    base.plus({ hours: 2, milliseconds: -1 }).toRelative({ base, round: false, rounding: ""round"" })
  ).toBe(""in 2 hours"");
  expect(
    base.plus({ hours: 2, milliseconds: 1 }).toRelative({ base, round: false, rounding: ""round"" })
  ).toBe(""in 2 hours"");
  expect(
    base.minus({ hours: 2, milliseconds: -1 }).toRelative({ base, round: false, rounding: ""round"" })
  ).toBe(""2 hours ago"");
  expect(
    base.minus({ hours: 2, milliseconds: 1 }).toRelative({ base, round: false, rounding: ""round"" })
  ).toBe(""2 hours ago"");

  expect(
    base.plus({ hours: 2, milliseconds: -1 }).toRelative({ base, round: false, rounding: ""floor"" })
  ).toBe(""in 1.99 hours"");
  expect(
    base.plus({ hours: 2, milliseconds: 1 }).toRelative({ base, round: false, rounding: ""floor"" })
  ).toBe(""in 2 hours"");
  expect(
    base.minus({ hours: 2, milliseconds: -1 }).toRelative({ base, round: false, rounding: ""floor"" })
  ).toBe(""2 hours ago"");
  expect(
    base.minus({ hours: 2, milliseconds: 1 }).toRelative({ base, round: false, rounding: ""floor"" })
  ).toBe(""2.01 hours ago"");

  expect(
    base.plus({ hours: 2, milliseconds: -1 }).toRelative({ base, round: false, rounding: ""ceil"" })
  ).toBe(""in 2 hours"");
  expect(
    base.plus({ hours: 2, milliseconds: 1 }).toRelative({ base, round: false, rounding: ""ceil"" })
  ).toBe(""in 2.01 hours"");
  expect(
    base.minus({ hours: 2, milliseconds: -1 }).toRelative({ base, round: false, rounding: ""ceil"" })
  ).toBe(""1.99 hours ago"");
  expect(
    base.minus({ hours: 2, milliseconds: 1 }).toRelative({ base, round: false, rounding: ""ceil"" })
  ).toBe(""2 hours ago"");
})",snuts
/test/datetime/relative.test.js,VerboseStatement,"{'startLine':290,'endLine':309}","test(""DateTime#toRelativeCalendar works down through the units"", () => {
  const base = DateTime.fromObject({ year: 1983, month: 10, day: 14, hour: 12 });
  expect(base.plus({ minutes: 1 }).toRelativeCalendar({ base })).toBe(""today"");
  expect(base.plus({ minutes: 5 }).toRelativeCalendar({ base })).toBe(""today"");
  expect(base.plus({ minutes: 65 }).toRelativeCalendar({ base })).toBe(""today"");
  expect(base.plus({ hours: 13 }).toRelativeCalendar({ base })).toBe(""tomorrow"");
  expect(base.plus({ days: 3 }).toRelativeCalendar({ base })).toBe(""in 3 days"");
  expect(base.plus({ months: 1 }).toRelativeCalendar({ base })).toBe(""next month"");
  expect(base.plus({ months: 5 }).toRelativeCalendar({ base })).toBe(""next year"");
  expect(base.plus({ months: 15 }).toRelativeCalendar({ base })).toBe(""in 2 years"");

  expect(base.minus({ minutes: 1 }).toRelativeCalendar({ base })).toBe(""today"");
  expect(base.minus({ minutes: 5 }).toRelativeCalendar({ base })).toBe(""today"");
  expect(base.minus({ minutes: 65 }).toRelativeCalendar({ base })).toBe(""today"");
  expect(base.minus({ hours: 24 }).toRelativeCalendar({ base })).toBe(""yesterday"");
  expect(base.minus({ days: 3 }).toRelativeCalendar({ base })).toBe(""3 days ago"");
  expect(base.minus({ months: 1 }).toRelativeCalendar({ base })).toBe(""last month"");
  expect(base.minus({ months: 5 }).toRelativeCalendar({ base })).toBe(""5 months ago"");
  expect(base.minus({ months: 15 }).toRelativeCalendar({ base })).toBe(""last year"");
})",snuts
/test/datetime/regexParse.test.js,IdenticalTestDescription,"{'startLine':531,'endLine':542}","test(""DateTime.fromISO() accepts hour:minute"", () => {
  const { year, month, day } = DateTime.now();
  isSame(""09:24"", {
    year,
    month,
    day,
    hour: 9,
    minute: 24,
    second: 0,
    millisecond: 0,
  });
})",snuts
/test/datetime/regexParse.test.js,ConditionalTestLogic,"{'startLine':764,'endLine':769}","test(""DateTime.fromRFC2822 parses a range of dates"", () => {
  const testCases = {
    ""Sun, 12 Apr 2015 05:06:07 GMT"": [2015, 4, 12, 5, 6, 7],
    ""Tue, 01 Nov 2016 01:23:45 +0000"": [2016, 11, 1, 1, 23, 45],
    ""Tue, 01 Nov 16 04:23:45 Z"": [2016, 11, 1, 4, 23, 45],
    ""01 Nov 2016 05:23:45 z"": [2016, 11, 1, 5, 23, 45],
    ""Mon, 02 Jan 2017 06:00:00 -0800"": [2017, 1, 2, 6 + 8, 0, 0],
    ""Mon, 02 Jan 2017 06:00:00 +0800"": [2017, 1, 1, 22, 0, 0],
    ""Mon, 02 Jan 2017 06:00:00 +0330"": [2017, 1, 2, 2, 30, 0],
    ""Mon, 02 Jan 2017 06:00:00 -0330"": [2017, 1, 2, 9, 30, 0],
    ""Mon, 02 Jan 2017 06:00:00 PST"": [2017, 1, 2, 6 + 8, 0, 0],
    ""Mon, 02 Jan 2017 06:00:00 PDT"": [2017, 1, 2, 6 + 7, 0, 0],
  };

  for (const testString in testCases) {
    if (Object.prototype.hasOwnProperty.call(testCases, testString)) {
      const expected = testCases[testString],
        r = DateTime.fromRFC2822(testString).toUTC(),
        actual = [r.year, r.month, r.day, r.hour, r.minute, r.second];
      expect(expected).toEqual(actual);
    }
  }
})",snuts
/test/datetime/regexParse.test.js,VerboseStatement,"{'startLine':49,'endLine':101}","test(""DateTime.fromISO() optionally adopts the UTC offset provided"", () => {
  let dt = DateTime.fromISO(""2016-05-25T09:08:34.123+06:00"", { setZone: true });
  expect(dt.zone.name).toBe(""UTC+6"");
  expect(dt.toObject()).toEqual({
    year: 2016,
    month: 5,
    day: 25,
    hour: 9,
    minute: 8,
    second: 34,
    millisecond: 123,
  });

  dt = DateTime.fromISO(""1983-10-14T13:30Z"", { setZone: true });
  expect(dt.zone.name).toBe(""UTC"");
  expect(dt.offset).toBe(0);
  expect(dt.toObject()).toEqual({
    year: 1983,
    month: 10,
    day: 14,
    hour: 13,
    minute: 30,
    second: 0,
    millisecond: 0,
  });

  // #1610 - lowercase z
  dt = DateTime.fromISO(""1983-10-14T13:30z"", { setZone: true });
  expect(dt.zone.name).toBe(""UTC"");
  expect(dt.offset).toBe(0);
  expect(dt.toObject()).toEqual({
    year: 1983,
    month: 10,
    day: 14,
    hour: 13,
    minute: 30,
    second: 0,
    millisecond: 0,
  });

  // #580
  dt = DateTime.fromISO(""2016-05-25T09:08:34.123-00:30"", { setZone: true });
  expect(dt.zone.name).toBe(""UTC-0:30"");
  expect(dt.toObject()).toEqual({
    year: 2016,
    month: 5,
    day: 25,
    hour: 9,
    minute: 8,
    second: 34,
    millisecond: 123,
  });
})",snuts
/test/datetime/regexParse.test.js,VerboseStatement,"{'startLine':560,'endLine':603}","test(""DateTime.fromISO() accepts extended zones"", () => {
  let dt = DateTime.fromISO(""2016-05-14T10:23:54[Europe/Paris]"", {
    setZone: true,
  });
  expect(dt.isValid).toBe(true);
  expect(dt.zoneName).toBe(""Europe/Paris"");
  expect(dt.toObject()).toEqual({
    year: 2016,
    month: 5,
    day: 14,
    hour: 10,
    minute: 23,
    second: 54,
    millisecond: 0,
  });

  dt = DateTime.fromISO(""2016-05-14T10:23:54[UTC]"", { setZone: true });
  expect(dt.isValid).toBe(true);
  expect(dt.zoneName).toBe(""UTC"");
  expect(dt.offset).toBe(0);
  expect(dt.toObject()).toEqual({
    year: 2016,
    month: 5,
    day: 14,
    hour: 10,
    minute: 23,
    second: 54,
    millisecond: 0,
  });

  dt = DateTime.fromISO(""2016-05-14T10:23:54[Etc/UTC]"", { setZone: true });
  expect(dt.isValid).toBe(true);
  expect(dt.zoneName).toBe(""Etc/UTC"");
  expect(dt.offset).toBe(0);
  expect(dt.toObject()).toEqual({
    year: 2016,
    month: 5,
    day: 14,
    hour: 10,
    minute: 23,
    second: 54,
    millisecond: 0,
  });
})",snuts
/test/datetime/regexParse.test.js,VerboseStatement,"{'startLine':710,'endLine':729}","test(""DateTime.fromISO() rejects poop"", () => {
  const rejects = (s) => expect(DateTime.fromISO(s).isValid).toBeFalsy();

  rejects(null);
  rejects("""");
  rejects("" "");
  rejects(""2016-1"");
  rejects(""2016-1-15"");
  rejects(""2016-01-5"");
  rejects(""2016-01-00"");
  rejects(""2016-00-01"");
  rejects(""2016-05-25 08:34:34"");
  rejects(""2016-05-25Q08:34:34"");
  rejects(""2016-05-25T8:04:34"");
  rejects(""2016-05-25T08:4:34"");
  rejects(""2016-05-25T08:04:4"");
  rejects(""2016-05-25T:03:4"");
  rejects(""2016-05-25T08::4"");
  rejects(""2016-W32-02"");
})",snuts
/test/datetime/math.test.js,IdenticalTestDescription,"{'startLine':223,'endLine':228}","test(""DateTime#plus renders invalid when out of max. datetime range using IANAZone"", () => {
  const d = DateTime.utc(1970, 1, 1, 0, 0, 0, 0)
    .setZone(""America/Los_Angeles"")
    .minus({ second: 1e8 * 24 * 60 * 60 + 1 });
  expect(d.isValid).toBe(false);
})",snuts
/test/datetime/invalid.test.js,AnonymousTest,"{'startLine':74,'endLine':88}","test(""throwOnInvalid throws"", () => {
  try {
    Settings.throwOnInvalid = true;
    expect(() =>
      DateTime.fromObject({
        weekday: 3,
        year: 1982,
        month: 5,
        day: 25,
      })
    ).toThrow();
  } finally {
    Settings.throwOnInvalid = false;
  }
})",snuts
/test/datetime/getters.test.js,IdenticalTestDescription,"{'startLine':119,'endLine':121}","test(""DateTime#monthShort returns the short human readable month"", () => {
  expect(dateTime.minus({ months: 1 }).setLocale(""en-US"").monthShort).toBe(""Apr"");
})",snuts
/test/datetime/getters.test.js,IdenticalTestDescription,"{'startLine':123,'endLine':125}","test(""DateTime#monthLong returns the human readable month"", () => {
  expect(dateTime.minus({ months: 1 }).setLocale(""en-US"").monthLong).toBe(""April"");
})",snuts
/test/datetime/getters.test.js,SubOptimalAssert,"{'startLine':101,'endLine':101}","test(""DateTime#weekdayShort returns null for invalid DateTimes"", () => {
  expect(inv.weekdayShort).toBe(null);
})",snuts
/test/datetime/getters.test.js,SubOptimalAssert,"{'startLine':105,'endLine':105}","test(""DateTime#weekdayLong returns null for invalid DateTimes"", () => {
  expect(inv.weekdayLong).toBe(null);
})",snuts
/test/datetime/getters.test.js,SubOptimalAssert,"{'startLine':136,'endLine':136}","test(""DateTime#monthLong returns null for invalid DateTimes"", () => {
  expect(inv.monthLong).toBe(null);
})",snuts
/test/datetime/getters.test.js,SubOptimalAssert,"{'startLine':140,'endLine':140}","test(""DateTime#monthShort returns null for invalid DateTimes"", () => {
  expect(inv.monthShort).toBe(null);
})",snuts
/test/datetime/format.test.js,SubOptimalAssert,"{'startLine':109,'endLine':109}","test(""DateTime#toISO() returns null for invalid DateTimes"", () => {
  expect(invalid.toISO()).toBe(null);
})",snuts
/test/datetime/format.test.js,SubOptimalAssert,"{'startLine':194,'endLine':194}","test(""DateTime#toISODate() returns null for invalid DateTimes"", () => {
  expect(invalid.toISODate()).toBe(null);
})",snuts
/test/datetime/format.test.js,SubOptimalAssert,"{'startLine':239,'endLine':239}","test(""DateTime#toISOWeekDate() returns null for invalid DateTimes"", () => {
  expect(invalid.toISOWeekDate()).toBe(null);
})",snuts
/test/datetime/format.test.js,SubOptimalAssert,"{'startLine':295,'endLine':295}","test(""DateTime#toISOTime() returns null for invalid DateTimes"", () => {
  expect(invalid.toISOTime()).toBe(null);
})",snuts
/test/datetime/format.test.js,SubOptimalAssert,"{'startLine':347,'endLine':347}","test(""DateTime#toRFC2822() returns null for invalid DateTimes"", () => {
  expect(invalid.toRFC2822()).toBe(null);
})",snuts
/test/datetime/format.test.js,SubOptimalAssert,"{'startLine':361,'endLine':361}","test(""DateTime#toHTTP() returns null for invalid DateTimes"", () => {
  expect(invalid.toHTTP()).toBe(null);
})",snuts
/test/datetime/format.test.js,SubOptimalAssert,"{'startLine':374,'endLine':374}","test(""DateTime#toSQLDate() returns null for invalid DateTimes"", () => {
  expect(invalid.toSQLDate()).toBe(null);
})",snuts
/test/datetime/format.test.js,SubOptimalAssert,"{'startLine':405,'endLine':405}","test(""DateTime#toSQLTime() returns null for invalid DateTimes"", () => {
  expect(invalid.toSQLTime()).toBe(null);
})",snuts
/test/datetime/format.test.js,SubOptimalAssert,"{'startLine':438,'endLine':438}","test(""DateTime#toSQL() returns null for invalid DateTimes"", () => {
  expect(invalid.toSQL()).toBe(null);
})",snuts
/test/datetime/format.test.js,SubOptimalAssert,"{'startLine':476,'endLine':476}","test(""DateTime#toLocaleString accepts options to the formatter"", () => {
  expect(dt.toLocaleString({ weekday: ""short"" }).indexOf(""Tue"") >= 0).toBeTruthy();
})",snuts
/test/datetime/equality.test.js,AnonymousTest,"{'startLine':5,'endLine':8}","test(""equals self"", () => {
  const l = DateTime.now();
  expect(l.equals(l)).toBe(true);
})",snuts
/test/datetime/create.test.js,SubOptimalAssert,"{'startLine':21,'endLine':21}","test(""DateTime.now has today's date"", () => {
  const date = new Date(),
    now = DateTime.now();
  expect(now.toJSDate().getDate()).toBe(date.getDate());
  // The two instants should be a few milliseconds apart
  expect(Math.abs(now.valueOf() - date.valueOf()) < 1000).toBe(true);
})",snuts
/test/datetime/create.test.js,SubOptimalAssert,"{'startLine':48,'endLine':48}","test(""DateTime.local() has today's date"", () => {
  const date = new Date(),
    now = DateTime.local();
  expect(now.toJSDate().getDate()).toBe(date.getDate());
  // The two instants should be a few milliseconds apart
  expect(Math.abs(now.valueOf() - date.valueOf()) < 1000).toBe(true);
})",snuts
/test/datetime/create.test.js,VerboseStatement,"{'startLine':474,'endLine':503}","test(""DateTime.fromObject() accepts a Zone as the zone option"", () => {
  const daylight = DateTime.fromObject(
    { ...baseObject, month: 5 },
    { zone: ""America/Los_Angeles"" }
  );
  const standard = DateTime.fromObject(
    { ...baseObject, month: 12 },
    { zone: ""America/Los_Angeles"" }
  );

  expect(daylight.isOffsetFixed).toBe(false);
  expect(daylight.offset).toBe(-7 * 60);
  expect(daylight.year).toBe(1982);
  expect(daylight.month).toBe(5);
  expect(daylight.day).toBe(25);
  expect(daylight.hour).toBe(9);
  expect(daylight.minute).toBe(23);
  expect(daylight.second).toBe(54);
  expect(daylight.millisecond).toBe(123);

  expect(standard.isOffsetFixed).toBe(false);
  expect(standard.offset).toBe(-8 * 60);
  expect(standard.year).toBe(1982);
  expect(standard.month).toBe(12);
  expect(standard.day).toBe(25);
  expect(standard.hour).toBe(9);
  expect(standard.minute).toBe(23);
  expect(standard.second).toBe(54);
  expect(standard.millisecond).toBe(123);
})",snuts
/test/datetime/create.test.js,VerboseStatement,"{'startLine':579,'endLine':595}","test(""DateTime.fromObject() w/weekYears handles skew with Gregorian years"", () => {
  let dt = DateTime.fromObject({ weekYear: 2015, weekNumber: 1, weekday: 3 });
  expect(dt.weekYear).toBe(2015);
  expect(dt.weekNumber).toBe(1);
  expect(dt.weekday).toBe(3);
  expect(dt.year).toBe(2014);
  expect(dt.month).toBe(12);
  expect(dt.day).toBe(31);

  dt = DateTime.fromObject({ weekYear: 2009, weekNumber: 53, weekday: 5 });
  expect(dt.weekYear).toBe(2009);
  expect(dt.weekNumber).toBe(53);
  expect(dt.weekday).toBe(5);
  expect(dt.year).toBe(2010);
  expect(dt.month).toBe(1);
  expect(dt.day).toBe(1);
})",snuts
/test/datetime/create.test.js,VerboseStatement,"{'startLine':690,'endLine':712}","test(""DateTime.fromObject() w/localWeekYears handles skew with Gregorian years"", () => {
  let dt = DateTime.fromObject(
    { localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 },
    { locale: ""en-US"" }
  );
  expect(dt.localWeekYear).toBe(2022);
  expect(dt.localWeekNumber).toBe(1);
  expect(dt.localWeekday).toBe(1);
  expect(dt.year).toBe(supportsMinDaysInFirstWeek() ? 2021 : 2022);
  expect(dt.month).toBe(supportsMinDaysInFirstWeek() ? 12 : 1);
  expect(dt.day).toBe(supportsMinDaysInFirstWeek() ? 26 : 2);

  dt = DateTime.fromObject(
    { localWeekYear: 2009, localWeekNumber: 53, localWeekday: 5 },
    { locale: ""de-DE"" }
  );
  expect(dt.localWeekYear).toBe(2009);
  expect(dt.localWeekNumber).toBe(53);
  expect(dt.localWeekday).toBe(5);
  expect(dt.year).toBe(2010);
  expect(dt.month).toBe(1);
  expect(dt.day).toBe(1);
})",snuts
/test/duration/create.test.js,Duplicate Assert,"{'line': 116, 'column': 2, 'index': 3420}","it(""Duration.fromDurationLike returns a Duration from millis"", () => {
  const dur = Duration.fromDurationLike(1000);
  expect(dur).toBeInstanceOf(Duration);
  expect(dur).toMatchInlineSnapshot(`""PT1S""`);
})",steel
/test/duration/create.test.js,Duplicate Assert,"{'line': 117, 'column': 2, 'index': 3460}","it(""Duration.fromDurationLike returns a Duration from millis"", () => {
  const dur = Duration.fromDurationLike(1000);
  expect(dur).toBeInstanceOf(Duration);
  expect(dur).toMatchInlineSnapshot(`""PT1S""`);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 18, 'column': 25, 'index': 339}","test(""Duration.fromObject sets all the values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4,
    minutes: 5,
    seconds: 6,
    milliseconds: 7,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 19, 'column': 26, 'index': 369}","test(""Duration.fromObject sets all the values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4,
    minutes: 5,
    seconds: 6,
    milliseconds: 7,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 20, 'column': 24, 'index': 397}","test(""Duration.fromObject sets all the values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4,
    minutes: 5,
    seconds: 6,
    milliseconds: 7,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 21, 'column': 25, 'index': 426}","test(""Duration.fromObject sets all the values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4,
    minutes: 5,
    seconds: 6,
    milliseconds: 7,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 22, 'column': 27, 'index': 457}","test(""Duration.fromObject sets all the values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4,
    minutes: 5,
    seconds: 6,
    milliseconds: 7,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 23, 'column': 27, 'index': 488}","test(""Duration.fromObject sets all the values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4,
    minutes: 5,
    seconds: 6,
    milliseconds: 7,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 24, 'column': 32, 'index': 524}","test(""Duration.fromObject sets all the values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4,
    minutes: 5,
    seconds: 6,
    milliseconds: 7,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 34, 'column': 25, 'index': 725}","test(""Duration.fromObject sets all the fractional values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4.5,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4.5);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 35, 'column': 26, 'index': 755}","test(""Duration.fromObject sets all the fractional values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4.5,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4.5);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 36, 'column': 24, 'index': 783}","test(""Duration.fromObject sets all the fractional values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4.5,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4.5);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 37, 'column': 25, 'index': 812}","test(""Duration.fromObject sets all the fractional values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4.5,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4.5);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 38, 'column': 27, 'index': 845}","test(""Duration.fromObject sets all the fractional values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4.5,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4.5);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 39, 'column': 27, 'index': 876}","test(""Duration.fromObject sets all the fractional values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4.5,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4.5);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 40, 'column': 32, 'index': 912}","test(""Duration.fromObject sets all the fractional values"", () => {
  const dur = Duration.fromObject({
    years: 1,
    months: 2,
    days: 3,
    hours: 4.5,
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4.5);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 53, 'column': 25, 'index': 1209}","test(""Duration.fromObject sets all the values from the object having string type values"", () => {
  const dur = Duration.fromObject({
    years: ""1"",
    months: ""2"",
    days: ""3"",
    hours: ""4"",
    minutes: ""5"",
    seconds: ""6"",
    milliseconds: ""7"",
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 54, 'column': 26, 'index': 1239}","test(""Duration.fromObject sets all the values from the object having string type values"", () => {
  const dur = Duration.fromObject({
    years: ""1"",
    months: ""2"",
    days: ""3"",
    hours: ""4"",
    minutes: ""5"",
    seconds: ""6"",
    milliseconds: ""7"",
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 55, 'column': 24, 'index': 1267}","test(""Duration.fromObject sets all the values from the object having string type values"", () => {
  const dur = Duration.fromObject({
    years: ""1"",
    months: ""2"",
    days: ""3"",
    hours: ""4"",
    minutes: ""5"",
    seconds: ""6"",
    milliseconds: ""7"",
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 56, 'column': 25, 'index': 1296}","test(""Duration.fromObject sets all the values from the object having string type values"", () => {
  const dur = Duration.fromObject({
    years: ""1"",
    months: ""2"",
    days: ""3"",
    hours: ""4"",
    minutes: ""5"",
    seconds: ""6"",
    milliseconds: ""7"",
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 57, 'column': 27, 'index': 1327}","test(""Duration.fromObject sets all the values from the object having string type values"", () => {
  const dur = Duration.fromObject({
    years: ""1"",
    months: ""2"",
    days: ""3"",
    hours: ""4"",
    minutes: ""5"",
    seconds: ""6"",
    milliseconds: ""7"",
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 58, 'column': 27, 'index': 1358}","test(""Duration.fromObject sets all the values from the object having string type values"", () => {
  const dur = Duration.fromObject({
    years: ""1"",
    months: ""2"",
    days: ""3"",
    hours: ""4"",
    minutes: ""5"",
    seconds: ""6"",
    milliseconds: ""7"",
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 59, 'column': 32, 'index': 1394}","test(""Duration.fromObject sets all the values from the object having string type values"", () => {
  const dur = Duration.fromObject({
    years: ""1"",
    months: ""2"",
    days: ""3"",
    hours: ""4"",
    minutes: ""5"",
    seconds: ""6"",
    milliseconds: ""7"",
  });
  expect(dur.years).toBe(1);
  expect(dur.months).toBe(2);
  expect(dur.days).toBe(3);
  expect(dur.hours).toBe(4);
  expect(dur.minutes).toBe(5);
  expect(dur.seconds).toBe(6);
  expect(dur.milliseconds).toBe(7);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 75, 'column': 25, 'index': 1974}","test(""Duration.fromObject({}) constructs zero duration"", () => {
  const dur = Duration.fromObject({});
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 76, 'column': 26, 'index': 2004}","test(""Duration.fromObject({}) constructs zero duration"", () => {
  const dur = Duration.fromObject({});
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 77, 'column': 24, 'index': 2032}","test(""Duration.fromObject({}) constructs zero duration"", () => {
  const dur = Duration.fromObject({});
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 78, 'column': 25, 'index': 2061}","test(""Duration.fromObject({}) constructs zero duration"", () => {
  const dur = Duration.fromObject({});
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 79, 'column': 27, 'index': 2092}","test(""Duration.fromObject({}) constructs zero duration"", () => {
  const dur = Duration.fromObject({});
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 80, 'column': 27, 'index': 2123}","test(""Duration.fromObject({}) constructs zero duration"", () => {
  const dur = Duration.fromObject({});
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 81, 'column': 32, 'index': 2159}","test(""Duration.fromObject({}) constructs zero duration"", () => {
  const dur = Duration.fromObject({});
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 100, 'column': 25, 'index': 3029}","test(""Duration.fromObject is valid if providing options only"", () => {
  const dur = Duration.fromObject({}, { conversionAccuracy: ""longterm"" });
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
  expect(dur.isValid).toBe(true);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 101, 'column': 26, 'index': 3059}","test(""Duration.fromObject is valid if providing options only"", () => {
  const dur = Duration.fromObject({}, { conversionAccuracy: ""longterm"" });
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
  expect(dur.isValid).toBe(true);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 102, 'column': 24, 'index': 3087}","test(""Duration.fromObject is valid if providing options only"", () => {
  const dur = Duration.fromObject({}, { conversionAccuracy: ""longterm"" });
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
  expect(dur.isValid).toBe(true);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 103, 'column': 25, 'index': 3116}","test(""Duration.fromObject is valid if providing options only"", () => {
  const dur = Duration.fromObject({}, { conversionAccuracy: ""longterm"" });
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
  expect(dur.isValid).toBe(true);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 104, 'column': 27, 'index': 3147}","test(""Duration.fromObject is valid if providing options only"", () => {
  const dur = Duration.fromObject({}, { conversionAccuracy: ""longterm"" });
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
  expect(dur.isValid).toBe(true);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 105, 'column': 27, 'index': 3178}","test(""Duration.fromObject is valid if providing options only"", () => {
  const dur = Duration.fromObject({}, { conversionAccuracy: ""longterm"" });
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
  expect(dur.isValid).toBe(true);
})",steel
/test/duration/create.test.js,Magic Number,"{'line': 106, 'column': 32, 'index': 3214}","test(""Duration.fromObject is valid if providing options only"", () => {
  const dur = Duration.fromObject({}, { conversionAccuracy: ""longterm"" });
  expect(dur.years).toBe(0);
  expect(dur.months).toBe(0);
  expect(dur.days).toBe(0);
  expect(dur.hours).toBe(0);
  expect(dur.minutes).toBe(0);
  expect(dur.seconds).toBe(0);
  expect(dur.milliseconds).toBe(0);
  expect(dur.isValid).toBe(true);
})",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 99, 'column': 36, 'index': 3905}","test(""Jan  1 2012 should be week 52, year 2011"", () => {
    const dt = DateTime.fromISO(""2012-01-01"", { locale: ""de-DE"" });
    expect(dt.localWeekNumber).toBe(52);
    expect(dt.localWeekYear).toBe(2011);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 100, 'column': 34, 'index': 3944}","test(""Jan  1 2012 should be week 52, year 2011"", () => {
    const dt = DateTime.fromISO(""2012-01-01"", { locale: ""de-DE"" });
    expect(dt.localWeekNumber).toBe(52);
    expect(dt.localWeekYear).toBe(2011);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 104, 'column': 36, 'index': 4119}","test(""Jan  2 2012 should be week 1, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-02"", { locale: ""de-DE"" });
    expect(dt.localWeekNumber).toBe(1);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 105, 'column': 34, 'index': 4157}","test(""Jan  2 2012 should be week 1, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-02"", { locale: ""de-DE"" });
    expect(dt.localWeekNumber).toBe(1);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 109, 'column': 36, 'index': 4332}","test(""Jan  8 2012 should be week 1, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-08"", { locale: ""de-DE"" });
    expect(dt.localWeekNumber).toBe(1);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 110, 'column': 34, 'index': 4370}","test(""Jan  8 2012 should be week 1, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-08"", { locale: ""de-DE"" });
    expect(dt.localWeekNumber).toBe(1);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 114, 'column': 36, 'index': 4545}","test(""Jan  9 2012 should be week 2, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-09"", { locale: ""de-DE"" });
    expect(dt.localWeekNumber).toBe(2);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 115, 'column': 34, 'index': 4583}","test(""Jan  9 2012 should be week 2, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-09"", { locale: ""de-DE"" });
    expect(dt.localWeekNumber).toBe(2);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 119, 'column': 36, 'index': 4759}","test(""Jan  15 2012 should be week 2, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-15"", { locale: ""de-DE"" });
    expect(dt.localWeekNumber).toBe(2);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 120, 'column': 34, 'index': 4797}","test(""Jan  15 2012 should be week 2, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-15"", { locale: ""de-DE"" });
    expect(dt.localWeekNumber).toBe(2);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 127, 'column': 36, 'index': 5029}","test(""Jan  1 2012 should be week 1, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-01"", { locale: ""en-US"" });
    expect(dt.localWeekNumber).toBe(1);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 128, 'column': 34, 'index': 5067}","test(""Jan  1 2012 should be week 1, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-01"", { locale: ""en-US"" });
    expect(dt.localWeekNumber).toBe(1);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 132, 'column': 36, 'index': 5242}","test(""Jan  7 2012 should be week 1, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-07"", { locale: ""en-US"" });
    expect(dt.localWeekNumber).toBe(1);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 133, 'column': 34, 'index': 5280}","test(""Jan  7 2012 should be week 1, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-07"", { locale: ""en-US"" });
    expect(dt.localWeekNumber).toBe(1);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 137, 'column': 36, 'index': 5455}","test(""Jan  8 2012 should be week 2, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-08"", { locale: ""en-US"" });
    expect(dt.localWeekNumber).toBe(2);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 138, 'column': 34, 'index': 5493}","test(""Jan  8 2012 should be week 2, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-08"", { locale: ""en-US"" });
    expect(dt.localWeekNumber).toBe(2);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 142, 'column': 36, 'index': 5669}","test(""Jan  14 2012 should be week 2, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-14"", { locale: ""en-US"" });
    expect(dt.localWeekNumber).toBe(2);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 143, 'column': 34, 'index': 5707}","test(""Jan  14 2012 should be week 2, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-14"", { locale: ""en-US"" });
    expect(dt.localWeekNumber).toBe(2);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 147, 'column': 36, 'index': 5883}","test(""Jan  15 2012 should be week 3, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-15"", { locale: ""en-US"" });
    expect(dt.localWeekNumber).toBe(3);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 148, 'column': 34, 'index': 5921}","test(""Jan  15 2012 should be week 3, year 2012"", () => {
    const dt = DateTime.fromISO(""2012-01-15"", { locale: ""en-US"" });
    expect(dt.localWeekNumber).toBe(3);
    expect(dt.localWeekYear).toBe(2012);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 158, 'column': 33, 'index': 6195}","test(""Sunday should be reported as the 1st day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-06"", { locale: ""en-US"" });
    expect(dt.localWeekday).toBe(1);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 162, 'column': 33, 'index': 6377}","test(""Monday should be reported as the 2nd day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-07"", { locale: ""en-US"" });
    expect(dt.localWeekday).toBe(2);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 166, 'column': 33, 'index': 6560}","test(""Tuesday should be reported as the 3rd day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-08"", { locale: ""en-US"" });
    expect(dt.localWeekday).toBe(3);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 170, 'column': 33, 'index': 6745}","test(""Wednesday should be reported as the 4th day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-09"", { locale: ""en-US"" });
    expect(dt.localWeekday).toBe(4);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 174, 'column': 33, 'index': 6929}","test(""Thursday should be reported as the 5th day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-10"", { locale: ""en-US"" });
    expect(dt.localWeekday).toBe(5);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 178, 'column': 33, 'index': 7111}","test(""Friday should be reported as the 6th day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-11"", { locale: ""en-US"" });
    expect(dt.localWeekday).toBe(6);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 182, 'column': 33, 'index': 7295}","test(""Saturday should be reported as the 7th day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-12"", { locale: ""en-US"" });
    expect(dt.localWeekday).toBe(7);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 189, 'column': 33, 'index': 7531}","test(""Monday should be reported as the 1st day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-07"", { locale: ""de-DE"" });
    expect(dt.localWeekday).toBe(1);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 193, 'column': 33, 'index': 7714}","test(""Tuesday should be reported as the 2nd day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-08"", { locale: ""de-DE"" });
    expect(dt.localWeekday).toBe(2);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 197, 'column': 33, 'index': 7899}","test(""Wednesday should be reported as the 3rd day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-09"", { locale: ""de-DE"" });
    expect(dt.localWeekday).toBe(3);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 201, 'column': 33, 'index': 8083}","test(""Thursday should be reported as the 4th day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-10"", { locale: ""de-DE"" });
    expect(dt.localWeekday).toBe(4);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 205, 'column': 33, 'index': 8265}","test(""Friday should be reported as the 5th day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-11"", { locale: ""de-DE"" });
    expect(dt.localWeekday).toBe(5);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 209, 'column': 33, 'index': 8449}","test(""Saturday should be reported as the 6th day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-12"", { locale: ""de-DE"" });
    expect(dt.localWeekday).toBe(6);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 213, 'column': 33, 'index': 8631}","test(""Sunday should be reported as the 7th day of the week"", () => {
    const dt = DateTime.fromISO(""2023-08-13"", { locale: ""de-DE"" });
    expect(dt.localWeekday).toBe(7);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 219, 'column': 86, 'index': 8826}","test(""2018 should have 53 weeks in en-US"", () => {
    expect(DateTime.local(2018, 6, 1, { locale: ""en-US"" }).weeksInLocalWeekYear).toBe(52);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 227, 'column': 86, 'index': 9174}","test(""2022 should have 52 weeks in de-DE"", () => {
    expect(DateTime.local(2022, 6, 1, { locale: ""de-DE"" }).weeksInLocalWeekYear).toBe(52);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 230, 'column': 86, 'index': 9324}","test(""2020 should have 53 weeks in de-DE"", () => {
    expect(DateTime.local(2020, 6, 1, { locale: ""de-DE"" }).weeksInLocalWeekYear).toBe(53);
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 240, 'column': 69, 'index': 9602}","test(""2018 should have 52 weeks with minDays 1, start 7"", () => {
    withDefaultWeekSettings(
      {
        minimalDays: 1,
        firstDay: 7,
        weekend: [6, 7],
      },
      () => {
        expect(DateTime.local(2018, 6, 1).weeksInLocalWeekYear).toBe(52);
      }
    );
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 252, 'column': 69, 'index': 9895}","test(""2022 should have 53 weeks with minDays 1, start 7"", () => {
    withDefaultWeekSettings(
      {
        minimalDays: 1,
        firstDay: 7,
        weekend: [6, 7],
      },
      () => {
        expect(DateTime.local(2022, 6, 1).weeksInLocalWeekYear).toBe(53);
      }
    );
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 261, 'column': 41, 'index': 10171}","test(""Overridden week info should be reported by Info"", () => {
    withDefaultWeekSettings({ firstDay: 3, minimalDays: 5, weekend: [4, 6] }, () => {
      expect(Info.getStartOfWeek()).toBe(3);
      expect(Info.getMinimumDaysInFirstWeek()).toBe(5);
      expect(Info.getWeekendWeekdays()).toEqual([4, 6]);
    });
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 262, 'column': 52, 'index': 10227}","test(""Overridden week info should be reported by Info"", () => {
    withDefaultWeekSettings({ firstDay: 3, minimalDays: 5, weekend: [4, 6] }, () => {
      expect(Info.getStartOfWeek()).toBe(3);
      expect(Info.getMinimumDaysInFirstWeek()).toBe(5);
      expect(Info.getWeekendWeekdays()).toEqual([4, 6]);
    });
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 281, 'column': 35, 'index': 11198}","test(""Overridden week info should be respected by DateTime accessors"", () => {
    withDefaultWeekSettings({ firstDay: 7, minimalDays: 1, weekend: [6, 7] }, () => {
      const dt = DateTime.local(2022, 1, 1, { locale: ""de-DE"" });
      expect(dt.localWeekday).toBe(7);
      expect(dt.localWeekNumber).toBe(1);
      expect(dt.localWeekYear).toBe(2022);
    });
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 282, 'column': 38, 'index': 11240}","test(""Overridden week info should be respected by DateTime accessors"", () => {
    withDefaultWeekSettings({ firstDay: 7, minimalDays: 1, weekend: [6, 7] }, () => {
      const dt = DateTime.local(2022, 1, 1, { locale: ""de-DE"" });
      expect(dt.localWeekday).toBe(7);
      expect(dt.localWeekNumber).toBe(1);
      expect(dt.localWeekYear).toBe(2022);
    });
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 283, 'column': 36, 'index': 11280}","test(""Overridden week info should be respected by DateTime accessors"", () => {
    withDefaultWeekSettings({ firstDay: 7, minimalDays: 1, weekend: [6, 7] }, () => {
      const dt = DateTime.local(2022, 1, 1, { locale: ""de-DE"" });
      expect(dt.localWeekday).toBe(7);
      expect(dt.localWeekNumber).toBe(1);
      expect(dt.localWeekYear).toBe(2022);
    });
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 290, 'column': 33, 'index': 11613}","test(""Overridden week info should be respected by DateTime#set"", () => {
    withDefaultWeekSettings({ firstDay: 7, minimalDays: 1, weekend: [6, 7] }, () => {
      const dt = DateTime.local(2022, 1, 1, { locale: ""de-DE"" });
      const modified = dt.set({ localWeekday: 1 });
      expect(modified.year).toBe(2021);
      expect(modified.month).toBe(12);
      expect(modified.day).toBe(26);
    });
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 291, 'column': 34, 'index': 11654}","test(""Overridden week info should be respected by DateTime#set"", () => {
    withDefaultWeekSettings({ firstDay: 7, minimalDays: 1, weekend: [6, 7] }, () => {
      const dt = DateTime.local(2022, 1, 1, { locale: ""de-DE"" });
      const modified = dt.set({ localWeekday: 1 });
      expect(modified.year).toBe(2021);
      expect(modified.month).toBe(12);
      expect(modified.day).toBe(26);
    });
  })",steel
/test/datetime/localeWeek.test.js,Magic Number,"{'line': 292, 'column': 32, 'index': 11691}","test(""Overridden week info should be respected by DateTime#set"", () => {
    withDefaultWeekSettings({ firstDay: 7, minimalDays: 1, weekend: [6, 7] }, () => {
      const dt = DateTime.local(2022, 1, 1, { locale: ""de-DE"" });
      const modified = dt.set({ localWeekday: 1 });
      expect(modified.year).toBe(2021);
      expect(modified.month).toBe(12);
      expect(modified.day).toBe(26);
    });
  })",steel
/test/datetime/dst.test.js,Conditional Test Logic,"{'line': 12, 'column': 0, 'index': 352}",Unknown,steel
/test/datetime/dst.test.js,Conditional Test Logic,"{'line': 20, 'column': 4, 'index': 629}","describe(`DateTime.${name}`, () => {
    test(""Hole dates are bumped forward"", () => {
      const d = local(2017, 3, 12, 2);
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    });

    if (name == ""fromObject"") {
      // this is questionable behavior, but I wanted to document it
      test(""Ambiguous dates pick the one with the current offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      });
    } else {
      test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      });
    }

    test(""Adding an hour to land on the Spring Forward springs forward"", () => {
      const d = local(2017, 3, 12, 1).plus({ hour: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    });

    test(""Subtracting an hour to land on the Spring Forward springs forward"", () => {
      const d = local(2017, 3, 12, 3).minus({ hour: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    });

    test(""Adding an hour to land on the Fall Back falls back"", () => {
      const d = local(2017, 11, 5, 0).plus({ hour: 2 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    });

    test(""Subtracting an hour to land on the Fall Back falls back"", () => {
      let d = local(2017, 11, 5, 3).minus({ hour: 2 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);

      d = d.minus({ hour: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);
    });

    test(""Changing a calendar date to land on a hole bumps forward"", () => {
      let d = local(2017, 3, 11, 2).plus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 3, 13, 2).minus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    });

    test(""Changing a calendar date to land on an ambiguous time chooses the closest one"", () => {
      let d = local(2017, 11, 4, 1).plus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 11, 6, 1).minus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    });

    test(""Start of a 0:00->1:00 DST day is 1:00"", () => {
      const d = DateTime.fromObject(
        {
          year: 2017,
          month: 10,
          day: 15,
        },
        {
          zone: ""America/Sao_Paulo"",
        }
      ).startOf(""day"");
      expect(d.day).toBe(15);
      expect(d.hour).toBe(1);
      expect(d.minute).toBe(0);
      expect(d.second).toBe(0);
    });

    test(""End of a 0:00->1:00 DST day is 23:59"", () => {
      const d = DateTime.fromObject(
        {
          year: 2017,
          month: 10,
          day: 15,
        },
        {
          zone: ""America/Sao_Paulo"",
        }
      ).endOf(""day"");
      expect(d.day).toBe(15);
      expect(d.hour).toBe(23);
      expect(d.minute).toBe(59);
      expect(d.second).toBe(59);
    });
  })",steel
/test/datetime/dst.test.js,Conditional Test Logic,"{'line': 165, 'column': 2, 'index': 5134}","describe(""DateTime.local() with offset caching"", () => {
  const edtTs = 1495653314000; // May 24, 2017 15:15:14 -0400
  const estTs = 1484456400000; // Jan 15, 2017 00:00 -0500

  const edtDate = [2017, 5, 24, 15, 15, 14, 0];
  const estDate = [2017, 1, 15, 0, 0, 0, 0];

  const timestamps = { EDT: edtTs, EST: estTs };
  const dates = { EDT: edtDate, EST: estDate };
  const zoneObj = { zone: ""America/New_York"" };

  for (const [cacheName, cacheTs] of Object.entries(timestamps)) {
    for (const [nowName, nowTs] of Object.entries(timestamps)) {
      for (const [dateName, date] of Object.entries(dates)) {
        test(`cache = ${cacheName}, now = ${nowName}, date = ${dateName}`, () => {
          const oldSettings = Settings.now;
          try {
            Settings.now = () => cacheTs;
            Settings.resetCaches();
            // load cache
            DateTime.local(2020, 1, 1, 0, zoneObj);

            Settings.now = () => nowTs;
            const dt = DateTime.local(...date, zoneObj);
            expect(dt.toMillis()).toBe(timestamps[dateName]);
            expect(dt.year).toBe(date[0]);
            expect(dt.month).toBe(date[1]);
            expect(dt.day).toBe(date[2]);
            expect(dt.hour).toBe(date[3]);
            expect(dt.minute).toBe(date[4]);
            expect(dt.second).toBe(date[5]);
          } finally {
            Settings.now = oldSettings;
          }
        });
      }
    }
  }
})",steel
/test/datetime/dst.test.js,Conditional Test Logic,"{'line': 166, 'column': 4, 'index': 5203}","describe(""DateTime.local() with offset caching"", () => {
  const edtTs = 1495653314000; // May 24, 2017 15:15:14 -0400
  const estTs = 1484456400000; // Jan 15, 2017 00:00 -0500

  const edtDate = [2017, 5, 24, 15, 15, 14, 0];
  const estDate = [2017, 1, 15, 0, 0, 0, 0];

  const timestamps = { EDT: edtTs, EST: estTs };
  const dates = { EDT: edtDate, EST: estDate };
  const zoneObj = { zone: ""America/New_York"" };

  for (const [cacheName, cacheTs] of Object.entries(timestamps)) {
    for (const [nowName, nowTs] of Object.entries(timestamps)) {
      for (const [dateName, date] of Object.entries(dates)) {
        test(`cache = ${cacheName}, now = ${nowName}, date = ${dateName}`, () => {
          const oldSettings = Settings.now;
          try {
            Settings.now = () => cacheTs;
            Settings.resetCaches();
            // load cache
            DateTime.local(2020, 1, 1, 0, zoneObj);

            Settings.now = () => nowTs;
            const dt = DateTime.local(...date, zoneObj);
            expect(dt.toMillis()).toBe(timestamps[dateName]);
            expect(dt.year).toBe(date[0]);
            expect(dt.month).toBe(date[1]);
            expect(dt.day).toBe(date[2]);
            expect(dt.hour).toBe(date[3]);
            expect(dt.minute).toBe(date[4]);
            expect(dt.second).toBe(date[5]);
          } finally {
            Settings.now = oldSettings;
          }
        });
      }
    }
  }
})",steel
/test/datetime/dst.test.js,Conditional Test Logic,"{'line': 167, 'column': 6, 'index': 5270}","describe(""DateTime.local() with offset caching"", () => {
  const edtTs = 1495653314000; // May 24, 2017 15:15:14 -0400
  const estTs = 1484456400000; // Jan 15, 2017 00:00 -0500

  const edtDate = [2017, 5, 24, 15, 15, 14, 0];
  const estDate = [2017, 1, 15, 0, 0, 0, 0];

  const timestamps = { EDT: edtTs, EST: estTs };
  const dates = { EDT: edtDate, EST: estDate };
  const zoneObj = { zone: ""America/New_York"" };

  for (const [cacheName, cacheTs] of Object.entries(timestamps)) {
    for (const [nowName, nowTs] of Object.entries(timestamps)) {
      for (const [dateName, date] of Object.entries(dates)) {
        test(`cache = ${cacheName}, now = ${nowName}, date = ${dateName}`, () => {
          const oldSettings = Settings.now;
          try {
            Settings.now = () => cacheTs;
            Settings.resetCaches();
            // load cache
            DateTime.local(2020, 1, 1, 0, zoneObj);

            Settings.now = () => nowTs;
            const dt = DateTime.local(...date, zoneObj);
            expect(dt.toMillis()).toBe(timestamps[dateName]);
            expect(dt.year).toBe(date[0]);
            expect(dt.month).toBe(date[1]);
            expect(dt.day).toBe(date[2]);
            expect(dt.hour).toBe(date[3]);
            expect(dt.minute).toBe(date[4]);
            expect(dt.second).toBe(date[5]);
          } finally {
            Settings.now = oldSettings;
          }
        });
      }
    }
  }
})",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 27, 'column': 10, 'index': 969}","test(""Ambiguous dates pick the one with the current offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 27, 'column': 10, 'index': 969}","test(""Ambiguous dates pick the one with the current offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 28, 'column': 10, 'index': 1003}","test(""Ambiguous dates pick the one with the current offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 32, 'column': 10, 'index': 1145}","test(""Ambiguous dates pick the one with the current offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 32, 'column': 10, 'index': 1145}","test(""Ambiguous dates pick the one with the current offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 33, 'column': 10, 'index': 1179}","test(""Ambiguous dates pick the one with the current offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 45, 'column': 10, 'index': 1579}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 45, 'column': 10, 'index': 1579}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 46, 'column': 10, 'index': 1613}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 46, 'column': 10, 'index': 1613}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 50, 'column': 10, 'index': 1755}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 50, 'column': 10, 'index': 1755}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 51, 'column': 10, 'index': 1789}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 51, 'column': 10, 'index': 1789}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 57, 'column': 10, 'index': 1966}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 57, 'column': 10, 'index': 1966}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 58, 'column': 10, 'index': 2000}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 58, 'column': 10, 'index': 2000}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 62, 'column': 10, 'index': 2142}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 62, 'column': 10, 'index': 2142}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 63, 'column': 10, 'index': 2176}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 63, 'column': 10, 'index': 2176}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 90, 'column': 6, 'index': 3072}","test(""Subtracting an hour to land on the Fall Back falls back"", () => {
      let d = local(2017, 11, 5, 3).minus({ hour: 2 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);

      d = d.minus({ hour: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 90, 'column': 6, 'index': 3072}","test(""Subtracting an hour to land on the Fall Back falls back"", () => {
      let d = local(2017, 11, 5, 3).minus({ hour: 2 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);

      d = d.minus({ hour: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 91, 'column': 6, 'index': 3102}","test(""Subtracting an hour to land on the Fall Back falls back"", () => {
      let d = local(2017, 11, 5, 3).minus({ hour: 2 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);

      d = d.minus({ hour: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 94, 'column': 6, 'index': 3173}","test(""Subtracting an hour to land on the Fall Back falls back"", () => {
      let d = local(2017, 11, 5, 3).minus({ hour: 2 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);

      d = d.minus({ hour: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 94, 'column': 6, 'index': 3173}","test(""Subtracting an hour to land on the Fall Back falls back"", () => {
      let d = local(2017, 11, 5, 3).minus({ hour: 2 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);

      d = d.minus({ hour: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 95, 'column': 6, 'index': 3203}","test(""Subtracting an hour to land on the Fall Back falls back"", () => {
      let d = local(2017, 11, 5, 3).minus({ hour: 2 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);

      d = d.minus({ hour: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 100, 'column': 6, 'index': 3381}","test(""Changing a calendar date to land on a hole bumps forward"", () => {
      let d = local(2017, 3, 11, 2).plus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 3, 13, 2).minus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 100, 'column': 6, 'index': 3381}","test(""Changing a calendar date to land on a hole bumps forward"", () => {
      let d = local(2017, 3, 11, 2).plus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 3, 13, 2).minus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 101, 'column': 6, 'index': 3411}","test(""Changing a calendar date to land on a hole bumps forward"", () => {
      let d = local(2017, 3, 11, 2).plus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 3, 13, 2).minus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 101, 'column': 6, 'index': 3411}","test(""Changing a calendar date to land on a hole bumps forward"", () => {
      let d = local(2017, 3, 11, 2).plus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 3, 13, 2).minus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 104, 'column': 6, 'index': 3501}","test(""Changing a calendar date to land on a hole bumps forward"", () => {
      let d = local(2017, 3, 11, 2).plus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 3, 13, 2).minus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 104, 'column': 6, 'index': 3501}","test(""Changing a calendar date to land on a hole bumps forward"", () => {
      let d = local(2017, 3, 11, 2).plus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 3, 13, 2).minus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 105, 'column': 6, 'index': 3531}","test(""Changing a calendar date to land on a hole bumps forward"", () => {
      let d = local(2017, 3, 11, 2).plus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 3, 13, 2).minus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 105, 'column': 6, 'index': 3531}","test(""Changing a calendar date to land on a hole bumps forward"", () => {
      let d = local(2017, 3, 11, 2).plus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 3, 13, 2).minus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 110, 'column': 6, 'index': 3730}","test(""Changing a calendar date to land on an ambiguous time chooses the closest one"", () => {
      let d = local(2017, 11, 4, 1).plus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 11, 6, 1).minus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 110, 'column': 6, 'index': 3730}","test(""Changing a calendar date to land on an ambiguous time chooses the closest one"", () => {
      let d = local(2017, 11, 4, 1).plus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 11, 6, 1).minus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 111, 'column': 6, 'index': 3760}","test(""Changing a calendar date to land on an ambiguous time chooses the closest one"", () => {
      let d = local(2017, 11, 4, 1).plus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 11, 6, 1).minus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 114, 'column': 6, 'index': 3850}","test(""Changing a calendar date to land on an ambiguous time chooses the closest one"", () => {
      let d = local(2017, 11, 4, 1).plus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 11, 6, 1).minus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 114, 'column': 6, 'index': 3850}","test(""Changing a calendar date to land on an ambiguous time chooses the closest one"", () => {
      let d = local(2017, 11, 4, 1).plus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 11, 6, 1).minus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    })",steel
/test/datetime/dst.test.js,Duplicate Assert,"{'line': 115, 'column': 6, 'index': 3880}","test(""Changing a calendar date to land on an ambiguous time chooses the closest one"", () => {
      let d = local(2017, 11, 4, 1).plus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 11, 6, 1).minus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    })",steel
/test/datetime/dst.test.js,Exception Handling,"{'line': 24, 'column': 8, 'index': 850}","test(""Ambiguous dates pick the one with the current offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Exception Handling,"{'line': 41, 'column': 8, 'index': 1426}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 16, 'column': 26, 'index': 574}","test(""Hole dates are bumped forward"", () => {
      const d = local(2017, 3, 12, 2);
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 27, 'column': 30, 'index': 989}","test(""Ambiguous dates pick the one with the current offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 32, 'column': 30, 'index': 1165}","test(""Ambiguous dates pick the one with the current offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 45, 'column': 30, 'index': 1599}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 50, 'column': 30, 'index': 1775}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 57, 'column': 30, 'index': 1986}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 62, 'column': 30, 'index': 2162}","test(""Ambiguous dates pick the one with the cached offset"", () => {
        const oldSettings = Settings.now;
        try {
          Settings.resetCaches();
          Settings.now = () => 1495653314595; // May 24, 2017
          let d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-4 * 60);

          Settings.resetCaches();

          Settings.now = () => 1484456400000; // Jan 15, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);

          Settings.now = () => 1495653314595; // May 24, 2017
          d = local(2017, 11, 5, 1);
          expect(d.hour).toBe(1);
          expect(d.offset).toBe(-5 * 60);
        } finally {
          Settings.now = oldSettings;
        }
      })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 72, 'column': 26, 'index': 2457}","test(""Adding an hour to land on the Spring Forward springs forward"", () => {
      const d = local(2017, 3, 12, 1).plus({ hour: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 78, 'column': 26, 'index': 2678}","test(""Subtracting an hour to land on the Spring Forward springs forward"", () => {
      const d = local(2017, 3, 12, 3).minus({ hour: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 84, 'column': 26, 'index': 2883}","test(""Adding an hour to land on the Fall Back falls back"", () => {
      const d = local(2017, 11, 5, 0).plus({ hour: 2 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 90, 'column': 26, 'index': 3092}","test(""Subtracting an hour to land on the Fall Back falls back"", () => {
      let d = local(2017, 11, 5, 3).minus({ hour: 2 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);

      d = d.minus({ hour: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 94, 'column': 26, 'index': 3193}","test(""Subtracting an hour to land on the Fall Back falls back"", () => {
      let d = local(2017, 11, 5, 3).minus({ hour: 2 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);

      d = d.minus({ hour: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 100, 'column': 26, 'index': 3401}","test(""Changing a calendar date to land on a hole bumps forward"", () => {
      let d = local(2017, 3, 11, 2).plus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 3, 13, 2).minus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 104, 'column': 26, 'index': 3521}","test(""Changing a calendar date to land on a hole bumps forward"", () => {
      let d = local(2017, 3, 11, 2).plus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 3, 13, 2).minus({ day: 1 });
      expect(d.hour).toBe(3);
      expect(d.offset).toBe(-4 * 60);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 110, 'column': 26, 'index': 3750}","test(""Changing a calendar date to land on an ambiguous time chooses the closest one"", () => {
      let d = local(2017, 11, 4, 1).plus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 11, 6, 1).minus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 114, 'column': 26, 'index': 3870}","test(""Changing a calendar date to land on an ambiguous time chooses the closest one"", () => {
      let d = local(2017, 11, 4, 1).plus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-4 * 60);

      d = local(2017, 11, 6, 1).minus({ day: 1 });
      expect(d.hour).toBe(1);
      expect(d.offset).toBe(-5 * 60);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 129, 'column': 25, 'index': 4205}","test(""Start of a 0:00->1:00 DST day is 1:00"", () => {
      const d = DateTime.fromObject(
        {
          year: 2017,
          month: 10,
          day: 15,
        },
        {
          zone: ""America/Sao_Paulo"",
        }
      ).startOf(""day"");
      expect(d.day).toBe(15);
      expect(d.hour).toBe(1);
      expect(d.minute).toBe(0);
      expect(d.second).toBe(0);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 130, 'column': 26, 'index': 4236}","test(""Start of a 0:00->1:00 DST day is 1:00"", () => {
      const d = DateTime.fromObject(
        {
          year: 2017,
          month: 10,
          day: 15,
        },
        {
          zone: ""America/Sao_Paulo"",
        }
      ).startOf(""day"");
      expect(d.day).toBe(15);
      expect(d.hour).toBe(1);
      expect(d.minute).toBe(0);
      expect(d.second).toBe(0);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 131, 'column': 28, 'index': 4268}","test(""Start of a 0:00->1:00 DST day is 1:00"", () => {
      const d = DateTime.fromObject(
        {
          year: 2017,
          month: 10,
          day: 15,
        },
        {
          zone: ""America/Sao_Paulo"",
        }
      ).startOf(""day"");
      expect(d.day).toBe(15);
      expect(d.hour).toBe(1);
      expect(d.minute).toBe(0);
      expect(d.second).toBe(0);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 132, 'column': 28, 'index': 4300}","test(""Start of a 0:00->1:00 DST day is 1:00"", () => {
      const d = DateTime.fromObject(
        {
          year: 2017,
          month: 10,
          day: 15,
        },
        {
          zone: ""America/Sao_Paulo"",
        }
      ).startOf(""day"");
      expect(d.day).toBe(15);
      expect(d.hour).toBe(1);
      expect(d.minute).toBe(0);
      expect(d.second).toBe(0);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 146, 'column': 25, 'index': 4594}","test(""End of a 0:00->1:00 DST day is 23:59"", () => {
      const d = DateTime.fromObject(
        {
          year: 2017,
          month: 10,
          day: 15,
        },
        {
          zone: ""America/Sao_Paulo"",
        }
      ).endOf(""day"");
      expect(d.day).toBe(15);
      expect(d.hour).toBe(23);
      expect(d.minute).toBe(59);
      expect(d.second).toBe(59);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 147, 'column': 26, 'index': 4625}","test(""End of a 0:00->1:00 DST day is 23:59"", () => {
      const d = DateTime.fromObject(
        {
          year: 2017,
          month: 10,
          day: 15,
        },
        {
          zone: ""America/Sao_Paulo"",
        }
      ).endOf(""day"");
      expect(d.day).toBe(15);
      expect(d.hour).toBe(23);
      expect(d.minute).toBe(59);
      expect(d.second).toBe(59);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 148, 'column': 28, 'index': 4658}","test(""End of a 0:00->1:00 DST day is 23:59"", () => {
      const d = DateTime.fromObject(
        {
          year: 2017,
          month: 10,
          day: 15,
        },
        {
          zone: ""America/Sao_Paulo"",
        }
      ).endOf(""day"");
      expect(d.day).toBe(15);
      expect(d.hour).toBe(23);
      expect(d.minute).toBe(59);
      expect(d.second).toBe(59);
    })",steel
/test/datetime/dst.test.js,Magic Number,"{'line': 149, 'column': 28, 'index': 4691}","test(""End of a 0:00->1:00 DST day is 23:59"", () => {
      const d = DateTime.fromObject(
        {
          year: 2017,
          month: 10,
          day: 15,
        },
        {
          zone: ""America/Sao_Paulo"",
        }
      ).endOf(""day"");
      expect(d.day).toBe(15);
      expect(d.hour).toBe(23);
      expect(d.minute).toBe(59);
      expect(d.second).toBe(59);
    })",steel
